!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
A	.\tests\heap-checker_unittest.cc	/^  virtual void A() { }$/;"	f	class:ClassMltD1
A	.\tests\heap-checker_unittest.cc	/^  virtual void A() { }$/;"	f	class:ClassMltD2
ACMRandom	.\tests\tcmalloc_unittest.cc	/^    explicit ACMRandom(int32 seed) { seed_ = seed; }$/;"	f	class:testing::TesterThread::ACMRandom
ACMRandom	.\tests\tcmalloc_unittest.cc	/^  class ACMRandom {$/;"	c	class:testing::TesterThread	file:
ACQUIRED_AFTER	.\base\thread_annotations.h	84;"	d
ACQUIRED_BEFORE	.\base\thread_annotations.h	86;"	d
ADCDF	.\tests\sampler_test.cc	/^void ADCDF() {$/;"	f
ADDR_IN_ATTRIBUTE_SECTION	.\malloc_hook.cc	579;"	d	file:
ADDR_IN_ATTRIBUTE_SECTION	.\malloc_hook.cc	595;"	d	file:
ADJUST_ADDRESS_RANGE_FROM_RA	.\tests\stacktrace_unittest.cc	77;"	d	file:
ADJUST_ADDRESS_RANGE_FROM_RA	.\tests\stacktrace_unittest.cc	96;"	d	file:
ADTestTest	.\tests\sampler_test.cc	/^void ADTestTest(int n) {$/;"	f
ALARM	.\tests\heap-checker-death_unittest.sh	/^ALARM() {$/;"	f
ALIAS	.\libc_override_gcc_and_weak.h	166;"	d
ALIAS	.\libc_override_gcc_and_weak.h	58;"	d
ALIAS	.\libc_override_glibc.h	73;"	d
ALIAS	.\libc_override_glibc.h	85;"	d
ALLOC	.\tests\tcmalloc_unittest.cc	/^  enum Type { ALLOC, FREE, UPDATE, PASS };$/;"	e	enum:testing::TesterThread::Type	file:
ALLOC_COUNT	.\addressmap-inl.h	/^  static const int ALLOC_COUNT = 64;$/;"	m	class:AddressMap
ALT_STACKSIZE	.\base\linuxthreads.cc	246;"	d	file:
ALWAYS_INLINE	.\tcmalloc.cc	138;"	d	file:
ALWAYS_INLINE	.\tcmalloc.cc	140;"	d	file:
AM_A	.\windows\mini_disassembler_types.h	/^  AM_A = 0x00010000,    \/\/ A addressing type$/;"	e	enum:sidestep::AddressingMethod
AM_C	.\windows\mini_disassembler_types.h	/^  AM_C = 0x00020000,    \/\/ C addressing type$/;"	e	enum:sidestep::AddressingMethod
AM_D	.\windows\mini_disassembler_types.h	/^  AM_D = 0x00030000,    \/\/ D addressing type$/;"	e	enum:sidestep::AddressingMethod
AM_E	.\windows\mini_disassembler_types.h	/^  AM_E = 0x00040000,    \/\/ E addressing type$/;"	e	enum:sidestep::AddressingMethod
AM_F	.\windows\mini_disassembler_types.h	/^  AM_F = 0x00050000,    \/\/ F addressing type$/;"	e	enum:sidestep::AddressingMethod
AM_G	.\windows\mini_disassembler_types.h	/^  AM_G = 0x00060000,    \/\/ G addressing type$/;"	e	enum:sidestep::AddressingMethod
AM_I	.\windows\mini_disassembler_types.h	/^  AM_I = 0x00070000,    \/\/ I addressing type$/;"	e	enum:sidestep::AddressingMethod
AM_IMPLICIT	.\windows\mini_disassembler_types.h	/^  AM_IMPLICIT = 0x00150000,  \/\/ An implicit, fixed value is used$/;"	e	enum:sidestep::AddressingMethod
AM_J	.\windows\mini_disassembler_types.h	/^  AM_J = 0x00080000,    \/\/ J addressing type$/;"	e	enum:sidestep::AddressingMethod
AM_M	.\windows\mini_disassembler_types.h	/^  AM_M = 0x00090000,    \/\/ M addressing type$/;"	e	enum:sidestep::AddressingMethod
AM_MASK	.\windows\mini_disassembler_types.h	/^  AM_MASK = 0x00FF0000,  \/\/ Mask for the rest of the values in this enumeration$/;"	e	enum:sidestep::AddressingMethod
AM_NOT_USED	.\windows\mini_disassembler_types.h	/^  AM_NOT_USED = 0,        \/\/ This operand is not used for this instruction$/;"	e	enum:sidestep::AddressingMethod
AM_O	.\windows\mini_disassembler_types.h	/^  AM_O = 0x000A0000,    \/\/ O addressing type$/;"	e	enum:sidestep::AddressingMethod
AM_P	.\windows\mini_disassembler_types.h	/^  AM_P = 0x000B0000,    \/\/ P addressing type$/;"	e	enum:sidestep::AddressingMethod
AM_Q	.\windows\mini_disassembler_types.h	/^  AM_Q = 0x000C0000,    \/\/ Q addressing type$/;"	e	enum:sidestep::AddressingMethod
AM_R	.\windows\mini_disassembler_types.h	/^  AM_R = 0x000D0000,    \/\/ R addressing type$/;"	e	enum:sidestep::AddressingMethod
AM_REGISTER	.\windows\mini_disassembler_types.h	/^  AM_REGISTER = 0x00140000,  \/\/ Specific register is always used as this op$/;"	e	enum:sidestep::AddressingMethod
AM_S	.\windows\mini_disassembler_types.h	/^  AM_S = 0x000E0000,    \/\/ S addressing type$/;"	e	enum:sidestep::AddressingMethod
AM_T	.\windows\mini_disassembler_types.h	/^  AM_T = 0x000F0000,    \/\/ T addressing type$/;"	e	enum:sidestep::AddressingMethod
AM_V	.\windows\mini_disassembler_types.h	/^  AM_V = 0x00100000,    \/\/ V addressing type$/;"	e	enum:sidestep::AddressingMethod
AM_W	.\windows\mini_disassembler_types.h	/^  AM_W = 0x00110000,    \/\/ W addressing type$/;"	e	enum:sidestep::AddressingMethod
AM_X	.\windows\mini_disassembler_types.h	/^  AM_X = 0x00120000,    \/\/ X addressing type$/;"	e	enum:sidestep::AddressingMethod
AM_Y	.\windows\mini_disassembler_types.h	/^  AM_Y = 0x00130000,    \/\/ Y addressing type$/;"	e	enum:sidestep::AddressingMethod
ANNOTALYSIS_IGNORE_READS_BEGIN	.\base\dynamic_annotations.h	381;"	d
ANNOTALYSIS_IGNORE_READS_BEGIN	.\base\dynamic_annotations.h	400;"	d
ANNOTALYSIS_IGNORE_READS_BEGIN	.\base\dynamic_annotations.h	401;"	d
ANNOTALYSIS_IGNORE_READS_END	.\base\dynamic_annotations.h	382;"	d
ANNOTALYSIS_IGNORE_READS_END	.\base\dynamic_annotations.h	402;"	d
ANNOTALYSIS_IGNORE_READS_END	.\base\dynamic_annotations.h	403;"	d
ANNOTALYSIS_IGNORE_WRITES_BEGIN	.\base\dynamic_annotations.h	383;"	d
ANNOTALYSIS_IGNORE_WRITES_BEGIN	.\base\dynamic_annotations.h	404;"	d
ANNOTALYSIS_IGNORE_WRITES_BEGIN	.\base\dynamic_annotations.h	405;"	d
ANNOTALYSIS_IGNORE_WRITES_END	.\base\dynamic_annotations.h	384;"	d
ANNOTALYSIS_IGNORE_WRITES_END	.\base\dynamic_annotations.h	406;"	d
ANNOTALYSIS_IGNORE_WRITES_END	.\base\dynamic_annotations.h	407;"	d
ANNOTALYSIS_ONLY	.\base\dynamic_annotations.h	391;"	d
ANNOTALYSIS_ONLY	.\base\dynamic_annotations.h	576;"	d
ANNOTALYSIS_SEMICOLON_OR_EMPTY_BODY	.\base\dynamic_annotations.h	380;"	d
ANNOTALYSIS_SEMICOLON_OR_EMPTY_BODY	.\base\dynamic_annotations.h	394;"	d
ANNOTALYSIS_SEMICOLON_OR_EMPTY_BODY	.\base\dynamic_annotations.h	395;"	d
ANNOTALYSIS_SEMICOLON_OR_EMPTY_BODY	.\base\dynamic_annotations.h	625;"	d
ANNOTALYSIS_STATIC_INLINE	.\base\dynamic_annotations.h	379;"	d
ANNOTALYSIS_STATIC_INLINE	.\base\dynamic_annotations.h	392;"	d
ANNOTALYSIS_STATIC_INLINE	.\base\dynamic_annotations.h	393;"	d
ANNOTALYSIS_STATIC_INLINE	.\base\dynamic_annotations.h	624;"	d
ANNOTALYSIS_UNPROTECTED_READ	.\base\dynamic_annotations.h	385;"	d
ANNOTALYSIS_UNPROTECTED_READ	.\base\dynamic_annotations.h	408;"	d
ANNOTALYSIS_UNPROTECTED_READ	.\base\dynamic_annotations.h	409;"	d
ANNOTATE_BARRIER_DESTROY	.\base\dynamic_annotations.h	309;"	d
ANNOTATE_BARRIER_DESTROY	.\base\dynamic_annotations.h	339;"	d
ANNOTATE_BARRIER_INIT	.\base\dynamic_annotations.h	296;"	d
ANNOTATE_BARRIER_INIT	.\base\dynamic_annotations.h	336;"	d
ANNOTATE_BARRIER_WAIT_AFTER	.\base\dynamic_annotations.h	305;"	d
ANNOTATE_BARRIER_WAIT_AFTER	.\base\dynamic_annotations.h	338;"	d
ANNOTATE_BARRIER_WAIT_BEFORE	.\base\dynamic_annotations.h	301;"	d
ANNOTATE_BARRIER_WAIT_BEFORE	.\base\dynamic_annotations.h	337;"	d
ANNOTATE_BENIGN_RACE	.\base\dynamic_annotations.h	206;"	d
ANNOTATE_BENIGN_RACE	.\base\dynamic_annotations.h	355;"	d
ANNOTATE_BENIGN_RACE_SIZED	.\base\dynamic_annotations.h	212;"	d
ANNOTATE_BENIGN_RACE_SIZED	.\base\dynamic_annotations.h	356;"	d
ANNOTATE_BENIGN_RACE_STATIC	.\base\dynamic_annotations.h	545;"	d
ANNOTATE_BENIGN_RACE_STATIC	.\base\dynamic_annotations.h	560;"	d
ANNOTATE_CONDVAR_LOCK_WAIT	.\base\dynamic_annotations.h	106;"	d
ANNOTATE_CONDVAR_LOCK_WAIT	.\base\dynamic_annotations.h	340;"	d
ANNOTATE_CONDVAR_SIGNAL	.\base\dynamic_annotations.h	116;"	d
ANNOTATE_CONDVAR_SIGNAL	.\base\dynamic_annotations.h	342;"	d
ANNOTATE_CONDVAR_SIGNAL_ALL	.\base\dynamic_annotations.h	120;"	d
ANNOTATE_CONDVAR_SIGNAL_ALL	.\base\dynamic_annotations.h	343;"	d
ANNOTATE_CONDVAR_WAIT	.\base\dynamic_annotations.h	111;"	d
ANNOTATE_CONDVAR_WAIT	.\base\dynamic_annotations.h	341;"	d
ANNOTATE_ENABLE_RACE_DETECTION	.\base\dynamic_annotations.h	252;"	d
ANNOTATE_ENABLE_RACE_DETECTION	.\base\dynamic_annotations.h	367;"	d
ANNOTATE_EXPECT_RACE	.\base\dynamic_annotations.h	317;"	d
ANNOTATE_EXPECT_RACE	.\base\dynamic_annotations.h	354;"	d
ANNOTATE_FLUSH_STATE	.\base\dynamic_annotations.h	326;"	d
ANNOTATE_FLUSH_STATE	.\base\dynamic_annotations.h	369;"	d
ANNOTATE_HAPPENS_AFTER	.\base\dynamic_annotations.h	125;"	d
ANNOTATE_HAPPENS_AFTER	.\base\dynamic_annotations.h	345;"	d
ANNOTATE_HAPPENS_BEFORE	.\base\dynamic_annotations.h	124;"	d
ANNOTATE_HAPPENS_BEFORE	.\base\dynamic_annotations.h	344;"	d
ANNOTATE_IGNORE_READS_AND_WRITES_BEGIN	.\base\dynamic_annotations.h	236;"	d
ANNOTATE_IGNORE_READS_AND_WRITES_BEGIN	.\base\dynamic_annotations.h	365;"	d
ANNOTATE_IGNORE_READS_AND_WRITES_BEGIN	.\base\dynamic_annotations.h	595;"	d
ANNOTATE_IGNORE_READS_AND_WRITES_BEGIN	.\base\dynamic_annotations.h	596;"	d
ANNOTATE_IGNORE_READS_AND_WRITES_END	.\base\dynamic_annotations.h	243;"	d
ANNOTATE_IGNORE_READS_AND_WRITES_END	.\base\dynamic_annotations.h	366;"	d
ANNOTATE_IGNORE_READS_AND_WRITES_END	.\base\dynamic_annotations.h	602;"	d
ANNOTATE_IGNORE_READS_AND_WRITES_END	.\base\dynamic_annotations.h	603;"	d
ANNOTATE_IGNORE_READS_BEGIN	.\base\dynamic_annotations.h	220;"	d
ANNOTATE_IGNORE_READS_BEGIN	.\base\dynamic_annotations.h	361;"	d
ANNOTATE_IGNORE_READS_BEGIN	.\base\dynamic_annotations.h	579;"	d
ANNOTATE_IGNORE_READS_BEGIN	.\base\dynamic_annotations.h	580;"	d
ANNOTATE_IGNORE_READS_END	.\base\dynamic_annotations.h	224;"	d
ANNOTATE_IGNORE_READS_END	.\base\dynamic_annotations.h	362;"	d
ANNOTATE_IGNORE_READS_END	.\base\dynamic_annotations.h	583;"	d
ANNOTATE_IGNORE_READS_END	.\base\dynamic_annotations.h	584;"	d
ANNOTATE_IGNORE_WRITES_BEGIN	.\base\dynamic_annotations.h	228;"	d
ANNOTATE_IGNORE_WRITES_BEGIN	.\base\dynamic_annotations.h	363;"	d
ANNOTATE_IGNORE_WRITES_BEGIN	.\base\dynamic_annotations.h	587;"	d
ANNOTATE_IGNORE_WRITES_BEGIN	.\base\dynamic_annotations.h	588;"	d
ANNOTATE_IGNORE_WRITES_END	.\base\dynamic_annotations.h	232;"	d
ANNOTATE_IGNORE_WRITES_END	.\base\dynamic_annotations.h	364;"	d
ANNOTATE_IGNORE_WRITES_END	.\base\dynamic_annotations.h	591;"	d
ANNOTATE_IGNORE_WRITES_END	.\base\dynamic_annotations.h	592;"	d
ANNOTATE_MUTEX_IS_USED_AS_CONDVAR	.\base\dynamic_annotations.h	159;"	d
ANNOTATE_MUTEX_IS_USED_AS_CONDVAR	.\base\dynamic_annotations.h	358;"	d
ANNOTATE_NEW_MEMORY	.\base\dynamic_annotations.h	170;"	d
ANNOTATE_NEW_MEMORY	.\base\dynamic_annotations.h	353;"	d
ANNOTATE_NO_OP	.\base\dynamic_annotations.h	321;"	d
ANNOTATE_NO_OP	.\base\dynamic_annotations.h	368;"	d
ANNOTATE_PCQ_CREATE	.\base\dynamic_annotations.h	181;"	d
ANNOTATE_PCQ_CREATE	.\base\dynamic_annotations.h	349;"	d
ANNOTATE_PCQ_DESTROY	.\base\dynamic_annotations.h	185;"	d
ANNOTATE_PCQ_DESTROY	.\base\dynamic_annotations.h	350;"	d
ANNOTATE_PCQ_GET	.\base\dynamic_annotations.h	194;"	d
ANNOTATE_PCQ_GET	.\base\dynamic_annotations.h	352;"	d
ANNOTATE_PCQ_PUT	.\base\dynamic_annotations.h	190;"	d
ANNOTATE_PCQ_PUT	.\base\dynamic_annotations.h	351;"	d
ANNOTATE_PUBLISH_MEMORY_RANGE	.\base\dynamic_annotations.h	134;"	d
ANNOTATE_PUBLISH_MEMORY_RANGE	.\base\dynamic_annotations.h	346;"	d
ANNOTATE_PURE_HAPPENS_BEFORE_MUTEX	.\base\dynamic_annotations.h	155;"	d
ANNOTATE_PURE_HAPPENS_BEFORE_MUTEX	.\base\dynamic_annotations.h	357;"	d
ANNOTATE_RWLOCK_ACQUIRED	.\base\dynamic_annotations.h	281;"	d
ANNOTATE_RWLOCK_ACQUIRED	.\base\dynamic_annotations.h	334;"	d
ANNOTATE_RWLOCK_CREATE	.\base\dynamic_annotations.h	272;"	d
ANNOTATE_RWLOCK_CREATE	.\base\dynamic_annotations.h	332;"	d
ANNOTATE_RWLOCK_DESTROY	.\base\dynamic_annotations.h	276;"	d
ANNOTATE_RWLOCK_DESTROY	.\base\dynamic_annotations.h	333;"	d
ANNOTATE_RWLOCK_RELEASED	.\base\dynamic_annotations.h	285;"	d
ANNOTATE_RWLOCK_RELEASED	.\base\dynamic_annotations.h	335;"	d
ANNOTATE_SWAP_MEMORY_RANGE	.\base\dynamic_annotations.h	142;"	d
ANNOTATE_SWAP_MEMORY_RANGE	.\base\dynamic_annotations.h	348;"	d
ANNOTATE_THREAD_NAME	.\base\dynamic_annotations.h	263;"	d
ANNOTATE_THREAD_NAME	.\base\dynamic_annotations.h	360;"	d
ANNOTATE_TRACE_MEMORY	.\base\dynamic_annotations.h	259;"	d
ANNOTATE_TRACE_MEMORY	.\base\dynamic_annotations.h	359;"	d
ANNOTATE_UNPROTECTED_READ	.\base\dynamic_annotations.h	559;"	d
ANNOTATE_UNPROTECTED_READ	.\base\dynamic_annotations.h	610;"	d
ANNOTATE_UNPUBLISH_MEMORY_RANGE	.\base\dynamic_annotations.h	138;"	d
ANNOTATE_UNPUBLISH_MEMORY_RANGE	.\base\dynamic_annotations.h	347;"	d
ARMV2	.\base\arm_instruction_set_select.h	81;"	d
ARMV3	.\base\arm_instruction_set_select.h	76;"	d
ARMV4	.\base\arm_instruction_set_select.h	70;"	d
ARMV5	.\base\arm_instruction_set_select.h	64;"	d
ARMV6	.\base\arm_instruction_set_select.h	56;"	d
ARMV7	.\base\arm_instruction_set_select.h	46;"	d
ARMV8	.\base\arm_instruction_set_select.h	39;"	d
ARM_INSTRUCTION_SET_SELECT_H_	.\base\arm_instruction_set_select.h	36;"	d
ARRAYSIZE	.\tests\stack_trace_table_test.cc	16;"	d	file:
ARRAYSIZE	.\tests\stack_trace_table_test.cc	17;"	d	file:
ASM_INT3	.\windows\preamble_patcher.cc	47;"	d	file:
ASM_INT3	.\windows\preamble_patcher_with_stub.cc	44;"	d	file:
ASM_JCC32REL_0	.\windows\preamble_patcher.cc	51;"	d	file:
ASM_JCC32REL_1_MASK	.\windows\preamble_patcher.cc	52;"	d	file:
ASM_JMP	.\windows\preamble_patcher.cc	57;"	d	file:
ASM_JMP	.\windows\preamble_patcher_with_stub.cc	49;"	d	file:
ASM_JMP32ABS_0	.\windows\preamble_patcher.cc	48;"	d	file:
ASM_JMP32ABS_1	.\windows\preamble_patcher.cc	49;"	d	file:
ASM_JMP32REL	.\windows\preamble_patcher.cc	46;"	d	file:
ASM_JMP32REL	.\windows\preamble_patcher_with_stub.cc	43;"	d	file:
ASM_JMP8REL	.\windows\preamble_patcher.cc	50;"	d	file:
ASM_JMP_RAX	.\windows\preamble_patcher.cc	58;"	d	file:
ASM_JMP_RAX	.\windows\preamble_patcher_with_stub.cc	50;"	d	file:
ASM_MOVRAX_IMM	.\windows\preamble_patcher.cc	56;"	d	file:
ASM_MOVRAX_IMM	.\windows\preamble_patcher_with_stub.cc	47;"	d	file:
ASM_NOP	.\windows\preamble_patcher.cc	53;"	d	file:
ASM_NOP	.\windows\preamble_patcher_with_stub.cc	45;"	d	file:
ASM_PUSH	.\windows\preamble_patcher_with_stub.cc	51;"	d	file:
ASM_RET	.\windows\preamble_patcher_with_stub.cc	52;"	d	file:
ASM_REXW	.\windows\preamble_patcher.cc	55;"	d	file:
ASM_REXW	.\windows\preamble_patcher_with_stub.cc	48;"	d	file:
ASSERT	.\internal_logging.h	120;"	d
ASSERT_EQ	.\base\logging.h	157;"	d
ASSERT_FALSE	.\base\logging.h	168;"	d
ASSERT_GE	.\base\logging.h	161;"	d
ASSERT_GT	.\base\logging.h	162;"	d
ASSERT_LE	.\base\logging.h	159;"	d
ASSERT_LT	.\base\logging.h	160;"	d
ASSERT_NE	.\base\logging.h	158;"	d
ASSERT_STREQ	.\base\logging.h	169;"	d
ASSERT_TRUE	.\base\logging.h	167;"	d
ATOMICOPS_COMPILER_BARRIER	.\base\atomicops-internals-x86.h	389;"	d
ATOMICOPS_COMPILER_BARRIER	.\base\atomicops-internals-x86.h	64;"	d
ATTRIBUTE_NOINLINE	.\base\basictypes.h	228;"	d
ATTRIBUTE_NOINLINE	.\base\basictypes.h	231;"	d
ATTRIBUTE_NOINSTRUMENT	.\stacktrace_instrument-inl.h	63;"	d
ATTRIBUTE_SECTION	.\base\basictypes.h	260;"	d
ATTRIBUTE_SECTION	.\base\basictypes.h	279;"	d
ATTRIBUTE_SECTION	.\base\basictypes.h	338;"	d
ATTRIBUTE_SECTION_START	.\base\basictypes.h	274;"	d
ATTRIBUTE_SECTION_START	.\base\basictypes.h	333;"	d
ATTRIBUTE_SECTION_START	.\base\basictypes.h	342;"	d
ATTRIBUTE_SECTION_STOP	.\base\basictypes.h	275;"	d
ATTRIBUTE_SECTION_STOP	.\base\basictypes.h	334;"	d
ATTRIBUTE_SECTION_STOP	.\base\basictypes.h	343;"	d
ATTRIBUTE_UNUSED	.\base\basictypes.h	190;"	d
ATTRIBUTE_UNUSED	.\base\basictypes.h	192;"	d
ATTRIBUTE_VISIBILITY_HIDDEN	.\base\basictypes.h	235;"	d
ATTRIBUTE_VISIBILITY_HIDDEN	.\base\basictypes.h	237;"	d
ATTRIBUTE_WEAK	.\base\atomicops-internals-arm-generic.h	/^LinuxKernelCmpxchgFunc pLinuxKernelCmpxchg ATTRIBUTE_WEAK =$/;"	m	namespace:base::subtle
ATTRIBUTE_WEAK	.\base\atomicops-internals-arm-generic.h	/^LinuxKernelMemoryBarrierFunc pLinuxKernelMemoryBarrier ATTRIBUTE_WEAK =$/;"	m	namespace:base::subtle
ATTRIBUTE_WEAK	.\base\basictypes.h	227;"	d
ATTRIBUTE_WEAK	.\base\basictypes.h	230;"	d
ATTRIBUTE_WEAK	.\maybe_threads.cc	/^      __THROW ATTRIBUTE_WEAK;$/;"	v
ATTRIBUTE_WEAK	.\maybe_threads.cc	/^    __THROW ATTRIBUTE_WEAK;$/;"	v
ATTR_INITIAL_EXEC	.\thread_cache.cc	/^    ATTR_INITIAL_EXEC$/;"	m	namespace:tcmalloc	file:
ATTR_INITIAL_EXEC	.\thread_cache.h	/^  static __thread ThreadLocalData threadlocal_data_ ATTR_INITIAL_EXEC;$/;"	m	class:tcmalloc::ThreadCache
ATTR_INITIAL_EXEC	.\thread_cache.h	263;"	d
ATTR_INITIAL_EXEC	.\thread_cache.h	265;"	d
AT_FDCWD	.\base\linux_syscall_support.h	535;"	d
AT_REMOVEDIR	.\base\linux_syscall_support.h	541;"	d
AT_SYMLINK_NOFOLLOW	.\base\linux_syscall_support.h	538;"	d
AT_SYSINFO_EHDR	.\base\vdso_support.cc	54;"	d	file:
AcquirePassedObjects	.\tests\tcmalloc_unittest.cc	/^  void AcquirePassedObjects() {$/;"	f	class:testing::TesterThread
Acquire_AtomicExchange	.\base\atomicops-internals-arm-generic.h	/^inline Atomic32 Acquire_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
Acquire_AtomicExchange	.\base\atomicops-internals-arm-generic.h	/^inline Atomic64 Acquire_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
Acquire_AtomicExchange	.\base\atomicops-internals-arm-v6plus.h	/^inline Atomic32 Acquire_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
Acquire_AtomicExchange	.\base\atomicops-internals-arm-v6plus.h	/^inline Atomic64 Acquire_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
Acquire_AtomicExchange	.\base\atomicops-internals-gcc.h	/^inline Atomic32 Acquire_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
Acquire_AtomicExchange	.\base\atomicops-internals-gcc.h	/^inline Atomic64 Acquire_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
Acquire_AtomicExchange	.\base\atomicops-internals-linuxppc.h	/^inline Atomic32 Acquire_AtomicExchange(volatile Atomic32 *ptr,$/;"	f	namespace:base::subtle
Acquire_AtomicExchange	.\base\atomicops-internals-linuxppc.h	/^inline Atomic64 Acquire_AtomicExchange(volatile Atomic64 *ptr,$/;"	f	namespace:base::subtle
Acquire_AtomicExchange	.\base\atomicops-internals-macosx.h	/^inline Atomic32 Acquire_AtomicExchange(volatile Atomic32 *ptr,$/;"	f	namespace:base::subtle
Acquire_AtomicExchange	.\base\atomicops-internals-macosx.h	/^inline Atomic64 Acquire_AtomicExchange(volatile Atomic64 *ptr,$/;"	f	namespace:base::subtle
Acquire_AtomicExchange	.\base\atomicops-internals-mips.h	/^inline Atomic32 Acquire_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
Acquire_AtomicExchange	.\base\atomicops-internals-mips.h	/^inline Atomic64 Acquire_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
Acquire_AtomicExchange	.\base\atomicops-internals-windows.h	/^inline Atomic32 Acquire_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
Acquire_AtomicExchange	.\base\atomicops-internals-windows.h	/^inline Atomic64 Acquire_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
Acquire_AtomicExchange	.\base\atomicops-internals-x86.h	/^inline Atomic32 Acquire_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
Acquire_AtomicExchange	.\base\atomicops-internals-x86.h	/^inline Atomic64 Acquire_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
Acquire_AtomicExchange	.\base\atomicops.h	/^inline AtomicWord Acquire_AtomicExchange(volatile AtomicWord* ptr,$/;"	f	namespace:base::subtle
Acquire_CompareAndSwap	.\base\atomicops-internals-arm-generic.h	/^inline Atomic32 Acquire_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
Acquire_CompareAndSwap	.\base\atomicops-internals-arm-generic.h	/^inline Atomic64 Acquire_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
Acquire_CompareAndSwap	.\base\atomicops-internals-arm-v6plus.h	/^inline Atomic32 Acquire_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
Acquire_CompareAndSwap	.\base\atomicops-internals-arm-v6plus.h	/^inline Atomic64 Acquire_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
Acquire_CompareAndSwap	.\base\atomicops-internals-gcc.h	/^inline Atomic32 Acquire_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
Acquire_CompareAndSwap	.\base\atomicops-internals-gcc.h	/^inline Atomic64 Acquire_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
Acquire_CompareAndSwap	.\base\atomicops-internals-linuxppc.h	/^inline Atomic32 Acquire_CompareAndSwap(volatile Atomic32 *ptr,$/;"	f	namespace:base::subtle
Acquire_CompareAndSwap	.\base\atomicops-internals-linuxppc.h	/^inline Atomic64 Acquire_CompareAndSwap(volatile Atomic64 *ptr,$/;"	f	namespace:base::subtle
Acquire_CompareAndSwap	.\base\atomicops-internals-macosx.h	/^inline Atomic32 Acquire_CompareAndSwap(volatile Atomic32 *ptr,$/;"	f	namespace:base::subtle
Acquire_CompareAndSwap	.\base\atomicops-internals-macosx.h	/^inline Atomic64 Acquire_CompareAndSwap(volatile Atomic64 *ptr,$/;"	f	namespace:base::subtle
Acquire_CompareAndSwap	.\base\atomicops-internals-mips.h	/^inline Atomic32 Acquire_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
Acquire_CompareAndSwap	.\base\atomicops-internals-mips.h	/^inline Atomic64 Acquire_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
Acquire_CompareAndSwap	.\base\atomicops-internals-windows.h	/^inline Atomic32 Acquire_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
Acquire_CompareAndSwap	.\base\atomicops-internals-windows.h	/^inline Atomic64 Acquire_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
Acquire_CompareAndSwap	.\base\atomicops-internals-x86.h	/^inline Atomic32 Acquire_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
Acquire_CompareAndSwap	.\base\atomicops-internals-x86.h	/^inline Atomic64 Acquire_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
Acquire_CompareAndSwap	.\base\atomicops.h	/^inline Atomic32 Acquire_CompareAndSwap(volatile Atomic32* ptr,$/;"	f
Acquire_CompareAndSwap	.\base\atomicops.h	/^inline AtomicWord Acquire_CompareAndSwap(volatile AtomicWord* ptr,$/;"	f	namespace:base::subtle
Acquire_CompareAndSwap	.\base\atomicops.h	/^inline AtomicWord Acquire_CompareAndSwap(volatile AtomicWord* ptr,$/;"	f
Acquire_CompareAndSwap	.\base\atomicops.h	/^inline base::subtle::Atomic64 Acquire_CompareAndSwap($/;"	f
Acquire_Load	.\base\atomicops-internals-arm-generic.h	/^inline Atomic32 Acquire_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle
Acquire_Load	.\base\atomicops-internals-arm-generic.h	/^inline Atomic64 Acquire_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle
Acquire_Load	.\base\atomicops-internals-arm-v6plus.h	/^inline Atomic32 Acquire_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle
Acquire_Load	.\base\atomicops-internals-arm-v6plus.h	/^inline Atomic64 Acquire_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle
Acquire_Load	.\base\atomicops-internals-gcc.h	/^inline Atomic32 Acquire_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle
Acquire_Load	.\base\atomicops-internals-gcc.h	/^inline Atomic64 Acquire_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle
Acquire_Load	.\base\atomicops-internals-linuxppc.h	/^inline Atomic32 Acquire_Load(volatile const Atomic32 *ptr) {$/;"	f	namespace:base::subtle
Acquire_Load	.\base\atomicops-internals-linuxppc.h	/^inline Atomic64 Acquire_Load(volatile const Atomic64 *ptr) {$/;"	f	namespace:base::subtle
Acquire_Load	.\base\atomicops-internals-macosx.h	/^inline Atomic32 Acquire_Load(volatile const Atomic32 *ptr) {$/;"	f	namespace:base::subtle
Acquire_Load	.\base\atomicops-internals-macosx.h	/^inline Atomic64 Acquire_Load(volatile const Atomic64 *ptr) {$/;"	f	namespace:base::subtle
Acquire_Load	.\base\atomicops-internals-mips.h	/^inline Atomic32 Acquire_Load(volatile const Atomic32* ptr)$/;"	f	namespace:base::subtle
Acquire_Load	.\base\atomicops-internals-mips.h	/^inline Atomic64 Acquire_Load(volatile const Atomic64* ptr)$/;"	f	namespace:base::subtle
Acquire_Load	.\base\atomicops-internals-windows.h	/^inline Atomic32 Acquire_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle
Acquire_Load	.\base\atomicops-internals-windows.h	/^inline Atomic64 Acquire_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle
Acquire_Load	.\base\atomicops-internals-x86.h	/^inline Atomic32 Acquire_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle
Acquire_Load	.\base\atomicops-internals-x86.h	/^inline Atomic64 Acquire_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle
Acquire_Load	.\base\atomicops.h	/^inline Atomic32 Acquire_Load(volatile const Atomic32* ptr) {$/;"	f
Acquire_Load	.\base\atomicops.h	/^inline AtomicWord Acquire_Load(volatile const AtomicWord* ptr) {$/;"	f	namespace:base::subtle
Acquire_Load	.\base\atomicops.h	/^inline AtomicWord Acquire_Load(volatile const AtomicWord* ptr) {$/;"	f
Acquire_Load	.\base\atomicops.h	/^inline base::subtle::Atomic64 Acquire_Load($/;"	f
Acquire_Store	.\base\atomicops-internals-arm-generic.h	/^inline void Acquire_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle
Acquire_Store	.\base\atomicops-internals-arm-generic.h	/^inline void Acquire_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle
Acquire_Store	.\base\atomicops-internals-arm-v6plus.h	/^inline void Acquire_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle
Acquire_Store	.\base\atomicops-internals-arm-v6plus.h	/^inline void Acquire_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle
Acquire_Store	.\base\atomicops-internals-gcc.h	/^inline void Acquire_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle
Acquire_Store	.\base\atomicops-internals-gcc.h	/^inline void Acquire_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle
Acquire_Store	.\base\atomicops-internals-linuxppc.h	/^inline void Acquire_Store(volatile Atomic32 *ptr, Atomic32 value) {$/;"	f	namespace:base::subtle
Acquire_Store	.\base\atomicops-internals-linuxppc.h	/^inline void Acquire_Store(volatile Atomic64 *ptr, Atomic64 value) {$/;"	f	namespace:base::subtle
Acquire_Store	.\base\atomicops-internals-macosx.h	/^inline void Acquire_Store(volatile Atomic32 *ptr, Atomic32 value) {$/;"	f	namespace:base::subtle
Acquire_Store	.\base\atomicops-internals-macosx.h	/^inline void Acquire_Store(volatile Atomic64 *ptr, Atomic64 value) {$/;"	f	namespace:base::subtle
Acquire_Store	.\base\atomicops-internals-mips.h	/^inline void Acquire_Store(volatile Atomic32* ptr, Atomic32 value)$/;"	f	namespace:base::subtle
Acquire_Store	.\base\atomicops-internals-mips.h	/^inline void Acquire_Store(volatile Atomic64* ptr, Atomic64 value)$/;"	f	namespace:base::subtle
Acquire_Store	.\base\atomicops-internals-windows.h	/^inline void Acquire_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle
Acquire_Store	.\base\atomicops-internals-windows.h	/^inline void Acquire_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle
Acquire_Store	.\base\atomicops-internals-x86.h	/^inline void Acquire_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle
Acquire_Store	.\base\atomicops-internals-x86.h	/^inline void Acquire_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle
Acquire_Store	.\base\atomicops.h	/^inline void Acquire_Store($/;"	f
Acquire_Store	.\base\atomicops.h	/^inline void Acquire_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f
Acquire_Store	.\base\atomicops.h	/^inline void Acquire_Store(volatile AtomicWord* ptr, AtomicWord value) {$/;"	f	namespace:base::subtle
Acquire_Store	.\base\atomicops.h	/^inline void Acquire_Store(volatile AtomicWord* ptr, AtomicWord value) {$/;"	f
Add	.\heap-profile-table.h	/^  inline void Add(const void* ptr, const AllocValue& v) {$/;"	f	class:HeapProfileTable::Snapshot
Add	.\internal_logging.cc	/^bool Logger::Add(const LogItem& item) {$/;"	f	class:tcmalloc::Logger
Add	.\malloc_hook.cc	/^bool HookList<T>::Add(T value_as_t) {$/;"	f	class:base::internal::HookList
Add	.\profiledata.cc	/^void ProfileData::Add(int depth, const void* const* stack) {$/;"	f	class:ProfileData
Add	.\symbolize.cc	/^void SymbolTable::Add(const void* addr) {$/;"	f	class:SymbolTable
AddDeleteHook	.\gperftools\malloc_hook.h	/^  inline static bool AddDeleteHook(DeleteHook hook) {$/;"	f	class:MallocHook
AddIfNonLive	.\heap-profile-table.cc	/^void HeapProfileTable::AddIfNonLive(const void* ptr, AllocValue* v,$/;"	f	class:HeapProfileTable
AddMmapHook	.\gperftools\malloc_hook.h	/^  inline static bool AddMmapHook(MmapHook hook) {$/;"	f	class:MallocHook
AddMremapHook	.\gperftools\malloc_hook.h	/^  inline static bool AddMremapHook(MremapHook hook) {$/;"	f	class:MallocHook
AddMunmapHook	.\gperftools\malloc_hook.h	/^  inline static bool AddMunmapHook(MunmapHook hook) {$/;"	f	class:MallocHook
AddNewHook	.\gperftools\malloc_hook.h	/^  inline static bool AddNewHook(NewHook hook) {$/;"	f	class:MallocHook
AddNonLiveArgs	.\heap-profile-table.h	/^  struct AddNonLiveArgs {$/;"	s	class:HeapProfileTable
AddNum	.\internal_logging.cc	/^bool Logger::AddNum(uint64_t num, int base) {$/;"	f	class:tcmalloc::Logger
AddPreMmapHook	.\gperftools\malloc_hook.h	/^  inline static bool AddPreMmapHook(PreMmapHook hook) {$/;"	f	class:MallocHook
AddPreSbrkHook	.\gperftools\malloc_hook.h	/^  inline static bool AddPreSbrkHook(PreSbrkHook hook) {$/;"	f	class:MallocHook
AddSbrkHook	.\gperftools\malloc_hook.h	/^  inline static bool AddSbrkHook(SbrkHook hook) {$/;"	f	class:MallocHook
AddStr	.\internal_logging.cc	/^bool Logger::AddStr(const char* str, int n) {$/;"	f	class:tcmalloc::Logger
AddToFreelist	.\base\low_level_alloc.cc	/^static void AddToFreelist(void *v, LowLevelAlloc::Arena *arena) {$/;"	f	file:
AddToSnapshot	.\heap-profile-table.cc	/^void HeapProfileTable::AddToSnapshot(const void* ptr, AllocValue* v,$/;"	f	class:HeapProfileTable
AddTrace	.\stack_trace_table.cc	/^void StackTraceTable::AddTrace(const StackTrace& t) {$/;"	f	class:tcmalloc::StackTraceTable
AddTrace	.\tests\stack_trace_table_test.cc	/^static void AddTrace(tcmalloc::StackTraceTable* table,$/;"	f	file:
AddType	.\tests\tcmalloc_unittest.cc	/^void TestHarness::AddType(int type, int weight, const char* name) {$/;"	f	class:testing::TestHarness
AddressMap	.\addressmap-inl.h	/^AddressMap<Value>::AddressMap(Allocator alloc, DeAllocator dealloc)$/;"	f	class:AddressMap
AddressMap	.\addressmap-inl.h	/^class AddressMap {$/;"	c
AddressRange	.\tests\stacktrace_unittest.cc	/^struct AddressRange {$/;"	s	namespace:__anon40	file:
AddressingMethod	.\windows\mini_disassembler_types.h	/^enum AddressingMethod {$/;"	g	namespace:sidestep
AggressiveDecommitChanger	.\tests\tcmalloc_unittest.cc	/^  AggressiveDecommitChanger(size_t new_value) {$/;"	f	class:testing::AggressiveDecommitChanger
AggressiveDecommitChanger	.\tests\tcmalloc_unittest.cc	/^class AggressiveDecommitChanger {$/;"	c	namespace:testing	file:
AlignmentForSize	.\common.cc	/^int AlignmentForSize(size_t size) {$/;"	f	namespace:tcmalloc
Alloc	.\base\low_level_alloc.cc	/^void *LowLevelAlloc::Alloc(size_t request) {$/;"	f	class:LowLevelAlloc
Alloc	.\memfs_malloc.cc	/^void* HugetlbSysAllocator::Alloc(size_t size, size_t *actual_size,$/;"	f	class:HugetlbSysAllocator
Alloc	.\system-alloc.cc	/^void* DefaultSysAllocator::Alloc(size_t size, size_t *actual_size,$/;"	f	class:DefaultSysAllocator
Alloc	.\system-alloc.cc	/^void* DevMemSysAllocator::Alloc(size_t size, size_t *actual_size,$/;"	f	class:DevMemSysAllocator
Alloc	.\system-alloc.cc	/^void* MmapSysAllocator::Alloc(size_t size, size_t *actual_size,$/;"	f	class:MmapSysAllocator
Alloc	.\system-alloc.cc	/^void* SbrkSysAllocator::Alloc(size_t size, size_t *actual_size,$/;"	f	class:SbrkSysAllocator
Alloc	.\tests\system-alloc_unittest.cc	/^  void* Alloc(size_t size, size_t *actual_size, size_t alignment) {$/;"	f	class:ArraySysAllocator
Alloc	.\windows\system-alloc.cc	/^void* VirtualSysAllocator::Alloc(size_t size, size_t *actual_size,$/;"	f	class:VirtualSysAllocator
AllocContextInfo	.\heap-profile-table.h	/^  struct AllocContextInfo : public Stats {$/;"	s	class:HeapProfileTable
AllocContextIterator	.\heap-profile-table.h	/^  typedef void (*AllocContextIterator)(const AllocContextInfo& info);$/;"	t	class:HeapProfileTable
AllocHidden	.\tests\heap-checker_unittest.cc	/^static void* AllocHidden(size_t size) {$/;"	f	file:
AllocHook	.\tests\low_level_alloc_unittest.cc	/^static void AllocHook(const void *p, size_t size) {$/;"	f	file:
AllocInfo	.\heap-profile-table.h	/^  struct AllocInfo {$/;"	s	class:HeapProfileTable
AllocInternal	.\memfs_malloc.cc	/^void* HugetlbSysAllocator::AllocInternal(size_t size, size_t* actual_size,$/;"	f	class:HugetlbSysAllocator
AllocIterator	.\heap-profile-table.h	/^  typedef void (*AllocIterator)(const void* ptr, const AllocInfo& info);$/;"	t	class:HeapProfileTable
AllocLarge	.\page_heap.cc	/^Span* PageHeap::AllocLarge(Length n) {$/;"	f	class:tcmalloc::PageHeap
AllocList	.\base\low_level_alloc.cc	/^  struct AllocList {$/;"	s	namespace:low_level_alloc_internal	file:
AllocMap	.\debugallocation.cc	/^  typedef AddressMap<int> AllocMap;$/;"	t	class:MallocBlock	file:
AllocName	.\debugallocation.cc	/^  static const char* AllocName(int type) {$/;"	f	class:MallocBlock	file:
AllocObject	.\heap-checker.cc	/^  AllocObject(const void* p, size_t s, ObjectPlacement l)$/;"	f	struct:AllocObject
AllocObject	.\heap-checker.cc	/^struct AllocObject {$/;"	s	file:
AllocPageNear	.\windows\preamble_patcher.cc	/^void* PreamblePatcher::AllocPageNear(void* target) {$/;"	f	class:sidestep::PreamblePatcher
AllocPreambleBlockNear	.\windows\preamble_patcher.cc	/^unsigned char* PreamblePatcher::AllocPreambleBlockNear(void* target) {$/;"	f	class:sidestep::PreamblePatcher
AllocStuff	.\tests\thread_dealloc_unittest.cc	/^static void AllocStuff() {$/;"	f	file:
AllocValue	.\heap-profile-table.h	/^  struct AllocValue {$/;"	s	class:HeapProfileTable
AllocValueSize	.\heap-profile-table.h	/^  static size_t AllocValueSize(const AllocValue& v) { return v.bytes; }$/;"	f	class:HeapProfileTable
AllocWithArena	.\base\low_level_alloc.cc	/^void *LowLevelAlloc::AllocWithArena(size_t request, Arena *arena) {$/;"	f	class:LowLevelAlloc
Allocate	.\debugallocation.cc	/^  static MallocBlock* Allocate(size_t size, int type) {$/;"	f	class:MallocBlock
Allocate	.\heap-checker.cc	/^  static void* Allocate(size_t n) {$/;"	f	class:HeapLeakChecker::Allocator
Allocate	.\memory_region_map.h	/^    static void *Allocate(size_t n) {$/;"	f	struct:MemoryRegionMap::MyAllocator
Allocate	.\tests\heap-profiler_unittest.cc	/^static ATTRIBUTE_NOINLINE void Allocate(int start, int end, int size) {$/;"	f	file:
Allocate	.\thread_cache.h	/^inline void* ThreadCache::Allocate(size_t size, size_t cl) {$/;"	f	class:tcmalloc::ThreadCache
Allocate2	.\tests\heap-profiler_unittest.cc	/^static ATTRIBUTE_NOINLINE void Allocate2(int start, int end, int size) {$/;"	f	file:
AllocateAllocate	.\tests\sampling_test.cc	/^extern "C" void* AllocateAllocate() {$/;"	f
AllocateObject	.\tests\tcmalloc_unittest.cc	/^  void AllocateObject() {$/;"	f	class:testing::TesterThread
AllocationMap	.\heap-profile-table.h	/^  typedef AddressMap<AllocValue> AllocationMap;$/;"	t	class:HeapProfileTable
Allocator	.\addressmap-inl.h	/^  typedef void* (*Allocator)(size_t size);$/;"	t	class:AddressMap
Allocator	.\heap-checker.cc	/^class HeapLeakChecker::Allocator {$/;"	c	class:HeapLeakChecker	file:
Allocator	.\heap-profile-table.h	/^  typedef void* (*Allocator)(size_t size);$/;"	t	class:HeapProfileTable
AllocatorState	.\tests\tcmalloc_unittest.cc	/^  explicit AllocatorState(int seed) : TestHarness(seed), memalign_fraction_(0) {$/;"	f	class:testing::AllocatorState
AllocatorState	.\tests\tcmalloc_unittest.cc	/^class AllocatorState : public TestHarness {$/;"	c	namespace:testing	file:
AndersonDarlingErrFix	.\tests\sampler_test.cc	/^double AndersonDarlingErrFix(int n, double x) {$/;"	f
AndersonDarlingInf	.\tests\sampler_test.cc	/^double AndersonDarlingInf(double z) {$/;"	f
AndersonDarlingPValue	.\tests\sampler_test.cc	/^double AndersonDarlingPValue(int n, double z) {$/;"	f
AndersonDarlingStatistic	.\tests\sampler_test.cc	/^double AndersonDarlingStatistic(int n, double* random_sample) {$/;"	f
AndersonDarlingTest	.\tests\sampler_test.cc	/^double AndersonDarlingTest(int n, double* random_sample) {$/;"	f
AnnotateBarrierDestroy	.\base\dynamic_annotations.c	/^void AnnotateBarrierDestroy(const char *file, int line,$/;"	f
AnnotateBarrierInit	.\base\dynamic_annotations.c	/^void AnnotateBarrierInit(const char *file, int line,$/;"	f
AnnotateBarrierWaitAfter	.\base\dynamic_annotations.c	/^void AnnotateBarrierWaitAfter(const char *file, int line,$/;"	f
AnnotateBarrierWaitBefore	.\base\dynamic_annotations.c	/^void AnnotateBarrierWaitBefore(const char *file, int line,$/;"	f
AnnotateBenignRace	.\base\dynamic_annotations.c	/^void AnnotateBenignRace(const char *file, int line,$/;"	f
AnnotateBenignRaceSized	.\base\dynamic_annotations.c	/^void AnnotateBenignRaceSized(const char *file, int line,$/;"	f
AnnotateCondVarSignal	.\base\dynamic_annotations.c	/^void AnnotateCondVarSignal(const char *file, int line,$/;"	f
AnnotateCondVarSignalAll	.\base\dynamic_annotations.c	/^void AnnotateCondVarSignalAll(const char *file, int line,$/;"	f
AnnotateCondVarWait	.\base\dynamic_annotations.c	/^void AnnotateCondVarWait(const char *file, int line,$/;"	f
AnnotateEnableRaceDetection	.\base\dynamic_annotations.c	/^void AnnotateEnableRaceDetection(const char *file, int line, int enable){}$/;"	f
AnnotateExpectRace	.\base\dynamic_annotations.c	/^void AnnotateExpectRace(const char *file, int line,$/;"	f
AnnotateFlushState	.\base\dynamic_annotations.c	/^void AnnotateFlushState(const char *file, int line){}$/;"	f
AnnotateIgnoreReadsBegin	.\base\dynamic_annotations.c	/^void AnnotateIgnoreReadsBegin(const char *file, int line){}$/;"	f
AnnotateIgnoreReadsEnd	.\base\dynamic_annotations.c	/^void AnnotateIgnoreReadsEnd(const char *file, int line){}$/;"	f
AnnotateIgnoreWritesBegin	.\base\dynamic_annotations.c	/^void AnnotateIgnoreWritesBegin(const char *file, int line){}$/;"	f
AnnotateIgnoreWritesEnd	.\base\dynamic_annotations.c	/^void AnnotateIgnoreWritesEnd(const char *file, int line){}$/;"	f
AnnotateMutexIsUsedAsCondVar	.\base\dynamic_annotations.c	/^void AnnotateMutexIsUsedAsCondVar(const char *file, int line,$/;"	f
AnnotateNewMemory	.\base\dynamic_annotations.c	/^void AnnotateNewMemory(const char *file, int line,$/;"	f
AnnotateNoOp	.\base\dynamic_annotations.c	/^void AnnotateNoOp(const char *file, int line,$/;"	f
AnnotatePCQCreate	.\base\dynamic_annotations.c	/^void AnnotatePCQCreate(const char *file, int line,$/;"	f
AnnotatePCQDestroy	.\base\dynamic_annotations.c	/^void AnnotatePCQDestroy(const char *file, int line,$/;"	f
AnnotatePCQGet	.\base\dynamic_annotations.c	/^void AnnotatePCQGet(const char *file, int line,$/;"	f
AnnotatePCQPut	.\base\dynamic_annotations.c	/^void AnnotatePCQPut(const char *file, int line,$/;"	f
AnnotatePublishMemoryRange	.\base\dynamic_annotations.c	/^void AnnotatePublishMemoryRange(const char *file, int line,$/;"	f
AnnotateRWLockAcquired	.\base\dynamic_annotations.c	/^void AnnotateRWLockAcquired(const char *file, int line,$/;"	f
AnnotateRWLockCreate	.\base\dynamic_annotations.c	/^void AnnotateRWLockCreate(const char *file, int line,$/;"	f
AnnotateRWLockDestroy	.\base\dynamic_annotations.c	/^void AnnotateRWLockDestroy(const char *file, int line,$/;"	f
AnnotateRWLockReleased	.\base\dynamic_annotations.c	/^void AnnotateRWLockReleased(const char *file, int line,$/;"	f
AnnotateThreadName	.\base\dynamic_annotations.c	/^void AnnotateThreadName(const char *file, int line,$/;"	f
AnnotateTraceMemory	.\base\dynamic_annotations.c	/^void AnnotateTraceMemory(const char *file, int line,$/;"	f
AnnotateUnpublishMemoryRange	.\base\dynamic_annotations.c	/^void AnnotateUnpublishMemoryRange(const char *file, int line,$/;"	f
Arena	.\base\low_level_alloc.cc	/^  Arena() : mu(SpinLock::LINKER_INITIALIZED) {} \/\/ does nothing; for static init$/;"	f	struct:LowLevelAlloc::Arena
Arena	.\base\low_level_alloc.cc	/^  explicit Arena(int) : pagesize(0) {}  \/\/ set pagesize to zero explicitly$/;"	f	struct:LowLevelAlloc::Arena
Arena	.\base\low_level_alloc.cc	/^struct LowLevelAlloc::Arena {$/;"	s	class:LowLevelAlloc	file:
ArenaInit	.\base\low_level_alloc.cc	/^static void ArenaInit(LowLevelAlloc::Arena *arena) {$/;"	f	file:
ArenaLock	.\base\low_level_alloc.cc	/^  class SCOPED_LOCKABLE ArenaLock {$/;"	c	namespace:__anon8	file:
Array	.\tests\heap-checker_unittest.cc	/^  Array() {$/;"	f	struct:Array
Array	.\tests\heap-checker_unittest.cc	/^  Array(const Array& x) {$/;"	f	struct:Array
Array	.\tests\heap-checker_unittest.cc	/^struct Array {$/;"	s	file:
ArraySysAllocator	.\tests\system-alloc_unittest.cc	/^  ArraySysAllocator() : SysAllocator() {$/;"	f	class:ArraySysAllocator
ArraySysAllocator	.\tests\system-alloc_unittest.cc	/^class ArraySysAllocator : public SysAllocator {$/;"	c	file:
AsInt	.\heap-checker.cc	/^inline static uintptr_t AsInt(const void* ptr) {$/;"	f	file:
AsPtr	.\heap-checker.cc	/^inline static const void* AsPtr(T addr) {$/;"	f	file:
AssertIsConsistent	.\memory_region_map.h	/^    void AssertIsConsistent() const {$/;"	f	struct:MemoryRegionMap::Region
AssignAttributeStartEnd	.\base\basictypes.h	/^  AssignAttributeStartEnd(const char* name, char** pstart, char** pend) {$/;"	f	class:AssignAttributeStartEnd
AssignAttributeStartEnd	.\base\basictypes.h	/^class AssignAttributeStartEnd {$/;"	c
Atomic32	.\base\atomicops-internals-arm-generic.h	/^typedef int32_t Atomic32;$/;"	t
Atomic32	.\base\atomicops-internals-arm-v6plus.h	/^typedef int32_t Atomic32;$/;"	t
Atomic32	.\base\atomicops-internals-gcc.h	/^typedef int32_t Atomic32;$/;"	t
Atomic32	.\base\atomicops-internals-linuxppc.h	/^typedef int32_t Atomic32;$/;"	t
Atomic32	.\base\atomicops-internals-macosx.h	/^typedef int32_t Atomic32;$/;"	t
Atomic32	.\base\atomicops-internals-mips.h	/^typedef int32_t Atomic32;$/;"	t
Atomic32	.\base\atomicops-internals-windows.h	/^typedef int32 Atomic32;$/;"	t
Atomic32	.\base\atomicops-internals-x86.h	/^typedef int32_t Atomic32;$/;"	t
Atomic64	.\base\atomicops-internals-arm-generic.h	/^typedef int64_t Atomic64;$/;"	t	namespace:base::subtle
Atomic64	.\base\atomicops-internals-arm-v6plus.h	/^typedef int64_t Atomic64;$/;"	t	namespace:base::subtle
Atomic64	.\base\atomicops-internals-gcc.h	/^typedef int64_t Atomic64;$/;"	t	namespace:base::subtle
Atomic64	.\base\atomicops-internals-linuxppc.h	/^typedef int64_t Atomic64;$/;"	t	namespace:base::subtle
Atomic64	.\base\atomicops-internals-macosx.h	/^typedef int64_t Atomic64;$/;"	t	namespace:base::subtle
Atomic64	.\base\atomicops-internals-mips.h	/^typedef int64_t Atomic64;$/;"	t	namespace:base::subtle
Atomic64	.\base\atomicops-internals-windows.h	/^typedef int64 Atomic64;$/;"	t	namespace:base::subtle
Atomic64	.\base\atomicops-internals-x86.h	/^typedef int64_t Atomic64;$/;"	t	namespace:base::subtle
AtomicOps_Internalx86CPUFeatures	.\base\atomicops-internals-x86.cc	/^struct AtomicOps_x86CPUFeatureStruct AtomicOps_Internalx86CPUFeatures = {$/;"	v	typeref:struct:AtomicOps_x86CPUFeatureStruct
AtomicOps_Internalx86CPUFeaturesInit	.\base\atomicops-internals-x86.cc	/^static void AtomicOps_Internalx86CPUFeaturesInit() {$/;"	f	file:
AtomicOps_x86CPUFeatureStruct	.\base\atomicops-internals-x86.h	/^struct AtomicOps_x86CPUFeatureStruct {$/;"	s
AtomicWord	.\base\atomicops.h	/^typedef intptr_t AtomicWord;$/;"	t
AtomicWordCastType	.\base\atomicops-internals-macosx.h	46;"	d
AtomicWordCastType	.\base\atomicops-internals-macosx.h	48;"	d
AutoHookIncrementNumber	.\windows\preamble_patcher_test.cc	/^int __declspec(noinline) AutoHookIncrementNumber(int i) {$/;"	f	namespace:__anon57
AutoTestingHook	.\windows\auto_testing_hook.h	/^typedef const AutoTestingHookBase& AutoTestingHook;$/;"	t	namespace:sidestep
AutoTestingHookBase	.\windows\auto_testing_hook.h	/^class AutoTestingHookBase {$/;"	c	namespace:sidestep
AutoTestingHookHolder	.\windows\auto_testing_hook.h	/^  AutoTestingHookHolder() {}  \/\/ disallow$/;"	f	class:sidestep::AutoTestingHookHolder
AutoTestingHookHolder	.\windows\auto_testing_hook.h	/^  explicit AutoTestingHookHolder(AutoTestingHookBase* hook) : hook_(hook) {}$/;"	f	class:sidestep::AutoTestingHookHolder
AutoTestingHookHolder	.\windows\auto_testing_hook.h	/^class AutoTestingHookHolder {$/;"	c	namespace:sidestep
AutoTestingHookImpl	.\windows\auto_testing_hook.h	/^  AutoTestingHookImpl(T target_function, T replacement_function, bool do_it)$/;"	f	class:sidestep::AutoTestingHookImpl
AutoTestingHookImpl	.\windows\auto_testing_hook.h	/^class AutoTestingHookImpl : public AutoTestingHookBase {$/;"	c	namespace:sidestep
AutoTestingHookInContainerTest	.\windows\preamble_patcher_test.cc	/^bool AutoTestingHookInContainerTest() {$/;"	f	namespace:sidestep
AutoTestingHookTest	.\windows\preamble_patcher_test.cc	/^bool AutoTestingHookTest() {$/;"	f	namespace:sidestep
B	.\tests\heap-checker_unittest.cc	/^  virtual void B() { }$/;"	f	class:ClassMltD1
B	.\tests\heap-checker_unittest.cc	/^  virtual void B() { }$/;"	f	class:ClassMltD2
BACKTRACE_STEPS	.\tests\stacktrace_unittest.cc	/^const int BACKTRACE_STEPS = 6;$/;"	m	namespace:__anon40	file:
BACK_TRACE	.\stacktrace_instrument-inl.h	/^}BACK_TRACE;$/;"	t	typeref:struct:__anon28
BASE_ADDRESSMAP_INL_H_	.\addressmap-inl.h	82;"	d
BASE_ATOMICOPS_HAS_LDREXD_AND_STREXD	.\base\atomicops-internals-arm-v6plus.h	50;"	d
BASE_ATOMICOPS_INTERNALS_ARM_GENERIC_H_	.\base\atomicops-internals-arm-generic.h	39;"	d
BASE_ATOMICOPS_INTERNALS_ARM_V6PLUS_H_	.\base\atomicops-internals-arm-v6plus.h	40;"	d
BASE_ATOMICOPS_INTERNALS_GCC_GENERIC_H_	.\base\atomicops-internals-gcc.h	39;"	d
BASE_ATOMICOPS_INTERNALS_LINUXPPC_H_	.\base\atomicops-internals-linuxppc.h	39;"	d
BASE_ATOMICOPS_INTERNALS_MACOSX_H_	.\base\atomicops-internals-macosx.h	37;"	d
BASE_ATOMICOPS_INTERNALS_MIPS_H_	.\base\atomicops-internals-mips.h	40;"	d
BASE_ATOMICOPS_INTERNALS_WINDOWS_H_	.\base\atomicops-internals-windows.h	40;"	d
BASE_ATOMICOPS_INTERNALS_X86_H_	.\base\atomicops-internals-x86.h	40;"	d
BASE_COMMANDLINEFLAGS_H_	.\base\commandlineflags.h	50;"	d
BASE_DYNAMIC_ANNOTATIONS_H_	.\base\dynamic_annotations.h	58;"	d
BASE_ELF_MEM_IMAGE_H_	.\base\elf_mem_image.h	37;"	d
BASE_GETPC_H_	.\getpc.h	45;"	d
BASE_HAS_ATOMIC64	.\base\atomicops-internals-arm-v6plus.h	168;"	d
BASE_HAS_ATOMIC64	.\base\atomicops-internals-linuxppc.h	44;"	d
BASE_HAS_ATOMIC64	.\base\atomicops-internals-macosx.h	52;"	d
BASE_HAS_ATOMIC64	.\base\atomicops-internals-mips.h	43;"	d
BASE_HAS_ATOMIC64	.\base\atomicops-internals-windows.h	49;"	d
BASE_HAS_ATOMIC64	.\base\atomicops-internals-x86.h	44;"	d
BASE_HEAP_CHECKER_H_	.\gperftools\heap-checker.h	53;"	d
BASE_HEAP_PROFILER_H_	.\gperftools\heap-profiler.h	52;"	d
BASE_HEAP_PROFILE_TABLE_H_	.\heap-profile-table.h	37;"	d
BASE_MALLOC_EXTENSION_H_	.\gperftools\malloc_extension.h	43;"	d
BASE_MEMORY_REGION_MAP_H_	.\memory_region_map.h	36;"	d
BASE_PROFILEDATA_H_	.\profiledata.h	42;"	d
BASE_PROFILER_H_	.\gperftools\profiler.h	61;"	d
BASE_PROFILE_HANDLER_H_	.\profile-handler.h	49;"	d
BASE_RAW_PRINTER_H_	.\raw_printer.h	44;"	d
BASE_SPINLOCK_H_	.\base\spinlock.h	40;"	d
BASE_SPINLOCK_INTERNAL_H_	.\base\spinlock_internal.h	37;"	d
BASE_STACKTRACE_ARM_INL_H_	.\stacktrace_arm-inl.h	37;"	d
BASE_STACKTRACE_GENERIC_INL_H_	.\stacktrace_generic-inl.h	40;"	d
BASE_STACKTRACE_INSTRUMENT_INL_H_	.\stacktrace_instrument-inl.h	46;"	d
BASE_STACKTRACE_LIBGCC_INL_H_	.\stacktrace_libgcc-inl.h	38;"	d
BASE_STACKTRACE_LIBINWIND_INL_H_	.\stacktrace_libunwind-inl.h	37;"	d
BASE_STACKTRACE_POWERPC_INL_H_	.\stacktrace_powerpc-darwin-inl.h	38;"	d
BASE_STACKTRACE_POWERPC_INL_H_	.\stacktrace_powerpc-inl.h	41;"	d
BASE_STACKTRACE_POWERPC_INL_H_	.\stacktrace_powerpc-linux-inl.h	41;"	d
BASE_STACKTRACE_UNW_CONTEXT_IS_UCONTEXT	.\stacktrace_libunwind-inl.h	62;"	d
BASE_STACKTRACE_WIN32_INL_H_	.\stacktrace_win32-inl.h	54;"	d
BASE_STACKTRACE_X86_INL_H_	.\stacktrace_x86-inl.h	37;"	d
BASE_STL_ALLOCATOR_H_	.\base\stl_allocator.h	37;"	d
BASE_THREAD_ANNOTATIONS_H_	.\base\thread_annotations.h	46;"	d
BASE_VDSO_SUPPORT_H_	.\base\vdso_support.h	56;"	d
BP	.\base\elfcore.h	70;"	d
BP	.\base\elfcore.h	94;"	d
BecomeIdle	.\thread_cache.cc	/^void ThreadCache::BecomeIdle() {$/;"	f	class:tcmalloc::ThreadCache
BecomeTemporarilyIdle	.\thread_cache.cc	/^void ThreadCache::BecomeTemporarilyIdle() {$/;"	f	class:tcmalloc::ThreadCache
BeforeConstructorsLocked	.\heap-checker.cc	/^void HeapLeakChecker::BeforeConstructorsLocked() {$/;"	f	class:HeapLeakChecker
BeginRegionLocked	.\memory_region_map.cc	/^MemoryRegionMap::RegionIterator MemoryRegionMap::BeginRegionLocked() {$/;"	f	class:MemoryRegionMap
BlockDesc	.\tests\low_level_alloc_unittest.cc	/^struct BlockDesc {$/;"	s	file:
BlockID	.\addressmap-inl.h	/^  static int BlockID(Number address) {$/;"	f	class:AddressMap
BriefNoLeaks	.\gperftools\heap-checker.h	/^  bool BriefNoLeaks()  { return NoLeaks(); }$/;"	f	class:HeapLeakChecker
BriefSameHeap	.\gperftools\heap-checker.h	/^  bool BriefSameHeap() { return NoLeaks(); }$/;"	f	class:HeapLeakChecker
Bucket	.\heap-profile-table.h	/^  typedef HeapProfileBucket Bucket;$/;"	t	class:HeapProfileTable
Bucket	.\profiledata.h	/^  struct Bucket {$/;"	s	class:ProfileData
Bucket	.\stack_trace_table.h	/^  struct Bucket {$/;"	s	class:tcmalloc::StackTraceTable
Buffer	.\base\sysinfo.h	/^  struct Buffer {$/;"	s	class:ProcMapsIterator
BufferArgs	.\heap-profile-table.h	/^    BufferArgs(char* buf_arg, int buflen_arg, int bufsize_arg)$/;"	f	struct:HeapProfileTable::BufferArgs
BufferArgs	.\heap-profile-table.h	/^  struct BufferArgs {$/;"	s	class:HeapProfileTable
BusyThread	.\tests\profile-handler_unittest.cc	/^  BusyThread() : stop_work_(false) {$/;"	f	class:__anon37::BusyThread
BusyThread	.\tests\profile-handler_unittest.cc	/^class BusyThread : public Thread {$/;"	c	namespace:__anon37	file:
ByAllocatedSpace	.\heap-profile-table.cc	/^static bool ByAllocatedSpace(HeapProfileTable::Stats* a,$/;"	f	file:
ByteSizeForClass	.\common.h	/^  inline size_t ByteSizeForClass(size_t cl) {$/;"	f	class:tcmalloc::SizeMap
BytesLeaked	.\heap-checker.cc	/^ssize_t HeapLeakChecker::BytesLeaked() const {$/;"	f	class:HeapLeakChecker
C	.\tests\heap-checker_unittest.cc	/^  virtual void C() { }$/;"	f	class:ClassMltD1
CACHELINE_ALIGNED	.\base\basictypes.h	/^} CACHELINE_ALIGNED;$/;"	v	typeref:union:MemoryAligner
CACHELINE_ALIGNED	.\base\basictypes.h	349;"	d
CACHELINE_ALIGNED	.\base\basictypes.h	351;"	d
CACHELINE_ALIGNED	.\base\basictypes.h	353;"	d
CACHELINE_ALIGNED	.\base\basictypes.h	356;"	d
CACHELINE_ALIGNED	.\base\basictypes.h	358;"	d
CACHELINE_ALIGNED	.\base\basictypes.h	361;"	d
CACHELINE_ALIGNED	.\base\basictypes.h	366;"	d
CACHELINE_ALIGNED	.\thread_cache.h	/^} CACHELINE_ALIGNED;$/;"	m	namespace:tcmalloc	typeref:class:tcmalloc::ThreadCache
CALLBACK_COMPLETED	.\heap-checker.cc	/^  CALLBACK_COMPLETED,$/;"	e	enum:__anon20	file:
CALLBACK_NOT_STARTED	.\heap-checker.cc	/^  CALLBACK_NOT_STARTED,$/;"	e	enum:__anon20	file:
CALLBACK_STARTED	.\heap-checker.cc	/^  CALLBACK_STARTED,$/;"	e	enum:__anon20	file:
CALL_FN_W_10W	.\third_party\valgrind.h	1322;"	d
CALL_FN_W_10W	.\third_party\valgrind.h	1765;"	d
CALL_FN_W_10W	.\third_party\valgrind.h	2271;"	d
CALL_FN_W_10W	.\third_party\valgrind.h	2826;"	d
CALL_FN_W_10W	.\third_party\valgrind.h	3387;"	d
CALL_FN_W_10W	.\third_party\valgrind.h	888;"	d
CALL_FN_W_11W	.\third_party\valgrind.h	1362;"	d
CALL_FN_W_11W	.\third_party\valgrind.h	1811;"	d
CALL_FN_W_11W	.\third_party\valgrind.h	2323;"	d
CALL_FN_W_11W	.\third_party\valgrind.h	2880;"	d
CALL_FN_W_11W	.\third_party\valgrind.h	3441;"	d
CALL_FN_W_11W	.\third_party\valgrind.h	926;"	d
CALL_FN_W_12W	.\third_party\valgrind.h	1404;"	d
CALL_FN_W_12W	.\third_party\valgrind.h	1861;"	d
CALL_FN_W_12W	.\third_party\valgrind.h	2379;"	d
CALL_FN_W_12W	.\third_party\valgrind.h	2938;"	d
CALL_FN_W_12W	.\third_party\valgrind.h	3499;"	d
CALL_FN_W_12W	.\third_party\valgrind.h	967;"	d
CALL_FN_W_5W	.\third_party\valgrind.h	1156;"	d
CALL_FN_W_5W	.\third_party\valgrind.h	1597;"	d
CALL_FN_W_5W	.\third_party\valgrind.h	2073;"	d
CALL_FN_W_5W	.\third_party\valgrind.h	2618;"	d
CALL_FN_W_5W	.\third_party\valgrind.h	3179;"	d
CALL_FN_W_5W	.\third_party\valgrind.h	730;"	d
CALL_FN_W_6W	.\third_party\valgrind.h	1184;"	d
CALL_FN_W_6W	.\third_party\valgrind.h	1625;"	d
CALL_FN_W_6W	.\third_party\valgrind.h	2107;"	d
CALL_FN_W_6W	.\third_party\valgrind.h	2654;"	d
CALL_FN_W_6W	.\third_party\valgrind.h	3215;"	d
CALL_FN_W_6W	.\third_party\valgrind.h	757;"	d
CALL_FN_W_7W	.\third_party\valgrind.h	1214;"	d
CALL_FN_W_7W	.\third_party\valgrind.h	1655;"	d
CALL_FN_W_7W	.\third_party\valgrind.h	2143;"	d
CALL_FN_W_7W	.\third_party\valgrind.h	2692;"	d
CALL_FN_W_7W	.\third_party\valgrind.h	3253;"	d
CALL_FN_W_7W	.\third_party\valgrind.h	786;"	d
CALL_FN_W_8W	.\third_party\valgrind.h	1248;"	d
CALL_FN_W_8W	.\third_party\valgrind.h	1688;"	d
CALL_FN_W_8W	.\third_party\valgrind.h	2182;"	d
CALL_FN_W_8W	.\third_party\valgrind.h	2733;"	d
CALL_FN_W_8W	.\third_party\valgrind.h	3294;"	d
CALL_FN_W_8W	.\third_party\valgrind.h	818;"	d
CALL_FN_W_9W	.\third_party\valgrind.h	1284;"	d
CALL_FN_W_9W	.\third_party\valgrind.h	1723;"	d
CALL_FN_W_9W	.\third_party\valgrind.h	2223;"	d
CALL_FN_W_9W	.\third_party\valgrind.h	2776;"	d
CALL_FN_W_9W	.\third_party\valgrind.h	3337;"	d
CALL_FN_W_9W	.\third_party\valgrind.h	852;"	d
CALL_FN_W_W	.\third_party\valgrind.h	1064;"	d
CALL_FN_W_W	.\third_party\valgrind.h	1505;"	d
CALL_FN_W_W	.\third_party\valgrind.h	1957;"	d
CALL_FN_W_W	.\third_party\valgrind.h	2494;"	d
CALL_FN_W_W	.\third_party\valgrind.h	3055;"	d
CALL_FN_W_W	.\third_party\valgrind.h	642;"	d
CALL_FN_W_WW	.\third_party\valgrind.h	1084;"	d
CALL_FN_W_WW	.\third_party\valgrind.h	1525;"	d
CALL_FN_W_WW	.\third_party\valgrind.h	1983;"	d
CALL_FN_W_WW	.\third_party\valgrind.h	2522;"	d
CALL_FN_W_WW	.\third_party\valgrind.h	3083;"	d
CALL_FN_W_WW	.\third_party\valgrind.h	661;"	d
CALL_FN_W_WWW	.\third_party\valgrind.h	1106;"	d
CALL_FN_W_WWW	.\third_party\valgrind.h	1547;"	d
CALL_FN_W_WWW	.\third_party\valgrind.h	2011;"	d
CALL_FN_W_WWW	.\third_party\valgrind.h	2552;"	d
CALL_FN_W_WWW	.\third_party\valgrind.h	3113;"	d
CALL_FN_W_WWW	.\third_party\valgrind.h	682;"	d
CALL_FN_W_WWWW	.\third_party\valgrind.h	1130;"	d
CALL_FN_W_WWWW	.\third_party\valgrind.h	1571;"	d
CALL_FN_W_WWWW	.\third_party\valgrind.h	2041;"	d
CALL_FN_W_WWWW	.\third_party\valgrind.h	2584;"	d
CALL_FN_W_WWWW	.\third_party\valgrind.h	3145;"	d
CALL_FN_W_WWWW	.\third_party\valgrind.h	705;"	d
CALL_FN_W_v	.\third_party\valgrind.h	1046;"	d
CALL_FN_W_v	.\third_party\valgrind.h	1487;"	d
CALL_FN_W_v	.\third_party\valgrind.h	1933;"	d
CALL_FN_W_v	.\third_party\valgrind.h	2468;"	d
CALL_FN_W_v	.\third_party\valgrind.h	3029;"	d
CALL_FN_W_v	.\third_party\valgrind.h	626;"	d
CALL_FN_v_W	.\third_party\valgrind.h	603;"	d
CALL_FN_v_WW	.\third_party\valgrind.h	607;"	d
CALL_FN_v_WWW	.\third_party\valgrind.h	611;"	d
CALL_FN_v_v	.\third_party\valgrind.h	599;"	d
CANT_OPEN_PROC_MAPS	.\gperftools\heap-checker.h	/^    CANT_OPEN_PROC_MAPS,$/;"	e	enum:HeapLeakChecker::ProcMapsResult
CEEE_TESTING_SIDESTEP_AUTO_TESTING_HOOK_H_	.\windows\auto_testing_hook.h	33;"	d
CFI_ADJUST_CFA_OFFSET	.\base\linux_syscall_support.h	963;"	d
CFI_ADJUST_CFA_OFFSET	.\base\linux_syscall_support.h	966;"	d
CHECK	.\base\logging.h	84;"	d
CHECK_CONDITION	.\internal_logging.h	109;"	d
CHECK_CONDITION	.\internal_logging.h	110;"	d
CHECK_EQ	.\base\logging.h	143;"	d
CHECK_ERR	.\base\logging.h	172;"	d
CHECK_GE	.\base\logging.h	147;"	d
CHECK_GT	.\base\logging.h	148;"	d
CHECK_LE	.\base\logging.h	145;"	d
CHECK_LT	.\base\logging.h	146;"	d
CHECK_NE	.\base\logging.h	144;"	d
CHECK_OP	.\base\logging.h	135;"	d
CLONE_STACK_SIZE	.\base\linuxthreads.cc	103;"	d	file:
CLONE_STACK_SIZE	.\base\linuxthreads.cc	105;"	d	file:
CLONE_UNTRACED	.\base\linuxthreads.cc	56;"	d	file:
COMPILE_ASSERT	.\base\basictypes.h	195;"	d
C_SHIM	.\malloc_extension.cc	354;"	d	file:
CacheSizeClass	.\page_heap.h	/^  void CacheSizeClass(PageID p, size_t cl) const { pagemap_cache_.Put(p, cl); }$/;"	f	class:tcmalloc::PageHeap
CacheType	.\page_heap.h	/^  typedef PackedCache<32-kPageShift, uint16_t> CacheType;$/;"	t	class:tcmalloc::MapSelector
CacheType	.\page_heap.h	/^  typedef PackedCache<BITS-kPageShift, uint64_t> CacheType;$/;"	t	class:tcmalloc::MapSelector
CallNearRelativeFunction	.\windows\shortproc.asm	/^CallNearRelativeFunction PROC$/;"	l
CallUnrollInfo	.\getpc.h	/^struct CallUnrollInfo {$/;"	s
Callback0	.\tests\heap-checker_unittest.cc	/^  inline Callback0(FunctionSignature f) : f_(f) {}$/;"	f	class:Callback0
Callback0	.\tests\heap-checker_unittest.cc	/^class Callback0 : public Closure {$/;"	c	file:
Callback1	.\tests\heap-checker_unittest.cc	/^  inline Callback1<P1>(FunctionSignature f, P1 p1) : f_(f), p1_(p1) {}$/;"	f	class:Callback1
Callback1	.\tests\heap-checker_unittest.cc	/^template <class P1> class Callback1 : public Closure {$/;"	c	file:
Callback2	.\tests\heap-checker_unittest.cc	/^  inline Callback2<P1,P2>(FunctionSignature f, P1 p1, P2 p2) : f_(f), p1_(p1), p2_(p2) {}$/;"	f	class:Callback2
Callback2	.\tests\heap-checker_unittest.cc	/^template <class P1, class P2> class Callback2 : public Closure {$/;"	c	file:
CallbackIterator	.\profile-handler.cc	/^  typedef CallbackList::iterator CallbackIterator;$/;"	t	class:ProfileHandler	file:
CallbackList	.\profile-handler.cc	/^  typedef list<ProfileHandlerToken*> CallbackList;$/;"	t	class:ProfileHandler	file:
CancelGlobalCheck	.\heap-checker.cc	/^void HeapLeakChecker::CancelGlobalCheck() {$/;"	f	class:HeapLeakChecker
Carve	.\page_heap.cc	/^Span* PageHeap::Carve(Span* span, Length n) {$/;"	f	class:tcmalloc::PageHeap
CentralCacheLockAll	.\static_vars.cc	/^void CentralCacheLockAll()$/;"	f	namespace:tcmalloc
CentralCacheUnlockAll	.\static_vars.cc	/^void CentralCacheUnlockAll()$/;"	f	namespace:tcmalloc
CentralFreeList	.\central_freelist.h	/^  CentralFreeList() : lock_(base::LINKER_INITIALIZED) { }$/;"	f	class:tcmalloc::CentralFreeList
CentralFreeList	.\central_freelist.h	/^class CentralFreeList {$/;"	c	namespace:tcmalloc
CentralFreeListPadded	.\central_freelist.h	/^class CentralFreeListPadded : public CentralFreeListPaddedTo<$/;"	c	namespace:tcmalloc
CentralFreeListPaddedTo	.\central_freelist.h	/^class CentralFreeListPaddedTo : public CentralFreeList {$/;"	c	namespace:tcmalloc
CentralFreeListPaddedTo	.\central_freelist.h	/^class CentralFreeListPaddedTo<0> : public CentralFreeList {$/;"	c	namespace:tcmalloc
Check	.\debugallocation.cc	/^  void Check(int type) const {$/;"	f	class:MallocBlock
Check	.\page_heap.cc	/^bool PageHeap::Check() {$/;"	f	class:tcmalloc::PageHeap
Check	.\tests\profiledata_unittest.cc	/^  string Check(const ProfileDataSlot* slots, int num_slots) {$/;"	f	class:__anon38::ProfileDataChecker
CheckAddressBits	.\system-alloc.cc	/^template <> bool CheckAddressBits<8 * sizeof(void*)>(uintptr_t ptr) {$/;"	f	namespace:__anon29
CheckAddressBits	.\system-alloc.cc	/^template <int ADDRESS_BITS> bool CheckAddressBits(uintptr_t ptr) {$/;"	f	namespace:__anon29
CheckAlignment	.\tests\memalign_unittest.cc	/^static void CheckAlignment(void* p, int align) {$/;"	f	file:
CheckAndClear	.\debugallocation.cc	/^  size_t CheckAndClear(int type, size_t given_size) {$/;"	f	class:MallocBlock	file:
CheckBlockDesc	.\tests\low_level_alloc_unittest.cc	/^static void CheckBlockDesc(const BlockDesc &d) {$/;"	f	file:
CheckCachedSizeClass	.\tcmalloc.cc	/^static inline bool CheckCachedSizeClass(void *ptr) {$/;"	f	file:
CheckCallback	.\debugallocation.cc	/^  static void CheckCallback(const void* ptr, int* type, int dummy) {$/;"	f	class:MallocBlock	file:
CheckContents	.\tests\tcmalloc_unittest.cc	/^  void CheckContents(const Object& object) {$/;"	f	class:testing::TesterThread
CheckEverything	.\debugallocation.cc	/^  static bool CheckEverything() {$/;"	f	class:MallocBlock
CheckExpensive	.\page_heap.cc	/^bool PageHeap::CheckExpensive() {$/;"	f	class:tcmalloc::PageHeap
CheckForCorruptedBuffer	.\debugallocation.cc	/^  static void CheckForCorruptedBuffer(const MallocBlockQueueEntry& queue_entry,$/;"	f	class:MallocBlock
CheckForDanglingWrites	.\debugallocation.cc	/^  static void CheckForDanglingWrites(const MallocBlockQueueEntry& queue_entry) {$/;"	f	class:MallocBlock
CheckInHookCaller	.\malloc_hook.cc	/^static inline void CheckInHookCaller() {$/;"	f	file:
CheckList	.\page_heap.cc	/^bool PageHeap::CheckList(Span* list, Length min_pages, Length max_pages,$/;"	f	class:tcmalloc::PageHeap
CheckLocked	.\debugallocation.cc	/^  void CheckLocked(int type) const {$/;"	f	class:MallocBlock	file:
CheckMean	.\tests\sampler_test.cc	/^bool CheckMean(size_t mean, int num_samples) {$/;"	f
CheckRangeCallback	.\tests\tcmalloc_unittest.cc	/^static void CheckRangeCallback(void* ptr, base::MallocRange::Type type,$/;"	f	namespace:testing::__anon41
CheckRetAddrIsInFunction	.\tests\stacktrace_unittest.cc	/^void CheckRetAddrIsInFunction(void *ret_addr, const AddressRange &range)$/;"	f	namespace:__anon40
CheckStackTrace	.\tests\stacktrace_unittest.cc	/^void ATTRIBUTE_NOINLINE CheckStackTrace(int i) {$/;"	f	namespace:__anon40
CheckStackTrace1	.\tests\stacktrace_unittest.cc	/^void ATTRIBUTE_NOINLINE CheckStackTrace1(int i) {$/;"	f	namespace:__anon40
CheckStackTrace2	.\tests\stacktrace_unittest.cc	/^void ATTRIBUTE_NOINLINE CheckStackTrace2(int i) {$/;"	f	namespace:__anon40
CheckStackTrace3	.\tests\stacktrace_unittest.cc	/^void ATTRIBUTE_NOINLINE CheckStackTrace3(int i) {$/;"	f	namespace:__anon40
CheckStackTrace4	.\tests\stacktrace_unittest.cc	/^void ATTRIBUTE_NOINLINE CheckStackTrace4(int i) {$/;"	f	namespace:__anon40
CheckStackTraceLeaf	.\tests\stacktrace_unittest.cc	/^void ATTRIBUTE_NOINLINE CheckStackTraceLeaf(void) {$/;"	f	namespace:__anon40
CheckStats	.\tests\page_heap_test.cc	/^static void CheckStats(const tcmalloc::PageHeap* ph,$/;"	f	namespace:__anon36
CheckTracesAndReset	.\tests\stack_trace_table_test.cc	/^static void CheckTracesAndReset(tcmalloc::StackTraceTable* table,$/;"	f	file:
CheckType	.\tests\heap-checker_unittest.cc	/^enum CheckType { SAME_HEAP, NO_LEAKS };$/;"	g	file:
CheckWithSkips	.\tests\profiledata_unittest.cc	/^string ProfileDataChecker::CheckWithSkips(const ProfileDataSlot* slots,$/;"	f	class:__anon38::ProfileDataChecker
CheckedMallocResult	.\tcmalloc.cc	/^static inline void* CheckedMallocResult(void *result) {$/;"	f	file:
ClassA	.\tests\heap-checker_unittest.cc	/^  explicit ClassA(int a) : ptr(NULL) { }$/;"	f	class:ClassA
ClassA	.\tests\heap-checker_unittest.cc	/^class ClassA {$/;"	c	file:
ClassB	.\tests\heap-checker_unittest.cc	/^  ClassB() { }$/;"	f	class:ClassB
ClassB	.\tests\heap-checker_unittest.cc	/^class ClassB {$/;"	c	file:
ClassB2	.\tests\heap-checker_unittest.cc	/^  ClassB2() { }$/;"	f	class:ClassB2
ClassB2	.\tests\heap-checker_unittest.cc	/^class ClassB2 {$/;"	c	file:
ClassD	.\tests\heap-checker_unittest.cc	/^class ClassD : public ClassD1, public ClassD2 {$/;"	c	file:
ClassD1	.\tests\heap-checker_unittest.cc	/^class ClassD1 : public ClassB {$/;"	c	file:
ClassD2	.\tests\heap-checker_unittest.cc	/^class ClassD2 : public ClassB2 {$/;"	c	file:
ClassIndex	.\common.h	/^  static inline size_t ClassIndex(size_t s) {$/;"	f	class:tcmalloc::SizeMap
ClassMltD1	.\tests\heap-checker_unittest.cc	/^class ClassMltD1 : public ClassB, public InterfaceB, public InterfaceC {$/;"	c	file:
ClassMltD2	.\tests\heap-checker_unittest.cc	/^class ClassMltD2 : public InterfaceA, public InterfaceB, public ClassB {$/;"	c	file:
Cleanup	.\tests\sampler_test.cc	/^  void Cleanup() {}$/;"	f	class:OldSampler
Cleanup	.\thread_cache.cc	/^void ThreadCache::Cleanup() {$/;"	f	class:tcmalloc::ThreadCache
CleanupOldProfiles	.\heap-profile-table.cc	/^void HeapProfileTable::CleanupOldProfiles(const char* prefix) {$/;"	f	class:HeapProfileTable
Clear	.\packed-cache-inl.h	/^  void Clear(V value) {$/;"	f	class:PackedCache
Closure	.\tests\heap-checker_unittest.cc	/^class Closure {$/;"	c	file:
Cluster	.\addressmap-inl.h	/^  struct Cluster {$/;"	s	class:AddressMap
Coalesce	.\base\low_level_alloc.cc	/^static void Coalesce(AllocList *a) {$/;"	f	file:
CommitSpan	.\page_heap.cc	/^void PageHeap::CommitSpan(Span* span) {$/;"	f	class:tcmalloc::PageHeap
CompileAssert	.\base\basictypes.h	/^struct CompileAssert {$/;"	s
ConstructFilename	.\base\sysinfo.cc	/^static void ConstructFilename(const char* spec, pid_t pid,$/;"	f	file:
CopyFrom	.\windows\patch_functions.cc	/^  void CopyFrom(const LibcInfo& that) {$/;"	f	class:__anon52::LibcInfo
CopyStringUntilChar	.\base\sysinfo.cc	/^static char *CopyStringUntilChar($/;"	f	file:
Count	.\malloc_extension.cc	/^uintptr_t Count(void** entry) {$/;"	f	namespace:__anon23
CountPushInstructions	.\stacktrace_x86-inl.h	/^static int CountPushInstructions(const unsigned char *const addr) {$/;"	f
CpuProfiler	.\profiler.cc	/^CpuProfiler::CpuProfiler(): prof_handler_token_(NULL) {$/;"	f	class:CpuProfiler
CpuProfiler	.\profiler.cc	/^class CpuProfiler {$/;"	c	file:
CpuProfilerSwitch	.\profiler.cc	/^static void CpuProfilerSwitch(int signal_number){$/;"	f	file:
Create	.\heap-checker.cc	/^void HeapLeakChecker::Create(const char *name, bool make_start_snapshot) {$/;"	f	class:HeapLeakChecker
Create	.\memory_region_map.h	/^    void Create(const void* start, size_t size) {$/;"	f	struct:MemoryRegionMap::Region
CreateCacheIfNecessary	.\thread_cache.cc	/^ThreadCache* ThreadCache::CreateCacheIfNecessary() {$/;"	f	class:tcmalloc::ThreadCache
CreateThreadTimerKey	.\profile-handler.cc	/^static void CreateThreadTimerKey(pthread_key_t *pkey) {$/;"	f	file:
CurrentElfClass	.\base\elf_mem_image.cc	/^typedef ElfClass<__WORDSIZE> CurrentElfClass;$/;"	t	namespace:base::__anon1	file:
CurrentLine	.\base\sysinfo.h	/^  const char *CurrentLine() const { return stext_; }$/;"	f	class:ProcMapsIterator
CurrentlyAllocatedBytes	.\tests\debugallocation_test.cc	/^static size_t CurrentlyAllocatedBytes() {$/;"	f	file:
DCHECK_EQ	.\base\logging.h	176;"	d
DCHECK_EQ	.\base\logging.h	183;"	d
DCHECK_GE	.\base\logging.h	180;"	d
DCHECK_GE	.\base\logging.h	187;"	d
DCHECK_GT	.\base\logging.h	181;"	d
DCHECK_GT	.\base\logging.h	188;"	d
DCHECK_LE	.\base\logging.h	178;"	d
DCHECK_LE	.\base\logging.h	185;"	d
DCHECK_LT	.\base\logging.h	179;"	d
DCHECK_LT	.\base\logging.h	186;"	d
DCHECK_NE	.\base\logging.h	177;"	d
DCHECK_NE	.\base\logging.h	184;"	d
DEBUG_MODE	.\base\logging.h	/^enum { DEBUG_MODE = 0 };$/;"	e	enum:__anon5
DEBUG_MODE	.\base\logging.h	/^enum { DEBUG_MODE = 1 };$/;"	e	enum:__anon6
DECLARE_ADDRESS_LABEL	.\tests\stacktrace_unittest.cc	71;"	d	file:
DECLARE_ADDRESS_LABEL	.\tests\stacktrace_unittest.cc	95;"	d	file:
DECLARE_ATTRIBUTE_SECTION_VARS	.\base\basictypes.h	265;"	d
DECLARE_ATTRIBUTE_SECTION_VARS	.\base\basictypes.h	320;"	d
DECLARE_ATTRIBUTE_SECTION_VARS	.\base\basictypes.h	339;"	d
DECLARE_VARIABLE	.\base\commandlineflags.h	58;"	d
DECLARE_bool	.\base\commandlineflags.h	72;"	d
DECLARE_double	.\base\commandlineflags.h	95;"	d
DECLARE_int32	.\base\commandlineflags.h	78;"	d
DECLARE_int64	.\base\commandlineflags.h	84;"	d
DECLARE_string	.\base\commandlineflags.h	102;"	d
DECLARE_uint64	.\base\commandlineflags.h	89;"	d
DEFINE_ATTRIBUTE_SECTION_VARS	.\base\basictypes.h	269;"	d
DEFINE_ATTRIBUTE_SECTION_VARS	.\base\basictypes.h	329;"	d
DEFINE_ATTRIBUTE_SECTION_VARS	.\base\basictypes.h	341;"	d
DEFINE_VARIABLE	.\base\commandlineflags.h	64;"	d
DEFINE_bool	.\base\commandlineflags.h	74;"	d
DEFINE_double	.\base\commandlineflags.h	97;"	d
DEFINE_int32	.\base\commandlineflags.h	80;"	d
DEFINE_int64	.\base\commandlineflags.h	86;"	d
DEFINE_string	.\base\commandlineflags.h	107;"	d
DEFINE_uint64	.\base\commandlineflags.h	91;"	d
DISABLE_LIBRARY_ALLOCS	.\gperftools\heap-checker.h	/^    DISABLE_LIBRARY_ALLOCS$/;"	e	enum:HeapLeakChecker::ProcMapsTask
DISALLOW_COPY_AND_ASSIGN	.\base\basictypes.h	127;"	d
DISALLOW_EVIL_CONSTRUCTORS	.\base\basictypes.h	122;"	d
DLL_Init	.\span.cc	/^void DLL_Init(Span* list) {$/;"	f	namespace:tcmalloc
DLL_IsEmpty	.\span.h	/^inline bool DLL_IsEmpty(const Span* list) {$/;"	f	namespace:tcmalloc
DLL_Length	.\span.cc	/^int DLL_Length(const Span* list) {$/;"	f	namespace:tcmalloc
DLL_Prepend	.\span.cc	/^void DLL_Prepend(Span* list, Span* span) {$/;"	f	namespace:tcmalloc
DLL_Remove	.\span.cc	/^void DLL_Remove(Span* span) {$/;"	f	namespace:tcmalloc
DO_NOT_SYMBOLIZE	.\gperftools\heap-checker.h	/^  enum ShouldSymbolize { SYMBOLIZE, DO_NOT_SYMBOLIZE };$/;"	e	enum:HeapLeakChecker::ShouldSymbolize
DTSL	.\tests\heap-checker_unittest.cc	1506;"	d	file:
DTSL	.\tests\heap-checker_unittest.cc	1519;"	d	file:
DUMPER	.\base\elfcore.h	56;"	d
DYNAMIC_ANNOTATIONS_ENABLED	.\base\dynamic_annotations.h	61;"	d
DYNAMIC_ANNOTATIONS_EXTERNAL_IMPL	.\base\dynamic_annotations.c	59;"	d	file:
DanglingWriteChecker	.\debugallocation.cc	/^void DanglingWriteChecker() {$/;"	f
DeAllocHidden	.\tests\heap-checker_unittest.cc	/^static void DeAllocHidden(void** ptr) {$/;"	f	file:
DeAllocator	.\addressmap-inl.h	/^  typedef void  (*DeAllocator)(void* ptr);$/;"	t	class:AddressMap
DeAllocator	.\heap-profile-table.h	/^  typedef void  (*DeAllocator)(void* ptr);$/;"	t	class:HeapProfileTable
DeallocName	.\debugallocation.cc	/^  static const char* DeallocName(int type) {$/;"	f	class:MallocBlock	file:
Deallocate	.\debugallocation.cc	/^  void Deallocate(int type, size_t given_size) {$/;"	f	class:MallocBlock
Deallocate	.\tests\heap-profiler_unittest.cc	/^static void Deallocate(int start, int end) {$/;"	f	file:
Deallocate	.\thread_cache.h	/^inline void ThreadCache::Deallocate(void* ptr, size_t cl) {$/;"	f	class:tcmalloc::ThreadCache
DebugAllocate	.\debugallocation.cc	/^static inline void* DebugAllocate(size_t size, int type) {$/;"	f	file:
DebugDeallocate	.\debugallocation.cc	/^static inline void DebugDeallocate(void* ptr, int type, size_t given_size) {$/;"	f	file:
DebugMallocImplementation	.\debugallocation.cc	/^class DebugMallocImplementation : public TCMallocImplementation {$/;"	c	file:
DecommitSpan	.\page_heap.cc	/^bool PageHeap::DecommitSpan(Span* span) {$/;"	f	class:tcmalloc::PageHeap
DefaultArena	.\base\low_level_alloc.cc	/^LowLevelAlloc::Arena *LowLevelAlloc::DefaultArena() {$/;"	f	class:LowLevelAlloc
DefaultPagesAllocator	.\base\low_level_alloc.cc	/^  class DefaultPagesAllocator : public LowLevelAlloc::PagesAllocator {$/;"	c	namespace:__anon7	file:
DefaultSysAllocator	.\system-alloc.cc	/^  DefaultSysAllocator() : SysAllocator() {$/;"	f	class:DefaultSysAllocator
DefaultSysAllocator	.\system-alloc.cc	/^class DefaultSysAllocator : public SysAllocator {$/;"	c	file:
Delay	.\tests\profile-handler_unittest.cc	/^void Delay(int delay_ns) {$/;"	f	namespace:__anon37
Delete	.\page_heap.cc	/^void PageHeap::Delete(Span* span) {$/;"	f	class:tcmalloc::PageHeap
Delete	.\page_heap_allocator.h	/^  void Delete(T* p) {$/;"	f	class:tcmalloc::PageHeapAllocator
DeleteAndNull	.\heap-checker.cc	/^  template<typename T> static void DeleteAndNull(T** p) {$/;"	f	class:HeapLeakChecker::Allocator
DeleteAndNullIfNot	.\heap-checker.cc	/^  template<typename T> static void DeleteAndNullIfNot(T** p) {$/;"	f	class:HeapLeakChecker::Allocator
DeleteArena	.\base\low_level_alloc.cc	/^bool LowLevelAlloc::DeleteArena(Arena *arena) {$/;"	f	class:LowLevelAlloc
DeleteCache	.\thread_cache.cc	/^void ThreadCache::DeleteCache(ThreadCache* heap) {$/;"	f	class:tcmalloc::ThreadCache
DeleteHeap	.\tests\tcmalloc_unittest.cc	/^  void DeleteHeap() {$/;"	f	class:testing::TesterThread
DeleteHook	.\gperftools\malloc_hook.h	/^  typedef MallocHook_DeleteHook DeleteHook;$/;"	t	class:MallocHook
DeleteHook	.\heap-checker.cc	/^static void DeleteHook(const void* ptr) {$/;"	f	file:
DeleteHook	.\heap-profiler.cc	/^void DeleteHook(const void* ptr) {$/;"	f
DeleteMatchingFiles	.\windows\port.cc	/^void DeleteMatchingFiles(const char* prefix, const char* full_glob) {$/;"	f
DeleteSpan	.\span.cc	/^void DeleteSpan(Span* span) {$/;"	f	namespace:tcmalloc
DeleteUnsignedCharArray	.\windows\preamble_patcher.cc	/^  DeleteUnsignedCharArray(unsigned char* array) : array_(array) {$/;"	f	class:sidestep::DeleteUnsignedCharArray
DeleteUnsignedCharArray	.\windows\preamble_patcher.cc	/^class DeleteUnsignedCharArray {$/;"	c	namespace:sidestep	file:
Depth	.\malloc_extension.cc	/^uintptr_t Depth(void** entry) {$/;"	f	namespace:__anon23
DestrFnClosure	.\windows\port.cc	/^struct DestrFnClosure {$/;"	s	file:
DestroyThreadCache	.\thread_cache.cc	/^void ThreadCache::DestroyThreadCache(void* ptr) {$/;"	f	class:tcmalloc::ThreadCache
DevMemSysAllocator	.\system-alloc.cc	/^  DevMemSysAllocator() : SysAllocator() {$/;"	f	class:DevMemSysAllocator
DevMemSysAllocator	.\system-alloc.cc	/^class DevMemSysAllocator : public SysAllocator {$/;"	c	file:
DirectTestSTLAlloc	.\tests\heap-checker_unittest.cc	/^static void DirectTestSTLAlloc(Alloc allocator, const char* name) {$/;"	f	file:
DirtyStack	.\base\linuxthreads.cc	/^static void DirtyStack(size_t amount) {$/;"	f	file:
DisableChecksFromToLocked	.\heap-checker.cc	/^void HeapLeakChecker::DisableChecksFromToLocked(const void* start_address,$/;"	f	class:HeapLeakChecker
DisableChecksIn	.\heap-checker.cc	/^void HeapLeakChecker::DisableChecksIn(const char* pattern) {$/;"	f	class:HeapLeakChecker
DisableHandler	.\profiler.cc	/^void CpuProfiler::DisableHandler() {$/;"	f	class:CpuProfiler
DisableLibraryAllocsLocked	.\heap-checker.cc	/^void HeapLeakChecker::DisableLibraryAllocsLocked(const char* library,$/;"	f	class:HeapLeakChecker
DisabledRangeMap	.\heap-checker.cc	/^           > DisabledRangeMap;$/;"	t	file:
Disabler	.\gperftools\heap-checker.h	/^  class Disabler {$/;"	c	class:HeapLeakChecker
Disabler	.\heap-checker.cc	/^HeapLeakChecker::Disabler::Disabler() {$/;"	f	class:HeapLeakChecker::Disabler
Disassemble	.\windows\mini_disassembler.cc	/^InstructionType MiniDisassembler::Disassemble($/;"	f	class:sidestep::MiniDisassembler
DllMain	.\windows\port.cc	/^BOOL WINAPI DllMain(HINSTANCE h, DWORD dwReason, PVOID pv) {$/;"	f
DoAllocHidden	.\tests\heap-checker_unittest.cc	/^static void DoAllocHidden(size_t size, void** ptr) {$/;"	f	file:
DoAllocWithArena	.\base\low_level_alloc.cc	/^static void *DoAllocWithArena(size_t request, LowLevelAlloc::Arena *arena) {$/;"	f	file:
DoDeAllocHidden	.\tests\heap-checker_unittest.cc	/^static void DoDeAllocHidden(void** ptr) {$/;"	f	file:
DoFindRegionLocked	.\memory_region_map.cc	/^MemoryRegionMap::DoFindRegionLocked(uintptr_t addr) {$/;"	f	class:MemoryRegionMap
DoGetHeapProfileLocked	.\heap-profiler.cc	/^static char* DoGetHeapProfileLocked(char* buf, int buflen) {$/;"	f	file:
DoIgnoreObject	.\heap-checker.cc	/^void HeapLeakChecker::DoIgnoreObject(const void* ptr) {$/;"	f	class:HeapLeakChecker
DoInsertRegionLocked	.\memory_region_map.cc	/^inline void MemoryRegionMap::DoInsertRegionLocked(const Region& region) {$/;"	f	class:MemoryRegionMap
DoMainHeapCheck	.\heap-checker.cc	/^bool HeapLeakChecker::DoMainHeapCheck() {$/;"	f	class:HeapLeakChecker
DoNoLeaks	.\heap-checker.cc	/^bool HeapLeakChecker::DoNoLeaks(ShouldSymbolize should_symbolize) {$/;"	f	class:HeapLeakChecker
DoRun	.\tests\profile-handler_unittest.cc	/^  static void* DoRun(void* cls) {$/;"	f	class:__anon37::Thread	file:
DoRunHidden	.\tests\heap-checker_unittest.cc	/^static void DoRunHidden(Closure* c, int n) {$/;"	f	file:
DoSampledAllocation	.\tcmalloc.cc	/^static void* DoSampledAllocation(size_t size) {$/;"	f	file:
DoTestSTLAlloc	.\tests\heap-checker_unittest.cc	/^static void DoTestSTLAlloc() {$/;"	f	file:
DoTestSTLAllocInverse	.\tests\heap-checker_unittest.cc	/^static void DoTestSTLAllocInverse(IntSet** setx) {$/;"	f	file:
DoWipeStack	.\tests\heap-checker_unittest.cc	/^\/*static*\/ void DoWipeStack(int n) {$/;"	f
DumpAddressMap	.\malloc_extension.cc	/^static void DumpAddressMap(string* result) {$/;"	f	file:
DumpArgs	.\heap-profile-table.h	/^    DumpArgs(RawFD fd_arg, Stats* profile_stats_arg)$/;"	f	struct:HeapProfileTable::DumpArgs
DumpArgs	.\heap-profile-table.h	/^  struct DumpArgs {$/;"	s	class:HeapProfileTable
DumpBucketIterator	.\heap-profile-table.cc	/^void HeapProfileTable::DumpBucketIterator(const Bucket* bucket,$/;"	f	class:HeapProfileTable
DumpHeapGrowthStackTraces	.\tcmalloc.cc	/^static void** DumpHeapGrowthStackTraces() {$/;"	f	file:
DumpNonLiveIterator	.\heap-profile-table.cc	/^void HeapProfileTable::DumpNonLiveIterator(const void* ptr, AllocValue* v,$/;"	f	class:HeapProfileTable
DumpProcSelfMaps	.\base\sysinfo.cc	/^void DumpProcSelfMaps(RawFD fd) {$/;"	f	namespace:tcmalloc
DumpProcSelfMaps	.\profiledata.cc	/^static void DumpProcSelfMaps(int fd) {$/;"	f	file:
DumpProfileLocked	.\heap-profiler.cc	/^static void DumpProfileLocked(const char* reason) {$/;"	f	file:
DumpStats	.\tcmalloc.cc	/^static void DumpStats(TCMalloc_Printer* out, int level) {$/;"	f	file:
DumpStats	.\tests\system-alloc_unittest.cc	/^  void DumpStats() {$/;"	f	class:ArraySysAllocator
DumpSystemAllocatorStats	.\windows\system-alloc.cc	/^void DumpSystemAllocatorStats(TCMalloc_Printer* printer) {$/;"	f
EMERGENCY_MALLOC_H	.\emergency_malloc.h	32;"	d
ERRNO	.\base\linuxthreads.cc	167;"	d	file:
ERROR	.\base\logging.h	/^enum LogSeverity {INFO = -1, WARNING = -2, ERROR = -3, FATAL = -4};$/;"	e	enum:LogSeverity
ERROR	.\base\logging.h	193;"	d
ERROR	.\heap-checker.cc	66;"	d	file:
EXCLUSIVE_LOCKS_REQUIRED	.\base\thread_annotations.h	93;"	d
EXCLUSIVE_LOCK_FUNCTION	.\base\spinlock.h	/^  inline explicit SpinLockHolder(SpinLock* l) EXCLUSIVE_LOCK_FUNCTION(l)$/;"	f	class:SpinLockHolder
EXCLUSIVE_LOCK_FUNCTION	.\base\thread_annotations.h	115;"	d
EXCLUSIVE_TRYLOCK_FUNCTION	.\base\spinlock.h	/^  inline bool TryLock() EXCLUSIVE_TRYLOCK_FUNCTION(true) {$/;"	f	class:SpinLock
EXCLUSIVE_TRYLOCK_FUNCTION	.\base\thread_annotations.h	121;"	d
EXPECT_EQ	.\base\logging.h	151;"	d
EXPECT_FALSE	.\base\logging.h	165;"	d
EXPECT_GE	.\base\logging.h	155;"	d
EXPECT_GT	.\base\logging.h	156;"	d
EXPECT_LE	.\base\logging.h	153;"	d
EXPECT_LT	.\base\logging.h	154;"	d
EXPECT_NE	.\base\logging.h	152;"	d
EXPECT_STREQ	.\base\logging.h	166;"	d
EXPECT_TRUE	.\base\logging.h	164;"	d
EXTERN_C	.\windows\port.h	495;"	d
EXTERN_C	.\windows\port.h	97;"	d
EXTERN_C	.\windows\port.h	99;"	d
ElfClass	.\base\elf_mem_image.cc	/^template <> class ElfClass<32> {$/;"	c	namespace:base::__anon1	file:
ElfClass	.\base\elf_mem_image.cc	/^template <> class ElfClass<64> {$/;"	c	namespace:base::__anon1	file:
ElfClass	.\base\elf_mem_image.cc	/^template <int N> class ElfClass {$/;"	c	namespace:base::__anon1	file:
ElfMemImage	.\base\elf_mem_image.cc	/^ElfMemImage::ElfMemImage(const void *base) {$/;"	f	class:base::ElfMemImage
ElfMemImage	.\base\elf_mem_image.h	/^class ElfMemImage {$/;"	c	namespace:base
ElfW	.\base\elf_mem_image.cc	/^  static int ElfBind(const ElfW(Sym) *) {$/;"	f	class:base::__anon1::ElfClass
ElfW	.\base\elf_mem_image.cc	/^  static int ElfType(const ElfW(Sym) *) {$/;"	f	class:base::__anon1::ElfClass
EmergencyArenaPagesAllocator	.\emergency_malloc.cc	/^  class EmergencyArenaPagesAllocator : public LowLevelAlloc::PagesAllocator {$/;"	c	namespace:tcmalloc	file:
EmergencyCalloc	.\emergency_malloc.cc	/^  PERFTOOLS_DLL_DECL void *EmergencyCalloc(size_t n, size_t elem_size) {$/;"	f	namespace:tcmalloc
EmergencyCalloc	.\maybe_emergency_malloc.h	/^  static inline void *EmergencyCalloc(size_t n, size_t elem_size) {return NULL;}$/;"	f	namespace:tcmalloc
EmergencyFree	.\emergency_malloc.cc	/^  PERFTOOLS_DLL_DECL void EmergencyFree(void *p) {$/;"	f	namespace:tcmalloc
EmergencyFree	.\maybe_emergency_malloc.h	/^  static inline void EmergencyFree(void *p) {}$/;"	f	namespace:tcmalloc
EmergencyMalloc	.\emergency_malloc.cc	/^  PERFTOOLS_DLL_DECL void *EmergencyMalloc(size_t size) {$/;"	f	namespace:tcmalloc
EmergencyMalloc	.\maybe_emergency_malloc.h	/^  static inline void *EmergencyMalloc(size_t size) {return NULL;}$/;"	f	namespace:tcmalloc
EmergencyRealloc	.\emergency_malloc.cc	/^  PERFTOOLS_DLL_DECL void *EmergencyRealloc(void *_old_ptr, size_t new_size) {$/;"	f	namespace:tcmalloc
EmergencyRealloc	.\maybe_emergency_malloc.h	/^  static inline void *EmergencyRealloc(void *old_ptr, size_t new_size) {return NULL;}$/;"	f	namespace:tcmalloc
Empty	.\heap-profile-table.h	/^  bool Empty() const {$/;"	f	class:HeapProfileTable::Snapshot
EnableHandler	.\profiler.cc	/^void CpuProfiler::EnableHandler() {$/;"	f	class:CpuProfiler
Enabled	.\profiler.cc	/^bool CpuProfiler::Enabled() {$/;"	f	class:CpuProfiler
EndRegionLocked	.\memory_region_map.cc	/^MemoryRegionMap::RegionIterator MemoryRegionMap::EndRegionLocked() {$/;"	f	class:MemoryRegionMap
Ensure	.\pagemap.h	/^  bool Ensure(Number start, size_t n) {$/;"	f	class:TCMalloc_PageMap2
Ensure	.\pagemap.h	/^  bool Ensure(Number start, size_t n) {$/;"	f	class:TCMalloc_PageMap3
Ensure	.\pagemap.h	/^  bool Ensure(Number x, size_t n) {$/;"	f	class:TCMalloc_PageMap1
EnsureLimit	.\page_heap.cc	/^bool PageHeap::EnsureLimit(Length n, bool withRelease)$/;"	f	class:tcmalloc::PageHeap
EnterStacktraceScope	.\emergency_malloc_for_stacktrace.cc	/^bool tcmalloc::EnterStacktraceScope(void) {$/;"	f	class:tcmalloc
EnterStacktraceScope	.\fake_stacktrace_scope.cc	/^  ATTRIBUTE_WEAK bool EnterStacktraceScope(void) {$/;"	f	namespace:tcmalloc
Entry	.\addressmap-inl.h	/^  struct Entry {$/;"	s	class:AddressMap
Entry	.\heap-profile-table.cc	/^  Entry() : count(0), bytes(0) { }$/;"	f	struct:HeapProfileTable::Snapshot::Entry
Entry	.\heap-profile-table.cc	/^struct HeapProfileTable::Snapshot::Entry {$/;"	s	class:HeapProfileTable::Snapshot	file:
Entry	.\profiledata.h	/^  struct Entry {$/;"	s	class:ProfileData
EntryToValue	.\packed-cache-inl.h	/^  static V EntryToValue(T t) { return t & kValueMask; }$/;"	f	class:PackedCache
EnumSymProc	.\windows\nm-pdb.c	/^static BOOL CALLBACK EnumSymProc(PSYMBOL_INFO symbol_info,$/;"	f	file:
EnvToBool	.\base\commandlineflags.h	154;"	d
EnvToDouble	.\base\commandlineflags.h	163;"	d
EnvToInt	.\base\commandlineflags.h	157;"	d
EnvToInt64	.\base\commandlineflags.h	160;"	d
EnvToString	.\base\commandlineflags.h	151;"	d
Equivalent	.\heap-profile-stats.h	/^  bool Equivalent(const HeapProfileStats& other) const {$/;"	f	struct:HeapProfileStats
Event	.\span.cc	/^void Event(Span* span, char op, int v = 0) {$/;"	f	namespace:tcmalloc
Event	.\span.h	71;"	d
Evict	.\profiledata.cc	/^void ProfileData::Evict(const Entry& entry) {$/;"	f	class:ProfileData
EvictRandomSizeClass	.\central_freelist.cc	/^bool CentralFreeList::EvictRandomSizeClass($/;"	f	class:tcmalloc::CentralFreeList
ExchangeSingular	.\malloc_hook.cc	/^T HookList<T>::ExchangeSingular(T value_as_t) {$/;"	f	class:base::internal::HookList
ExpectRunningSamples	.\tests\profiledata_unittest.cc	/^  void ExpectRunningSamples(int samples) {$/;"	f	class:__anon38::ProfileDataTest
ExpectSameState	.\tests\profiledata_unittest.cc	/^  void ExpectSameState(const ProfileData::State& before,$/;"	f	class:__anon38::ProfileDataTest
ExpectStopped	.\tests\profiledata_unittest.cc	/^  void ExpectStopped() {$/;"	f	class:__anon38::ProfileDataTest
ExtractStats	.\tcmalloc.cc	/^static void ExtractStats(TCMallocStats* r, uint64_t* class_count,$/;"	f	file:
ExtractUntilChar	.\base\sysinfo.cc	/^static bool ExtractUntilChar(char *text, int c, char **endptr) {$/;"	f	file:
FAIL	.\tests\malloc_extension_c_test.c	47;"	d	file:
FATAL	.\base\logging.h	/^enum LogSeverity {INFO = -1, WARNING = -2, ERROR = -3, FATAL = -4};$/;"	e	enum:LogSeverity
FDWrite	.\profiledata.cc	/^static void FDWrite(int fd, const char* buf, size_t len) {$/;"	f	file:
FLAGS_allocweight	.\tests\tcmalloc_unittest.cc	/^static const int FLAGS_allocweight = 50;    \/\/ Weight for picking allocation$/;"	m	namespace:testing	file:
FLAGS_freeweight	.\tests\tcmalloc_unittest.cc	/^static const int FLAGS_freeweight = 50;     \/\/ Weight for picking free$/;"	m	namespace:testing	file:
FLAGS_lg_max_memalign	.\tests\tcmalloc_unittest.cc	/^static const int FLAGS_lg_max_memalign = 18; \/\/ lg of max alignment for memalign$/;"	m	namespace:testing	file:
FLAGS_lgmaxsize	.\tests\tcmalloc_unittest.cc	/^static const int FLAGS_lgmaxsize = 16;   \/\/ lg() of the max size object to alloc$/;"	m	namespace:testing	file:
FLAGS_log_every_n_tests	.\tests\tcmalloc_unittest.cc	/^static const int FLAGS_log_every_n_tests = 50000; \/\/ log exactly once$/;"	m	namespace:testing	file:
FLAGS_memalign_max_alignment_ratio	.\tests\tcmalloc_unittest.cc	/^static const double FLAGS_memalign_max_alignment_ratio = 6;  \/\/ alignment\/size$/;"	m	namespace:testing	file:
FLAGS_memalign_max_fraction	.\tests\tcmalloc_unittest.cc	/^static const double FLAGS_memalign_max_fraction = 0.4;  \/\/ max expected%$/;"	m	namespace:testing	file:
FLAGS_memalign_min_fraction	.\tests\tcmalloc_unittest.cc	/^static const double FLAGS_memalign_min_fraction = 0;    \/\/ min expected%$/;"	m	namespace:testing	file:
FLAGS_mock_tcmalloc_sample_parameter	.\tests\sampler_test.cc	/^const int64 FLAGS_mock_tcmalloc_sample_parameter = 1<<19;$/;"	v
FLAGS_numtests	.\tests\tcmalloc_unittest.cc	/^static const int FLAGS_numtests = 50000;$/;"	m	namespace:testing	file:
FLAGS_numthreads	.\tests\tcmalloc_unittest.cc	/^static const int FLAGS_numthreads = 10;  \/\/ Number of threads$/;"	m	namespace:testing	file:
FLAGS_passweight	.\tests\tcmalloc_unittest.cc	/^static const int FLAGS_passweight = 1;      \/\/ Weight for passing object$/;"	m	namespace:testing	file:
FLAGS_tcmalloc_transfer_num_objects	.\common.cc	/^static int32 FLAGS_tcmalloc_transfer_num_objects;$/;"	m	namespace:tcmalloc	file:
FLAGS_threadmb	.\tests\tcmalloc_unittest.cc	/^static const int FLAGS_threadmb = 4;     \/\/ Max memory size allocated by thread$/;"	m	namespace:testing	file:
FLAGS_updateweight	.\tests\tcmalloc_unittest.cc	/^static const int FLAGS_updateweight = 10;   \/\/ Weight for picking update$/;"	m	namespace:testing	file:
FRAME	.\base\elfcore.h	139;"	d
FRAME	.\base\elfcore.h	192;"	d
FRAME	.\base\elfcore.h	257;"	d
FRAME	.\base\elfcore.h	289;"	d
FRAME	.\base\elfcore.h	351;"	d
FRAME_MIN_SIZE	.\base\linux_syscall_support.h	1968;"	d
FRAME_TOC_SAVE	.\base\linux_syscall_support.h	1969;"	d
FREE	.\gperftools\malloc_extension.h	/^    FREE,                 \/\/ Range is currently free$/;"	e	enum:base::MallocRange::Type
FREE	.\tests\tcmalloc_unittest.cc	/^  enum Type { ALLOC, FREE, UPDATE, PASS };$/;"	e	enum:testing::TesterThread::Type	file:
FUTEX_PRIVATE_FLAG	.\base\spinlock_linux-inl.h	43;"	d
FUTEX_WAIT	.\base\spinlock_linux-inl.h	41;"	d
FUTEX_WAKE	.\base\spinlock_linux-inl.h	42;"	d
FastInterlockedCompareExchange	.\base\atomicops-internals-windows.h	/^inline LONG FastInterlockedCompareExchange(volatile LONG* ptr,$/;"	f
FastInterlockedCompareExchangePointer	.\base\atomicops-internals-windows.h	/^inline PVOID FastInterlockedCompareExchangePointer(volatile PVOID* ptr,$/;"	f
FastInterlockedExchange	.\base\atomicops-internals-windows.h	/^inline LONG FastInterlockedExchange(volatile LONG* ptr, LONG newval) {$/;"	f
FastInterlockedExchangeAdd	.\base\atomicops-internals-windows.h	/^inline LONG FastInterlockedExchangeAdd(volatile LONG* ptr, LONG increment) {$/;"	f
FastInterlockedExchangeAdd64	.\base\atomicops-internals-windows.h	/^inline LONGLONG FastInterlockedExchangeAdd64(volatile LONGLONG* ptr,$/;"	f
FastInterlockedExchangePointer	.\base\atomicops-internals-windows.h	/^inline PVOID FastInterlockedExchangePointer(volatile PVOID* ptr, PVOID newval) {$/;"	f
FastLog2	.\sampler.h	/^inline double Sampler::FastLog2(const double & d) {$/;"	f	class:tcmalloc::Sampler
FetchFromCentralCache	.\thread_cache.cc	/^void* ThreadCache::FetchFromCentralCache(size_t cl, size_t byte_size) {$/;"	f	class:tcmalloc::ThreadCache
FetchFromOneSpans	.\central_freelist.cc	/^int CentralFreeList::FetchFromOneSpans(int N, void **start, void **end) {$/;"	f	class:tcmalloc::CentralFreeList
FetchFromOneSpansSafe	.\central_freelist.cc	/^int CentralFreeList::FetchFromOneSpansSafe(int N, void **start, void **end) {$/;"	f	class:tcmalloc::CentralFreeList
FileDescriptor	.\tests\profiledata_unittest.cc	/^  explicit FileDescriptor(int fd) : fd_(fd) {}$/;"	f	struct:__anon38::FileDescriptor
FileDescriptor	.\tests\profiledata_unittest.cc	/^struct FileDescriptor {$/;"	s	namespace:__anon38	file:
Fill	.\tests\memalign_unittest.cc	/^static void Fill(void* p, int n, char seed) {$/;"	f	file:
Fill	.\tests\realloc_unittest.cc	/^static void Fill(unsigned char* buffer, int n) {$/;"	f	file:
FillContents	.\tests\tcmalloc_unittest.cc	/^  void FillContents(Object* object) {$/;"	f	class:testing::TesterThread
FillOrderedProfile	.\heap-profile-table.cc	/^int HeapProfileTable::FillOrderedProfile(char buf[], int size) const {$/;"	f	class:HeapProfileTable
FillProcSelfMaps	.\base\sysinfo.cc	/^int FillProcSelfMaps(char buf[], int size, bool* wrote_all) {$/;"	f	namespace:tcmalloc
Find	.\addressmap-inl.h	/^inline const Value* AddressMap<Value>::Find(Key key) const {$/;"	f	class:AddressMap
FindAlloc	.\heap-profile-table.cc	/^bool HeapProfileTable::FindAlloc(const void* ptr, size_t* object_size) const {$/;"	f	class:HeapProfileTable
FindAllocDetails	.\heap-profile-table.cc	/^bool HeapProfileTable::FindAllocDetails(const void* ptr,$/;"	f	class:HeapProfileTable
FindAndMarkStackRegion	.\memory_region_map.cc	/^bool MemoryRegionMap::FindAndMarkStackRegion(uintptr_t stack_top,$/;"	f	class:MemoryRegionMap
FindAndRemove	.\addressmap-inl.h	/^bool AddressMap<Value>::FindAndRemove(Key key, Value* removed_value) {$/;"	f	class:AddressMap
FindCluster	.\addressmap-inl.h	/^  Cluster* FindCluster(Number address, bool create) {$/;"	f	class:AddressMap
FindInside	.\addressmap-inl.h	/^const Value* AddressMap<Value>::FindInside(ValueSizeFunc size_func,$/;"	f	class:AddressMap
FindInsideAlloc	.\heap-profile-table.cc	/^bool HeapProfileTable::FindInsideAlloc(const void* ptr,$/;"	f	class:HeapProfileTable
FindMutable	.\addressmap-inl.h	/^inline Value* AddressMap<Value>::FindMutable(Key key) {$/;"	f	class:AddressMap
FindRegion	.\memory_region_map.cc	/^bool MemoryRegionMap::FindRegion(uintptr_t addr, Region* result) {$/;"	f	class:MemoryRegionMap
FixupPrivEndLocked	.\malloc_hook.cc	/^void HookList<T>::FixupPrivEndLocked() {$/;"	f	class:base::internal::HookList
FlushEvicted	.\profiledata.cc	/^void ProfileData::FlushEvicted() {$/;"	f	class:ProfileData
FlushTable	.\profiledata.cc	/^void ProfileData::FlushTable() {$/;"	f	class:ProfileData
FlushTable	.\profiler.cc	/^void CpuProfiler::FlushTable() {$/;"	f	class:CpuProfiler
FormatLine	.\base\sysinfo.cc	/^int ProcMapsIterator::FormatLine(char* buffer, int bufsize,$/;"	f	class:ProcMapsIterator
Frame	.\base\elfcore.h	/^  typedef struct Frame {$/;"	s
Frame	.\base\elfcore.h	/^  } Frame;$/;"	t	typeref:struct:Frame
Free	.\base\low_level_alloc.cc	/^void LowLevelAlloc::Free(void *v) {$/;"	f	class:LowLevelAlloc
Free	.\heap-checker.cc	/^  static void Free(void* p) {$/;"	f	class:HeapLeakChecker::Allocator
Free	.\heap-checker.cc	/^  static void Free(void* p, size_t \/* n *\/) {$/;"	f	class:HeapLeakChecker::Allocator
Free	.\memory_region_map.h	/^    static void Free(const void *p, size_t \/* n *\/) {$/;"	f	struct:MemoryRegionMap::MyAllocator
FreeHook	.\tests\low_level_alloc_unittest.cc	/^static void FreeHook(const void *p) {$/;"	f	file:
FreeList	.\thread_cache.h	/^  class FreeList {$/;"	c	class:tcmalloc::ThreadCache
FreeListInfo	.\gperftools\malloc_extension.h	/^  struct FreeListInfo {$/;"	s	class:MallocExtension
FreeObject	.\tests\tcmalloc_unittest.cc	/^  void FreeObject() {$/;"	f	class:testing::TesterThread
FreePreambleBlock	.\windows\preamble_patcher.cc	/^void PreamblePatcher::FreePreambleBlock(unsigned char* block) {$/;"	f	class:sidestep::PreamblePatcher
FreeQueue	.\debugallocation.cc	/^  FreeQueue() : q_front_(0), q_back_(0) {}$/;"	f	class:FreeQueue
FreeQueue	.\debugallocation.cc	/^class FreeQueue {$/;"	c	file:
FreeQueueSize	.\debugallocation.cc	/^  static size_t FreeQueueSize() {$/;"	f	class:MallocBlock
FreeTestSTLAllocInverse	.\tests\heap-checker_unittest.cc	/^static void FreeTestSTLAllocInverse(IntSet** setx) {$/;"	f	file:
FromRawPointer	.\debugallocation.cc	/^  static MallocBlock* FromRawPointer(void* p) {$/;"	f	class:MallocBlock
FromRawPointer	.\debugallocation.cc	/^  static const MallocBlock* FromRawPointer(const void* p) {$/;"	f	class:MallocBlock
Full	.\debugallocation.cc	/^  bool Full() {$/;"	f	class:FreeQueue
FunctionAndId	.\tests\testutil.cc	/^struct FunctionAndId {$/;"	s	file:
FunctionInfo	.\windows\patch_functions.cc	/^  struct FunctionInfo {$/;"	s	class:__anon52::WindowsInfo	file:
FunctionSignature	.\tests\heap-checker_unittest.cc	/^  typedef void (*FunctionSignature)();$/;"	t	class:Callback0	file:
FunctionSignature	.\tests\heap-checker_unittest.cc	/^  typedef void (*FunctionSignature)(P1);$/;"	t	class:Callback1	file:
FunctionSignature	.\tests\heap-checker_unittest.cc	/^  typedef void (*FunctionSignature)(P1,P2);$/;"	t	class:Callback2	file:
GCC_VERSION	.\base\atomicops.h	101;"	d
GETDENTS	.\base\linux_syscall_support.h	2368;"	d
GETENV_SAFE_H	.\getenv_safe.h	33;"	d
GET_STACK_TRACE_OR_FRAMES	.\stacktrace_impl_setup-inl.h	49;"	d
GET_STACK_TRACE_OR_FRAMES	.\stacktrace_impl_setup-inl.h	54;"	d
GET_STACK_TRACE_OR_FRAMES	.\stacktrace_impl_setup-inl.h	58;"	d
GET_STACK_TRACE_OR_FRAMES	.\stacktrace_impl_setup-inl.h	63;"	d
GET_STACK_TRACE_OR_FRAMES	.\stacktrace_impl_setup-inl.h	67;"	d
GET_STACK_TRACE_OR_FRAMES	.\stacktrace_impl_setup-inl.h	73;"	d
GET_STACK_TRACE_OR_FRAMES	.\stacktrace_impl_setup-inl.h	77;"	d
GET_STACK_TRACE_OR_FRAMES	.\stacktrace_impl_setup-inl.h	83;"	d
GG_ULONGLONG	.\tests\atomicops_unittest.cc	39;"	d	file:
GLOB_NOMATCH	.\heap-profile-table.cc	45;"	d	file:
GOOGLE_BASE_WINDOWS_H_	.\windows\port.h	42;"	d
GOOGLE_MAYBE_THREADS_H_	.\maybe_threads.h	40;"	d
GOOGLE_MAYBE_THREADS_H_	.\windows\port.h	146;"	d
GOOGLE_MUTEX_H_	.\base\simple_mutex.h	106;"	d
GOOGLE_PERFTOOLS_MINI_DISASSEMBLER_H_	.\windows\mini_disassembler.h	38;"	d
GOOGLE_PERFTOOLS_MINI_DISASSEMBLER_TYPES_H_	.\windows\mini_disassembler_types.h	39;"	d
GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_	.\windows\preamble_patcher.h	39;"	d
GOOGLE_PERFTOOLS_WINDOWS_CONFIG_H_	.\windows\config.h	13;"	d
GOOGLE_PERFTOOLS_WINDOWS_CONFIG_H_	.\windows\config.h	17;"	d
GOOGLE_PERFTOOLS_WINDOWS_MINGW_H_	.\windows\mingw.h	40;"	d
GOOGLE_STACKTRACE_H_	.\gperftools\stacktrace.h	38;"	d
GPERFTOOLS_CONFIG_H_	.\windows\config.h	19;"	d
GPRIuPTHREAD	.\base\basictypes.h	112;"	d
GPRIxPTHREAD	.\base\basictypes.h	113;"	d
GROWS_TOWARDS_HIGH_ADDRESSES	.\heap-checker.cc	/^  GROWS_TOWARDS_HIGH_ADDRESSES,$/;"	e	enum:StackDirection	file:
GROWS_TOWARDS_LOW_ADDRESSES	.\heap-checker.cc	/^  GROWS_TOWARDS_LOW_ADDRESSES,$/;"	e	enum:StackDirection	file:
GST_SUFFIX	.\stacktrace.cc	106;"	d	file:
GST_SUFFIX	.\stacktrace.cc	108;"	d	file:
GST_SUFFIX	.\stacktrace.cc	115;"	d	file:
GST_SUFFIX	.\stacktrace.cc	117;"	d	file:
GST_SUFFIX	.\stacktrace.cc	128;"	d	file:
GST_SUFFIX	.\stacktrace.cc	130;"	d	file:
GST_SUFFIX	.\stacktrace.cc	137;"	d	file:
GST_SUFFIX	.\stacktrace.cc	139;"	d	file:
GST_SUFFIX	.\stacktrace.cc	146;"	d	file:
GST_SUFFIX	.\stacktrace.cc	148;"	d	file:
GST_SUFFIX	.\stacktrace.cc	157;"	d	file:
GST_SUFFIX	.\stacktrace.cc	159;"	d	file:
GST_SUFFIX	.\stacktrace.cc	86;"	d	file:
GST_SUFFIX	.\stacktrace.cc	88;"	d	file:
GST_SUFFIX	.\stacktrace.cc	95;"	d	file:
GST_SUFFIX	.\stacktrace.cc	97;"	d	file:
GUARDED_BY	.\base\thread_annotations.h	63;"	d
GUARDED_VAR	.\base\thread_annotations.h	64;"	d
GenericFnPtr	.\windows\patch_functions.cc	/^typedef void (*GenericFnPtr)();$/;"	t	namespace:__anon52	file:
GetAggressiveDecommit	.\page_heap.h	/^  bool GetAggressiveDecommit(void) {return aggressive_decommit_;}$/;"	f	class:tcmalloc::PageHeap
GetAllocCaller	.\heap-checker.cc	/^const void* HeapLeakChecker::GetAllocCaller(void* ptr) {$/;"	f	class:HeapLeakChecker
GetAllocatedSize	.\debugallocation.cc	/^  virtual size_t GetAllocatedSize(const void* p) {$/;"	f	class:DebugMallocImplementation
GetAllocatedSize	.\malloc_extension.cc	/^size_t MallocExtension::GetAllocatedSize(const void* p) {$/;"	f	class:MallocExtension
GetAllocatedSize	.\tcmalloc.cc	/^size_t TCMallocImplementation::GetAllocatedSize(const void* ptr) {$/;"	f	class:TCMallocImplementation
GetBucket	.\heap-profile-table.cc	/^HeapProfileTable::Bucket* HeapProfileTable::GetBucket(int depth,$/;"	f	class:HeapProfileTable
GetBucket	.\memory_region_map.cc	/^HeapProfileBucket* MemoryRegionMap::GetBucket(int depth,$/;"	f	class:MemoryRegionMap
GetCache	.\thread_cache.h	/^inline ThreadCache* ThreadCache::GetCache() {$/;"	f	class:tcmalloc::ThreadCache
GetCacheIfPresent	.\thread_cache.h	/^inline ThreadCache* ThreadCache::GetCacheIfPresent() {$/;"	f	class:tcmalloc::ThreadCache
GetCacheWhichMustBePresent	.\thread_cache.h	/^inline ThreadCache* ThreadCache::GetCacheWhichMustBePresent() {$/;"	f	class:tcmalloc::ThreadCache
GetCallbackCount	.\tests\profile-handler_unittest.cc	/^  uint32 GetCallbackCount() {$/;"	f	class:__anon37::ProfileHandlerTest
GetCallerStackTrace	.\gperftools\malloc_hook.h	/^  inline static int GetCallerStackTrace(void** result, int max_depth,$/;"	f	class:MallocHook
GetCallerStackTrace	.\heap-profile-table.cc	/^int HeapProfileTable::GetCallerStackTrace($/;"	f	class:HeapProfileTable
GetCurrentState	.\profiledata.cc	/^void ProfileData::GetCurrentState(State* state) const {$/;"	f	class:ProfileData
GetCurrentState	.\profiler.cc	/^void CpuProfiler::GetCurrentState(ProfilerState* state) {$/;"	f	class:CpuProfiler
GetDefaultPagesAllocator	.\base\low_level_alloc.cc	/^LowLevelAlloc::PagesAllocator *LowLevelAlloc::GetDefaultPagesAllocator(void) {$/;"	f	class:LowLevelAlloc
GetDeleteHook	.\malloc_hook-inl.h	/^inline MallocHook::DeleteHook MallocHook::GetDeleteHook() {$/;"	f	class:MallocHook
GetDescriptor	.\page_heap.h	/^  inline Span* GetDescriptor(PageID p) const {$/;"	f	class:tcmalloc::PageHeap
GetDynsym	.\base\elf_mem_image.cc	/^const ElfW(Sym) *ElfMemImage::GetDynsym(int index) const {$/;"	f	class:base::ElfMemImage
GetEnvAppendPid	.\base\sysinfo.cc	/^bool GetEnvAppendPid(const char* env_name, char* path) {$/;"	f
GetEstimatedAllocatedSize	.\debugallocation.cc	/^  virtual size_t GetEstimatedAllocatedSize(size_t size) {$/;"	f	class:DebugMallocImplementation
GetEstimatedAllocatedSize	.\malloc_extension.cc	/^size_t MallocExtension::GetEstimatedAllocatedSize(size_t size) {$/;"	f	class:MallocExtension
GetEstimatedAllocatedSize	.\tcmalloc.cc	/^  virtual size_t GetEstimatedAllocatedSize(size_t size) {$/;"	f	class:TCMallocImplementation
GetFreeListSizes	.\debugallocation.cc	/^  virtual void GetFreeListSizes(vector<MallocExtension::FreeListInfo>* v) {$/;"	f	class:DebugMallocImplementation
GetFreeListSizes	.\malloc_extension.cc	/^void MallocExtension::GetFreeListSizes($/;"	f	class:MallocExtension
GetFreeListSizes	.\tcmalloc.cc	/^  virtual void GetFreeListSizes(vector<MallocExtension::FreeListInfo>* v) {$/;"	f	class:TCMallocImplementation
GetFunctionAddress	.\tests\heap-checker_unittest.cc	/^static inline uintptr_t GetFunctionAddress (void* (*func)(uintptr_t*))$/;"	f	file:
GetHeapGrowthStacks	.\malloc_extension.cc	/^void MallocExtension::GetHeapGrowthStacks(MallocExtensionWriter* writer) {$/;"	f	class:MallocExtension
GetHeapProfile	.\heap-profiler.cc	/^extern "C" char* GetHeapProfile() {$/;"	f
GetHeapSample	.\malloc_extension.cc	/^void MallocExtension::GetHeapSample(MallocExtensionWriter* writer) {$/;"	f	class:MallocExtension
GetHeapSample	.\tcmalloc.cc	/^  virtual void GetHeapSample(MallocExtensionWriter* writer) {$/;"	f	class:TCMallocImplementation
GetInterruptCount	.\tests\profile-handler_unittest.cc	/^  uint64 GetInterruptCount() {$/;"	f	class:__anon37::ProfileHandlerTest
GetLargeSpanStats	.\page_heap.cc	/^void PageHeap::GetLargeSpanStats(LargeSpanStats* result) {$/;"	f	class:tcmalloc::PageHeap
GetMemoryReleaseRate	.\malloc_extension.cc	/^double MallocExtension::GetMemoryReleaseRate() {$/;"	f	class:MallocExtension
GetMemoryReleaseRate	.\tcmalloc.cc	/^  virtual double GetMemoryReleaseRate() {$/;"	f	class:TCMallocImplementation
GetMmapHook	.\malloc_hook-inl.h	/^inline MallocHook::MmapHook MallocHook::GetMmapHook() {$/;"	f	class:MallocHook
GetMremapHook	.\malloc_hook-inl.h	/^inline MallocHook::MremapHook MallocHook::GetMremapHook() {$/;"	f	class:MallocHook
GetMunmapHook	.\malloc_hook-inl.h	/^inline MallocHook::MunmapHook MallocHook::GetMunmapHook() {$/;"	f	class:MallocHook
GetNewHook	.\malloc_hook-inl.h	/^inline MallocHook::NewHook MallocHook::GetNewHook() {$/;"	f	class:MallocHook
GetNextRange	.\page_heap.cc	/^bool PageHeap::GetNextRange(PageID start, base::MallocRange* r) {$/;"	f	class:tcmalloc::PageHeap
GetNumSymbols	.\base\elf_mem_image.cc	/^int ElfMemImage::GetNumSymbols() const {$/;"	f	class:base::ElfMemImage
GetNumericProperty	.\debugallocation.cc	/^  virtual bool GetNumericProperty(const char* name, size_t* value) {$/;"	f	class:DebugMallocImplementation
GetNumericProperty	.\malloc_extension.cc	/^bool MallocExtension::GetNumericProperty(const char* property, size_t* value) {$/;"	f	class:MallocExtension
GetNumericProperty	.\tcmalloc.cc	/^  virtual bool GetNumericProperty(const char* name, size_t* value) {$/;"	f	class:TCMallocImplementation
GetOrDefault	.\packed-cache-inl.h	/^  V GetOrDefault(K key, V default_value) const {$/;"	f	class:PackedCache
GetOwnership	.\debugallocation.cc	/^  virtual MallocExtension::Ownership GetOwnership(const void* p) {$/;"	f	class:DebugMallocImplementation
GetOwnership	.\malloc_extension.cc	/^MallocExtension::Ownership MallocExtension::GetOwnership(const void* p) {$/;"	f	class:MallocExtension
GetOwnership	.\tcmalloc.cc	/^  virtual Ownership GetOwnership(const void* ptr) {$/;"	f	class:TCMallocImplementation
GetPC	.\getpc.h	/^inline void* GetPC(const struct ucontext_t& signal_ucontext) {$/;"	f
GetPC	.\getpc.h	/^inline void* GetPC(const ucontext_t& signal_ucontext) {$/;"	f
GetPhdr	.\base\elf_mem_image.cc	/^const ElfW(Phdr) *ElfMemImage::GetPhdr(int index) const {$/;"	f	class:base::ElfMemImage
GetPreMmapHook	.\malloc_hook-inl.h	/^inline MallocHook::PreMmapHook MallocHook::GetPreMmapHook() {$/;"	f	class:MallocHook
GetPreSbrkHook	.\malloc_hook-inl.h	/^inline MallocHook::PreSbrkHook MallocHook::GetPreSbrkHook() {$/;"	f	class:MallocHook
GetProgramInvocationName	.\symbolize.cc	/^static const char* GetProgramInvocationName() {$/;"	f	file:
GetRunningOnValgrind	.\base\dynamic_annotations.c	/^static int GetRunningOnValgrind(void) {$/;"	f	file:
GetSamplePeriod	.\sampler.cc	/^int Sampler::GetSamplePeriod() {$/;"	f	class:tcmalloc::Sampler
GetSamplePeriod	.\thread_cache.cc	/^int ThreadCache::GetSamplePeriod() {$/;"	f	class:tcmalloc::ThreadCache
GetSbrkHook	.\malloc_hook-inl.h	/^inline MallocHook::SbrkHook MallocHook::GetSbrkHook() {$/;"	f	class:MallocHook
GetSingular	.\malloc_hook-inl.h	/^  T GetSingular() const {$/;"	f	struct:base::internal::HookList
GetSizeClassIfCached	.\page_heap.h	/^  size_t GetSizeClassIfCached(PageID p) const {$/;"	f	class:tcmalloc::PageHeap
GetSizeWithCallback	.\tcmalloc.cc	/^inline size_t GetSizeWithCallback(const void* ptr,$/;"	f	namespace:__anon34
GetSmallSpanStats	.\page_heap.cc	/^void PageHeap::GetSmallSpanStats(SmallSpanStats* result) {$/;"	f	class:tcmalloc::PageHeap
GetStackDirection	.\heap-checker.cc	/^static StackDirection ATTRIBUTE_NOINLINE GetStackDirection($/;"	f	file:
GetStackFrames	.\stacktrace.cc	/^PERFTOOLS_DLL_DECL int GetStackFrames(void** result, int* sizes, int max_depth,$/;"	f
GetStackFramesPtr	.\stacktrace.cc	/^  int (*GetStackFramesPtr)(void** result, int* sizes, int max_depth,$/;"	m	struct:GetStackImplementation	file:
GetStackFramesWithContext	.\stacktrace.cc	/^PERFTOOLS_DLL_DECL int GetStackFramesWithContext(void** result, int* sizes, int max_depth,$/;"	f
GetStackFramesWithContextPtr	.\stacktrace.cc	/^  int (*GetStackFramesWithContextPtr)(void** result, int* sizes, int max_depth,$/;"	m	struct:GetStackImplementation	file:
GetStackFramesWithContext_win32	.\stacktrace_win32-inl.h	/^static int GetStackFramesWithContext_win32(void** result, int* sizes, int max_depth,$/;"	f
GetStackFrames_win32	.\stacktrace_win32-inl.h	/^static int GetStackFrames_win32(void** \/* pcs *\/,$/;"	f
GetStackImplementation	.\stacktrace.cc	/^struct GetStackImplementation {$/;"	s	file:
GetStackTrace	.\malloc_hook.cc	61;"	d	file:
GetStackTrace	.\page_heap.h	63;"	d
GetStackTrace	.\stacktrace.cc	/^PERFTOOLS_DLL_DECL int GetStackTrace(void** result, int max_depth,$/;"	f
GetStackTracePtr	.\stacktrace.cc	/^  int (*GetStackTracePtr)(void** result, int max_depth,$/;"	m	struct:GetStackImplementation	file:
GetStackTraceWithContext	.\stacktrace.cc	/^PERFTOOLS_DLL_DECL int GetStackTraceWithContext(void** result, int max_depth,$/;"	f
GetStackTraceWithContextPtr	.\stacktrace.cc	/^  int (*GetStackTraceWithContextPtr)(void** result, int max_depth,$/;"	m	struct:GetStackImplementation	file:
GetStackTraceWithContext_win32	.\stacktrace_win32-inl.h	/^static int GetStackTraceWithContext_win32(void** result, int max_depth,$/;"	f
GetStackTrace_win32	.\stacktrace_win32-inl.h	/^static int GetStackTrace_win32(void** result, int max_depth,$/;"	f
GetState	.\profile-handler.cc	/^void ProfileHandler::GetState(ProfileHandlerState* state) {$/;"	f	class:ProfileHandler
GetStats	.\malloc_extension.cc	/^void MallocExtension::GetStats(char* buffer, int length) {$/;"	f	class:MallocExtension
GetStats	.\tcmalloc.cc	/^  virtual void GetStats(char* buffer, int buffer_length) {$/;"	f	class:TCMallocImplementation
GetSymbol	.\symbolize.cc	/^const char* SymbolTable::GetSymbol(const void* addr) {$/;"	f	class:SymbolTable
GetSystemAllocator	.\malloc_extension.cc	/^SysAllocator* MallocExtension::GetSystemAllocator() {$/;"	f	class:MallocExtension
GetSystemAllocator	.\tcmalloc.cc	/^  virtual SysAllocator* GetSystemAllocator() {$/;"	f	class:TCMallocImplementation
GetSystemCPUsCount	.\base\sysinfo.cc	/^int GetSystemCPUsCount()$/;"	f
GetThreadCacheSize	.\malloc_extension.cc	/^size_t MallocExtension::GetThreadCacheSize() {$/;"	f	class:MallocExtension
GetThreadCacheSize	.\tcmalloc.cc	/^  virtual size_t GetThreadCacheSize() {$/;"	f	class:TCMallocImplementation
GetThreadHeap	.\thread_cache.h	/^inline ThreadCache* ThreadCache::GetThreadHeap() {$/;"	f	class:tcmalloc::ThreadCache
GetThreadStats	.\thread_cache.cc	/^void ThreadCache::GetThreadStats(uint64_t* total_bytes, uint64_t* class_count) {$/;"	f	class:tcmalloc::ThreadCache
GetTotalThreadCacheSize	.\tests\markidle_unittest.cc	/^static size_t GetTotalThreadCacheSize() {$/;"	f	file:
GetUniquePathFromEnv	.\base\sysinfo.cc	/^bool GetUniquePathFromEnv(const char* env_name, char* path) {$/;"	f
GetUnmappedBytes	.\tests\tcmalloc_unittest.cc	/^static size_t GetUnmappedBytes() {$/;"	f	namespace:testing
GetVerdef	.\base\elf_mem_image.cc	/^const ElfW(Verdef) *ElfMemImage::GetVerdef(int index) const {$/;"	f	class:base::ElfMemImage
GetVersym	.\base\elf_mem_image.cc	/^const ElfW(Versym) *ElfMemImage::GetVersym(int index) const {$/;"	f	class:base::ElfMemImage
GetenvBeforeMain	.\base\sysinfo.cc	/^const char* GetenvBeforeMain(const char* name) {$/;"	f
GlobalChecker	.\heap-checker.cc	/^HeapLeakChecker* HeapLeakChecker::GlobalChecker() {$/;"	f	class:HeapLeakChecker
GlobalRegionCallerRangeMap	.\heap-checker.cc	/^           > GlobalRegionCallerRangeMap;$/;"	t	file:
GoogleInitializer	.\base\googleinit.h	/^  GoogleInitializer(const char* name, VoidFunction ctor, VoidFunction dtor)$/;"	f	class:GoogleInitializer
GoogleInitializer	.\base\googleinit.h	/^class GoogleInitializer {$/;"	c
GrowHeap	.\page_heap.cc	/^bool PageHeap::GrowHeap(Length n) {$/;"	f	class:tcmalloc::PageHeap
HAVE_ATTRIBUTE_SECTION_START	.\base\basictypes.h	276;"	d
HAVE_ATTRIBUTE_SECTION_START	.\base\basictypes.h	335;"	d
HAVE_BUILTIN_STACK_POINTER	.\windows\config.h	36;"	d
HAVE_CONFLICT_SIGNAL_H	.\windows\config.h	39;"	d
HAVE_CYGWIN_SIGNAL_H	.\windows\config.h	42;"	d
HAVE_DECL_CFREE	.\windows\config.h	46;"	d
HAVE_DECL_MEMALIGN	.\windows\config.h	50;"	d
HAVE_DECL_NANOSLEEP	.\windows\port.h	452;"	d
HAVE_DECL_POSIX_MEMALIGN	.\windows\config.h	54;"	d
HAVE_DECL_PVALLOC	.\windows\config.h	58;"	d
HAVE_DECL_SLEEP	.\windows\port.h	432;"	d
HAVE_DECL_UNAME	.\windows\config.h	62;"	d
HAVE_DECL_VALLOC	.\windows\config.h	66;"	d
HAVE_DLFCN_H	.\windows\config.h	69;"	d
HAVE_ELF32_VERSYM	.\windows\config.h	72;"	d
HAVE_ELF_MEM_IMAGE	.\base\elf_mem_image.h	48;"	d
HAVE_EXECINFO_H	.\windows\config.h	75;"	d
HAVE_FCNTL_H	.\windows\config.h	78;"	d
HAVE_FEATURES_H	.\windows\config.h	81;"	d
HAVE_GETEUID	.\windows\config.h	84;"	d
HAVE_GETPAGESIZE	.\windows\config.h	87;"	d
HAVE_GLOB_H	.\windows\config.h	90;"	d
HAVE_GRP_H	.\windows\config.h	93;"	d
HAVE_GST_arm	.\stacktrace.cc	141;"	d	file:
HAVE_GST_generic	.\stacktrace.cc	90;"	d	file:
HAVE_GST_instrument	.\stacktrace.cc	150;"	d	file:
HAVE_GST_libgcc	.\stacktrace.cc	99;"	d	file:
HAVE_GST_libunwind	.\stacktrace.cc	110;"	d	file:
HAVE_GST_ppc	.\stacktrace.cc	132;"	d	file:
HAVE_GST_win32	.\stacktrace.cc	161;"	d	file:
HAVE_GST_x86	.\stacktrace.cc	119;"	d	file:
HAVE_INTTYPES_H	.\windows\config.h	96;"	d
HAVE_LIBUNWIND_H	.\windows\config.h	99;"	d
HAVE_LINUX_PTRACE_H	.\windows\config.h	102;"	d
HAVE_MALLOC_H	.\windows\config.h	105;"	d
HAVE_MALLOC_MALLOC_H	.\windows\config.h	108;"	d
HAVE_MEMORY_H	.\windows\config.h	111;"	d
HAVE_MMAP	.\windows\config.h	114;"	d
HAVE_NAMESPACES	.\windows\config.h	117;"	d
HAVE_PID_T	.\windows\mingw.h	66;"	d
HAVE_POLL_H	.\windows\config.h	120;"	d
HAVE_PROGRAM_INVOCATION_NAME	.\windows\config.h	123;"	d
HAVE_PTHREAD	.\windows\config.h	126;"	d
HAVE_PTHREAD	.\windows\mingw.h	63;"	d
HAVE_PWD_H	.\windows\config.h	129;"	d
HAVE_SBRK	.\windows\config.h	132;"	d
HAVE_SCHED_H	.\windows\config.h	135;"	d
HAVE_SNPRINTF	.\windows\config.h	30;"	d
HAVE_SNPRINTF	.\windows\config.h	32;"	d
HAVE_SNPRINTF	.\windows\mingw.h	57;"	d
HAVE_STDINT_H	.\windows\config.h	139;"	d
HAVE_STDINT_H	.\windows\config.h	141;"	d
HAVE_STDLIB_H	.\windows\config.h	145;"	d
HAVE_STRINGS_H	.\windows\config.h	148;"	d
HAVE_STRING_H	.\windows\config.h	151;"	d
HAVE_STRUCT_MALLINFO	.\windows\config.h	154;"	d
HAVE_SYS_CDEFS_H	.\windows\config.h	157;"	d
HAVE_SYS_MALLOC_H	.\windows\config.h	160;"	d
HAVE_SYS_PARAM_H	.\windows\config.h	163;"	d
HAVE_SYS_PRCTL_H	.\windows\config.h	166;"	d
HAVE_SYS_RESOURCE_H	.\windows\config.h	169;"	d
HAVE_SYS_SOCKET_H	.\windows\config.h	172;"	d
HAVE_SYS_STAT_H	.\windows\config.h	175;"	d
HAVE_SYS_SYSCALL_H	.\windows\config.h	178;"	d
HAVE_SYS_TYPES_H	.\windows\config.h	181;"	d
HAVE_SYS_UCONTEXT_H	.\windows\config.h	184;"	d
HAVE_SYS_WAIT_H	.\windows\config.h	187;"	d
HAVE_TLS	.\windows\config.h	190;"	d
HAVE_UCONTEXT_H	.\windows\config.h	193;"	d
HAVE_UNISTD_H	.\windows\config.h	196;"	d
HAVE_UNWIND_H	.\windows\config.h	199;"	d
HAVE_VALGRIND_H	.\windows\config.h	202;"	d
HAVE_VDSO_SUPPORT	.\base\vdso_support.h	64;"	d
HAVE___ATTRIBUTE__	.\windows\config.h	205;"	d
HAVE___ENVIRON	.\windows\config.h	208;"	d
HAVE___INT64	.\windows\config.h	211;"	d
HCL_string	.\heap-checker.cc	/^                    > HCL_string;$/;"	t	file:
HEAP_PROFILE_STATS_H_	.\heap-profile-stats.h	52;"	d
HandleSavedRegionsLocked	.\memory_region_map.cc	/^inline void MemoryRegionMap::HandleSavedRegionsLocked($/;"	f	class:MemoryRegionMap
Has	.\packed-cache-inl.h	/^  bool Has(K key) const {$/;"	f	class:PackedCache
Hash	.\packed-cache-inl.h	/^  static size_t Hash(K key) {$/;"	f	class:PackedCache
HashInt	.\addressmap-inl.h	/^  static int HashInt(Number x) {$/;"	f	class:AddressMap
HaveOnHeapLocked	.\heap-checker.cc	/^inline bool HeapLeakChecker::HaveOnHeapLocked(const void** ptr,$/;"	f	class:HeapLeakChecker
HaveSystemRelease	.\tests\page_heap_test.cc	/^static bool HaveSystemRelease =$/;"	m	namespace:__anon36	file:
HaveSystemRelease	.\tests\tcmalloc_unittest.cc	/^static bool HaveSystemRelease =$/;"	m	namespace:testing	file:
Header	.\base\low_level_alloc.cc	/^    struct Header {$/;"	s	struct:low_level_alloc_internal::AllocList	file:
HeapBusyThreadBody	.\tests\heap-checker_unittest.cc	/^static void* HeapBusyThreadBody(void* a) {$/;"	f	file:
HeapCleaner	.\gperftools\heap-checker.h	/^class PERFTOOLS_DLL_DECL HeapCleaner {$/;"	c
HeapCleaner	.\heap-checker.cc	/^HeapCleaner::HeapCleaner(void_function f) {$/;"	f	class:HeapCleaner
HeapLeakChecker	.\gperftools\heap-checker.h	/^class PERFTOOLS_DLL_DECL HeapLeakChecker {$/;"	c
HeapLeakChecker	.\heap-checker.cc	/^HeapLeakChecker::HeapLeakChecker() : lock_(new SpinLock) {$/;"	f	class:HeapLeakChecker
HeapLeakChecker	.\heap-checker.cc	/^HeapLeakChecker::HeapLeakChecker(const char *name) : lock_(new SpinLock) {$/;"	f	class:HeapLeakChecker
HeapLeakCheckerGlobalPrePost	.\heap-checker-bcad.cc	/^  HeapLeakCheckerGlobalPrePost() {$/;"	f	class:HeapLeakCheckerGlobalPrePost
HeapLeakCheckerGlobalPrePost	.\heap-checker-bcad.cc	/^class HeapLeakCheckerGlobalPrePost {$/;"	c	file:
HeapLeakChecker_AfterDestructors	.\heap-checker.cc	/^void HeapLeakChecker_AfterDestructors() {$/;"	f
HeapLeakChecker_BeforeConstructors	.\heap-checker.cc	/^void HeapLeakChecker_BeforeConstructors() {$/;"	f
HeapLeakChecker_InternalInitStart	.\heap-checker.cc	/^void HeapLeakChecker_InternalInitStart() {$/;"	f
HeapLeakChecker_RunHeapCleanups	.\heap-checker.cc	/^void HeapLeakChecker_RunHeapCleanups() {$/;"	f
HeapProfileBucket	.\heap-profile-stats.h	/^struct HeapProfileBucket : public HeapProfileStats {$/;"	s
HeapProfileEndWriter	.\heap-profiler.cc	/^struct HeapProfileEndWriter {$/;"	s	file:
HeapProfileStats	.\heap-profile-stats.h	/^struct HeapProfileStats {$/;"	s
HeapProfileTable	.\heap-profile-table.cc	/^HeapProfileTable::HeapProfileTable(Allocator alloc,$/;"	f	class:HeapProfileTable
HeapProfileTable	.\heap-profile-table.h	/^class HeapProfileTable {$/;"	c
HeapProfilerDump	.\heap-profiler.cc	/^extern "C" void HeapProfilerDump(const char *reason) {$/;"	f
HeapProfilerDumpSignal	.\heap-profiler.cc	/^static void HeapProfilerDumpSignal(int signal_number) {$/;"	f	file:
HeapProfilerInit	.\heap-profiler.cc	/^static void HeapProfilerInit() {$/;"	f	file:
HeapProfilerStart	.\heap-profiler.cc	/^extern "C" void HeapProfilerStart(const char* prefix) {$/;"	f
HeapProfilerStop	.\heap-profiler.cc	/^extern "C" void HeapProfilerStop() {$/;"	f
HeapsInUse	.\thread_cache.h	/^inline int ThreadCache::HeapsInUse() {$/;"	f	class:tcmalloc::ThreadCache
HiddenPointer	.\gperftools\heap-checker.h	/^  explicit HiddenPointer(T* t)$/;"	f	class:HiddenPointer
HiddenPointer	.\gperftools\heap-checker.h	/^class HiddenPointer {$/;"	c
Hide	.\tests\heap-checker_unittest.cc	/^static void Hide(T** ptr) {$/;"	f	file:
HookIncrementNumber	.\windows\preamble_patcher_test.cc	/^int HookIncrementNumber(int i) {$/;"	f	namespace:__anon57
HookList	.\malloc_hook-inl.h	/^struct PERFTOOLS_DLL_DECL HookList {$/;"	s	namespace:base::internal
HugetlbSysAllocator	.\memfs_malloc.cc	/^  explicit HugetlbSysAllocator(SysAllocator* fallback)$/;"	f	class:HugetlbSysAllocator
HugetlbSysAllocator	.\memfs_malloc.cc	/^class HugetlbSysAllocator: public SysAllocator {$/;"	c	file:
IF_DEBUG_EXPECT_DEATH	.\tests\debugallocation_test.cc	71;"	d	file:
IGNORED_ON_HEAP	.\heap-checker.cc	/^  IGNORED_ON_HEAP,   \/\/ Is a live (ignored) object on heap$/;"	e	enum:ObjectPlacement	file:
INFO	.\base\logging.h	/^enum LogSeverity {INFO = -1, WARNING = -2, ERROR = -3, FATAL = -4};$/;"	e	enum:LogSeverity
INIT_ADDRESS_RANGE	.\tests\stacktrace_unittest.cc	60;"	d	file:
INIT_ADDRESS_RANGE	.\tests\stacktrace_unittest.cc	90;"	d	file:
INIT_ATTRIBUTE_SECTION_VARS	.\base\basictypes.h	268;"	d
INIT_ATTRIBUTE_SECTION_VARS	.\base\basictypes.h	324;"	d
INIT_ATTRIBUTE_SECTION_VARS	.\base\basictypes.h	340;"	d
INIT_HOOK_LIST	.\malloc_hook.cc	253;"	d	file:
INIT_HOOK_LIST	.\malloc_hook.cc	278;"	d	file:
INIT_HOOK_LIST	.\tests\malloc_hook_test.cc	120;"	d	file:
INIT_HOOK_LIST_WITH_VALUE	.\malloc_hook.cc	254;"	d	file:
INIT_HOOK_LIST_WITH_VALUE	.\malloc_hook.cc	277;"	d	file:
INSTALL_PREFIX	.\windows\config.h	214;"	d
INT32_EQUALS_INTPTR	.\windows\config.h	217;"	d
INTERIOR_BITS	.\pagemap.h	/^  static const int INTERIOR_BITS = (BITS + 2) \/ 3; \/\/ Round-up$/;"	m	class:TCMalloc_PageMap3
INTERIOR_LENGTH	.\pagemap.h	/^  static const int INTERIOR_LENGTH = 1 << INTERIOR_BITS;$/;"	m	class:TCMalloc_PageMap3
INUSE	.\gperftools\malloc_extension.h	/^    INUSE,                \/\/ Application is using this range$/;"	e	enum:base::MallocRange::Type
INVOKE_HOOKS	.\malloc_hook.cc	477;"	d	file:
INVOKE_HOOKS	.\malloc_hook.cc	568;"	d	file:
INVOKE_REPLACEMENT	.\malloc_hook.cc	487;"	d	file:
IN_GLOBAL_DATA	.\heap-checker.cc	/^  IN_GLOBAL_DATA,    \/\/ Is part of global data region of the executable$/;"	e	enum:ObjectPlacement	file:
IN_USE	.\span.h	/^  enum { IN_USE, ON_NORMAL_FREELIST, ON_RETURNED_FREELIST };$/;"	e	enum:tcmalloc::Span::__anon26
IOS_64	.\windows\mini_disassembler_types.h	/^  IOS_64 = 0x00001000$/;"	e	enum:sidestep::ImmediateOperandSize
IOS_DEFAULT	.\windows\mini_disassembler_types.h	/^  IOS_DEFAULT = 0x0,$/;"	e	enum:sidestep::ImmediateOperandSize
IOS_MASK	.\windows\mini_disassembler_types.h	/^  IOS_MASK = 0x0000F000,$/;"	e	enum:sidestep::ImmediateOperandSize
IP	.\base\elfcore.h	115;"	d
IP	.\base\elfcore.h	72;"	d
IP	.\base\elfcore.h	96;"	d
IS_STACK_FRAMES	.\stacktrace_impl_setup-inl.h	47;"	d
IS_STACK_FRAMES	.\stacktrace_impl_setup-inl.h	52;"	d
IS_STACK_FRAMES	.\stacktrace_impl_setup-inl.h	56;"	d
IS_STACK_FRAMES	.\stacktrace_impl_setup-inl.h	61;"	d
IS_STACK_FRAMES	.\stacktrace_impl_setup-inl.h	65;"	d
IS_STACK_FRAMES	.\stacktrace_impl_setup-inl.h	71;"	d
IS_STACK_FRAMES	.\stacktrace_impl_setup-inl.h	75;"	d
IS_STACK_FRAMES	.\stacktrace_impl_setup-inl.h	81;"	d
IS_WITH_CONTEXT	.\stacktrace_impl_setup-inl.h	48;"	d
IS_WITH_CONTEXT	.\stacktrace_impl_setup-inl.h	53;"	d
IS_WITH_CONTEXT	.\stacktrace_impl_setup-inl.h	57;"	d
IS_WITH_CONTEXT	.\stacktrace_impl_setup-inl.h	62;"	d
IS_WITH_CONTEXT	.\stacktrace_impl_setup-inl.h	66;"	d
IS_WITH_CONTEXT	.\stacktrace_impl_setup-inl.h	72;"	d
IS_WITH_CONTEXT	.\stacktrace_impl_setup-inl.h	76;"	d
IS_WITH_CONTEXT	.\stacktrace_impl_setup-inl.h	82;"	d
IT_GENERIC	.\windows\mini_disassembler_types.h	/^  IT_GENERIC,$/;"	e	enum:sidestep::InstructionType
IT_JUMP	.\windows\mini_disassembler_types.h	/^  IT_JUMP,$/;"	e	enum:sidestep::InstructionType
IT_PREFIX	.\windows\mini_disassembler_types.h	/^  IT_PREFIX,$/;"	e	enum:sidestep::InstructionType
IT_PREFIX_ADDRESS	.\windows\mini_disassembler_types.h	/^  IT_PREFIX_ADDRESS,$/;"	e	enum:sidestep::InstructionType
IT_PREFIX_OPERAND	.\windows\mini_disassembler_types.h	/^  IT_PREFIX_OPERAND,$/;"	e	enum:sidestep::InstructionType
IT_REFERENCE	.\windows\mini_disassembler_types.h	/^  IT_REFERENCE,$/;"	e	enum:sidestep::InstructionType
IT_RETURN	.\windows\mini_disassembler_types.h	/^  IT_RETURN,$/;"	e	enum:sidestep::InstructionType
IT_UNKNOWN	.\windows\mini_disassembler_types.h	/^  IT_UNKNOWN,$/;"	e	enum:sidestep::InstructionType
IT_UNUSED	.\windows\mini_disassembler_types.h	/^  IT_UNUSED,$/;"	e	enum:sidestep::InstructionType
I_WRAP_SONAME_FNNAME_ZU	.\third_party\valgrind.h	584;"	d
I_WRAP_SONAME_FNNAME_ZZ	.\third_party\valgrind.h	587;"	d
IgnoreAllLiveObjectsLocked	.\heap-checker.cc	/^void HeapLeakChecker::IgnoreAllLiveObjectsLocked(const void* self_stack_top) {$/;"	f	class:HeapLeakChecker
IgnoreLiveObjectsLocked	.\heap-checker.cc	/^\/*static*\/ void HeapLeakChecker::IgnoreLiveObjectsLocked(const char* name,$/;"	f	class:HeapLeakChecker
IgnoreLiveThreadsLocked	.\heap-checker.cc	/^\/*static*\/ int HeapLeakChecker::IgnoreLiveThreadsLocked(void* parameter,$/;"	f	class:HeapLeakChecker
IgnoreNonThreadLiveObjectsLocked	.\heap-checker.cc	/^void HeapLeakChecker::IgnoreNonThreadLiveObjectsLocked() {$/;"	f	class:HeapLeakChecker
IgnoreObject	.\gperftools\heap-checker.h	/^  static T* IgnoreObject(T* ptr) {$/;"	f	class:HeapLeakChecker
IgnoredObjectsMap	.\heap-checker.cc	/^           > IgnoredObjectsMap;$/;"	t	file:
ImmediateOperandSize	.\windows\mini_disassembler_types.h	/^enum ImmediateOperandSize {$/;"	g	namespace:sidestep
InHookCaller	.\malloc_hook.cc	/^static inline bool InHookCaller(const void* caller) {$/;"	f	file:
IncreaseCacheLimit	.\thread_cache.cc	/^void ThreadCache::IncreaseCacheLimit() {$/;"	f	class:tcmalloc::ThreadCache
IncreaseCacheLimitLocked	.\thread_cache.cc	/^void ThreadCache::IncreaseCacheLimitLocked() {$/;"	f	class:tcmalloc::ThreadCache
IncrementNumber	.\windows\preamble_patcher_test.cc	/^int __declspec(noinline) IncrementNumber(int i) {$/;"	f	namespace:__anon57
IncrementalScavenge	.\page_heap.cc	/^void PageHeap::IncrementalScavenge(Length n) {$/;"	f	class:tcmalloc::PageHeap
IncrementingFunc	.\windows\preamble_patcher_test.cc	/^typedef int (*IncrementingFunc)(int);$/;"	t	namespace:__anon57	file:
Init	.\base\elf_mem_image.cc	/^void ElfMemImage::Init(const void *base) {$/;"	f	class:base::ElfMemImage
Init	.\base\sysinfo.cc	/^void ProcMapsIterator::Init(pid_t pid, Buffer *buffer,$/;"	f	class:ProcMapsIterator
Init	.\base\vdso_support.cc	/^const void *VDSOSupport::Init() {$/;"	f	class:base::VDSOSupport
Init	.\central_freelist.cc	/^void CentralFreeList::Init(size_t cl) {$/;"	f	class:tcmalloc::CentralFreeList
Init	.\common.cc	/^void SizeMap::Init() {$/;"	f	class:tcmalloc::SizeMap
Init	.\heap-checker.cc	/^  static void Init() {$/;"	f	class:HeapLeakChecker::Allocator
Init	.\memory_region_map.cc	/^void MemoryRegionMap::Init(int max_stack_depth, bool use_buckets) {$/;"	f	class:MemoryRegionMap
Init	.\page_heap_allocator.h	/^  void Init() {$/;"	f	class:tcmalloc::PageHeapAllocator
Init	.\profile-handler.cc	/^void ProfileHandler::Init() {$/;"	f	class:ProfileHandler
Init	.\sampler.cc	/^void Sampler::Init(uint32_t seed) {$/;"	f	class:tcmalloc::Sampler
Init	.\tests\sampler_test.cc	/^void OldSampler::Init(uint32_t seed) {$/;"	f	class:OldSampler
Init	.\thread_cache.cc	/^void ThreadCache::Init(pthread_t tid) {$/;"	f	class:tcmalloc::ThreadCache
Init	.\thread_cache.h	/^    void Init() {$/;"	f	class:tcmalloc::ThreadCache::FreeList
InitDeletedBuffer	.\debugallocation.cc	/^  static void InitDeletedBuffer() {$/;"	f	class:MallocBlock
InitEmergencyMalloc	.\emergency_malloc.cc	/^  static void InitEmergencyMalloc(void) {$/;"	f	namespace:tcmalloc
InitModule	.\base\spinlock_linux-inl.h	/^  InitModule() {$/;"	f	struct:__anon15::InitModule
InitModule	.\base\spinlock_linux-inl.h	/^static struct InitModule {$/;"	s	namespace:__anon15
InitModule	.\malloc_extension.cc	/^static void InitModule() {$/;"	f	file:
InitModule	.\thread_cache.cc	/^void ThreadCache::InitModule() {$/;"	f	class:tcmalloc::ThreadCache
InitStaticVars	.\static_vars.cc	/^void Static::InitStaticVars() {$/;"	f	class:tcmalloc::Static
InitStatics	.\sampler.cc	/^void Sampler::InitStatics() {$/;"	f	class:tcmalloc::Sampler
InitStatics	.\tests\sampler_test.cc	/^  static void InitStatics() {$/;"	f	class:OldSampler
InitSystemAllocators	.\system-alloc.cc	/^void InitSystemAllocators(void) {$/;"	f
InitSystemAllocators	.\windows\system-alloc.cc	/^void InitSystemAllocators(void) {$/;"	f
InitTCMallocTransferNumObjects	.\common.cc	/^static inline void InitTCMallocTransferNumObjects()$/;"	f	namespace:tcmalloc
InitTSD	.\thread_cache.cc	/^void ThreadCache::InitTSD() {$/;"	f	class:tcmalloc::ThreadCache
InitThreadDisableCounter	.\heap-checker.cc	/^  InitThreadDisableCounter() {$/;"	f	class:InitThreadDisableCounter
InitThreadDisableCounter	.\heap-checker.cc	/^class InitThreadDisableCounter {$/;"	c	file:
InitialNewHook	.\malloc_hook.cc	/^void InitialNewHook(const void* ptr, size_t size) {$/;"	f	namespace:__anon24
InitialPreMMapHook	.\malloc_hook.cc	/^void InitialPreMMapHook(const void* start,$/;"	f	namespace:__anon24
InitialPreSbrkHook	.\malloc_hook.cc	/^void InitialPreSbrkHook(ptrdiff_t increment) {$/;"	f	namespace:__anon24
Initialize	.\debugallocation.cc	/^  void Initialize(size_t size, int type) {$/;"	f	class:MallocBlock	file:
Initialize	.\malloc_extension.cc	/^void MallocExtension::Initialize() {$/;"	f	class:MallocExtension
Initialize	.\memfs_malloc.cc	/^bool HugetlbSysAllocator::Initialize() {$/;"	f	class:HugetlbSysAllocator
Initialize	.\windows\mini_disassembler.cc	/^void MiniDisassembler::Initialize() {$/;"	f	class:sidestep::MiniDisassembler
Initialize	.\windows\preamble_patcher.cc	/^void PreamblePatcher::Initialize() {$/;"	f	class:sidestep::PreamblePatcher
Initialized	.\tests\heap-checker_unittest.cc	/^struct Initialized { };$/;"	s	file:
Inner	.\tests\heap-checker_unittest.cc	/^    Inner(Nesting* p) : parent(p) {}$/;"	f	struct:Nesting::Inner
Inner	.\tests\heap-checker_unittest.cc	/^  struct Inner {$/;"	s	struct:Nesting	file:
Insert	.\addressmap-inl.h	/^void AddressMap<Value>::Insert(Key key, Value value) {$/;"	f	class:AddressMap
InsertRange	.\central_freelist.cc	/^void CentralFreeList::InsertRange(void *start, void *end, int N) {$/;"	f	class:tcmalloc::CentralFreeList
InsertRegionLocked	.\memory_region_map.cc	/^inline void MemoryRegionMap::InsertRegionLocked(const Region& region) {$/;"	f	class:MemoryRegionMap
Instance	.\profile-handler.cc	/^ProfileHandler* ProfileHandler::Instance() {$/;"	f	class:ProfileHandler
InstructionType	.\windows\mini_disassembler_types.h	/^enum InstructionType {$/;"	g	namespace:sidestep
IntLog2	.\base\low_level_alloc.cc	/^static int IntLog2(size_t size, size_t base) {$/;"	f	file:
IntSet	.\tests\heap-checker_unittest.cc	/^typedef set<int> IntSet;$/;"	t	file:
InterfaceA	.\tests\heap-checker_unittest.cc	/^  InterfaceA() { }$/;"	f	class:InterfaceA
InterfaceA	.\tests\heap-checker_unittest.cc	/^class InterfaceA {$/;"	c	file:
InterfaceB	.\tests\heap-checker_unittest.cc	/^  InterfaceB() { }$/;"	f	class:InterfaceB
InterfaceB	.\tests\heap-checker_unittest.cc	/^class InterfaceB {$/;"	c	file:
InterfaceC	.\tests\heap-checker_unittest.cc	/^  InterfaceC() { }$/;"	f	class:InterfaceC
InterfaceC	.\tests\heap-checker_unittest.cc	/^class InterfaceC : public InterfaceA {$/;"	c	file:
InvalidFree	.\tcmalloc.cc	/^void InvalidFree(void* ptr) {$/;"	f	namespace:__anon33
InvalidGetAllocatedSize	.\tcmalloc.cc	/^size_t InvalidGetAllocatedSize(const void* ptr) {$/;"	f	namespace:__anon33
InvalidGetSizeForRealloc	.\tcmalloc.cc	/^size_t InvalidGetSizeForRealloc(const void* old_ptr) {$/;"	f	namespace:__anon33
InvokeDeleteHook	.\malloc_hook-inl.h	/^inline void MallocHook::InvokeDeleteHook(const void* p) {$/;"	f	class:MallocHook
InvokeDeleteHookSlow	.\malloc_hook.cc	/^void MallocHook::InvokeDeleteHookSlow(const void* p) {$/;"	f	class:MallocHook
InvokeMmapHook	.\malloc_hook-inl.h	/^inline void MallocHook::InvokeMmapHook(const void* result,$/;"	f	class:MallocHook
InvokeMmapHookSlow	.\malloc_hook.cc	/^void MallocHook::InvokeMmapHookSlow(const void* result,$/;"	f	class:MallocHook
InvokeMmapReplacement	.\malloc_hook-inl.h	/^inline bool MallocHook::InvokeMmapReplacement(const void* start,$/;"	f	class:MallocHook
InvokeMmapReplacementSlow	.\malloc_hook.cc	/^bool MallocHook::InvokeMmapReplacementSlow(const void* start,$/;"	f	class:MallocHook
InvokeMremapHook	.\malloc_hook-inl.h	/^inline void MallocHook::InvokeMremapHook(const void* result,$/;"	f	class:MallocHook
InvokeMremapHookSlow	.\malloc_hook.cc	/^void MallocHook::InvokeMremapHookSlow(const void* result,$/;"	f	class:MallocHook
InvokeMunmapHook	.\malloc_hook-inl.h	/^inline void MallocHook::InvokeMunmapHook(const void* p, size_t size) {$/;"	f	class:MallocHook
InvokeMunmapHookSlow	.\malloc_hook.cc	/^void MallocHook::InvokeMunmapHookSlow(const void* p, size_t s) {$/;"	f	class:MallocHook
InvokeMunmapReplacement	.\malloc_hook-inl.h	/^inline bool MallocHook::InvokeMunmapReplacement($/;"	f	class:MallocHook
InvokeMunmapReplacementSlow	.\malloc_hook.cc	/^bool MallocHook::InvokeMunmapReplacementSlow(const void* p,$/;"	f	class:MallocHook
InvokeNewHook	.\malloc_hook-inl.h	/^inline void MallocHook::InvokeNewHook(const void* p, size_t s) {$/;"	f	class:MallocHook
InvokeNewHookSlow	.\malloc_hook.cc	/^void MallocHook::InvokeNewHookSlow(const void* p, size_t s) {$/;"	f	class:MallocHook
InvokePreMmapHook	.\malloc_hook-inl.h	/^inline void MallocHook::InvokePreMmapHook(const void* start,$/;"	f	class:MallocHook
InvokePreMmapHookSlow	.\malloc_hook.cc	/^void MallocHook::InvokePreMmapHookSlow(const void* start,$/;"	f	class:MallocHook
InvokePreSbrkHook	.\malloc_hook-inl.h	/^inline void MallocHook::InvokePreSbrkHook(ptrdiff_t increment) {$/;"	f	class:MallocHook
InvokePreSbrkHookSlow	.\malloc_hook.cc	/^void MallocHook::InvokePreSbrkHookSlow(ptrdiff_t increment) {$/;"	f	class:MallocHook
InvokeSbrkHook	.\malloc_hook-inl.h	/^inline void MallocHook::InvokeSbrkHook(const void* result,$/;"	f	class:MallocHook
InvokeSbrkHookSlow	.\malloc_hook.cc	/^void MallocHook::InvokeSbrkHookSlow(const void* result, ptrdiff_t increment) {$/;"	f	class:MallocHook
IsActive	.\heap-checker.cc	/^bool HeapLeakChecker::IsActive() {$/;"	f	class:HeapLeakChecker
IsDebuggerAttached	.\heap-checker.cc	/^static bool IsDebuggerAttached(void) {    \/\/ only works under linux, probably$/;"	f	file:
IsEmergencyPtr	.\emergency_malloc.h	/^  static inline bool IsEmergencyPtr(const void *_ptr) {$/;"	f	namespace:tcmalloc
IsEmergencyPtr	.\maybe_emergency_malloc.h	/^  static inline bool IsEmergencyPtr(const void *_ptr) {$/;"	f	namespace:tcmalloc
IsFastPathAllowed	.\thread_cache.h	/^  static bool IsFastPathAllowed() { return MinSizeForSlowPath() != 0; }$/;"	f	class:tcmalloc::ThreadCache
IsHeapProfilerRunning	.\heap-profiler.cc	/^extern "C" int IsHeapProfilerRunning() {$/;"	f
IsHeld	.\base\spinlock.h	/^  inline bool IsHeld() const {$/;"	f	class:SpinLock
IsInited	.\static_vars.h	/^  static bool IsInited() { return pageheap() != NULL; }$/;"	f	class:tcmalloc::Static
IsLibraryNamed	.\heap-checker.cc	/^static bool IsLibraryNamed(const char* library, const char* library_base) {$/;"	f	file:
IsMMapped	.\debugallocation.cc	/^  bool IsMMapped() const { return kMagicMMap == magic1_; }$/;"	f	class:MallocBlock	file:
IsMovWithDisplacement	.\windows\preamble_patcher.cc	/^bool PreamblePatcher::IsMovWithDisplacement($/;"	f	class:sidestep::PreamblePatcher
IsNearAbsoluteCall	.\windows\preamble_patcher.cc	/^bool PreamblePatcher::IsNearAbsoluteCall($/;"	f	class:sidestep::PreamblePatcher
IsNearConditionalJump	.\windows\preamble_patcher.cc	/^bool PreamblePatcher::IsNearConditionalJump($/;"	f	class:sidestep::PreamblePatcher
IsNearRelativeCall	.\windows\preamble_patcher.cc	/^bool PreamblePatcher::IsNearRelativeCall($/;"	f	class:sidestep::PreamblePatcher
IsNearRelativeJump	.\windows\preamble_patcher.cc	/^bool PreamblePatcher::IsNearRelativeJump($/;"	f	class:sidestep::PreamblePatcher
IsOneThread	.\heap-checker.cc	/^static int IsOneThread(void* parameter, int num_threads,$/;"	f	file:
IsPresent	.\base\elf_mem_image.h	/^  bool                 IsPresent() const { return ehdr_ != NULL; }$/;"	f	class:base::ElfMemImage
IsPresent	.\base\vdso_support.h	/^  bool IsPresent() const { return image_.IsPresent(); }$/;"	f	class:base::VDSOSupport
IsRecordingLocked	.\memory_region_map.cc	/^bool MemoryRegionMap::IsRecordingLocked() {$/;"	f	class:MemoryRegionMap
IsShortConditionalJump	.\windows\preamble_patcher.cc	/^bool PreamblePatcher::IsShortConditionalJump($/;"	f	class:sidestep::PreamblePatcher
IsShortJump	.\windows\preamble_patcher.cc	/^bool PreamblePatcher::IsShortJump($/;"	f	class:sidestep::PreamblePatcher
IsSignalHandlerAvailable	.\profile-handler.cc	/^bool ProfileHandler::IsSignalHandlerAvailable() {$/;"	f	class:ProfileHandler
IsStacktraceAllowed	.\stacktrace.cc	/^    bool IsStacktraceAllowed() {$/;"	f	class:__anon27::StacktraceScope
IsTimerEnabled	.\tests\profile-handler_unittest.cc	/^bool IsTimerEnabled() {$/;"	f	namespace:__anon37
IsUseEmergencyMalloc	.\thread_cache.h	/^inline bool ThreadCache::IsUseEmergencyMalloc() {$/;"	f	class:tcmalloc::ThreadCache
IsValidMagicValue	.\debugallocation.cc	/^  bool IsValidMagicValue(int value) const {$/;"	f	class:MallocBlock	file:
Iterate	.\addressmap-inl.h	/^inline void AddressMap<Value>::Iterate(void (*callback)(Key, Value*, Type),$/;"	f	class:AddressMap
IterateAllocs	.\heap-profile-table.h	/^  void IterateAllocs(AllocIterator callback) const {$/;"	f	class:HeapProfileTable
IterateBuckets	.\memory_region_map.h	/^void MemoryRegionMap::IterateBuckets($/;"	f	class:MemoryRegionMap
IterateOrderedAllocContexts	.\heap-profile-table.cc	/^void HeapProfileTable::IterateOrderedAllocContexts($/;"	f	class:HeapProfileTable
IterateOverRanges	.\tcmalloc.cc	/^static void IterateOverRanges(void* arg, MallocExtension::RangeFunction func) {$/;"	f	file:
Join	.\tests\profile-handler_unittest.cc	/^  void Join()  {$/;"	f	class:__anon37::Thread
JumpAbsoluteFunction	.\windows\shortproc.asm	/^JumpAbsoluteFunction PROC$/;"	l
JumpNearCondFunction	.\windows\shortproc.asm	/^JumpNearCondFunction PROC$/;"	l
JumpShortCondFunction	.\windows\shortproc.asm	/^JumpShortCondFunction PROC$/;"	l
K	.\packed-cache-inl.h	/^  typedef uintptr_t K;$/;"	t	class:PackedCache
KERNEL_DIRENT	.\base\linux_syscall_support.h	2367;"	d
KERNEL_NSIG	.\base\linux_syscall_support.h	278;"	d
KERNEL_NSIG	.\base\linux_syscall_support.h	280;"	d
Key	.\addressmap-inl.h	/^  typedef const void* Key;$/;"	t	class:AddressMap
KeyEqual	.\stack_trace_table.cc	/^bool StackTraceTable::Bucket::KeyEqual(uintptr_t h,$/;"	f	class:tcmalloc::StackTraceTable::Bucket
KeyFree	.\tests\heap-checker_unittest.cc	/^static void KeyFree(void* ptr) {$/;"	f	file:
KeyInit	.\tests\heap-checker_unittest.cc	/^static void KeyInit() {$/;"	f	file:
KeyMatch	.\packed-cache-inl.h	/^  static bool KeyMatch(T entry, K key) {$/;"	f	class:PackedCache
KeyToUpper	.\packed-cache-inl.h	/^  static UPPER KeyToUpper(K k) {$/;"	f	class:PackedCache
LEAF_BITS	.\pagemap.h	/^  static const int LEAF_BITS = BITS - 2*INTERIOR_BITS;$/;"	m	class:TCMalloc_PageMap3
LEAF_BITS	.\pagemap.h	/^  static const int LEAF_BITS = BITS - ROOT_BITS;$/;"	m	class:TCMalloc_PageMap2
LEAF_LENGTH	.\pagemap.h	/^  static const int LEAF_LENGTH = 1 << LEAF_BITS;$/;"	m	class:TCMalloc_PageMap2
LEAF_LENGTH	.\pagemap.h	/^  static const int LEAF_LENGTH = 1 << LEAF_BITS;$/;"	m	class:TCMalloc_PageMap3
LENGTH	.\pagemap.h	/^  static const int LENGTH = 1 << BITS;$/;"	m	class:TCMalloc_PageMap1
LIKELY	.\common.h	48;"	d
LIKELY	.\common.h	51;"	d
LINKER_INITIALIZED	.\base\basictypes.h	/^enum LinkerInitialized { LINKER_INITIALIZED };$/;"	e	enum:base::LinkerInitialized
LINKER_INITIALIZED	.\base\simple_mutex.h	/^  enum LinkerInitialized { LINKER_INITIALIZED };$/;"	e	enum:MUTEX_NAMESPACE::Mutex::LinkerInitialized
LINKER_INITIALIZED	.\base\spinlock.cc	/^const base::LinkerInitialized SpinLock::LINKER_INITIALIZED =$/;"	m	class:SpinLock	file:
LINKER_INITIALIZED	.\base\spinlock.h	/^  static const base::LinkerInitialized LINKER_INITIALIZED;  \/\/ backwards compat$/;"	m	class:SpinLock
LLA_SkiplistDelete	.\base\low_level_alloc.cc	/^static void LLA_SkiplistDelete(AllocList *head, AllocList *e,$/;"	f	file:
LLA_SkiplistInsert	.\base\low_level_alloc.cc	/^static void LLA_SkiplistInsert(AllocList *head, AllocList *e,$/;"	f	file:
LLA_SkiplistLevels	.\base\low_level_alloc.cc	/^static int LLA_SkiplistLevels(size_t size, size_t base, bool random) {$/;"	f	file:
LLA_SkiplistSearch	.\base\low_level_alloc.cc	/^static AllocList *LLA_SkiplistSearch(AllocList *head,$/;"	f	file:
LOAD	.\stacktrace_powerpc-inl.h	100;"	d
LOAD	.\stacktrace_powerpc-inl.h	102;"	d
LOAD	.\stacktrace_powerpc-linux-inl.h	121;"	d
LOAD	.\stacktrace_powerpc-linux-inl.h	123;"	d
LOCKABLE	.\base\thread_annotations.h	109;"	d
LOCKS_EXCLUDED	.\base\thread_annotations.h	102;"	d
LOCK_RETURNED	.\base\thread_annotations.h	106;"	d
LOG	.\base\logging.h	/^inline void LOG(int lvl, const char* pat, ...)      { LOG_PRINTF(lvl, pat); }$/;"	f
LOG	.\tests\sampler_test.cc	82;"	d	file:
LOG	.\tests\sampler_test.cc	85;"	d	file:
LOGF	.\tests\heap-checker_unittest.cc	169;"	d	file:
LOGSTREAM	.\tests\tcmalloc_unittest.cc	152;"	d	file:
LOG_IF	.\base\logging.h	/^inline void LOG_IF(int lvl, bool cond, const char* pat, ...) {$/;"	f
LOG_PRINTF	.\base\logging.h	218;"	d
LPMODULEENTRY32	.\base\sysinfo.cc	75;"	d	file:
LR	.\base\elfcore.h	116;"	d
LR	.\base\elfcore.h	97;"	d
LSS_ASMINPUT_0	.\base\linux_syscall_support.h	1877;"	d
LSS_ASMINPUT_0	.\base\linux_syscall_support.h	1878;"	d
LSS_ASMINPUT_1	.\base\linux_syscall_support.h	1879;"	d
LSS_ASMINPUT_1	.\base\linux_syscall_support.h	1880;"	d
LSS_ASMINPUT_2	.\base\linux_syscall_support.h	1881;"	d
LSS_ASMINPUT_2	.\base\linux_syscall_support.h	1882;"	d
LSS_ASMINPUT_3	.\base\linux_syscall_support.h	1883;"	d
LSS_ASMINPUT_3	.\base\linux_syscall_support.h	1884;"	d
LSS_ASMINPUT_4	.\base\linux_syscall_support.h	1885;"	d
LSS_ASMINPUT_4	.\base\linux_syscall_support.h	1886;"	d
LSS_ASMINPUT_5	.\base\linux_syscall_support.h	1887;"	d
LSS_ASMINPUT_5	.\base\linux_syscall_support.h	1888;"	d
LSS_ASMINPUT_6	.\base\linux_syscall_support.h	1889;"	d
LSS_ASMINPUT_6	.\base\linux_syscall_support.h	1890;"	d
LSS_BODY	.\base\linux_syscall_support.h	1231;"	d
LSS_BODY	.\base\linux_syscall_support.h	1232;"	d
LSS_BODY	.\base\linux_syscall_support.h	1448;"	d
LSS_BODY	.\base\linux_syscall_support.h	1449;"	d
LSS_BODY	.\base\linux_syscall_support.h	1636;"	d
LSS_BODY	.\base\linux_syscall_support.h	1637;"	d
LSS_BODY	.\base\linux_syscall_support.h	1891;"	d
LSS_BODY	.\base\linux_syscall_support.h	1892;"	d
LSS_BODY	.\base\linux_syscall_support.h	2120;"	d
LSS_BODY	.\base\linux_syscall_support.h	2121;"	d
LSS_BODY	.\base\linux_syscall_support.h	2242;"	d
LSS_BODY	.\base\linux_syscall_support.h	2243;"	d
LSS_BODY	.\base\linux_syscall_support.h	977;"	d
LSS_BODY	.\base\linux_syscall_support.h	978;"	d
LSS_BODY_ARG0	.\base\linux_syscall_support.h	1265;"	d
LSS_BODY_ARG0	.\base\linux_syscall_support.h	1272;"	d
LSS_BODY_ARG1	.\base\linux_syscall_support.h	1266;"	d
LSS_BODY_ARG1	.\base\linux_syscall_support.h	1273;"	d
LSS_BODY_ARG2	.\base\linux_syscall_support.h	1267;"	d
LSS_BODY_ARG2	.\base\linux_syscall_support.h	1275;"	d
LSS_BODY_ARG3	.\base\linux_syscall_support.h	1268;"	d
LSS_BODY_ARG3	.\base\linux_syscall_support.h	1277;"	d
LSS_BODY_ARG4	.\base\linux_syscall_support.h	1269;"	d
LSS_BODY_ARG4	.\base\linux_syscall_support.h	1279;"	d
LSS_BODY_ARG5	.\base\linux_syscall_support.h	1270;"	d
LSS_BODY_ARG5	.\base\linux_syscall_support.h	1281;"	d
LSS_BODY_ARG6	.\base\linux_syscall_support.h	1271;"	d
LSS_BODY_ARG6	.\base\linux_syscall_support.h	1283;"	d
LSS_BODY_ASM0	.\base\linux_syscall_support.h	1235;"	d
LSS_BODY_ASM0	.\base\linux_syscall_support.h	1242;"	d
LSS_BODY_ASM1	.\base\linux_syscall_support.h	1236;"	d
LSS_BODY_ASM1	.\base\linux_syscall_support.h	1243;"	d
LSS_BODY_ASM2	.\base\linux_syscall_support.h	1237;"	d
LSS_BODY_ASM2	.\base\linux_syscall_support.h	1244;"	d
LSS_BODY_ASM3	.\base\linux_syscall_support.h	1238;"	d
LSS_BODY_ASM3	.\base\linux_syscall_support.h	1245;"	d
LSS_BODY_ASM4	.\base\linux_syscall_support.h	1239;"	d
LSS_BODY_ASM4	.\base\linux_syscall_support.h	1246;"	d
LSS_BODY_ASM5	.\base\linux_syscall_support.h	1240;"	d
LSS_BODY_ASM5	.\base\linux_syscall_support.h	1247;"	d
LSS_BODY_ASM6	.\base\linux_syscall_support.h	1241;"	d
LSS_BODY_ASM6	.\base\linux_syscall_support.h	1248;"	d
LSS_BODY_CLOBBER0	.\base\linux_syscall_support.h	1250;"	d
LSS_BODY_CLOBBER0	.\base\linux_syscall_support.h	1257;"	d
LSS_BODY_CLOBBER1	.\base\linux_syscall_support.h	1251;"	d
LSS_BODY_CLOBBER1	.\base\linux_syscall_support.h	1258;"	d
LSS_BODY_CLOBBER2	.\base\linux_syscall_support.h	1252;"	d
LSS_BODY_CLOBBER2	.\base\linux_syscall_support.h	1259;"	d
LSS_BODY_CLOBBER3	.\base\linux_syscall_support.h	1253;"	d
LSS_BODY_CLOBBER3	.\base\linux_syscall_support.h	1260;"	d
LSS_BODY_CLOBBER4	.\base\linux_syscall_support.h	1254;"	d
LSS_BODY_CLOBBER4	.\base\linux_syscall_support.h	1261;"	d
LSS_BODY_CLOBBER5	.\base\linux_syscall_support.h	1255;"	d
LSS_BODY_CLOBBER5	.\base\linux_syscall_support.h	1262;"	d
LSS_BODY_CLOBBER6	.\base\linux_syscall_support.h	1256;"	d
LSS_BODY_CLOBBER6	.\base\linux_syscall_support.h	1263;"	d
LSS_ENTRYPOINT	.\base\linux_syscall_support.h	1200;"	d
LSS_ENTRYPOINT	.\base\linux_syscall_support.h	1201;"	d
LSS_ERRNO	.\base\linux_syscall_support.h	873;"	d
LSS_ERRNO	.\base\linux_syscall_support.h	878;"	d
LSS_ERRNO	.\base\linux_syscall_support.h	880;"	d
LSS_INLINE	.\base\linux_syscall_support.h	883;"	d
LSS_INLINE	.\base\linux_syscall_support.h	885;"	d
LSS_INLINE	.\base\linux_syscall_support.h	887;"	d
LSS_LOADARGS_0	.\base\linux_syscall_support.h	1850;"	d
LSS_LOADARGS_0	.\base\linux_syscall_support.h	1851;"	d
LSS_LOADARGS_1	.\base\linux_syscall_support.h	1853;"	d
LSS_LOADARGS_1	.\base\linux_syscall_support.h	1854;"	d
LSS_LOADARGS_2	.\base\linux_syscall_support.h	1857;"	d
LSS_LOADARGS_2	.\base\linux_syscall_support.h	1858;"	d
LSS_LOADARGS_3	.\base\linux_syscall_support.h	1861;"	d
LSS_LOADARGS_3	.\base\linux_syscall_support.h	1862;"	d
LSS_LOADARGS_4	.\base\linux_syscall_support.h	1865;"	d
LSS_LOADARGS_4	.\base\linux_syscall_support.h	1866;"	d
LSS_LOADARGS_5	.\base\linux_syscall_support.h	1869;"	d
LSS_LOADARGS_5	.\base\linux_syscall_support.h	1870;"	d
LSS_LOADARGS_6	.\base\linux_syscall_support.h	1873;"	d
LSS_LOADARGS_6	.\base\linux_syscall_support.h	1874;"	d
LSS_LOAD_ARG	.\base\linux_syscall_support.h	1445;"	d
LSS_LOAD_ARG	.\base\linux_syscall_support.h	1446;"	d
LSS_NAME	.\base\linux_syscall_support.h	/^    LSS_INLINE void (*LSS_NAME(restore)(void))(void) {$/;"	f
LSS_NAME	.\base\linux_syscall_support.h	/^    LSS_INLINE void (*LSS_NAME(restore_rt)(void))(void) {$/;"	f
LSS_NAME	.\base\linux_syscall_support.h	893;"	d
LSS_NAME	.\base\linux_syscall_support.h	895;"	d
LSS_NAME	.\base\linux_syscall_support.h	897;"	d
LSS_NAME	.\base\linux_syscall_support.h	899;"	d
LSS_NAME	.\base\linux_syscall_support.h	901;"	d
LSS_NAME	.\base\linux_syscall_support.h	903;"	d
LSS_NAME	.\base\linux_syscall_support.h	905;"	d
LSS_NAME	.\base\linux_syscall_support.h	907;"	d
LSS_NAME	.\base\linux_syscall_support.h	909;"	d
LSS_NAME	.\base\linux_syscall_support.h	911;"	d
LSS_NAME	.\base\linux_syscall_support.h	913;"	d
LSS_NAME	.\base\linux_syscall_support.h	915;"	d
LSS_NAME	.\base\linux_syscall_support.h	917;"	d
LSS_REG	.\base\linux_syscall_support.h	1435;"	d
LSS_REG	.\base\linux_syscall_support.h	1436;"	d
LSS_REG	.\base\linux_syscall_support.h	1622;"	d
LSS_REG	.\base\linux_syscall_support.h	1623;"	d
LSS_REG	.\base\linux_syscall_support.h	2118;"	d
LSS_REG	.\base\linux_syscall_support.h	2119;"	d
LSS_REG	.\base\linux_syscall_support.h	2240;"	d
LSS_REG	.\base\linux_syscall_support.h	2241;"	d
LSS_RETURN	.\base\linux_syscall_support.h	1220;"	d
LSS_RETURN	.\base\linux_syscall_support.h	1221;"	d
LSS_RETURN	.\base\linux_syscall_support.h	920;"	d
LSS_RETURN	.\base\linux_syscall_support.h	926;"	d
LSS_RETURN	.\base\linux_syscall_support.h	938;"	d
LSS_RETURN	.\base\linux_syscall_support.h	950;"	d
LSS_SAVE_ARG	.\base\linux_syscall_support.h	1443;"	d
LSS_SAVE_ARG	.\base\linux_syscall_support.h	1444;"	d
LSS_SYSCALL_ARG	.\base\linux_syscall_support.h	1209;"	d
LSS_SYSCALL_ARG	.\base\linux_syscall_support.h	1210;"	d
LT_OBJDIR	.\windows\config.h	221;"	d
LargeSizeClass	.\common.h	/^  static inline size_t LargeSizeClass(size_t s) {$/;"	f	class:tcmalloc::SizeMap
LargeSpanStats	.\page_heap.h	/^  struct LargeSpanStats {$/;"	s	class:tcmalloc::PageHeap
Leaf	.\pagemap.h	/^  struct Leaf {$/;"	s	class:TCMalloc_PageMap2
Leaf	.\pagemap.h	/^  struct Leaf {$/;"	s	class:TCMalloc_PageMap3
Leave	.\base\low_level_alloc.cc	/^    void Leave() \/*UNLOCK_FUNCTION()*\/ {$/;"	f	class:__anon8::ArenaLock
LeaveStacktraceScope	.\emergency_malloc_for_stacktrace.cc	/^void tcmalloc::LeaveStacktraceScope(void) {$/;"	f	class:tcmalloc
LeaveStacktraceScope	.\fake_stacktrace_scope.cc	/^  ATTRIBUTE_WEAK void LeaveStacktraceScope(void) {$/;"	f	namespace:tcmalloc
Length	.\common.h	/^typedef uintptr_t Length;$/;"	t
LgFloor	.\common.cc	/^static inline int LgFloor(size_t n) {$/;"	f	namespace:tcmalloc
LibcInfo	.\windows\patch_functions.cc	/^  LibcInfo() {$/;"	f	class:__anon52::LibcInfo
LibcInfo	.\windows\patch_functions.cc	/^class LibcInfo {$/;"	c	namespace:__anon52	file:
LibcInfoWithPatchFunctions	.\windows\patch_functions.cc	/^template<int> class LibcInfoWithPatchFunctions : public LibcInfo {$/;"	c	namespace:__anon52	file:
LibraryLiveObjectsStacks	.\heap-checker.cc	/^           > LibraryLiveObjectsStacks;$/;"	t	file:
LinkerInitialized	.\base\basictypes.h	/^enum LinkerInitialized { LINKER_INITIALIZED };$/;"	g	namespace:base
LinkerInitialized	.\base\simple_mutex.h	/^  enum LinkerInitialized { LINKER_INITIALIZED };$/;"	g	class:MUTEX_NAMESPACE::Mutex
LinuxKernelCmpxchgFunc	.\base\atomicops-internals-arm-generic.h	/^typedef Atomic32 (*LinuxKernelCmpxchgFunc)(Atomic32 old_value,$/;"	t	namespace:base::subtle
LinuxKernelMemoryBarrierFunc	.\base\atomicops-internals-arm-generic.h	/^typedef void (*LinuxKernelMemoryBarrierFunc)(void);$/;"	t	namespace:base::subtle
ListAllProcessThreadsCallBack	.\base\thread_lister.h	/^typedef int (*ListAllProcessThreadsCallBack)(void *parameter,$/;"	t
ListTooLong	.\thread_cache.cc	/^void ThreadCache::ListTooLong(FreeList* list, size_t cl) {$/;"	f	class:tcmalloc::ThreadCache
ListerParams	.\base\linuxthreads.cc	/^struct ListerParams {$/;"	s	file:
ListerThread	.\base\linuxthreads.cc	/^static void ListerThread(struct ListerParams *args) {$/;"	f	file:
LiveObjectsStack	.\heap-checker.cc	/^              > LiveObjectsStack;$/;"	t	file:
Lock	.\base\simple_mutex.h	/^void Mutex::Lock()         { SAFE_PTHREAD(pthread_mutex_lock); }$/;"	f	class:MUTEX_NAMESPACE::Mutex
Lock	.\base\simple_mutex.h	/^void Mutex::Lock()         { SAFE_PTHREAD(pthread_rwlock_wrlock); }$/;"	f	class:MUTEX_NAMESPACE::Mutex
Lock	.\base\simple_mutex.h	/^void Mutex::Lock()         { assert(--mutex_ == -1); }$/;"	f	class:MUTEX_NAMESPACE::Mutex
Lock	.\base\simple_mutex.h	/^void Mutex::Lock()         { if (is_safe_) EnterCriticalSection(&mutex_); }$/;"	f	class:MUTEX_NAMESPACE::Mutex
Lock	.\base\spinlock.h	/^  inline void Lock() \/*EXCLUSIVE_LOCK_FUNCTION()*\/ {$/;"	f	class:SpinLock
Lock	.\central_freelist.h	/^  void Lock() {$/;"	f	class:tcmalloc::CentralFreeList
Lock	.\memory_region_map.cc	/^void MemoryRegionMap::Lock() {$/;"	f	class:MemoryRegionMap
LockHolder	.\memory_region_map.h	/^    LockHolder() { Lock(); }$/;"	f	class:MemoryRegionMap::LockHolder
LockHolder	.\memory_region_map.h	/^  class LockHolder {$/;"	c	class:MemoryRegionMap
LockInverter	.\central_freelist.cc	/^  inline explicit LockInverter(SpinLock* held, SpinLock *temp)$/;"	f	class:tcmalloc::__anon16::LockInverter
LockInverter	.\central_freelist.cc	/^class LockInverter {$/;"	c	namespace:tcmalloc::__anon16	file:
LockIsHeld	.\memory_region_map.cc	/^bool MemoryRegionMap::LockIsHeld() {$/;"	f	class:MemoryRegionMap
Log	.\internal_logging.cc	/^void Log(LogMode mode, const char* filename, int line,$/;"	f	namespace:tcmalloc
LogAllLocked	.\memory_region_map.cc	/^void MemoryRegionMap::LogAllLocked() {$/;"	f	class:MemoryRegionMap
LogHidden	.\tests\heap-checker_unittest.cc	/^static void LogHidden(const char* message, const void* ptr) {$/;"	f	file:
LogItem	.\internal_logging.h	/^  LogItem()                     : tag_(kEnd)      { }$/;"	f	class:tcmalloc::LogItem
LogItem	.\internal_logging.h	/^  LogItem(const char* v)        : tag_(kStr)      { u_.str = v; }$/;"	f	class:tcmalloc::LogItem
LogItem	.\internal_logging.h	/^  LogItem(const void* v)        : tag_(kPtr)      { u_.ptr = v; }$/;"	f	class:tcmalloc::LogItem
LogItem	.\internal_logging.h	/^  LogItem(int v)                : tag_(kSigned)   { u_.snum = v; }$/;"	f	class:tcmalloc::LogItem
LogItem	.\internal_logging.h	/^  LogItem(long long v)          : tag_(kSigned)   { u_.snum = v; }$/;"	f	class:tcmalloc::LogItem
LogItem	.\internal_logging.h	/^  LogItem(long v)               : tag_(kSigned)   { u_.snum = v; }$/;"	f	class:tcmalloc::LogItem
LogItem	.\internal_logging.h	/^  LogItem(unsigned int v)       : tag_(kUnsigned) { u_.unum = v; }$/;"	f	class:tcmalloc::LogItem
LogItem	.\internal_logging.h	/^  LogItem(unsigned long long v) : tag_(kUnsigned) { u_.unum = v; }$/;"	f	class:tcmalloc::LogItem
LogItem	.\internal_logging.h	/^  LogItem(unsigned long v)      : tag_(kUnsigned) { u_.unum = v; }$/;"	f	class:tcmalloc::LogItem
LogItem	.\internal_logging.h	/^class LogItem {$/;"	c	namespace:tcmalloc
LogMode	.\internal_logging.h	/^enum LogMode {$/;"	g	namespace:tcmalloc
LogPrintf	.\base\logging.h	/^inline void LogPrintf(int severity, const char* pat, va_list ap) {$/;"	f
LogSeverity	.\base\logging.h	/^enum LogSeverity {INFO = -1, WARNING = -2, ERROR = -3, FATAL = -4};$/;"	g
Logger	.\internal_logging.cc	/^class Logger {$/;"	c	namespace:tcmalloc	file:
LookupSymbol	.\base\elf_mem_image.cc	/^bool ElfMemImage::LookupSymbol(const char *name,$/;"	f	class:base::ElfMemImage
LookupSymbol	.\base\vdso_support.cc	/^bool VDSOSupport::LookupSymbol(const char *name,$/;"	f	class:base::VDSOSupport
LookupSymbolByAddress	.\base\elf_mem_image.cc	/^bool ElfMemImage::LookupSymbolByAddress(const void *address,$/;"	f	class:base::ElfMemImage
LookupSymbolByAddress	.\base\vdso_support.cc	/^bool VDSOSupport::LookupSymbolByAddress(const void *address,$/;"	f	class:base::VDSOSupport
LowLevelAlloc	.\base\low_level_alloc.h	/^class LowLevelAlloc {$/;"	c
MADV_FREE	.\system-alloc.cc	69;"	d	file:
MAKE_HOOK_CALLBACK	.\tests\tcmalloc_unittest.cc	728;"	d	file:
MALLOC_HOOK_HAVE_DO_MMAP64	.\malloc_hook_mmap_linux.h	120;"	d
MALLOC_HOOK_HAVE_DO_MMAP64	.\malloc_hook_mmap_linux.h	134;"	d
MALLOC_HOOK_HAVE_DO_MMAP64	.\malloc_hook_mmap_linux.h	250;"	d
MALLOC_HOOK_HAVE_DO_MMAP64	.\malloc_hook_mmap_linux.h	63;"	d
MALLOC_HOOK_MAYBE_VOLATILE	.\windows\config.h	224;"	d
MALLOC_HOOK_SYSCALL	.\malloc_hook_mmap_freebsd.h	135;"	d
MALLOC_HOOK_SYSCALL	.\malloc_hook_mmap_freebsd.h	54;"	d
MALLOC_HOOK_SYSCALL	.\malloc_hook_mmap_freebsd.h	56;"	d
MALLOC_TRACE	.\debugallocation.cc	999;"	d	file:
MAP_ANONYMOUS	.\base\low_level_alloc.cc	55;"	d	file:
MAP_ANONYMOUS	.\debugallocation.cc	97;"	d	file:
MAP_ANONYMOUS	.\system-alloc.cc	62;"	d	file:
MAP_ANONYMOUS	.\tests\heap-checker_unittest.cc	113;"	d	file:
MAP_ANONYMOUS	.\tests\malloc_hook_test.cc	56;"	d	file:
MAP_ANONYMOUS	.\tests\tcmalloc_unittest.cc	149;"	d	file:
MAP_ANONYMOUS	.\windows\port.h	278;"	d
MAP_FAILED	.\memory_region_map.cc	111;"	d	file:
MAP_FAILED	.\windows\port.h	273;"	d
MAP_PRIVATE	.\windows\port.h	279;"	d
MAP_SHARED	.\windows\port.h	280;"	d
MAX_DEPTH	.\stacktrace_instrument-inl.h	62;"	d
MAX_PERTHREAD_VALS	.\maybe_threads.cc	78;"	d	file:
MAX_PREAMBLE_STUB_SIZE	.\windows\preamble_patcher.h	61;"	d
MAX_PREAMBLE_STUB_SIZE	.\windows\preamble_patcher.h	63;"	d
MAX_THREAD	.\stacktrace_instrument-inl.h	58;"	d
MAX_THREAD	.\stacktrace_instrument-inl.h	60;"	d
MAYBE_EMERGENCY_MALLOC_H	.\maybe_emergency_malloc.h	32;"	d
MAYBE_LIVE	.\heap-checker.cc	/^  MAYBE_LIVE,        \/\/ Is a piece of writable memory from \/proc\/self\/maps$/;"	e	enum:ObjectPlacement	file:
MIPSREG	.\base\elfcore.h	288;"	d
MIPS_SYSCALL_CLOBBERS	.\base\linux_syscall_support.h	1629;"	d
MIPS_SYSCALL_CLOBBERS	.\base\linux_syscall_support.h	1632;"	d
MODULEENTRY32	.\base\sysinfo.cc	71;"	d	file:
MODULEENTRY32	.\base\sysinfo.h	202;"	d
MODULEENTRY32	.\base\sysinfo.h	204;"	d
MREMAP_FIXED	.\base\linux_syscall_support.h	544;"	d
MREMAP_FIXED	.\memory_region_map.cc	135;"	d	file:
MREMAP_FIXED	.\windows\port.h	274;"	d
MUST_BE_ON_HEAP	.\heap-checker.cc	/^  MUST_BE_ON_HEAP,   \/\/ Must point to a live object of the matching size in the$/;"	e	enum:ObjectPlacement	file:
MUTEX_NAMESPACE	.\base\simple_mutex.h	/^namespace MUTEX_NAMESPACE {$/;"	n
MUTEX_NAMESPACE	.\base\simple_mutex.h	144;"	d
MUTEX_NAMESPACE	.\base\simple_mutex.h	330;"	d
MY_LOG_NAME	.\heap-checker.cc	110;"	d	file:
MY_LOG_NAME	.\profiler.cc	71;"	d	file:
Magic	.\base\low_level_alloc.cc	/^inline static intptr_t Magic(intptr_t magic, AllocList::Header *ptr) {$/;"	f	file:
MakeALeak	.\tests\heap-checker_unittest.cc	/^static void MakeALeak(void** arr) {$/;"	f	file:
MakeCacheSpace	.\central_freelist.cc	/^bool CentralFreeList::MakeCacheSpace() {$/;"	f	class:tcmalloc::CentralFreeList
MakeDeathLoop	.\tests\heap-checker_unittest.cc	/^static void MakeDeathLoop(void** arr1, void** arr2) {$/;"	f	file:
MakeDisabledLiveCallbackLocked	.\heap-checker.cc	/^static void MakeDisabledLiveCallbackLocked($/;"	f	file:
MakeIgnoredObjectsLiveCallbackLocked	.\heap-checker.cc	/^static void MakeIgnoredObjectsLiveCallbackLocked($/;"	f	file:
MakeProfileNameLocked	.\heap-checker.cc	/^char* HeapLeakChecker::MakeProfileNameLocked() {$/;"	f	class:HeapLeakChecker
MakeSortedBucketList	.\heap-profile-table.cc	/^HeapProfileTable::MakeSortedBucketList() const {$/;"	f	class:HeapProfileTable
MakeTestingHook	.\windows\auto_testing_hook.h	/^  static AutoTestingHookImpl<T> MakeTestingHook(T target_function,$/;"	f	class:sidestep::AutoTestingHookImpl
MakeTestingHook	.\windows\auto_testing_hook.h	/^inline AutoTestingHookImpl<T> MakeTestingHook(T target, T replacement) {$/;"	f	namespace:sidestep
MakeTestingHook	.\windows\auto_testing_hook.h	/^inline AutoTestingHookImpl<T> MakeTestingHook(T target,$/;"	f	namespace:sidestep
MakeTestingHookHolder	.\windows\auto_testing_hook.h	/^  static AutoTestingHookImpl<T>* MakeTestingHookHolder(T target_function,$/;"	f	class:sidestep::AutoTestingHookImpl
MakeTestingHookHolder	.\windows\auto_testing_hook.h	/^inline AutoTestingHookImpl<T>* MakeTestingHookHolder(T target, T replacement) {$/;"	f	namespace:sidestep
MallocBlock	.\debugallocation.cc	/^class MallocBlock {$/;"	c	file:
MallocBlockQueueEntry	.\debugallocation.cc	/^  MallocBlockQueueEntry() : block(NULL), size(0),$/;"	f	struct:MallocBlockQueueEntry
MallocBlockQueueEntry	.\debugallocation.cc	/^  MallocBlockQueueEntry(MallocBlock* b, size_t s) : block(b), size(s) {$/;"	f	struct:MallocBlockQueueEntry
MallocBlockQueueEntry	.\debugallocation.cc	/^struct MallocBlockQueueEntry {$/;"	s	file:
MallocExtension	.\gperftools\malloc_extension.h	/^class PERFTOOLS_DLL_DECL MallocExtension {$/;"	c
MallocExtensionWriter	.\gperftools\malloc_extension.h	/^typedef std::string MallocExtensionWriter;$/;"	t
MallocExtension_GetOwnership	.\malloc_extension.cc	/^MallocExtension_Ownership MallocExtension_GetOwnership(const void* p) {$/;"	f
MallocExtension_Ownership	.\gperftools\malloc_extension_c.h	/^} MallocExtension_Ownership;$/;"	t	typeref:enum:__anon19
MallocExtension_kNotOwned	.\gperftools\malloc_extension_c.h	/^  MallocExtension_kNotOwned$/;"	e	enum:__anon19
MallocExtension_kOwned	.\gperftools\malloc_extension_c.h	/^  MallocExtension_kOwned,$/;"	e	enum:__anon19
MallocExtension_kUnknownOwnership	.\gperftools\malloc_extension_c.h	/^  MallocExtension_kUnknownOwnership = 0,$/;"	e	enum:__anon19
MallocHook	.\gperftools\malloc_hook.h	/^class PERFTOOLS_DLL_DECL MallocHook {$/;"	c
MallocHook_AddDeleteHook	.\malloc_hook.cc	/^int MallocHook_AddDeleteHook(MallocHook_DeleteHook hook) {$/;"	f
MallocHook_AddMmapHook	.\malloc_hook.cc	/^int MallocHook_AddMmapHook(MallocHook_MmapHook hook) {$/;"	f
MallocHook_AddMremapHook	.\malloc_hook.cc	/^int MallocHook_AddMremapHook(MallocHook_MremapHook hook) {$/;"	f
MallocHook_AddMunmapHook	.\malloc_hook.cc	/^int MallocHook_AddMunmapHook(MallocHook_MunmapHook hook) {$/;"	f
MallocHook_AddNewHook	.\malloc_hook.cc	/^int MallocHook_AddNewHook(MallocHook_NewHook hook) {$/;"	f
MallocHook_AddPreMmapHook	.\malloc_hook.cc	/^int MallocHook_AddPreMmapHook(MallocHook_PreMmapHook hook) {$/;"	f
MallocHook_AddPreSbrkHook	.\malloc_hook.cc	/^int MallocHook_AddPreSbrkHook(MallocHook_PreSbrkHook hook) {$/;"	f
MallocHook_AddSbrkHook	.\malloc_hook.cc	/^int MallocHook_AddSbrkHook(MallocHook_SbrkHook hook) {$/;"	f
MallocHook_DeleteHook	.\gperftools\malloc_hook_c.h	/^typedef void (*MallocHook_DeleteHook)(const void* ptr);$/;"	t
MallocHook_GetCallerStackTrace	.\malloc_hook.cc	/^extern "C" int MallocHook_GetCallerStackTrace(void** result, int max_depth,$/;"	f
MallocHook_InitAtFirstAllocation_HeapLeakChecker	.\heap-checker.cc	/^extern "C" void MallocHook_InitAtFirstAllocation_HeapLeakChecker() {$/;"	f
MallocHook_InitAtFirstAllocation_HeapLeakChecker	.\malloc_hook.cc	/^extern "C" void MallocHook_InitAtFirstAllocation_HeapLeakChecker() {$/;"	f
MallocHook_MmapHook	.\gperftools\malloc_hook_c.h	/^typedef void (*MallocHook_MmapHook)(const void* result,$/;"	t
MallocHook_MmapReplacement	.\gperftools\malloc_hook_c.h	/^typedef int (*MallocHook_MmapReplacement)(const void* start,$/;"	t
MallocHook_MremapHook	.\gperftools\malloc_hook_c.h	/^typedef void (*MallocHook_MremapHook)(const void* result,$/;"	t
MallocHook_MunmapHook	.\gperftools\malloc_hook_c.h	/^typedef void (*MallocHook_MunmapHook)(const void* ptr, size_t size);$/;"	t
MallocHook_MunmapReplacement	.\gperftools\malloc_hook_c.h	/^typedef int (*MallocHook_MunmapReplacement)(const void* ptr,$/;"	t
MallocHook_NewHook	.\gperftools\malloc_hook_c.h	/^typedef void (*MallocHook_NewHook)(const void* ptr, size_t size);$/;"	t
MallocHook_PreMmapHook	.\gperftools\malloc_hook_c.h	/^typedef void (*MallocHook_PreMmapHook)(const void *start,$/;"	t
MallocHook_PreSbrkHook	.\gperftools\malloc_hook_c.h	/^typedef void (*MallocHook_PreSbrkHook)(ptrdiff_t increment);$/;"	t
MallocHook_RemoveDeleteHook	.\malloc_hook.cc	/^int MallocHook_RemoveDeleteHook(MallocHook_DeleteHook hook) {$/;"	f
MallocHook_RemoveMmapHook	.\malloc_hook.cc	/^int MallocHook_RemoveMmapHook(MallocHook_MmapHook hook) {$/;"	f
MallocHook_RemoveMmapReplacement	.\malloc_hook.cc	/^int MallocHook_RemoveMmapReplacement(MallocHook_MmapReplacement hook) {$/;"	f
MallocHook_RemoveMremapHook	.\malloc_hook.cc	/^int MallocHook_RemoveMremapHook(MallocHook_MremapHook hook) {$/;"	f
MallocHook_RemoveMunmapHook	.\malloc_hook.cc	/^int MallocHook_RemoveMunmapHook(MallocHook_MunmapHook hook) {$/;"	f
MallocHook_RemoveMunmapReplacement	.\malloc_hook.cc	/^int MallocHook_RemoveMunmapReplacement(MallocHook_MunmapReplacement hook) {$/;"	f
MallocHook_RemoveNewHook	.\malloc_hook.cc	/^int MallocHook_RemoveNewHook(MallocHook_NewHook hook) {$/;"	f
MallocHook_RemovePreMmapHook	.\malloc_hook.cc	/^int MallocHook_RemovePreMmapHook(MallocHook_PreMmapHook hook) {$/;"	f
MallocHook_RemovePreSbrkHook	.\malloc_hook.cc	/^int MallocHook_RemovePreSbrkHook(MallocHook_PreSbrkHook hook) {$/;"	f
MallocHook_RemoveSbrkHook	.\malloc_hook.cc	/^int MallocHook_RemoveSbrkHook(MallocHook_SbrkHook hook) {$/;"	f
MallocHook_SbrkHook	.\gperftools\malloc_hook_c.h	/^typedef void (*MallocHook_SbrkHook)(const void* result, ptrdiff_t increment);$/;"	t
MallocHook_SetDeleteHook	.\malloc_hook.cc	/^MallocHook_DeleteHook MallocHook_SetDeleteHook(MallocHook_DeleteHook hook) {$/;"	f
MallocHook_SetMmapHook	.\malloc_hook.cc	/^MallocHook_MmapHook MallocHook_SetMmapHook(MallocHook_MmapHook hook) {$/;"	f
MallocHook_SetMmapReplacement	.\malloc_hook.cc	/^int MallocHook_SetMmapReplacement(MallocHook_MmapReplacement hook) {$/;"	f
MallocHook_SetMremapHook	.\malloc_hook.cc	/^MallocHook_MremapHook MallocHook_SetMremapHook(MallocHook_MremapHook hook) {$/;"	f
MallocHook_SetMunmapHook	.\malloc_hook.cc	/^MallocHook_MunmapHook MallocHook_SetMunmapHook(MallocHook_MunmapHook hook) {$/;"	f
MallocHook_SetMunmapReplacement	.\malloc_hook.cc	/^int MallocHook_SetMunmapReplacement(MallocHook_MunmapReplacement hook) {$/;"	f
MallocHook_SetNewHook	.\malloc_hook.cc	/^MallocHook_NewHook MallocHook_SetNewHook(MallocHook_NewHook hook) {$/;"	f
MallocHook_SetPreMmapHook	.\malloc_hook.cc	/^MallocHook_PreMmapHook MallocHook_SetPreMmapHook(MallocHook_PreMmapHook hook) {$/;"	f
MallocHook_SetPreSbrkHook	.\malloc_hook.cc	/^MallocHook_PreSbrkHook MallocHook_SetPreSbrkHook(MallocHook_PreSbrkHook hook) {$/;"	f
MallocHook_SetSbrkHook	.\malloc_hook.cc	/^MallocHook_SbrkHook MallocHook_SetSbrkHook(MallocHook_SbrkHook hook) {$/;"	f
MallocMemoryStats	.\debugallocation.cc	/^  virtual bool MallocMemoryStats(int* blocks, size_t* total,$/;"	f	class:DebugMallocImplementation
MallocMemoryStats	.\malloc_extension.cc	/^bool MallocExtension::MallocMemoryStats(int* blocks, size_t* total,$/;"	f	class:MallocExtension
MallocRange	.\gperftools\malloc_extension.h	/^struct MallocRange {$/;"	s	namespace:base
Mallocer	.\tests\heap-checker_unittest.cc	/^static void* Mallocer(uintptr_t* addr_after_malloc_call) {$/;"	f	file:
MapArgsAllocIterator	.\heap-profile-table.h	/^  static void MapArgsAllocIterator(const void* ptr, AllocValue* v,$/;"	f	class:HeapProfileTable
MapObjectToSpan	.\central_freelist.cc	/^Span* MapObjectToSpan(void* object) {$/;"	f	namespace:tcmalloc
MapPages	.\base\low_level_alloc.cc	/^void *DefaultPagesAllocator::MapPages(int32 flags, size_t size) {$/;"	f	class:DefaultPagesAllocator
MapPages	.\emergency_malloc.cc	/^    void *MapPages(int32 flags, size_t size) {$/;"	f	class:tcmalloc::EmergencyArenaPagesAllocator	file:
MapSelector	.\page_heap.h	/^template <> class MapSelector<32> {$/;"	c	namespace:tcmalloc
MapSelector	.\page_heap.h	/^template <int BITS> class MapSelector {$/;"	c	namespace:tcmalloc
MapSize	.\memory_region_map.h	/^  static int64 MapSize() { return map_size_; }$/;"	f	class:MemoryRegionMap
MarkAsIgnored	.\heap-profile-table.cc	/^void HeapProfileTable::MarkAsIgnored(const void* ptr) {$/;"	f	class:HeapProfileTable
MarkAsLive	.\heap-profile-table.cc	/^bool HeapProfileTable::MarkAsLive(const void* ptr) {$/;"	f	class:HeapProfileTable
MarkThreadBusy	.\malloc_extension.cc	/^void MallocExtension::MarkThreadBusy() {$/;"	f	class:MallocExtension
MarkThreadBusy	.\tcmalloc.cc	/^void TCMallocImplementation::MarkThreadBusy() {$/;"	f	class:TCMallocImplementation
MarkThreadIdle	.\malloc_extension.cc	/^void MallocExtension::MarkThreadIdle() {$/;"	f	class:MallocExtension
MarkThreadIdle	.\tcmalloc.cc	/^  virtual void MarkThreadIdle() {$/;"	f	class:TCMallocImplementation
MarkThreadTemporarilyIdle	.\malloc_extension.cc	/^void MallocExtension::MarkThreadTemporarilyIdle() {$/;"	f	class:MallocExtension
MarkThreadTemporarilyIdle	.\tcmalloc.cc	/^  virtual void MarkThreadTemporarilyIdle() {$/;"	f	class:TCMallocImplementation
MayMergeSpans	.\page_heap.cc	/^bool PageHeap::MayMergeSpans(Span *span, Span *other) {$/;"	f	class:tcmalloc::PageHeap
MaybeDumpProfileLocked	.\heap-profiler.cc	/^static void MaybeDumpProfileLocked() {$/;"	f	file:
MaybePrint	.\windows\nm-pdb.c	/^static void MaybePrint(const char* var, const char* description) {$/;"	f	file:
MaybeSizeClass	.\common.h	/^  inline bool MaybeSizeClass(size_t size, size_t *size_class) {$/;"	f	class:tcmalloc::SizeMap
Memalign	.\tests\tcmalloc_unittest.cc	/^static inline void* Memalign(size_t align, size_t size) {$/;"	f	file:
MemoryAligner	.\base\basictypes.h	/^union MemoryAligner {$/;"	u
MemoryBarrier	.\base\atomicops-internals-arm-generic.h	/^inline void MemoryBarrier() {$/;"	f	namespace:base::subtle
MemoryBarrier	.\base\atomicops-internals-arm-v6plus.h	/^inline void MemoryBarrier() {$/;"	f	namespace:base::subtle
MemoryBarrier	.\base\atomicops-internals-gcc.h	/^inline void MemoryBarrier() {$/;"	f	namespace:base::subtle
MemoryBarrier	.\base\atomicops-internals-linuxppc.h	/^inline void MemoryBarrier() {$/;"	f	namespace:base::subtle
MemoryBarrier	.\base\atomicops-internals-macosx.h	/^inline void MemoryBarrier() {$/;"	f	namespace:base::subtle
MemoryBarrier	.\base\atomicops-internals-mips.h	/^inline void MemoryBarrier()$/;"	f	namespace:base::subtle
MemoryBarrier	.\base\atomicops-internals-windows.h	/^inline void MemoryBarrier() {$/;"	f	namespace:base::subtle
MemoryBarrier	.\base\atomicops-internals-windows.h	/^inline void MemoryBarrier() {$/;"	f
MemoryBarrier	.\base\atomicops-internals-x86.h	/^inline void MemoryBarrier() {$/;"	f	namespace:base::subtle
MemoryRegionMap	.\memory_region_map.h	/^class MemoryRegionMap {$/;"	c
MemoryStats	.\debugallocation.cc	/^  static bool MemoryStats(int* blocks, size_t* total,$/;"	f	class:MallocBlock
MergeIntoFreeList	.\page_heap.cc	/^void PageHeap::MergeIntoFreeList(Span* span) {$/;"	f	class:tcmalloc::PageHeap
MetaDataAlloc	.\common.cc	/^void* MetaDataAlloc(size_t bytes) {$/;"	f	namespace:tcmalloc
MinSizeForSlowPath	.\thread_cache.h	/^inline size_t ThreadCache::MinSizeForSlowPath() {$/;"	f	class:tcmalloc::ThreadCache
MiniDisassembler	.\windows\mini_disassembler.cc	/^MiniDisassembler::MiniDisassembler()$/;"	f	class:sidestep::MiniDisassembler
MiniDisassembler	.\windows\mini_disassembler.cc	/^MiniDisassembler::MiniDisassembler(bool operand_default_is_32_bits,$/;"	f	class:sidestep::MiniDisassembler
MiniDisassembler	.\windows\mini_disassembler.h	/^class PERFTOOLS_DLL_DECL MiniDisassembler {$/;"	c	namespace:sidestep
MmapHook	.\gperftools\malloc_hook.h	/^  typedef MallocHook_MmapHook MmapHook;$/;"	t	class:MallocHook
MmapHook	.\heap-profiler.cc	/^static void MmapHook(const void* result, const void* start, size_t size,$/;"	f	file:
MmapHook	.\memory_region_map.cc	/^void MemoryRegionMap::MmapHook(const void* result,$/;"	f	class:MemoryRegionMap
MmapReplacement	.\gperftools\malloc_hook.h	/^  typedef MallocHook_MmapReplacement MmapReplacement;$/;"	t	class:MallocHook
MmapReplacement	.\tests\malloc_hook_test.cc	/^int MmapReplacement(const void* start,$/;"	f	namespace:__anon35
MmapSysAllocator	.\system-alloc.cc	/^  MmapSysAllocator() : SysAllocator() {$/;"	f	class:MmapSysAllocator
MmapSysAllocator	.\system-alloc.cc	/^class MmapSysAllocator : public SysAllocator {$/;"	c	file:
Mmapper	.\tests\heap-checker_unittest.cc	/^static void* Mmapper(uintptr_t* addr_after_mmap_call) {$/;"	f	file:
ModrmEntry	.\windows\mini_disassembler_types.h	/^struct ModrmEntry {$/;"	s	namespace:sidestep
Module32First	.\base\sysinfo.cc	72;"	d	file:
Module32Next	.\base\sysinfo.cc	73;"	d	file:
ModuleEntryCopy	.\windows\patch_functions.cc	/^  ModuleEntryCopy() {$/;"	f	struct:__anon52::ModuleEntryCopy
ModuleEntryCopy	.\windows\patch_functions.cc	/^  ModuleEntryCopy(const MODULEINFO& mi) {$/;"	f	struct:__anon52::ModuleEntryCopy
ModuleEntryCopy	.\windows\patch_functions.cc	/^struct ModuleEntryCopy {$/;"	s	namespace:__anon52	file:
MremapHook	.\gperftools\malloc_hook.h	/^  typedef MallocHook_MremapHook MremapHook;$/;"	t	class:MallocHook
MremapHook	.\heap-profiler.cc	/^static void MremapHook(const void* result, const void* old_addr,$/;"	f	file:
MremapHook	.\memory_region_map.cc	/^void MemoryRegionMap::MremapHook(const void* result,$/;"	f	class:MemoryRegionMap
MultipleIdleCalls	.\tests\markidle_unittest.cc	/^static void MultipleIdleCalls() {$/;"	f	file:
MultipleIdleNonIdlePhases	.\tests\markidle_unittest.cc	/^static void MultipleIdleNonIdlePhases() {$/;"	f	file:
MultithreadedTestThread	.\tests\malloc_hook_test.cc	/^void MultithreadedTestThread(TestHookList* list, int shift,$/;"	f	namespace:__anon35
MultithreadedTestThreadRunner	.\tests\malloc_hook_test.cc	/^void MultithreadedTestThreadRunner(int thread_num) {$/;"	f	namespace:__anon35
MunmapHook	.\gperftools\malloc_hook.h	/^  typedef MallocHook_MunmapHook MunmapHook;$/;"	t	class:MallocHook
MunmapHook	.\heap-profiler.cc	/^static void MunmapHook(const void* ptr, size_t size) {$/;"	f	file:
MunmapHook	.\memory_region_map.cc	/^void MemoryRegionMap::MunmapHook(const void* ptr, size_t size) {$/;"	f	class:MemoryRegionMap
MunmapReplacement	.\gperftools\malloc_hook.h	/^  typedef MallocHook_MunmapReplacement MunmapReplacement;$/;"	t	class:MallocHook
MunmapReplacement	.\tests\malloc_hook_test.cc	/^int MunmapReplacement(const void* ptr, size_t size, int* result) {$/;"	f	namespace:__anon35
Mutex	.\base\simple_mutex.h	/^  Mutex(Mutex* \/*ignored*\/) {}$/;"	f	class:MUTEX_NAMESPACE::Mutex
Mutex	.\base\simple_mutex.h	/^Mutex::Mutex() : destroy_(true) {$/;"	f	class:MUTEX_NAMESPACE::Mutex
Mutex	.\base\simple_mutex.h	/^Mutex::Mutex() : mutex_(0) { }$/;"	f	class:MUTEX_NAMESPACE::Mutex
Mutex	.\base\simple_mutex.h	/^Mutex::Mutex(LinkerInitialized) : destroy_(false) {$/;"	f	class:MUTEX_NAMESPACE::Mutex
Mutex	.\base\simple_mutex.h	/^Mutex::Mutex(Mutex::LinkerInitialized) : destroy_(false) {$/;"	f	class:MUTEX_NAMESPACE::Mutex
Mutex	.\base\simple_mutex.h	/^Mutex::Mutex(Mutex::LinkerInitialized) : mutex_(0) { }$/;"	f	class:MUTEX_NAMESPACE::Mutex
Mutex	.\base\simple_mutex.h	/^class Mutex {$/;"	c	namespace:MUTEX_NAMESPACE
MutexLock	.\base\simple_mutex.h	/^  explicit MutexLock(Mutex *mu) : mu_(mu) { mu_->Lock(); }$/;"	f	class:MUTEX_NAMESPACE::MutexLock
MutexLock	.\base\simple_mutex.h	/^class MutexLock {$/;"	c	namespace:MUTEX_NAMESPACE
MutexLock	.\base\simple_mutex.h	322;"	d
MutexType	.\base\simple_mutex.h	/^  typedef CRITICAL_SECTION MutexType;$/;"	t
MutexType	.\base\simple_mutex.h	/^  typedef int MutexType;      \/\/ to keep a lock-count$/;"	t
MutexType	.\base\simple_mutex.h	/^  typedef pthread_mutex_t MutexType;$/;"	t
MutexType	.\base\simple_mutex.h	/^  typedef pthread_rwlock_t MutexType;$/;"	t
MyAllocator	.\memory_region_map.h	/^  struct MyAllocator {$/;"	s	class:MemoryRegionMap
NOMINMAX	.\base\logging.h	245;"	d
NOMINMAX	.\windows\port.cc	39;"	d	file:
NO_HEAP_CHECK	.\windows\config.h	315;"	d
NO_INTR	.\base\linuxthreads.cc	145;"	d	file:
NO_INTR	.\base\logging.cc	88;"	d	file:
NO_INTR	.\base\sysinfo.cc	84;"	d	file:
NO_INTR	.\profiledata.cc	139;"	d	file:
NO_INTR	.\tests\profiledata_unittest.cc	70;"	d	file:
NO_LEAKS	.\tests\heap-checker_unittest.cc	/^enum CheckType { SAME_HEAP, NO_LEAKS };$/;"	e	enum:CheckType	file:
NO_MINUS_C_MINUS_O	.\windows\config.h	227;"	d
NO_SHARED_LIBS_IN_PROC_MAPS	.\gperftools\heap-checker.h	/^    NO_SHARED_LIBS_IN_PROC_MAPS$/;"	e	enum:HeapLeakChecker::ProcMapsResult
NO_THREAD_SAFETY_ANALYSIS	.\base\thread_annotations.h	131;"	d
NO_THREAD_SAFETY_ANALYSIS	.\profile-handler.cc	/^      NO_THREAD_SAFETY_ANALYSIS;$/;"	m	class:ProfileHandler	file:
NUM_BITS	.\tests\atomicops_unittest.cc	42;"	d	file:
NVALGRIND	.\third_party\valgrind.h	116;"	d
N_ONES_	.\packed-cache-inl.h	125;"	d
N_ONES_	.\packed-cache-inl.h	237;"	d
Nesting	.\tests\heap-checker_unittest.cc	/^  Nesting() : i0(this), i1(this), i2(this), i3(this) {}$/;"	f	struct:Nesting
Nesting	.\tests\heap-checker_unittest.cc	/^struct Nesting {$/;"	s	file:
New	.\addressmap-inl.h	/^  template <class T> T* New(int num) {$/;"	f	class:AddressMap
New	.\page_heap.cc	/^Span* PageHeap::New(Length n) {$/;"	f	class:tcmalloc::PageHeap
New	.\page_heap_allocator.h	/^  T* New() {$/;"	f	class:tcmalloc::PageHeapAllocator
NewArena	.\base\low_level_alloc.cc	/^LowLevelAlloc::Arena *LowLevelAlloc::NewArena(int32 flags,$/;"	f	class:LowLevelAlloc
NewArenaWithCustomAlloc	.\base\low_level_alloc.cc	/^LowLevelAlloc::Arena *LowLevelAlloc::NewArenaWithCustomAlloc(int32 flags,$/;"	f	class:LowLevelAlloc
NewCallback	.\tests\heap-checker_unittest.cc	/^inline Callback0* NewCallback(void (*function)()) {$/;"	f
NewCallback	.\tests\heap-checker_unittest.cc	/^inline Callback1<P1>* NewCallback(void (*function)(P1), P1 p1) {$/;"	f
NewCallback	.\tests\heap-checker_unittest.cc	/^inline Callback2<P1,P2>* NewCallback(void (*function)(P1,P2), P1 p1, P2 p2) {$/;"	f
NewHeap	.\thread_cache.cc	/^ThreadCache* ThreadCache::NewHeap(pthread_t tid) {$/;"	f	class:tcmalloc::ThreadCache
NewHook	.\gperftools\malloc_hook.h	/^  typedef MallocHook_NewHook NewHook;$/;"	t	class:MallocHook
NewHook	.\heap-checker.cc	/^static void NewHook(const void* ptr, size_t size) {$/;"	f	file:
NewHook	.\heap-profiler.cc	/^void NewHook(const void* ptr, size_t size) {$/;"	f
NewNode	.\pagemap.h	/^  Node* NewNode() {$/;"	f	class:TCMalloc_PageMap3
NewSpan	.\span.cc	/^Span* NewSpan(PageID p, Length len) {$/;"	f	namespace:tcmalloc
Next	.\base\low_level_alloc.cc	/^static AllocList *Next(int i, AllocList *prev, LowLevelAlloc::Arena *arena) {$/;"	f	file:
Next	.\base\sysinfo.cc	/^bool ProcMapsIterator::Next(uint64 *start, uint64 *end, char **flags,$/;"	f	class:ProcMapsIterator
Next	.\pagemap.h	/^  void* Next(Number k) const {$/;"	f	class:TCMalloc_PageMap1
Next	.\pagemap.h	/^  void* Next(Number k) const {$/;"	f	class:TCMalloc_PageMap2
Next	.\pagemap.h	/^  void* Next(Number k) const {$/;"	f	class:TCMalloc_PageMap3
Next	.\tests\tcmalloc_unittest.cc	/^    int32 Next() {$/;"	f	class:testing::TesterThread::ACMRandom
Next	.\thread_cache.h	/^    void* Next() {$/;"	f	class:tcmalloc::ThreadCache::FreeList
NextExt	.\base\sysinfo.cc	/^bool ProcMapsIterator::NextExt(uint64 *start, uint64 *end, char **flags,$/;"	f	class:ProcMapsIterator
NextExtMachHelper	.\base\sysinfo.cc	/^static bool NextExtMachHelper(const mach_header* hdr,$/;"	f	file:
NextRandom	.\sampler.h	/^inline uint64_t Sampler::NextRandom(uint64_t rnd) {$/;"	f	class:tcmalloc::Sampler
NextSize	.\tests\memalign_unittest.cc	/^static int NextSize(int size) {$/;"	f	file:
NextSize	.\tests\realloc_unittest.cc	/^static int NextSize(int size) {$/;"	f	file:
NextStackFrame	.\stacktrace_arm-inl.h	/^static void **NextStackFrame(void **old_sp) {$/;"	f
NextStackFrame	.\stacktrace_powerpc-darwin-inl.h	/^static void **NextStackFrame(void **old_sp) {$/;"	f
NextStackFrame	.\stacktrace_powerpc-inl.h	/^static layout_ppc *NextStackFrame(layout_ppc *current) {$/;"	f
NextStackFrame	.\stacktrace_powerpc-linux-inl.h	/^static layout_ppc *NextStackFrame(layout_ppc *current) {$/;"	f
NextStackFrame	.\stacktrace_x86-inl.h	/^static void **NextStackFrame(void **old_sp, const void *uc) {$/;"	f
NoBarrier_AtomicExchange	.\base\atomicops-internals-arm-generic.h	/^inline Atomic32 NoBarrier_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
NoBarrier_AtomicExchange	.\base\atomicops-internals-arm-generic.h	/^inline Atomic64 NoBarrier_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
NoBarrier_AtomicExchange	.\base\atomicops-internals-arm-v6plus.h	/^inline Atomic32 NoBarrier_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
NoBarrier_AtomicExchange	.\base\atomicops-internals-arm-v6plus.h	/^inline Atomic64 NoBarrier_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
NoBarrier_AtomicExchange	.\base\atomicops-internals-gcc.h	/^inline Atomic32 NoBarrier_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
NoBarrier_AtomicExchange	.\base\atomicops-internals-gcc.h	/^inline Atomic64 NoBarrier_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
NoBarrier_AtomicExchange	.\base\atomicops-internals-linuxppc.h	/^inline Atomic32 NoBarrier_AtomicExchange(volatile Atomic32 *ptr,$/;"	f	namespace:base::subtle
NoBarrier_AtomicExchange	.\base\atomicops-internals-linuxppc.h	/^inline Atomic64 NoBarrier_AtomicExchange(volatile Atomic64 *ptr,$/;"	f	namespace:base::subtle
NoBarrier_AtomicExchange	.\base\atomicops-internals-macosx.h	/^inline Atomic32 NoBarrier_AtomicExchange(volatile Atomic32 *ptr,$/;"	f	namespace:base::subtle
NoBarrier_AtomicExchange	.\base\atomicops-internals-macosx.h	/^inline Atomic64 NoBarrier_AtomicExchange(volatile Atomic64 *ptr,$/;"	f	namespace:base::subtle
NoBarrier_AtomicExchange	.\base\atomicops-internals-mips.h	/^inline Atomic32 NoBarrier_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
NoBarrier_AtomicExchange	.\base\atomicops-internals-mips.h	/^inline Atomic64 NoBarrier_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
NoBarrier_AtomicExchange	.\base\atomicops-internals-windows.h	/^inline Atomic32 NoBarrier_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
NoBarrier_AtomicExchange	.\base\atomicops-internals-windows.h	/^inline Atomic64 NoBarrier_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
NoBarrier_AtomicExchange	.\base\atomicops-internals-x86.h	/^inline Atomic32 NoBarrier_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
NoBarrier_AtomicExchange	.\base\atomicops-internals-x86.h	/^inline Atomic64 NoBarrier_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
NoBarrier_AtomicExchange	.\base\atomicops.h	/^inline AtomicWord NoBarrier_AtomicExchange(volatile AtomicWord* ptr,$/;"	f	namespace:base::subtle
NoBarrier_CompareAndSwap	.\base\atomicops-internals-arm-generic.h	/^inline Atomic32 NoBarrier_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
NoBarrier_CompareAndSwap	.\base\atomicops-internals-arm-generic.h	/^inline Atomic64 NoBarrier_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
NoBarrier_CompareAndSwap	.\base\atomicops-internals-arm-v6plus.h	/^inline Atomic32 NoBarrier_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
NoBarrier_CompareAndSwap	.\base\atomicops-internals-arm-v6plus.h	/^inline Atomic64 NoBarrier_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
NoBarrier_CompareAndSwap	.\base\atomicops-internals-gcc.h	/^inline Atomic32 NoBarrier_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
NoBarrier_CompareAndSwap	.\base\atomicops-internals-gcc.h	/^inline Atomic64 NoBarrier_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
NoBarrier_CompareAndSwap	.\base\atomicops-internals-linuxppc.h	/^inline Atomic32 NoBarrier_CompareAndSwap(volatile Atomic32 *ptr,$/;"	f	namespace:base::subtle
NoBarrier_CompareAndSwap	.\base\atomicops-internals-linuxppc.h	/^inline Atomic64 NoBarrier_CompareAndSwap(volatile Atomic64 *ptr,$/;"	f	namespace:base::subtle
NoBarrier_CompareAndSwap	.\base\atomicops-internals-macosx.h	/^inline Atomic32 NoBarrier_CompareAndSwap(volatile Atomic32 *ptr,$/;"	f	namespace:base::subtle
NoBarrier_CompareAndSwap	.\base\atomicops-internals-macosx.h	/^inline Atomic64 NoBarrier_CompareAndSwap(volatile Atomic64 *ptr,$/;"	f	namespace:base::subtle
NoBarrier_CompareAndSwap	.\base\atomicops-internals-mips.h	/^inline Atomic32 NoBarrier_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
NoBarrier_CompareAndSwap	.\base\atomicops-internals-mips.h	/^inline Atomic64 NoBarrier_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
NoBarrier_CompareAndSwap	.\base\atomicops-internals-windows.h	/^inline Atomic32 NoBarrier_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
NoBarrier_CompareAndSwap	.\base\atomicops-internals-windows.h	/^inline Atomic64 NoBarrier_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
NoBarrier_CompareAndSwap	.\base\atomicops-internals-x86.h	/^inline Atomic32 NoBarrier_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
NoBarrier_CompareAndSwap	.\base\atomicops-internals-x86.h	/^inline Atomic64 NoBarrier_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
NoBarrier_CompareAndSwap	.\base\atomicops.h	/^inline AtomicWord NoBarrier_CompareAndSwap(volatile AtomicWord* ptr,$/;"	f	namespace:base::subtle
NoBarrier_Load	.\base\atomicops-internals-arm-generic.h	/^inline Atomic32 NoBarrier_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle
NoBarrier_Load	.\base\atomicops-internals-arm-generic.h	/^inline Atomic64 NoBarrier_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle
NoBarrier_Load	.\base\atomicops-internals-arm-v6plus.h	/^inline Atomic32 NoBarrier_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle
NoBarrier_Load	.\base\atomicops-internals-arm-v6plus.h	/^inline Atomic64 NoBarrier_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle
NoBarrier_Load	.\base\atomicops-internals-gcc.h	/^inline Atomic32 NoBarrier_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle
NoBarrier_Load	.\base\atomicops-internals-gcc.h	/^inline Atomic64 NoBarrier_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle
NoBarrier_Load	.\base\atomicops-internals-linuxppc.h	/^inline Atomic32 NoBarrier_Load(volatile const Atomic32 *ptr) {$/;"	f	namespace:base::subtle
NoBarrier_Load	.\base\atomicops-internals-linuxppc.h	/^inline Atomic64 NoBarrier_Load(volatile const Atomic64 *ptr) {$/;"	f	namespace:base::subtle
NoBarrier_Load	.\base\atomicops-internals-macosx.h	/^inline Atomic32 NoBarrier_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle
NoBarrier_Load	.\base\atomicops-internals-macosx.h	/^inline Atomic64 NoBarrier_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle
NoBarrier_Load	.\base\atomicops-internals-mips.h	/^inline Atomic32 NoBarrier_Load(volatile const Atomic32* ptr)$/;"	f	namespace:base::subtle
NoBarrier_Load	.\base\atomicops-internals-mips.h	/^inline Atomic64 NoBarrier_Load(volatile const Atomic64* ptr)$/;"	f	namespace:base::subtle
NoBarrier_Load	.\base\atomicops-internals-windows.h	/^inline Atomic32 NoBarrier_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle
NoBarrier_Load	.\base\atomicops-internals-windows.h	/^inline Atomic64 NoBarrier_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle
NoBarrier_Load	.\base\atomicops-internals-windows.h	/^inline Atomic64 NoBarrier_Load(volatile const Atomic64* ptrValue)$/;"	f	namespace:base::subtle
NoBarrier_Load	.\base\atomicops-internals-x86.h	/^inline Atomic32 NoBarrier_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle
NoBarrier_Load	.\base\atomicops-internals-x86.h	/^inline Atomic64 NoBarrier_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle
NoBarrier_Load	.\base\atomicops.h	/^inline AtomicWord NoBarrier_Load(volatile const AtomicWord *ptr) {$/;"	f	namespace:base::subtle
NoBarrier_Store	.\base\atomicops-internals-arm-generic.h	/^inline void NoBarrier_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle
NoBarrier_Store	.\base\atomicops-internals-arm-generic.h	/^inline void NoBarrier_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle
NoBarrier_Store	.\base\atomicops-internals-arm-v6plus.h	/^inline void NoBarrier_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle
NoBarrier_Store	.\base\atomicops-internals-arm-v6plus.h	/^inline void NoBarrier_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle
NoBarrier_Store	.\base\atomicops-internals-gcc.h	/^inline void NoBarrier_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle
NoBarrier_Store	.\base\atomicops-internals-gcc.h	/^inline void NoBarrier_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle
NoBarrier_Store	.\base\atomicops-internals-linuxppc.h	/^inline void NoBarrier_Store(volatile Atomic32 *ptr, Atomic32 value) {$/;"	f	namespace:base::subtle
NoBarrier_Store	.\base\atomicops-internals-linuxppc.h	/^inline void NoBarrier_Store(volatile Atomic64 *ptr, Atomic64 value) {$/;"	f	namespace:base::subtle
NoBarrier_Store	.\base\atomicops-internals-macosx.h	/^inline void NoBarrier_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle
NoBarrier_Store	.\base\atomicops-internals-macosx.h	/^inline void NoBarrier_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle
NoBarrier_Store	.\base\atomicops-internals-mips.h	/^inline void NoBarrier_Store(volatile Atomic32* ptr, Atomic32 value)$/;"	f	namespace:base::subtle
NoBarrier_Store	.\base\atomicops-internals-mips.h	/^inline void NoBarrier_Store(volatile Atomic64* ptr, Atomic64 value)$/;"	f	namespace:base::subtle
NoBarrier_Store	.\base\atomicops-internals-windows.h	/^inline void NoBarrier_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle
NoBarrier_Store	.\base\atomicops-internals-windows.h	/^inline void NoBarrier_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle
NoBarrier_Store	.\base\atomicops-internals-windows.h	/^inline void NoBarrier_Store(volatile Atomic64* ptrValue, Atomic64 value)$/;"	f	namespace:base::subtle
NoBarrier_Store	.\base\atomicops-internals-x86.h	/^inline void NoBarrier_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle
NoBarrier_Store	.\base\atomicops-internals-x86.h	/^inline void NoBarrier_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle
NoBarrier_Store	.\base\atomicops.h	/^inline void NoBarrier_Store(volatile AtomicWord *ptr, AtomicWord value) {$/;"	f	namespace:base::subtle
NoGlobalLeaks	.\heap-checker.cc	/^bool HeapLeakChecker::NoGlobalLeaks() {$/;"	f	class:HeapLeakChecker
NoGlobalLeaksMaybeSymbolize	.\heap-checker.cc	/^bool HeapLeakChecker::NoGlobalLeaksMaybeSymbolize($/;"	f	class:HeapLeakChecker
NoLeaks	.\gperftools\heap-checker.h	/^  bool NoLeaks() { return DoNoLeaks(DO_NOT_SYMBOLIZE); }$/;"	f	class:HeapLeakChecker
Node	.\pagemap.h	/^  struct Node {$/;"	s	class:TCMalloc_PageMap3
NonLiveSnapshot	.\heap-profile-table.cc	/^HeapProfileTable::Snapshot* HeapProfileTable::NonLiveSnapshot($/;"	f	class:HeapProfileTable
NotImplementedFatalError	.\base\atomicops-internals-arm-generic.h	/^inline void NotImplementedFatalError(const char *function_name) {$/;"	f	namespace:base::subtle
NotImplementedFatalError	.\base\atomicops-internals-arm-v6plus.h	/^inline void NotImplementedFatalError(const char *function_name) {$/;"	f	namespace:base::subtle
NotImplementedFatalError	.\base\atomicops-internals-windows.h	/^inline void NotImplementedFatalError(const char *function_name) {$/;"	f	namespace:base::subtle
NullThread	.\tests\profile-handler_unittest.cc	/^class NullThread : public Thread {$/;"	c	namespace:__anon37	file:
NumMoveSize	.\common.cc	/^int SizeMap::NumMoveSize(size_t size) {$/;"	f	class:tcmalloc::SizeMap
Number	.\addressmap-inl.h	/^  typedef uintptr_t Number;$/;"	t	class:AddressMap
Number	.\pagemap.h	/^  typedef uintptr_t Number;$/;"	t	class:TCMalloc_PageMap1
Number	.\pagemap.h	/^  typedef uintptr_t Number;$/;"	t	class:TCMalloc_PageMap2
Number	.\pagemap.h	/^  typedef uintptr_t Number;$/;"	t	class:TCMalloc_PageMap3
Number	.\tests\memalign_unittest.cc	/^static uintptr_t Number(void* p) {$/;"	f	file:
OFFSETOF_MEMBER	.\base\basictypes.h	200;"	d
ON_NORMAL_FREELIST	.\span.h	/^  enum { IN_USE, ON_NORMAL_FREELIST, ON_RETURNED_FREELIST };$/;"	e	enum:tcmalloc::Span::__anon26
ON_RETURNED_FREELIST	.\span.h	/^  enum { IN_USE, ON_NORMAL_FREELIST, ON_RETURNED_FREELIST };$/;"	e	enum:tcmalloc::Span::__anon26
OSAtomicAdd32	.\base\atomicops-internals-linuxppc.h	/^static inline Atomic32 OSAtomicAdd32(Atomic32 amount, Atomic32 *value) {$/;"	f	namespace:base::subtle
OSAtomicAdd32Barrier	.\base\atomicops-internals-linuxppc.h	/^static inline Atomic32 OSAtomicAdd32Barrier(Atomic32 amount, Atomic32 *value) {$/;"	f	namespace:base::subtle
OSAtomicAdd64	.\base\atomicops-internals-linuxppc.h	/^static inline Atomic64 OSAtomicAdd64(Atomic64 amount, Atomic64 *value) {$/;"	f	namespace:base::subtle
OSAtomicAdd64	.\base\atomicops-internals-macosx.h	/^inline int64_t OSAtomicAdd64(int64_t theAmount, int64_t *theValue) {$/;"	f	namespace:base::subtle
OSAtomicAdd64Barrier	.\base\atomicops-internals-linuxppc.h	/^static inline Atomic64 OSAtomicAdd64Barrier(Atomic64 amount, Atomic64 *value) {$/;"	f	namespace:base::subtle
OSAtomicAdd64Barrier	.\base\atomicops-internals-macosx.h	/^inline int64_t OSAtomicAdd64Barrier($/;"	f	namespace:base::subtle
OSAtomicCompareAndSwap32	.\base\atomicops-internals-linuxppc.h	/^static inline bool OSAtomicCompareAndSwap32(Atomic32 old_value,$/;"	f	namespace:base::subtle
OSAtomicCompareAndSwap32Acquire	.\base\atomicops-internals-linuxppc.h	/^static inline Atomic32 OSAtomicCompareAndSwap32Acquire(Atomic32 old_value,$/;"	f	namespace:base::subtle
OSAtomicCompareAndSwap32Release	.\base\atomicops-internals-linuxppc.h	/^static inline Atomic32 OSAtomicCompareAndSwap32Release(Atomic32 old_value,$/;"	f	namespace:base::subtle
OSAtomicCompareAndSwap64	.\base\atomicops-internals-linuxppc.h	/^static inline bool OSAtomicCompareAndSwap64(Atomic64 old_value,$/;"	f	namespace:base::subtle
OSAtomicCompareAndSwap64	.\base\atomicops-internals-macosx.h	/^inline int64_t OSAtomicCompareAndSwap64($/;"	f	namespace:base::subtle
OSAtomicCompareAndSwap64Acquire	.\base\atomicops-internals-linuxppc.h	/^static inline Atomic64 OSAtomicCompareAndSwap64Acquire(Atomic64 old_value,$/;"	f	namespace:base::subtle
OSAtomicCompareAndSwap64Barrier	.\base\atomicops-internals-macosx.h	/^inline int64_t OSAtomicCompareAndSwap64Barrier($/;"	f	namespace:base::subtle
OSAtomicCompareAndSwap64Release	.\base\atomicops-internals-linuxppc.h	/^static inline Atomic64 OSAtomicCompareAndSwap64Release(Atomic64 old_value,$/;"	f	namespace:base::subtle
OS_128_BIT_PACKED_SINGLE_PRECISION_FLOATING	.\windows\mini_disassembler_types.h	/^  OS_128_BIT_PACKED_SINGLE_PRECISION_FLOATING = 128\/8,$/;"	e	enum:sidestep::OperandSize
OS_32_BIT_POINTER	.\windows\mini_disassembler_types.h	/^  OS_32_BIT_POINTER = 32\/8,$/;"	e	enum:sidestep::OperandSize
OS_48_BIT_POINTER	.\windows\mini_disassembler_types.h	/^  OS_48_BIT_POINTER = 48\/8,$/;"	e	enum:sidestep::OperandSize
OS_BYTE	.\windows\mini_disassembler_types.h	/^  OS_BYTE = 1,$/;"	e	enum:sidestep::OperandSize
OS_DOUBLE_EXTENDED_PRECISION_FLOATING	.\windows\mini_disassembler_types.h	/^  OS_DOUBLE_EXTENDED_PRECISION_FLOATING = 80\/8,$/;"	e	enum:sidestep::OperandSize
OS_DOUBLE_PRECISION_FLOATING	.\windows\mini_disassembler_types.h	/^  OS_DOUBLE_PRECISION_FLOATING = 64\/8,$/;"	e	enum:sidestep::OperandSize
OS_DOUBLE_QUAD_WORD	.\windows\mini_disassembler_types.h	/^  OS_DOUBLE_QUAD_WORD = 16,$/;"	e	enum:sidestep::OperandSize
OS_DOUBLE_WORD	.\windows\mini_disassembler_types.h	/^  OS_DOUBLE_WORD = 4,$/;"	e	enum:sidestep::OperandSize
OS_PSEUDO_DESCRIPTOR	.\windows\mini_disassembler_types.h	/^  OS_PSEUDO_DESCRIPTOR = 6$/;"	e	enum:sidestep::OperandSize
OS_QUAD_WORD	.\windows\mini_disassembler_types.h	/^  OS_QUAD_WORD = 8,$/;"	e	enum:sidestep::OperandSize
OS_SINGLE_PRECISION_FLOATING	.\windows\mini_disassembler_types.h	/^  OS_SINGLE_PRECISION_FLOATING = 32\/8,$/;"	e	enum:sidestep::OperandSize
OS_WORD	.\windows\mini_disassembler_types.h	/^  OS_WORD = 2,$/;"	e	enum:sidestep::OperandSize
OS_ZERO	.\windows\mini_disassembler_types.h	/^  OS_ZERO = 0,$/;"	e	enum:sidestep::OperandSize
OT_A	.\windows\mini_disassembler_types.h	/^  OT_A = 0x01000000,$/;"	e	enum:sidestep::OperandType
OT_ADDRESS_MODE_M	.\windows\mini_disassembler_types.h	/^  OT_ADDRESS_MODE_M = 0x80000000$/;"	e	enum:sidestep::OperandType
OT_B	.\windows\mini_disassembler_types.h	/^  OT_B = 0x02000000,$/;"	e	enum:sidestep::OperandType
OT_C	.\windows\mini_disassembler_types.h	/^  OT_C = 0x03000000,$/;"	e	enum:sidestep::OperandType
OT_D	.\windows\mini_disassembler_types.h	/^  OT_D = 0x04000000,$/;"	e	enum:sidestep::OperandType
OT_DQ	.\windows\mini_disassembler_types.h	/^  OT_DQ = 0x05000000,$/;"	e	enum:sidestep::OperandType
OT_MASK	.\windows\mini_disassembler_types.h	/^  OT_MASK = 0xFF000000,$/;"	e	enum:sidestep::OperandType
OT_P	.\windows\mini_disassembler_types.h	/^  OT_P = 0x06000000,$/;"	e	enum:sidestep::OperandType
OT_PD	.\windows\mini_disassembler_types.h	/^  OT_PD = 0x10000000,  \/\/ double-precision floating point$/;"	e	enum:sidestep::OperandType
OT_PI	.\windows\mini_disassembler_types.h	/^  OT_PI = 0x07000000,$/;"	e	enum:sidestep::OperandType
OT_PS	.\windows\mini_disassembler_types.h	/^  OT_PS = 0x08000000,  \/\/ actually unsupported for (we don't know its size)$/;"	e	enum:sidestep::OperandType
OT_Q	.\windows\mini_disassembler_types.h	/^  OT_Q = 0x09000000,$/;"	e	enum:sidestep::OperandType
OT_S	.\windows\mini_disassembler_types.h	/^  OT_S = 0x0A000000,$/;"	e	enum:sidestep::OperandType
OT_SD	.\windows\mini_disassembler_types.h	/^  OT_SD = 0x0F000000,  \/\/ scalar double-precision floating-point value$/;"	e	enum:sidestep::OperandType
OT_SI	.\windows\mini_disassembler_types.h	/^  OT_SI = 0x0C000000,$/;"	e	enum:sidestep::OperandType
OT_SS	.\windows\mini_disassembler_types.h	/^  OT_SS = 0x0B000000,$/;"	e	enum:sidestep::OperandType
OT_V	.\windows\mini_disassembler_types.h	/^  OT_V = 0x0D000000,$/;"	e	enum:sidestep::OperandType
OT_W	.\windows\mini_disassembler_types.h	/^  OT_W = 0x0E000000,$/;"	e	enum:sidestep::OperandType
O_DIRECTORY	.\base\linux_syscall_support.h	523;"	d
O_DIRECTORY	.\base\linux_syscall_support.h	525;"	d
O_RDONLY	.\windows\port.h	365;"	d
ObjMakerFunc	.\tests\heap-checker_unittest.cc	/^typedef void* (*ObjMakerFunc)();$/;"	t	file:
ObjMakerRegistrar	.\tests\heap-checker_unittest.cc	/^  ObjMakerRegistrar(ObjMakerFunc obj_maker) { obj_makers.push_back(obj_maker); }$/;"	f	struct:ObjMakerRegistrar
ObjMakerRegistrar	.\tests\heap-checker_unittest.cc	/^struct ObjMakerRegistrar {$/;"	s	file:
Object	.\addressmap-inl.h	/^  struct Object {$/;"	s	class:AddressMap
Object	.\tests\tcmalloc_unittest.cc	/^  struct Object {$/;"	s	class:testing::TesterThread	file:
ObjectPlacement	.\heap-checker.cc	/^enum ObjectPlacement {$/;"	g	file:
ObjectsLeaked	.\heap-checker.cc	/^ssize_t HeapLeakChecker::ObjectsLeaked() const {$/;"	f	class:HeapLeakChecker
OldSampler	.\tests\sampler_test.cc	/^class OldSampler {$/;"	c	file:
OnNoMemory	.\tests\tcmalloc_unittest.cc	/^static void OnNoMemory() {$/;"	f	namespace:testing
OneDeathTest	.\tests\debugallocation_test.sh	/^OneDeathTest() {$/;"	f
Opcode	.\windows\mini_disassembler_types.h	/^struct Opcode {$/;"	s	namespace:sidestep
OpcodeTable	.\windows\mini_disassembler_types.h	/^struct OpcodeTable {$/;"	s	namespace:sidestep
OperandSize	.\windows\mini_disassembler_types.h	/^enum OperandSize {$/;"	g	namespace:sidestep
OperandType	.\windows\mini_disassembler_types.h	/^enum OperandType {$/;"	g	namespace:sidestep
Options	.\profiledata.cc	/^ProfileData::Options::Options()$/;"	f	class:ProfileData::Options
Options	.\profiledata.h	/^  class Options {$/;"	c	class:ProfileData
OrigFn	.\third_party\valgrind.h	/^   OrigFn;$/;"	t	typeref:struct:__anon42
OrigFn	.\third_party\valgrind.h	/^   OrigFn;$/;"	t	typeref:struct:__anon43
OrigFn	.\third_party\valgrind.h	/^   OrigFn;$/;"	t	typeref:struct:__anon44
OrigFn	.\third_party\valgrind.h	/^   OrigFn;$/;"	t	typeref:struct:__anon45
OrigFn	.\third_party\valgrind.h	/^   OrigFn;$/;"	t	typeref:struct:__anon46
OrigFn	.\third_party\valgrind.h	/^   OrigFn;$/;"	t	typeref:struct:__anon47
OutputSequence	.\tests\sampler_test.cc	/^void OutputSequence(int sequence_length) {$/;"	f
OverheadBytes	.\central_freelist.cc	/^size_t CentralFreeList::OverheadBytes() {$/;"	f	class:tcmalloc::CentralFreeList
Overlaps	.\memory_region_map.h	/^    bool Overlaps(const Region& x) const {$/;"	f	struct:MemoryRegionMap::Region
Ownership	.\gperftools\malloc_extension.h	/^  enum Ownership {$/;"	g	class:MallocExtension
PACKAGE	.\windows\config.h	230;"	d
PACKAGE_BUGREPORT	.\windows\config.h	233;"	d
PACKAGE_NAME	.\windows\config.h	236;"	d
PACKAGE_STRING	.\windows\config.h	239;"	d
PACKAGE_TARNAME	.\windows\config.h	242;"	d
PACKAGE_URL	.\windows\config.h	245;"	d
PACKAGE_VERSION	.\windows\config.h	248;"	d
PASS	.\tests\tcmalloc_unittest.cc	/^  enum Type { ALLOC, FREE, UPDATE, PASS };$/;"	e	enum:testing::TesterThread::Type	file:
PATH_MAX	.\heap-profiler.cc	79;"	d	file:
PATH_MAX	.\heap-profiler.cc	81;"	d	file:
PATH_MAX	.\windows\port.h	359;"	d
PC	.\malloc_extension.cc	/^void* PC(void** entry, int i) {$/;"	f	namespace:__anon23
PCHECK	.\base\logging.h	114;"	d
PC_FROM_UCONTEXT	.\windows\config.h	251;"	d
PERFTOOLS_DLL_DECL	.\config_for_unittests.h	60;"	d
PERFTOOLS_DLL_DECL	.\config_for_unittests.h	62;"	d
PERFTOOLS_DLL_DECL	.\config_for_unittests.h	64;"	d
PERFTOOLS_DLL_DECL	.\gperftools\heap-checker.h	69;"	d
PERFTOOLS_DLL_DECL	.\gperftools\heap-checker.h	71;"	d
PERFTOOLS_DLL_DECL	.\gperftools\heap-profiler.h	59;"	d
PERFTOOLS_DLL_DECL	.\gperftools\heap-profiler.h	61;"	d
PERFTOOLS_DLL_DECL	.\gperftools\malloc_extension.h	59;"	d
PERFTOOLS_DLL_DECL	.\gperftools\malloc_extension.h	61;"	d
PERFTOOLS_DLL_DECL	.\gperftools\malloc_extension_c.h	48;"	d
PERFTOOLS_DLL_DECL	.\gperftools\malloc_extension_c.h	50;"	d
PERFTOOLS_DLL_DECL	.\gperftools\malloc_hook.h	79;"	d
PERFTOOLS_DLL_DECL	.\gperftools\malloc_hook.h	81;"	d
PERFTOOLS_DLL_DECL	.\gperftools\malloc_hook_c.h	46;"	d
PERFTOOLS_DLL_DECL	.\gperftools\malloc_hook_c.h	48;"	d
PERFTOOLS_DLL_DECL	.\gperftools\profiler.h	68;"	d
PERFTOOLS_DLL_DECL	.\gperftools\profiler.h	70;"	d
PERFTOOLS_DLL_DECL	.\gperftools\stacktrace.h	43;"	d
PERFTOOLS_DLL_DECL	.\gperftools\stacktrace.h	45;"	d
PERFTOOLS_DLL_DECL	.\windows\config.h	260;"	d
PERFTOOLS_DLL_DECL	.\windows\gperftools\tcmalloc.h	133;"	d
PERFTOOLS_DLL_DECL	.\windows\gperftools\tcmalloc.h	60;"	d
PERFTOOLS_DLL_DECL	.\windows\gperftools\tcmalloc.h	62;"	d
PERFTOOLS_DLL_DECL_DEFINED	.\windows\gperftools\tcmalloc.h	134;"	d
PERFTOOLS_DLL_DECL_DEFINED	.\windows\gperftools\tcmalloc.h	58;"	d
PERFTOOLS_DLL_DECL_FOR_UNITTESTS	.\windows\config.h	261;"	d
PERFTOOLS_IS_A_DLL	.\windows\config.h	259;"	d
PERFTOOLS_NO_ALIGNED_MALLOC	.\windows\mingw.h	46;"	d
PERFTOOLS_THROW	.\windows\gperftools\tcmalloc.h	130;"	d
PERFTOOLS_THROW	.\windows\gperftools\tcmalloc.h	48;"	d
PERFTOOLS_THROW	.\windows\gperftools\tcmalloc.h	51;"	d
PERFTOOLS_THROW	.\windows\gperftools\tcmalloc.h	53;"	d
PLATFORM_WINDOWS	.\base\sysinfo.cc	33;"	d	file:
PLAT_amd64_linux	.\third_party\valgrind.h	3918;"	d
PLAT_amd64_linux	.\third_party\valgrind.h	89;"	d
PLAT_amd64_linux	.\third_party\valgrind.h	98;"	d
PLAT_ppc32_aix5	.\third_party\valgrind.h	106;"	d
PLAT_ppc32_aix5	.\third_party\valgrind.h	3921;"	d
PLAT_ppc32_aix5	.\third_party\valgrind.h	92;"	d
PLAT_ppc32_linux	.\third_party\valgrind.h	100;"	d
PLAT_ppc32_linux	.\third_party\valgrind.h	3919;"	d
PLAT_ppc32_linux	.\third_party\valgrind.h	90;"	d
PLAT_ppc64_aix5	.\third_party\valgrind.h	104;"	d
PLAT_ppc64_aix5	.\third_party\valgrind.h	3922;"	d
PLAT_ppc64_aix5	.\third_party\valgrind.h	93;"	d
PLAT_ppc64_linux	.\third_party\valgrind.h	102;"	d
PLAT_ppc64_linux	.\third_party\valgrind.h	3920;"	d
PLAT_ppc64_linux	.\third_party\valgrind.h	91;"	d
PLAT_x86_linux	.\third_party\valgrind.h	3917;"	d
PLAT_x86_linux	.\third_party\valgrind.h	88;"	d
PLAT_x86_linux	.\third_party\valgrind.h	96;"	d
PMODULEENTRY32	.\base\sysinfo.cc	74;"	d	file:
PRINTABLE_PTHREAD	.\base\basictypes.h	115;"	d
PRINTABLE_PTHREAD	.\base\basictypes.h	117;"	d
PRId64	.\base\basictypes.h	99;"	d
PRId64	.\windows\port.h	345;"	d
PRIdS	.\windows\config.h	265;"	d
PRIu64	.\base\basictypes.h	105;"	d
PRIu64	.\windows\port.h	347;"	d
PRIuPTR	.\windows\port.h	349;"	d
PRIuPTR	.\windows\port.h	352;"	d
PRIuS	.\windows\config.h	268;"	d
PRIx64	.\base\basictypes.h	93;"	d
PRIx64	.\windows\port.h	343;"	d
PRIxPTR	.\base\basictypes.h	108;"	d
PRIxPTR	.\windows\port.h	350;"	d
PRIxPTR	.\windows\port.h	353;"	d
PRIxS	.\windows\config.h	271;"	d
PROC_MAPS_USED	.\gperftools\heap-checker.h	/^    PROC_MAPS_USED,$/;"	e	enum:HeapLeakChecker::ProcMapsResult
PROT_READ	.\windows\port.h	276;"	d
PROT_WRITE	.\windows\port.h	277;"	d
PR_GET_DUMPABLE	.\base\linux_syscall_support.h	529;"	d
PR_SET_DUMPABLE	.\base\linux_syscall_support.h	532;"	d
PSAPI_VERSION	.\windows\patch_functions.cc	82;"	d	file:
PTHREADS_CRASHES_IF_RUN_TOO_EARLY	.\windows\config.h	276;"	d
PTHREAD_CREATE_JOINABLE	.\windows\config.h	281;"	d
PTHREAD_ONCE_INIT	.\windows\port.h	/^enum { PTHREAD_ONCE_INIT = 0 };   \/* important that this be 0! for SpinLock *\/$/;"	e	enum:__anon55
PT_GUARDED_BY	.\base\thread_annotations.h	74;"	d
PT_GUARDED_VAR	.\base\thread_annotations.h	76;"	d
PackedCache	.\packed-cache-inl.h	/^  explicit PackedCache(V initial_value) {$/;"	f	class:PackedCache
PackedCache	.\packed-cache-inl.h	/^class PackedCache {$/;"	c
PackedCacheTest_basic	.\tests\packed-cache_test.cc	/^void PackedCacheTest_basic() {$/;"	f
PageHeap	.\page_heap.cc	/^PageHeap::PageHeap()$/;"	f	class:tcmalloc::PageHeap
PageHeap	.\page_heap.h	/^class PERFTOOLS_DLL_DECL PageHeap {$/;"	c	namespace:tcmalloc
PageHeapAllocator	.\page_heap_allocator.h	/^class PageHeapAllocator {$/;"	c	namespace:tcmalloc
PageID	.\common.h	/^typedef uintptr_t PageID;$/;"	t
PageMap	.\page_heap.h	/^  typedef MapSelector<kAddressBits>::Type PageMap;$/;"	t	class:tcmalloc::PageHeap
PageMapCache	.\page_heap.h	/^  typedef MapSelector<kAddressBits>::CacheType PageMapCache;$/;"	t	class:tcmalloc::PageHeap
PagesAllocator	.\base\low_level_alloc.h	/^  class PagesAllocator {$/;"	c	class:LowLevelAlloc
PagesToMiB	.\tcmalloc.cc	/^static double PagesToMiB(uint64_t pages) {$/;"	f	file:
ParseProcMapsLine	.\base\sysinfo.cc	/^static bool ParseProcMapsLine(char *text, uint64 *start, uint64 *end,$/;"	f	file:
Pass	.\tests\heap-checker_unittest.cc	/^static int Pass() {$/;"	f	file:
PassObject	.\tests\tcmalloc_unittest.cc	/^  void PassObject() {$/;"	f	class:testing::TesterThread
Patch	.\windows\patch_functions.cc	/^bool LibcInfoWithPatchFunctions<T>::Patch(const LibcInfo& me_info) {$/;"	f	class:__anon52::LibcInfoWithPatchFunctions
Patch	.\windows\patch_functions.cc	/^void WindowsInfo::Patch() {$/;"	f	class:__anon52::WindowsInfo
Patch	.\windows\preamble_patcher.h	/^  static SideStepError Patch(LPCTSTR module_name,$/;"	f	class:sidestep::PreamblePatcher
Patch	.\windows\preamble_patcher.h	/^  static SideStepError Patch(T target_function,$/;"	f	class:sidestep::PreamblePatcher
PatchAllModules	.\windows\patch_functions.cc	/^bool PatchAllModules() {$/;"	f	namespace:__anon52
PatchMainExecutableLocked	.\windows\patch_functions.cc	/^void PatchMainExecutableLocked() {$/;"	f	namespace:__anon52
PatchMovWithDisplacement	.\windows\preamble_patcher.cc	/^SideStepError PreamblePatcher::PatchMovWithDisplacement($/;"	f	class:sidestep::PreamblePatcher
PatchNearJumpOrCall	.\windows\preamble_patcher.cc	/^SideStepError PreamblePatcher::PatchNearJumpOrCall($/;"	f	class:sidestep::PreamblePatcher
PatchOneModuleLocked	.\windows\patch_functions.cc	/^void PatchOneModuleLocked(const LibcInfo& me_info) {$/;"	f	namespace:__anon52
PatchShortConditionalJump	.\windows\preamble_patcher.cc	/^SideStepError PreamblePatcher::PatchShortConditionalJump($/;"	f	class:sidestep::PreamblePatcher
PatchShortJump	.\windows\preamble_patcher.cc	/^SideStepError PreamblePatcher::PatchShortJump($/;"	f	class:sidestep::PreamblePatcher
PatchThenUnpatch	.\windows\preamble_patcher_test.cc	/^bool PatchThenUnpatch() {$/;"	f	namespace:sidestep
PatchWindowsFunctions	.\windows\patch_functions.cc	/^void PatchWindowsFunctions() {$/;"	f
Pause	.\tests\heap-checker_unittest.cc	/^static void Pause() {$/;"	f	file:
Perftools_FreeLibrary	.\windows\patch_functions.cc	/^BOOL WINAPI WindowsInfo::Perftools_FreeLibrary(HMODULE hLibModule) {$/;"	f	class:WindowsInfo
Perftools_HeapAlloc	.\windows\patch_functions.cc	/^LPVOID WINAPI WindowsInfo::Perftools_HeapAlloc(HANDLE hHeap, DWORD dwFlags,$/;"	f	class:WindowsInfo
Perftools_HeapFree	.\windows\patch_functions.cc	/^BOOL WINAPI WindowsInfo::Perftools_HeapFree(HANDLE hHeap, DWORD dwFlags,$/;"	f	class:WindowsInfo
Perftools_LoadLibraryExW	.\windows\patch_functions.cc	/^HMODULE WINAPI WindowsInfo::Perftools_LoadLibraryExW(LPCWSTR lpFileName,$/;"	f	class:WindowsInfo
Perftools_MapViewOfFileEx	.\windows\patch_functions.cc	/^LPVOID WINAPI WindowsInfo::Perftools_MapViewOfFileEx($/;"	f	class:WindowsInfo
Perftools_UnmapViewOfFile	.\windows\patch_functions.cc	/^BOOL WINAPI WindowsInfo::Perftools_UnmapViewOfFile(LPCVOID lpBaseAddress) {$/;"	f	class:WindowsInfo
Perftools_VirtualAllocEx	.\windows\patch_functions.cc	/^LPVOID WINAPI WindowsInfo::Perftools_VirtualAllocEx(HANDLE process,$/;"	f	class:WindowsInfo
Perftools_VirtualFreeEx	.\windows\patch_functions.cc	/^BOOL WINAPI WindowsInfo::Perftools_VirtualFreeEx(HANDLE process, LPVOID address,$/;"	f	class:WindowsInfo
Perftools_delete	.\windows\patch_functions.cc	/^void LibcInfoWithPatchFunctions<T>::Perftools_delete(void *p) {$/;"	f	class:LibcInfoWithPatchFunctions
Perftools_deletearray	.\windows\patch_functions.cc	/^void LibcInfoWithPatchFunctions<T>::Perftools_deletearray(void *p) {$/;"	f	class:LibcInfoWithPatchFunctions
Perftools_new	.\windows\patch_functions.cc	/^void* LibcInfoWithPatchFunctions<T>::Perftools_new(size_t size) {$/;"	f	class:LibcInfoWithPatchFunctions
Perftools_newarray	.\windows\patch_functions.cc	/^void* LibcInfoWithPatchFunctions<T>::Perftools_newarray(size_t size) {$/;"	f	class:LibcInfoWithPatchFunctions
Permute	.\tests\pagemap_unittest.cc	/^static void Permute(vector<intptr_t>* elements) {$/;"	f	file:
PickNextSample	.\tests\sampler_test.cc	/^void OldSampler::PickNextSample(size_t k) {$/;"	f	class:OldSampler
PickNextSamplingPoint	.\sampler.cc	/^size_t Sampler::PickNextSamplingPoint() {$/;"	f	class:tcmalloc::Sampler
PickType	.\tests\tcmalloc_unittest.cc	/^int TestHarness::PickType() {$/;"	f	class:testing::TestHarness
Pop	.\debugallocation.cc	/^  QueueEntry Pop() {$/;"	f	class:FreeQueue
Pop	.\thread_cache.h	/^    void* Pop() {$/;"	f	class:tcmalloc::ThreadCache::FreeList
PopRange	.\thread_cache.h	/^    void PopRange(int N, void **start, void **end) {$/;"	f	class:tcmalloc::ThreadCache::FreeList
Populate	.\central_freelist.cc	/^void CentralFreeList::Populate() {$/;"	f	class:tcmalloc::CentralFreeList
PopulateFastLog2Table	.\sampler.cc	/^void Sampler::PopulateFastLog2Table() {$/;"	f	class:tcmalloc::Sampler
PopulateWindowsFn	.\windows\patch_functions.cc	/^bool LibcInfo::PopulateWindowsFn(const ModuleEntryCopy& module_entry) {$/;"	f	class:__anon52::LibcInfo
PosixMemalign	.\tests\tcmalloc_unittest.cc	/^static inline int PosixMemalign(void** ptr, size_t align, size_t size) {$/;"	f	file:
PreMmapHook	.\gperftools\malloc_hook.h	/^  typedef MallocHook_PreMmapHook PreMmapHook;$/;"	t	class:MallocHook
PreSbrkHook	.\gperftools\malloc_hook.h	/^  typedef MallocHook_PreSbrkHook PreSbrkHook;$/;"	t	class:MallocHook
PreallocateMoreMemory	.\pagemap.h	/^  void PreallocateMoreMemory() {$/;"	f	class:TCMalloc_PageMap2
PreallocateMoreMemory	.\pagemap.h	/^  void PreallocateMoreMemory() {$/;"	f	class:TCMalloc_PageMap3
PreallocateMoreMemory	.\pagemap.h	/^  void PreallocateMoreMemory() {}$/;"	f	class:TCMalloc_PageMap1
PreamblePage	.\windows\preamble_patcher.h	/^  struct PreamblePage {$/;"	s	class:sidestep::PreamblePatcher
PreamblePatcher	.\windows\preamble_patcher.h	/^class PERFTOOLS_DLL_DECL PreamblePatcher {$/;"	c	namespace:sidestep
PrependToFreeList	.\page_heap.cc	/^void PageHeap::PrependToFreeList(Span* span) {$/;"	f	class:tcmalloc::PageHeap
PreventHeapReclaiming	.\tests\heap-checker_unittest.cc	/^void PreventHeapReclaiming(size_t size) {$/;"	f
PrintAvailability	.\windows\nm-pdb.c	/^static void PrintAvailability(BOOL var, const char *description) {$/;"	f	file:
PrintCountAndSize	.\malloc_extension.cc	/^void PrintCountAndSize(MallocExtensionWriter* writer,$/;"	f	namespace:__anon23
PrintError	.\symbolize.cc	/^static void PrintError(const char* reason) {$/;"	f	file:
PrintHeader	.\malloc_extension.cc	/^void PrintHeader(MallocExtensionWriter* writer,$/;"	f	namespace:__anon23
PrintStackEntry	.\malloc_extension.cc	/^void PrintStackEntry(MallocExtensionWriter* writer, void** entry) {$/;"	f	namespace:__anon23
PrintStats	.\tcmalloc.cc	/^static void PrintStats(int level) {$/;"	f	file:
Printf	.\raw_printer.cc	/^void RawPrinter::Printf(const char* format, ...) {$/;"	f	class:base::RawPrinter
ProcMapsIterator	.\base\sysinfo.cc	/^ProcMapsIterator::ProcMapsIterator(pid_t pid) {$/;"	f	class:ProcMapsIterator
ProcMapsIterator	.\base\sysinfo.cc	/^ProcMapsIterator::ProcMapsIterator(pid_t pid, Buffer *buffer) {$/;"	f	class:ProcMapsIterator
ProcMapsIterator	.\base\sysinfo.cc	/^ProcMapsIterator::ProcMapsIterator(pid_t pid, Buffer *buffer,$/;"	f	class:ProcMapsIterator
ProcMapsIterator	.\base\sysinfo.h	/^class ProcMapsIterator {$/;"	c
ProcMapsResult	.\gperftools\heap-checker.h	/^  enum ProcMapsResult {$/;"	g	class:HeapLeakChecker
ProcMapsTask	.\gperftools\heap-checker.h	/^  enum ProcMapsTask {$/;"	g	class:HeapLeakChecker
ProcessFreeQueue	.\debugallocation.cc	/^  static void ProcessFreeQueue(MallocBlock* b, size_t size,$/;"	f	class:MallocBlock
ProcessModrm	.\windows\mini_disassembler.cc	/^bool MiniDisassembler::ProcessModrm(unsigned char* start_byte,$/;"	f	class:sidestep::MiniDisassembler
ProcessOpcode	.\windows\mini_disassembler.cc	/^InstructionType MiniDisassembler::ProcessOpcode(unsigned char* start_byte,$/;"	f	class:sidestep::MiniDisassembler
ProcessOperand	.\windows\mini_disassembler.cc	/^bool MiniDisassembler::ProcessOperand(int flag_operand) {$/;"	f	class:sidestep::MiniDisassembler
ProcessPrefixes	.\windows\mini_disassembler.cc	/^InstructionType MiniDisassembler::ProcessPrefixes(unsigned char* start_byte,$/;"	f	class:sidestep::MiniDisassembler
ProcessSib	.\windows\mini_disassembler.cc	/^bool MiniDisassembler::ProcessSib(unsigned char* start_byte,$/;"	f	class:sidestep::MiniDisassembler
ProfileData	.\profiledata.cc	/^ProfileData::ProfileData()$/;"	f	class:ProfileData
ProfileData	.\profiledata.h	/^class ProfileData {$/;"	c
ProfileDataChecker	.\tests\profiledata_unittest.cc	/^  ProfileDataChecker() {$/;"	f	class:__anon38::ProfileDataChecker
ProfileDataChecker	.\tests\profiledata_unittest.cc	/^class ProfileDataChecker {$/;"	c	namespace:__anon38	file:
ProfileDataSlot	.\tests\profiledata_unittest.cc	/^typedef uintptr_t ProfileDataSlot;$/;"	t	namespace:__anon38	file:
ProfileDataTest	.\tests\profiledata_unittest.cc	/^class ProfileDataTest {$/;"	c	namespace:__anon38	file:
ProfileHandler	.\profile-handler.cc	/^ProfileHandler::ProfileHandler()$/;"	f	class:ProfileHandler
ProfileHandler	.\profile-handler.cc	/^class ProfileHandler {$/;"	c	file:
ProfileHandlerCallback	.\profile-handler.h	/^typedef void (*ProfileHandlerCallback)(int sig, siginfo_t* sig_info,$/;"	t
ProfileHandlerGetState	.\profile-handler.cc	/^void ProfileHandlerGetState(ProfileHandlerState* state) {$/;"	f
ProfileHandlerRegisterCallback	.\profile-handler.cc	/^ProfileHandlerToken* ProfileHandlerRegisterCallback($/;"	f
ProfileHandlerRegisterThread	.\profile-handler.cc	/^void ProfileHandlerRegisterThread() {$/;"	f
ProfileHandlerReset	.\profile-handler.cc	/^void ProfileHandlerReset() {$/;"	f
ProfileHandlerState	.\profile-handler.h	/^struct ProfileHandlerState {$/;"	s
ProfileHandlerTest	.\tests\profile-handler_unittest.cc	/^class ProfileHandlerTest {$/;"	c	namespace:__anon37	file:
ProfileHandlerToken	.\profile-handler.cc	/^  ProfileHandlerToken(ProfileHandlerCallback cb, void* cb_arg)$/;"	f	struct:ProfileHandlerToken
ProfileHandlerToken	.\profile-handler.cc	/^struct ProfileHandlerToken {$/;"	s	file:
ProfileHandlerUnregisterCallback	.\profile-handler.cc	/^void ProfileHandlerUnregisterCallback(ProfileHandlerToken* token) {$/;"	f
ProfilerDisable	.\profiler.cc	/^extern "C" PERFTOOLS_DLL_DECL void ProfilerDisable() { }$/;"	f
ProfilerEnable	.\profiler.cc	/^extern "C" PERFTOOLS_DLL_DECL void ProfilerEnable() { }$/;"	f
ProfilerFlush	.\profiler.cc	/^extern "C" PERFTOOLS_DLL_DECL void ProfilerFlush() {$/;"	f
ProfilerFlush	.\profiler.cc	/^extern "C" void ProfilerFlush() { }$/;"	f
ProfilerFree	.\heap-profiler.cc	/^static void ProfilerFree(void* p) {$/;"	f	file:
ProfilerGetCurrentState	.\profiler.cc	/^extern "C" PERFTOOLS_DLL_DECL void ProfilerGetCurrentState($/;"	f
ProfilerGetCurrentState	.\profiler.cc	/^extern "C" void ProfilerGetCurrentState(ProfilerState* state) {$/;"	f
ProfilerMalloc	.\heap-profiler.cc	/^static void* ProfilerMalloc(size_t bytes) {$/;"	f	file:
ProfilerOptions	.\gperftools\profiler.h	/^struct ProfilerOptions {$/;"	s
ProfilerRegisterThread	.\profiler.cc	/^extern "C" PERFTOOLS_DLL_DECL void ProfilerRegisterThread() {$/;"	f
ProfilerRegisterThread	.\profiler.cc	/^extern "C" void ProfilerRegisterThread() { }$/;"	f
ProfilerStart	.\profiler.cc	/^extern "C" PERFTOOLS_DLL_DECL int ProfilerStart(const char* fname) {$/;"	f
ProfilerStart	.\profiler.cc	/^extern "C" int ProfilerStart(const char* fname) { return 0; }$/;"	f
ProfilerStartWithOptions	.\profiler.cc	/^extern "C" PERFTOOLS_DLL_DECL int ProfilerStartWithOptions($/;"	f
ProfilerStartWithOptions	.\profiler.cc	/^extern "C" int ProfilerStartWithOptions(const char *fname,$/;"	f
ProfilerState	.\gperftools\profiler.h	/^struct ProfilerState {$/;"	s
ProfilerStop	.\profiler.cc	/^extern "C" PERFTOOLS_DLL_DECL void ProfilerStop() {$/;"	f
ProfilerStop	.\profiler.cc	/^extern "C" void ProfilerStop() { }$/;"	f
ProfilingIsEnabledForAllThreads	.\heap-checker.cc	/^bool ProfilingIsEnabledForAllThreads() { return false; }$/;"	f
ProfilingIsEnabledForAllThreads	.\profiler.cc	/^extern "C" PERFTOOLS_DLL_DECL int ProfilingIsEnabledForAllThreads() {$/;"	f
ProfilingIsEnabledForAllThreads	.\profiler.cc	/^extern "C" int ProfilingIsEnabledForAllThreads() { return 0; }$/;"	f
PthreadKeyCreate	.\windows\port.cc	/^extern "C" pthread_key_t PthreadKeyCreate(void (*destr_fn)(void*)) {$/;"	f
PtrAndSize	.\tests\addressmap_unittest.cc	/^  PtrAndSize(char* p, size_t s) : ptr(p), size(s) {}$/;"	f	struct:PtrAndSize
PtrAndSize	.\tests\addressmap_unittest.cc	/^struct PtrAndSize {$/;"	s	file:
Push	.\debugallocation.cc	/^  void Push(const QueueEntry& block) {$/;"	f	class:FreeQueue
Push	.\thread_cache.h	/^    void Push(void* ptr) {$/;"	f	class:tcmalloc::ThreadCache::FreeList
PushRange	.\thread_cache.h	/^    void PushRange(int N, void *start, void *end) {$/;"	f	class:tcmalloc::ThreadCache::FreeList
Put	.\packed-cache-inl.h	/^  void Put(K key, V value) {$/;"	f	class:PackedCache
QuickNoLeaks	.\gperftools\heap-checker.h	/^  bool QuickNoLeaks()  { return NoLeaks(); }$/;"	f	class:HeapLeakChecker
QuickSameHeap	.\gperftools\heap-checker.h	/^  bool QuickSameHeap() { return NoLeaks(); }$/;"	f	class:HeapLeakChecker
RAW_CHECK	.\base\logging.h	94;"	d
RAW_DCHECK	.\base\logging.h	106;"	d
RAW_DCHECK	.\base\logging.h	109;"	d
RAW_LOG	.\base\logging.h	/^inline void RAW_LOG(int lvl, const char* pat, ...)  { LOG_PRINTF(lvl, pat); }$/;"	f
RAW_VLOG	.\base\logging.h	/^inline void RAW_VLOG(int lvl, const char* pat, ...) { LOG_PRINTF(lvl, pat); }$/;"	f
RECORD_GLOBAL_DATA	.\gperftools\heap-checker.h	/^    RECORD_GLOBAL_DATA,$/;"	e	enum:HeapLeakChecker::ProcMapsTask
REGISTER_HEAPCHECK_CLEANUP	.\gperftools\heap-checker.h	416;"	d
REGISTER_MODULE_DESTRUCTOR	.\base\googleinit.h	66;"	d
REGISTER_MODULE_INITIALIZER	.\base\googleinit.h	59;"	d
REGISTER_OBJ_MAKER	.\tests\heap-checker_unittest.cc	981;"	d	file:
ROOT_BITS	.\pagemap.h	/^  static const int ROOT_BITS = 5;$/;"	m	class:TCMalloc_PageMap2
ROOT_LENGTH	.\pagemap.h	/^  static const int ROOT_LENGTH = 1 << ROOT_BITS;$/;"	m	class:TCMalloc_PageMap2
RUN	.\tests\profile-handler_unittest.cc	289;"	d	file:
RUN	.\tests\profiledata_unittest.cc	354;"	d	file:
RUNNING_ON_VALGRIND	.\third_party\valgrind.h	3639;"	d
RUN_ALL_TESTS	.\tests\debugallocation_test.cc	/^static int RUN_ALL_TESTS() {$/;"	f	file:
RUN_ALL_TESTS	.\tests\malloc_hook_test.cc	/^static int RUN_ALL_TESTS() {$/;"	f	namespace:__anon35
RUN_ALL_TESTS	.\tests\profile-handler_unittest.cc	/^  static int RUN_ALL_TESTS() {$/;"	f	class:__anon37::ProfileHandlerTest
RUN_ALL_TESTS	.\tests\profiledata_unittest.cc	/^  static int RUN_ALL_TESTS() {$/;"	f	class:__anon38::ProfileDataTest
RUN_ALL_TESTS	.\tests\sampler_test.cc	/^static int RUN_ALL_TESTS() {$/;"	f	file:
RUN_SILENT	.\tests\heap-checker_unittest.cc	421;"	d	file:
RUN_TEST	.\tests\raw_printer_test.cc	16;"	d	file:
Random	.\base\low_level_alloc.cc	/^static int Random() {$/;"	f	file:
RandomizeBlockDesc	.\tests\low_level_alloc_unittest.cc	/^static void RandomizeBlockDesc(BlockDesc *d) {$/;"	f	file:
RangeCallback	.\tests\tcmalloc_unittest.cc	/^static void RangeCallback(void* arg, const base::MallocRange* r) {$/;"	f	namespace:testing::__anon41
RangeCallbackState	.\tests\tcmalloc_unittest.cc	/^struct RangeCallbackState {$/;"	s	namespace:testing::__anon41	file:
RangeFunction	.\gperftools\malloc_extension.h	/^  typedef void (RangeFunction)(void*, const base::MallocRange*);$/;"	t	class:MallocExtension
RangeValue	.\heap-checker.cc	/^struct HeapLeakChecker::RangeValue {$/;"	s	class:HeapLeakChecker	file:
Ranges	.\malloc_extension.cc	/^void MallocExtension::Ranges(void* arg, RangeFunction func) {$/;"	f	class:MallocExtension
Ranges	.\tcmalloc.cc	/^  virtual void Ranges(void* arg, RangeFunction func) {$/;"	f	class:TCMallocImplementation
RawClose	.\base\logging.cc	/^void RawClose(RawFD fd) {$/;"	f
RawClose	.\base\logging.cc	/^void RawClose(RawFD handle) {$/;"	f
RawFD	.\base\logging.h	/^typedef HANDLE RawFD;$/;"	t
RawFD	.\base\logging.h	/^typedef int RawFD;$/;"	t
RawInfoStackDumper	.\heap-profiler.cc	/^static void RawInfoStackDumper(const char* message, void*) {$/;"	f	file:
RawOpenForWriting	.\base\logging.cc	/^RawFD RawOpenForWriting(const char* filename) {$/;"	f
RawPatch	.\windows\preamble_patcher.cc	/^SideStepError PreamblePatcher::RawPatch(void* target_function,$/;"	f	class:sidestep::PreamblePatcher
RawPatchWithStub	.\windows\preamble_patcher_with_stub.cc	/^SideStepError PreamblePatcher::RawPatchWithStub($/;"	f	class:sidestep::PreamblePatcher
RawPatchWithStubAndProtections	.\windows\preamble_patcher.cc	/^SideStepError PreamblePatcher::RawPatchWithStubAndProtections($/;"	f	class:sidestep::PreamblePatcher
RawPrinter	.\raw_printer.cc	/^RawPrinter::RawPrinter(char* buf, int length)$/;"	f	class:base::RawPrinter
RawPrinter	.\raw_printer.h	/^class RawPrinter {$/;"	c	namespace:base
RawWrite	.\base\logging.cc	/^void RawWrite(RawFD fd, const char* buf, size_t len) {$/;"	f
RawWrite	.\base\logging.cc	/^void RawWrite(RawFD handle, const char* buf, size_t len) {$/;"	f
ReadHeapGrowthStackTraces	.\malloc_extension.cc	/^void** MallocExtension::ReadHeapGrowthStackTraces() {$/;"	f	class:MallocExtension
ReadHeapGrowthStackTraces	.\tcmalloc.cc	/^  virtual void** ReadHeapGrowthStackTraces() {$/;"	f	class:TCMallocImplementation
ReadPersistent	.\tests\profiledata_unittest.cc	/^static ssize_t ReadPersistent(const int fd, void *buf, const size_t count) {$/;"	f	namespace:__anon38
ReadStackTraces	.\malloc_extension.cc	/^void** MallocExtension::ReadStackTraces(int* sample_period) {$/;"	f	class:MallocExtension
ReadStackTraces	.\tcmalloc.cc	/^  virtual void** ReadStackTraces(int* sample_period) {$/;"	f	class:TCMallocImplementation
ReadStackTracesAndClear	.\stack_trace_table.cc	/^void** StackTraceTable::ReadStackTracesAndClear() {$/;"	f	class:tcmalloc::StackTraceTable
ReaderLock	.\base\simple_mutex.h	/^void Mutex::ReaderLock()   { Lock(); }      \/\/ we don't have read-write locks$/;"	f	class:MUTEX_NAMESPACE::Mutex
ReaderLock	.\base\simple_mutex.h	/^void Mutex::ReaderLock()   { Lock(); }$/;"	f	class:MUTEX_NAMESPACE::Mutex
ReaderLock	.\base\simple_mutex.h	/^void Mutex::ReaderLock()   { SAFE_PTHREAD(pthread_rwlock_rdlock); }$/;"	f	class:MUTEX_NAMESPACE::Mutex
ReaderLock	.\base\simple_mutex.h	/^void Mutex::ReaderLock()   { assert(++mutex_ > 0); }$/;"	f	class:MUTEX_NAMESPACE::Mutex
ReaderMutexLock	.\base\simple_mutex.h	/^  explicit ReaderMutexLock(Mutex *mu) : mu_(mu) { mu_->ReaderLock(); }$/;"	f	class:MUTEX_NAMESPACE::ReaderMutexLock
ReaderMutexLock	.\base\simple_mutex.h	/^class ReaderMutexLock {$/;"	c	namespace:MUTEX_NAMESPACE
ReaderMutexLock	.\base\simple_mutex.h	323;"	d
ReaderUnlock	.\base\simple_mutex.h	/^void Mutex::ReaderUnlock() { SAFE_PTHREAD(pthread_rwlock_unlock); }$/;"	f	class:MUTEX_NAMESPACE::Mutex
ReaderUnlock	.\base\simple_mutex.h	/^void Mutex::ReaderUnlock() { Unlock(); }$/;"	f	class:MUTEX_NAMESPACE::Mutex
ReaderUnlock	.\base\simple_mutex.h	/^void Mutex::ReaderUnlock() { assert(mutex_-- > 0); }$/;"	f	class:MUTEX_NAMESPACE::Mutex
Realname	.\tests\profiler_unittest.sh	/^Realname() {$/;"	f
RecomputePerThreadCacheSize	.\thread_cache.cc	/^void ThreadCache::RecomputePerThreadCacheSize() {$/;"	f	class:tcmalloc::ThreadCache
RecordAlloc	.\heap-profile-table.cc	/^void HeapProfileTable::RecordAlloc($/;"	f	class:HeapProfileTable
RecordAlloc	.\heap-profiler.cc	/^static void RecordAlloc(const void* ptr, size_t bytes, int skip_count) {$/;"	f	file:
RecordFree	.\heap-profile-table.cc	/^void HeapProfileTable::RecordFree(const void* ptr) {$/;"	f	class:HeapProfileTable
RecordFree	.\heap-profiler.cc	/^static void RecordFree(const void* ptr) {$/;"	f	file:
RecordGlobalDataLocked	.\heap-checker.cc	/^static void RecordGlobalDataLocked(uintptr_t start_address,$/;"	f	file:
RecordGrowth	.\page_heap.cc	/^static void RecordGrowth(size_t growth) {$/;"	f	namespace:tcmalloc
RecordRegionAddition	.\memory_region_map.cc	/^void MemoryRegionMap::RecordRegionAddition(const void* start, size_t size) {$/;"	f	class:MemoryRegionMap
RecordRegionRemoval	.\memory_region_map.cc	/^void MemoryRegionMap::RecordRegionRemoval(const void* start, size_t size) {$/;"	f	class:MemoryRegionMap
RecordRegionRemovalInBucket	.\memory_region_map.cc	/^void MemoryRegionMap::RecordRegionRemovalInBucket(int depth,$/;"	f	class:MemoryRegionMap
RecordSpan	.\page_heap.h	/^  void RecordSpan(Span* span) {$/;"	f	class:tcmalloc::PageHeap
Region	.\memory_region_map.h	/^  struct Region {$/;"	s	class:MemoryRegionMap
RegionCmp	.\memory_region_map.h	/^  struct RegionCmp {$/;"	s	class:MemoryRegionMap
RegionIterator	.\memory_region_map.h	/^  typedef RegionSet::const_iterator RegionIterator;$/;"	t	class:MemoryRegionMap
RegionSet	.\memory_region_map.h	/^              STL_Allocator<Region, MyAllocator> > RegionSet;$/;"	t	class:MemoryRegionMap
RegionSetRep	.\memory_region_map.cc	/^union MemoryRegionMap::RegionSetRep {$/;"	u	class:MemoryRegionMap	file:
Register	.\malloc_extension.cc	/^void MallocExtension::Register(MallocExtension* implementation) {$/;"	f	class:MallocExtension
RegisterCallback	.\profile-handler.cc	/^ProfileHandlerToken* ProfileHandler::RegisterCallback($/;"	f	class:ProfileHandler
RegisterCallback	.\tests\profile-handler_unittest.cc	/^  ProfileHandlerToken* RegisterCallback(void* callback_arg) {$/;"	f	class:__anon37::ProfileHandlerTest
RegisterFailure	.\tests\profiler_unittest.sh	/^RegisterFailure() {$/;"	f
RegisterSizeClass	.\page_heap.cc	/^void PageHeap::RegisterSizeClass(Span* span, size_t sc) {$/;"	f	class:tcmalloc::PageHeap
RegisterStackLocked	.\heap-checker.cc	/^static void RegisterStackLocked(const void* top_ptr) {$/;"	f	file:
RegisterSystemAllocator	.\windows\system-alloc.cc	/^bool RegisterSystemAllocator(SysAllocator *allocator, int priority) {$/;"	f
RegisterThread	.\profile-handler.cc	/^void ProfileHandler::RegisterThread() {$/;"	f	class:ProfileHandler
Release	.\windows\preamble_patcher.cc	/^  unsigned char* Release() {$/;"	f	class:sidestep::DeleteUnsignedCharArray
ReleaseAtLeastNPages	.\page_heap.cc	/^Length PageHeap::ReleaseAtLeastNPages(Length num_pages) {$/;"	f	class:tcmalloc::PageHeap
ReleaseFreeMemory	.\malloc_extension.cc	/^void MallocExtension::ReleaseFreeMemory() {$/;"	f	class:MallocExtension
ReleaseLastNormalSpan	.\page_heap.cc	/^Length PageHeap::ReleaseLastNormalSpan(SpanList* slist) {$/;"	f	class:tcmalloc::PageHeap
ReleaseListToSpans	.\central_freelist.cc	/^void CentralFreeList::ReleaseListToSpans(void* start) {$/;"	f	class:tcmalloc::CentralFreeList
ReleaseSnapshot	.\heap-profile-table.cc	/^void HeapProfileTable::ReleaseSnapshot(Snapshot* s) {$/;"	f	class:HeapProfileTable
ReleaseToCentralCache	.\thread_cache.cc	/^void ThreadCache::ReleaseToCentralCache(FreeList* src, size_t cl, int N) {$/;"	f	class:tcmalloc::ThreadCache
ReleaseToSpans	.\central_freelist.cc	/^void CentralFreeList::ReleaseToSpans(void* object) {$/;"	f	class:tcmalloc::CentralFreeList
ReleaseToSystem	.\malloc_extension.cc	/^void MallocExtension::ReleaseToSystem(size_t num_bytes) {$/;"	f	class:MallocExtension
ReleaseToSystem	.\tcmalloc.cc	/^  virtual void ReleaseToSystem(size_t num_bytes) {$/;"	f	class:TCMallocImplementation
Release_AtomicExchange	.\base\atomicops-internals-arm-generic.h	/^inline Atomic32 Release_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
Release_AtomicExchange	.\base\atomicops-internals-arm-generic.h	/^inline Atomic64 Release_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
Release_AtomicExchange	.\base\atomicops-internals-arm-v6plus.h	/^inline Atomic32 Release_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
Release_AtomicExchange	.\base\atomicops-internals-arm-v6plus.h	/^inline Atomic64 Release_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
Release_AtomicExchange	.\base\atomicops-internals-gcc.h	/^inline Atomic32 Release_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
Release_AtomicExchange	.\base\atomicops-internals-gcc.h	/^inline Atomic64 Release_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
Release_AtomicExchange	.\base\atomicops-internals-linuxppc.h	/^inline Atomic32 Release_AtomicExchange(volatile Atomic32 *ptr,$/;"	f	namespace:base::subtle
Release_AtomicExchange	.\base\atomicops-internals-linuxppc.h	/^inline Atomic64 Release_AtomicExchange(volatile Atomic64 *ptr,$/;"	f	namespace:base::subtle
Release_AtomicExchange	.\base\atomicops-internals-macosx.h	/^inline Atomic32 Release_AtomicExchange(volatile Atomic32 *ptr,$/;"	f	namespace:base::subtle
Release_AtomicExchange	.\base\atomicops-internals-macosx.h	/^inline Atomic64 Release_AtomicExchange(volatile Atomic64 *ptr,$/;"	f	namespace:base::subtle
Release_AtomicExchange	.\base\atomicops-internals-mips.h	/^inline Atomic32 Release_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
Release_AtomicExchange	.\base\atomicops-internals-mips.h	/^inline Atomic64 Release_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
Release_AtomicExchange	.\base\atomicops-internals-windows.h	/^inline Atomic32 Release_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
Release_AtomicExchange	.\base\atomicops-internals-windows.h	/^inline Atomic64 Release_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
Release_AtomicExchange	.\base\atomicops-internals-x86.h	/^inline Atomic32 Release_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
Release_AtomicExchange	.\base\atomicops-internals-x86.h	/^inline Atomic64 Release_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
Release_AtomicExchange	.\base\atomicops.h	/^inline AtomicWord Release_AtomicExchange(volatile AtomicWord* ptr,$/;"	f	namespace:base::subtle
Release_CompareAndSwap	.\base\atomicops-internals-arm-generic.h	/^inline Atomic32 Release_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
Release_CompareAndSwap	.\base\atomicops-internals-arm-generic.h	/^inline Atomic64 Release_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
Release_CompareAndSwap	.\base\atomicops-internals-arm-v6plus.h	/^inline Atomic32 Release_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
Release_CompareAndSwap	.\base\atomicops-internals-arm-v6plus.h	/^inline Atomic64 Release_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
Release_CompareAndSwap	.\base\atomicops-internals-gcc.h	/^inline Atomic32 Release_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
Release_CompareAndSwap	.\base\atomicops-internals-gcc.h	/^inline Atomic64 Release_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
Release_CompareAndSwap	.\base\atomicops-internals-linuxppc.h	/^inline Atomic32 Release_CompareAndSwap(volatile Atomic32 *ptr,$/;"	f	namespace:base::subtle
Release_CompareAndSwap	.\base\atomicops-internals-linuxppc.h	/^inline Atomic64 Release_CompareAndSwap(volatile Atomic64 *ptr,$/;"	f	namespace:base::subtle
Release_CompareAndSwap	.\base\atomicops-internals-macosx.h	/^inline Atomic32 Release_CompareAndSwap(volatile Atomic32 *ptr,$/;"	f	namespace:base::subtle
Release_CompareAndSwap	.\base\atomicops-internals-macosx.h	/^inline Atomic64 Release_CompareAndSwap(volatile Atomic64 *ptr,$/;"	f	namespace:base::subtle
Release_CompareAndSwap	.\base\atomicops-internals-mips.h	/^inline Atomic32 Release_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
Release_CompareAndSwap	.\base\atomicops-internals-mips.h	/^inline Atomic64 Release_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
Release_CompareAndSwap	.\base\atomicops-internals-windows.h	/^inline Atomic32 Release_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
Release_CompareAndSwap	.\base\atomicops-internals-windows.h	/^inline Atomic64 Release_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
Release_CompareAndSwap	.\base\atomicops-internals-x86.h	/^inline Atomic32 Release_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
Release_CompareAndSwap	.\base\atomicops-internals-x86.h	/^inline Atomic64 Release_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
Release_CompareAndSwap	.\base\atomicops.h	/^inline Atomic32 Release_CompareAndSwap(volatile Atomic32* ptr,$/;"	f
Release_CompareAndSwap	.\base\atomicops.h	/^inline AtomicWord Release_CompareAndSwap(volatile AtomicWord* ptr,$/;"	f	namespace:base::subtle
Release_CompareAndSwap	.\base\atomicops.h	/^inline AtomicWord Release_CompareAndSwap(volatile AtomicWord* ptr,$/;"	f
Release_CompareAndSwap	.\base\atomicops.h	/^inline base::subtle::Atomic64 Release_CompareAndSwap($/;"	f
Release_Load	.\base\atomicops-internals-arm-generic.h	/^inline Atomic32 Release_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle
Release_Load	.\base\atomicops-internals-arm-generic.h	/^inline Atomic64 Release_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle
Release_Load	.\base\atomicops-internals-arm-v6plus.h	/^inline Atomic32 Release_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle
Release_Load	.\base\atomicops-internals-arm-v6plus.h	/^inline Atomic64 Release_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle
Release_Load	.\base\atomicops-internals-gcc.h	/^inline Atomic32 Release_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle
Release_Load	.\base\atomicops-internals-gcc.h	/^inline Atomic64 Release_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle
Release_Load	.\base\atomicops-internals-linuxppc.h	/^inline Atomic32 Release_Load(volatile const Atomic32 *ptr) {$/;"	f	namespace:base::subtle
Release_Load	.\base\atomicops-internals-linuxppc.h	/^inline Atomic64 Release_Load(volatile const Atomic64 *ptr) {$/;"	f	namespace:base::subtle
Release_Load	.\base\atomicops-internals-macosx.h	/^inline Atomic32 Release_Load(volatile const Atomic32 *ptr) {$/;"	f	namespace:base::subtle
Release_Load	.\base\atomicops-internals-macosx.h	/^inline Atomic64 Release_Load(volatile const Atomic64 *ptr) {$/;"	f	namespace:base::subtle
Release_Load	.\base\atomicops-internals-mips.h	/^inline Atomic32 Release_Load(volatile const Atomic32* ptr)$/;"	f	namespace:base::subtle
Release_Load	.\base\atomicops-internals-mips.h	/^inline Atomic64 Release_Load(volatile const Atomic64* ptr)$/;"	f	namespace:base::subtle
Release_Load	.\base\atomicops-internals-windows.h	/^inline Atomic32 Release_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle
Release_Load	.\base\atomicops-internals-windows.h	/^inline Atomic64 Release_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle
Release_Load	.\base\atomicops-internals-x86.h	/^inline Atomic32 Release_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle
Release_Load	.\base\atomicops-internals-x86.h	/^inline Atomic64 Release_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle
Release_Load	.\base\atomicops.h	/^inline Atomic32 Release_Load(volatile const Atomic32* ptr) {$/;"	f
Release_Load	.\base\atomicops.h	/^inline AtomicWord Release_Load(volatile const AtomicWord* ptr) {$/;"	f	namespace:base::subtle
Release_Load	.\base\atomicops.h	/^inline AtomicWord Release_Load(volatile const AtomicWord* ptr) {$/;"	f
Release_Load	.\base\atomicops.h	/^inline base::subtle::Atomic64 Release_Load($/;"	f
Release_Store	.\base\atomicops-internals-arm-generic.h	/^inline void Release_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle
Release_Store	.\base\atomicops-internals-arm-generic.h	/^inline void Release_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle
Release_Store	.\base\atomicops-internals-arm-v6plus.h	/^inline void Release_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle
Release_Store	.\base\atomicops-internals-arm-v6plus.h	/^inline void Release_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle
Release_Store	.\base\atomicops-internals-gcc.h	/^inline void Release_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle
Release_Store	.\base\atomicops-internals-gcc.h	/^inline void Release_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle
Release_Store	.\base\atomicops-internals-linuxppc.h	/^inline void Release_Store(volatile Atomic32 *ptr, Atomic32 value) {$/;"	f	namespace:base::subtle
Release_Store	.\base\atomicops-internals-linuxppc.h	/^inline void Release_Store(volatile Atomic64 *ptr, Atomic64 value) {$/;"	f	namespace:base::subtle
Release_Store	.\base\atomicops-internals-macosx.h	/^inline void Release_Store(volatile Atomic32 *ptr, Atomic32 value) {$/;"	f	namespace:base::subtle
Release_Store	.\base\atomicops-internals-macosx.h	/^inline void Release_Store(volatile Atomic64 *ptr, Atomic64 value) {$/;"	f	namespace:base::subtle
Release_Store	.\base\atomicops-internals-mips.h	/^inline void Release_Store(volatile Atomic32* ptr, Atomic32 value)$/;"	f	namespace:base::subtle
Release_Store	.\base\atomicops-internals-mips.h	/^inline void Release_Store(volatile Atomic64* ptr, Atomic64 value)$/;"	f	namespace:base::subtle
Release_Store	.\base\atomicops-internals-windows.h	/^inline void Release_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle
Release_Store	.\base\atomicops-internals-windows.h	/^inline void Release_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle
Release_Store	.\base\atomicops-internals-x86.h	/^inline void Release_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle
Release_Store	.\base\atomicops-internals-x86.h	/^inline void Release_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle
Release_Store	.\base\atomicops.h	/^inline void Release_Store($/;"	f
Release_Store	.\base\atomicops.h	/^inline void Release_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f
Release_Store	.\base\atomicops.h	/^inline void Release_Store(volatile AtomicWord* ptr, AtomicWord value) {$/;"	f	namespace:base::subtle
Release_Store	.\base\atomicops.h	/^inline void Release_Store(volatile AtomicWord* ptr, AtomicWord value) {$/;"	f
Remove	.\malloc_hook.cc	/^bool HookList<T>::Remove(T value_as_t) {$/;"	f	class:base::internal::HookList
RemoveDeleteHook	.\gperftools\malloc_hook.h	/^  inline static bool RemoveDeleteHook(DeleteHook hook) {$/;"	f	class:MallocHook
RemoveFromFreeList	.\page_heap.cc	/^void PageHeap::RemoveFromFreeList(Span* span) {$/;"	f	class:tcmalloc::PageHeap
RemoveInitialHooksAndCallInitializers	.\malloc_hook.cc	/^void RemoveInitialHooksAndCallInitializers() {$/;"	f	namespace:__anon24
RemoveMmapHook	.\gperftools\malloc_hook.h	/^  inline static bool RemoveMmapHook(MmapHook hook) {$/;"	f	class:MallocHook
RemoveMmapReplacement	.\gperftools\malloc_hook.h	/^  inline static bool RemoveMmapReplacement(MmapReplacement hook) {$/;"	f	class:MallocHook
RemoveMremapHook	.\gperftools\malloc_hook.h	/^  inline static bool RemoveMremapHook(MremapHook hook) {$/;"	f	class:MallocHook
RemoveMunmapHook	.\gperftools\malloc_hook.h	/^  inline static bool RemoveMunmapHook(MunmapHook hook) {$/;"	f	class:MallocHook
RemoveMunmapReplacement	.\gperftools\malloc_hook.h	/^  inline static bool RemoveMunmapReplacement(MunmapReplacement hook) {$/;"	f	class:MallocHook
RemoveNewHook	.\gperftools\malloc_hook.h	/^  inline static bool RemoveNewHook(NewHook hook) {$/;"	f	class:MallocHook
RemovePreMmapHook	.\gperftools\malloc_hook.h	/^  inline static bool RemovePreMmapHook(PreMmapHook hook) {$/;"	f	class:MallocHook
RemovePreSbrkHook	.\gperftools\malloc_hook.h	/^  inline static bool RemovePreSbrkHook(PreSbrkHook hook) {$/;"	f	class:MallocHook
RemoveRange	.\central_freelist.cc	/^int CentralFreeList::RemoveRange(void **start, void **end, int N) {$/;"	f	class:tcmalloc::CentralFreeList
RemoveSbrkHook	.\gperftools\malloc_hook.h	/^  inline static bool RemoveSbrkHook(SbrkHook hook) {$/;"	f	class:MallocHook
ReplaceSystemAlloc	.\libc_override.h	/^static void ReplaceSystemAlloc() { PatchWindowsFunctions(); }$/;"	f
ReplaceSystemAlloc	.\libc_override_gcc_and_weak.h	/^static void ReplaceSystemAlloc() { }$/;"	f
ReplaceSystemAlloc	.\libc_override_osx.h	/^static void ReplaceSystemAlloc() {$/;"	f
ReplaceSystemAlloc	.\libc_override_redefine.h	/^static void ReplaceSystemAlloc() { }$/;"	f
ReportCallback	.\heap-profile-table.cc	/^void HeapProfileTable::Snapshot::ReportCallback(const void* ptr,$/;"	f	class:HeapProfileTable::Snapshot
ReportIndividualObjects	.\heap-profile-table.cc	/^void HeapProfileTable::Snapshot::ReportIndividualObjects() {$/;"	f	class:HeapProfileTable::Snapshot
ReportLargeAlloc	.\tcmalloc.cc	/^static void ReportLargeAlloc(Length num_pages, void* result) {$/;"	f	namespace:__anon34
ReportLeaks	.\heap-profile-table.cc	/^void HeapProfileTable::Snapshot::ReportLeaks(const char* checker_name,$/;"	f	class:HeapProfileTable::Snapshot
ReportObject	.\heap-profile-table.cc	/^void HeapProfileTable::Snapshot::ReportObject(const void* ptr,$/;"	f	class:HeapProfileTable::Snapshot
ReportState	.\heap-profile-table.cc	/^struct HeapProfileTable::Snapshot::ReportState {$/;"	s	class:HeapProfileTable::Snapshot	file:
Reset	.\profile-handler.cc	/^void ProfileHandler::Reset() {$/;"	f	class:ProfileHandler
Reset	.\profiledata.cc	/^void ProfileData::Reset() {$/;"	f	class:ProfileData
ResetUseEmergencyMalloc	.\thread_cache.h	/^inline void ThreadCache::ResetUseEmergencyMalloc() {$/;"	f	class:tcmalloc::ThreadCache
ResolveTarget	.\windows\preamble_patcher.h	/^  static T ResolveTarget(T target_function) {$/;"	f	class:sidestep::PreamblePatcher
ResolveTargetImpl	.\windows\preamble_patcher.cc	/^void* PreamblePatcher::ResolveTargetImpl(unsigned char* target,$/;"	f	class:sidestep::PreamblePatcher
RestoreSavedBucketsLocked	.\memory_region_map.cc	/^void MemoryRegionMap::RestoreSavedBucketsLocked() {$/;"	f	class:MemoryRegionMap
RoundUp	.\base\low_level_alloc.cc	/^static intptr_t RoundUp(intptr_t addr, intptr_t align) {$/;"	f	file:
RoundUp	.\debugallocation.cc	/^static intptr_t RoundUp(intptr_t value, intptr_t alignment) {$/;"	f	file:
RoutineCallingTheSignal	.\tests\getpc_test.cc	/^static void RoutineCallingTheSignal() {$/;"	f	file:
RtlCaptureStackBackTrace_Function	.\stacktrace_win32-inl.h	/^typedef USHORT NTAPI RtlCaptureStackBackTrace_Function($/;"	t
RtlCaptureStackBackTrace_fn	.\stacktrace_win32-inl.h	/^static RtlCaptureStackBackTrace_Function* const RtlCaptureStackBackTrace_fn =$/;"	v
Run	.\tests\heap-checker_unittest.cc	/^  virtual void Run() { (*f_)(); delete this; }$/;"	f	class:Callback0
Run	.\tests\heap-checker_unittest.cc	/^  virtual void Run() { (*f_)(p1_); delete this; }$/;"	f	class:Callback1
Run	.\tests\heap-checker_unittest.cc	/^  virtual void Run() { (*f_)(p1_, p2_); delete this; }$/;"	f	class:Callback2
Run	.\tests\profile-handler_unittest.cc	/^  void Run() {$/;"	f	class:__anon37::BusyThread	file:
Run	.\tests\profile-handler_unittest.cc	/^  void Run() {$/;"	f	class:__anon37::NullThread	file:
Run	.\tests\tcmalloc_unittest.cc	/^  virtual void Run() {$/;"	f	class:testing::TesterThread
RunAllTests	.\tests\tcmalloc_unittest.cc	/^static int RunAllTests(int argc, char** argv) {$/;"	f	namespace:testing
RunDisabledLeaks	.\tests\heap-checker_unittest.cc	/^static void* RunDisabledLeaks(void* a) {$/;"	f	file:
RunFunctionInThread	.\tests\testutil.cc	/^  DWORD WINAPI RunFunctionInThread(LPVOID ptr_to_ptr_to_fn) {$/;"	f
RunFunctionInThread	.\tests\testutil.cc	/^  static void* RunFunctionInThread(void *ptr_to_ptr_to_fn) {$/;"	f	file:
RunFunctionInThreadWithId	.\tests\testutil.cc	/^  DWORD WINAPI RunFunctionInThreadWithId(LPVOID ptr_to_fnid) {$/;"	f
RunFunctionInThreadWithId	.\tests\testutil.cc	/^  static void* RunFunctionInThreadWithId(void *ptr_to_fnid) {$/;"	f	file:
RunHeapBusyThreads	.\tests\heap-checker_unittest.cc	/^static void RunHeapBusyThreads() {$/;"	f	file:
RunHeapCleanups	.\heap-checker.cc	/^void HeapCleaner::RunHeapCleanups() {$/;"	f	class:HeapCleaner
RunHidden	.\tests\heap-checker_unittest.cc	/^static void RunHidden(Closure* c) {$/;"	f	file:
RunManyThreads	.\tests\testutil.cc	/^  void RunManyThreads(void (*fn)(), int count) {$/;"	f
RunManyThreads	.\tests\testutil.cc	/^extern "C" void RunManyThreads(void (*fn)(), int count) {$/;"	f
RunManyThreadsWithId	.\tests\testutil.cc	/^  void RunManyThreadsWithId(void (*fn)(int), int count, int stacksize) {$/;"	f
RunManyThreadsWithId	.\tests\testutil.cc	/^extern "C" void RunManyThreadsWithId(void (*fn)(int), int count, int) {$/;"	f
RunSilent	.\tests\heap-checker_unittest.cc	/^static bool RunSilent(HeapLeakChecker* check,$/;"	f	file:
RunThread	.\tests\tcmalloc_unittest.cc	/^static void RunThread(int thread_id) {$/;"	f	namespace:testing
RunThread	.\tests\testutil.cc	/^  void RunThread(void (*fn)()) {$/;"	f
RunThread	.\tests\testutil.cc	/^extern "C" void RunThread(void (*fn)()) {$/;"	f
RunningOnValgrind	.\base\dynamic_annotations.c	/^int RunningOnValgrind(void) {$/;"	f
SAFE_PTHREAD	.\base\simple_mutex.h	237;"	d
SAFE_PTHREAD	.\base\simple_mutex.h	256;"	d
SAFE_PTHREAD	.\base\simple_mutex.h	260;"	d
SAFE_PTHREAD	.\base\simple_mutex.h	279;"	d
SAFE_PTHREAD	.\tests\testutil.cc	163;"	d	file:
SAME_HEAP	.\tests\heap-checker_unittest.cc	/^enum CheckType { SAME_HEAP, NO_LEAKS };$/;"	e	enum:CheckType	file:
SA_RESTORER	.\base\linux_syscall_support.h	547;"	d
SCNd64	.\base\basictypes.h	102;"	d
SCNd64	.\windows\port.h	346;"	d
SCNx64	.\base\basictypes.h	96;"	d
SCNx64	.\windows\port.h	344;"	d
SCOPED_LOCKABLE	.\base\thread_annotations.h	112;"	d
SEARCH_CAP	.\windows\addr2line-pdb.c	48;"	d	file:
SEARCH_CAP	.\windows\nm-pdb.c	59;"	d	file:
SET_FRAME	.\base\elfcore.h	180;"	d
SET_FRAME	.\base\elfcore.h	241;"	d
SET_FRAME	.\base\elfcore.h	271;"	d
SET_FRAME	.\base\elfcore.h	334;"	d
SET_FRAME	.\base\elfcore.h	352;"	d
SHARED_LOCKS_REQUIRED	.\base\thread_annotations.h	96;"	d
SHARED_LOCK_FUNCTION	.\base\thread_annotations.h	118;"	d
SHARED_TRYLOCK_FUNCTION	.\base\thread_annotations.h	124;"	d
SIDESTEP_ACCESS_DENIED	.\windows\preamble_patcher.h	/^  SIDESTEP_ACCESS_DENIED,$/;"	e	enum:sidestep::SideStepError
SIDESTEP_ASSERT	.\windows\mini_disassembler.h	46;"	d
SIDESTEP_ASSERT	.\windows\preamble_patcher.h	46;"	d
SIDESTEP_CHK	.\windows\auto_testing_hook.h	39;"	d
SIDESTEP_EXPECT_TRUE	.\windows\auto_testing_hook.h	40;"	d
SIDESTEP_FUNCTION_TOO_SMALL	.\windows\preamble_patcher.h	/^  SIDESTEP_FUNCTION_TOO_SMALL,$/;"	e	enum:sidestep::SideStepError
SIDESTEP_INSUFFICIENT_BUFFER	.\windows\preamble_patcher.h	/^  SIDESTEP_INSUFFICIENT_BUFFER,$/;"	e	enum:sidestep::SideStepError
SIDESTEP_INVALID_PARAMETER	.\windows\preamble_patcher.h	/^  SIDESTEP_INVALID_PARAMETER,$/;"	e	enum:sidestep::SideStepError
SIDESTEP_JUMP_INSTRUCTION	.\windows\preamble_patcher.h	/^  SIDESTEP_JUMP_INSTRUCTION,$/;"	e	enum:sidestep::SideStepError
SIDESTEP_LOG	.\windows\mini_disassembler.h	47;"	d
SIDESTEP_LOG	.\windows\preamble_patcher.h	47;"	d
SIDESTEP_NO_SUCH_FUNCTION	.\windows\preamble_patcher.h	/^  SIDESTEP_NO_SUCH_FUNCTION,$/;"	e	enum:sidestep::SideStepError
SIDESTEP_NO_SUCH_MODULE	.\windows\preamble_patcher.h	/^  SIDESTEP_NO_SUCH_MODULE,$/;"	e	enum:sidestep::SideStepError
SIDESTEP_SUCCESS	.\windows\preamble_patcher.h	/^  SIDESTEP_SUCCESS = 0,$/;"	e	enum:sidestep::SideStepError
SIDESTEP_TO_HRESULT	.\windows\preamble_patcher.h	89;"	d
SIDESTEP_UNEXPECTED	.\windows\preamble_patcher.h	/^  SIDESTEP_UNEXPECTED,$/;"	e	enum:sidestep::SideStepError
SIDESTEP_UNSUPPORTED_INSTRUCTION	.\windows\preamble_patcher.h	/^  SIDESTEP_UNSUPPORTED_INSTRUCTION,$/;"	e	enum:sidestep::SideStepError
SIS_CONCAT	.\stacktrace_impl_setup-inl.h	42;"	d
SIS_CONCAT	.\stacktrace_impl_setup-inl.h	94;"	d
SIS_CONCAT2	.\stacktrace_impl_setup-inl.h	41;"	d
SIS_CONCAT2	.\stacktrace_impl_setup-inl.h	93;"	d
SIS_STRINGIFY	.\stacktrace_impl_setup-inl.h	44;"	d
SIS_STRINGIFY2	.\stacktrace_impl_setup-inl.h	45;"	d
SLL_Next	.\linked_list.h	/^inline void *SLL_Next(void *t) {$/;"	f	namespace:tcmalloc
SLL_Pop	.\linked_list.h	/^inline void *SLL_Pop(void **list) {$/;"	f	namespace:tcmalloc
SLL_PopRange	.\linked_list.h	/^inline void SLL_PopRange(void **head, int N, void **start, void **end) {$/;"	f	namespace:tcmalloc
SLL_Push	.\linked_list.h	/^inline void SLL_Push(void **list, void *element) {$/;"	f	namespace:tcmalloc
SLL_PushRange	.\linked_list.h	/^inline void SLL_PushRange(void **head, void *start, void *end) {$/;"	f	namespace:tcmalloc
SLL_SetNext	.\linked_list.h	/^inline void SLL_SetNext(void *t, void *n) {$/;"	f	namespace:tcmalloc
SLL_Size	.\linked_list.h	/^inline size_t SLL_Size(void *head) {$/;"	f	namespace:tcmalloc
SP	.\base\elfcore.h	114;"	d
SP	.\base\elfcore.h	71;"	d
SP	.\base\elfcore.h	95;"	d
SPAN_HISTORY	.\span.h	56;"	d
STACKTRACE_INL_HEADER	.\stacktrace.cc	105;"	d	file:
STACKTRACE_INL_HEADER	.\stacktrace.cc	109;"	d	file:
STACKTRACE_INL_HEADER	.\stacktrace.cc	114;"	d	file:
STACKTRACE_INL_HEADER	.\stacktrace.cc	118;"	d	file:
STACKTRACE_INL_HEADER	.\stacktrace.cc	124;"	d	file:
STACKTRACE_INL_HEADER	.\stacktrace.cc	126;"	d	file:
STACKTRACE_INL_HEADER	.\stacktrace.cc	131;"	d	file:
STACKTRACE_INL_HEADER	.\stacktrace.cc	136;"	d	file:
STACKTRACE_INL_HEADER	.\stacktrace.cc	140;"	d	file:
STACKTRACE_INL_HEADER	.\stacktrace.cc	145;"	d	file:
STACKTRACE_INL_HEADER	.\stacktrace.cc	149;"	d	file:
STACKTRACE_INL_HEADER	.\stacktrace.cc	156;"	d	file:
STACKTRACE_INL_HEADER	.\stacktrace.cc	160;"	d	file:
STACKTRACE_INL_HEADER	.\stacktrace.cc	85;"	d	file:
STACKTRACE_INL_HEADER	.\stacktrace.cc	89;"	d	file:
STACKTRACE_INL_HEADER	.\stacktrace.cc	94;"	d	file:
STACKTRACE_INL_HEADER	.\stacktrace.cc	98;"	d	file:
STDC_HEADERS	.\windows\config.h	284;"	d
STDERR_FILENO	.\windows\port.h	/^enum { STDIN_FILENO = 0, STDOUT_FILENO = 1, STDERR_FILENO = 2 };$/;"	e	enum:__anon56
STDIN_FILENO	.\windows\port.h	/^enum { STDIN_FILENO = 0, STDOUT_FILENO = 1, STDERR_FILENO = 2 };$/;"	e	enum:__anon56
STDOUT_FILENO	.\windows\port.h	/^enum { STDIN_FILENO = 0, STDOUT_FILENO = 1, STDERR_FILENO = 2 };$/;"	e	enum:__anon56
STL_Allocator	.\base\stl_allocator.h	/^  STL_Allocator() { }$/;"	f	class:STL_Allocator
STL_Allocator	.\base\stl_allocator.h	/^  STL_Allocator(const STL_Allocator&) { }$/;"	f	class:STL_Allocator
STL_Allocator	.\base\stl_allocator.h	/^  template <class T1> STL_Allocator(const STL_Allocator<T1, Alloc>&) { }$/;"	f	class:STL_Allocator
STL_Allocator	.\base\stl_allocator.h	/^class STL_Allocator {$/;"	c
STL_NAMESPACE	.\windows\config.h	287;"	d
SYM	.\windows\nm-pdb.c	/^} SYM;$/;"	t	typeref:struct:__anon50	file:
SYMBOLIZE	.\gperftools\heap-checker.h	/^  enum ShouldSymbolize { SYMBOLIZE, DO_NOT_SYMBOLIZE };$/;"	e	enum:HeapLeakChecker::ShouldSymbolize
SYM_CONTEXT	.\windows\nm-pdb.c	/^} SYM_CONTEXT;$/;"	t	typeref:struct:__anon51	file:
SYS_CPLUSPLUS	.\base\linuxthreads.cc	157;"	d	file:
SYS_ERRNO	.\base\linuxthreads.cc	158;"	d	file:
SYS_INLINE	.\base\linuxthreads.cc	159;"	d	file:
SYS_LINUX_SYSCALL_SUPPORT_H	.\base\linux_syscall_support.h	131;"	d
SYS_LINUX_SYSCALL_SUPPORT_H	.\base\linuxthreads.cc	161;"	d	file:
SYS_PREFIX	.\base\linuxthreads.cc	160;"	d	file:
SameHeap	.\gperftools\heap-checker.h	/^  bool SameHeap()      { return NoLeaks(); }$/;"	f	class:HeapLeakChecker
SampleAllocation	.\sampler.h	/^inline bool Sampler::SampleAllocation(size_t k) {$/;"	f	class:tcmalloc::Sampler
SampleAllocation	.\tests\sampler_test.cc	/^inline bool OldSampler::SampleAllocation(size_t k) {$/;"	f	class:OldSampler
SampleAllocation	.\thread_cache.h	/^inline bool ThreadCache::SampleAllocation(size_t k) {$/;"	f	class:tcmalloc::ThreadCache
Sampler	.\sampler.h	/^class PERFTOOLS_DLL_DECL Sampler {$/;"	c	namespace:tcmalloc
SbrkHook	.\gperftools\malloc_hook.h	/^  typedef MallocHook_SbrkHook SbrkHook;$/;"	t	class:MallocHook
SbrkHook	.\heap-profiler.cc	/^static void SbrkHook(const void* result, ptrdiff_t increment) {$/;"	f	file:
SbrkHook	.\memory_region_map.cc	/^void MemoryRegionMap::SbrkHook(const void* result, ptrdiff_t increment) {$/;"	f	class:MemoryRegionMap
SbrkSysAllocator	.\system-alloc.cc	/^  SbrkSysAllocator() : SysAllocator() {$/;"	f	class:SbrkSysAllocator
SbrkSysAllocator	.\system-alloc.cc	/^class SbrkSysAllocator : public SysAllocator {$/;"	c	file:
Scavenge	.\thread_cache.cc	/^void ThreadCache::Scavenge() {$/;"	f	class:tcmalloc::ThreadCache
ScopedDisabledLeaks	.\tests\heap-checker_unittest.cc	/^static void ScopedDisabledLeaks() {$/;"	f	file:
ScopedSignalBlocker	.\profile-handler.cc	/^  ScopedSignalBlocker(int signo) {$/;"	f	class:ScopedSignalBlocker
ScopedSignalBlocker	.\profile-handler.cc	/^class ScopedSignalBlocker {$/;"	c	file:
SearchFreeAndLargeLists	.\page_heap.cc	/^Span* PageHeap::SearchFreeAndLargeLists(Length n) {$/;"	f	class:tcmalloc::PageHeap
SetAggressiveDecommit	.\page_heap.h	/^  void SetAggressiveDecommit(bool aggressive_decommit) {$/;"	f	class:tcmalloc::PageHeap
SetBase	.\base\vdso_support.cc	/^const void *VDSOSupport::SetBase(const void *base) {$/;"	f	class:base::VDSOSupport
SetCheckCallback	.\tests\addressmap_unittest.cc	/^static void SetCheckCallback(const void* ptr, ValueT* val,$/;"	f	file:
SetChildAllocator	.\system-alloc.cc	/^  void SetChildAllocator(SysAllocator* alloc, unsigned int index,$/;"	f	class:DefaultSysAllocator
SetDeleteHook	.\gperftools\malloc_hook.h	/^  inline static DeleteHook SetDeleteHook(DeleteHook hook) {$/;"	f	class:MallocHook
SetIsSafe	.\base\simple_mutex.h	/^  inline void SetIsSafe() { is_safe_ = true; }$/;"	f	class:MUTEX_NAMESPACE::Mutex
SetJoinable	.\tests\profile-handler_unittest.cc	/^  void SetJoinable(bool value) { joinable_ = value; }$/;"	f	class:__anon37::Thread
SetMemoryReleaseRate	.\malloc_extension.cc	/^void MallocExtension::SetMemoryReleaseRate(double rate) {$/;"	f	class:MallocExtension
SetMemoryReleaseRate	.\tcmalloc.cc	/^  virtual void SetMemoryReleaseRate(double rate) {$/;"	f	class:TCMallocImplementation
SetMinSizeForSlowPath	.\thread_cache.h	/^inline void ThreadCache::SetMinSizeForSlowPath(size_t size) {$/;"	f	class:tcmalloc::ThreadCache
SetMmapHook	.\gperftools\malloc_hook.h	/^  inline static MmapHook SetMmapHook(MmapHook hook) {$/;"	f	class:MallocHook
SetMmapReplacement	.\gperftools\malloc_hook.h	/^  inline static bool SetMmapReplacement(MmapReplacement hook) {$/;"	f	class:MallocHook
SetMremapHook	.\gperftools\malloc_hook.h	/^  inline static MremapHook SetMremapHook(MremapHook hook) {$/;"	f	class:MallocHook
SetMunmapHook	.\gperftools\malloc_hook.h	/^  inline static MunmapHook SetMunmapHook(MunmapHook hook) {$/;"	f	class:MallocHook
SetMunmapReplacement	.\gperftools\malloc_hook.h	/^  inline static bool SetMunmapReplacement(MunmapReplacement hook) {$/;"	f	class:MallocHook
SetNewHook	.\gperftools\malloc_hook.h	/^  inline static NewHook SetNewHook(NewHook hook) {$/;"	f	class:MallocHook
SetNumericProperty	.\malloc_extension.cc	/^bool MallocExtension::SetNumericProperty(const char* property, size_t value) {$/;"	f	class:MallocExtension
SetNumericProperty	.\tcmalloc.cc	/^  virtual bool SetNumericProperty(const char* name, size_t value) {$/;"	f	class:TCMallocImplementation
SetPreMmapHook	.\gperftools\malloc_hook.h	/^  inline static PreMmapHook SetPreMmapHook(PreMmapHook hook) {$/;"	f	class:MallocHook
SetPreSbrkHook	.\gperftools\malloc_hook.h	/^  inline static PreSbrkHook SetPreSbrkHook(PreSbrkHook hook) {$/;"	f	class:MallocHook
SetRegionSetKey	.\memory_region_map.h	/^    void SetRegionSetKey(uintptr_t addr) {$/;"	f	struct:MemoryRegionMap::Region
SetSbrkHook	.\gperftools\malloc_hook.h	/^  inline static SbrkHook SetSbrkHook(SbrkHook hook) {$/;"	f	class:MallocHook
SetSystemAllocator	.\malloc_extension.cc	/^void MallocExtension::SetSystemAllocator(SysAllocator *a) {$/;"	f	class:MallocExtension
SetSystemAllocator	.\tcmalloc.cc	/^  virtual void SetSystemAllocator(SysAllocator* alloc) {$/;"	f	class:TCMallocImplementation
SetTestResourceLimit	.\tests\testutil.cc	/^void SetTestResourceLimit() {$/;"	f
SetUp	.\tests\profile-handler_unittest.cc	/^  virtual void SetUp() {$/;"	f	class:__anon37::ProfileHandlerTest
SetUpTestCase	.\tests\profile-handler_unittest.cc	/^  static void SetUpTestCase() {$/;"	f	class:__anon37::ProfileHandlerTest
SetUseEmergencyMalloc	.\thread_cache.h	/^inline void ThreadCache::SetUseEmergencyMalloc() {$/;"	f	class:tcmalloc::ThreadCache
SetupAtForkLocksHandler	.\static_vars.cc	/^void SetupAtForkLocksHandler()$/;"	f	namespace:tcmalloc
ShouldSymbolize	.\gperftools\heap-checker.h	/^  enum ShouldSymbolize { SYMBOLIZE, DO_NOT_SYMBOLIZE };$/;"	g	class:HeapLeakChecker
ShowSymbolInfo	.\windows\nm-pdb.c	/^static void ShowSymbolInfo(HANDLE process, ULONG64 module_base) {$/;"	f	file:
ShrinkHeap	.\tests\tcmalloc_unittest.cc	/^  void ShrinkHeap() {$/;"	f	class:testing::TesterThread
Shutdown	.\heap-checker.cc	/^  static void Shutdown() {$/;"	f	class:HeapLeakChecker::Allocator
Shutdown	.\memory_region_map.cc	/^bool MemoryRegionMap::Shutdown() {$/;"	f	class:MemoryRegionMap
SideStepError	.\windows\preamble_patcher.h	/^enum SideStepError {$/;"	g	namespace:sidestep
SignalHandler	.\base\linuxthreads.cc	/^static void SignalHandler(int signum, siginfo_t *si, void *data) {$/;"	f	file:
SignalHandler	.\profile-handler.cc	/^void ProfileHandler::SignalHandler(int sig, siginfo_t* sinfo, void* ucontext) {$/;"	f	class:ProfileHandler
Size	.\malloc_extension.cc	/^uintptr_t Size(void** entry) {$/;"	f	namespace:__anon23
Size	.\thread_cache.h	/^  size_t Size() const { return size_; }$/;"	f	class:tcmalloc::ThreadCache
SizeClass	.\common.h	/^  inline int SizeClass(size_t size) {$/;"	f	class:tcmalloc::SizeMap
SizeFunc	.\tests\addressmap_unittest.cc	/^size_t SizeFunc(const ValueT& v) { return v.second; }$/;"	f
SizeMap	.\common.h	/^  SizeMap() { }$/;"	f	class:tcmalloc::SizeMap
SizeMap	.\common.h	/^class SizeMap {$/;"	c	namespace:tcmalloc
Skewed	.\tests\tcmalloc_unittest.cc	/^  int Skewed(int max_log) {$/;"	f	class:testing::TestHarness
SkipWhileWhitespace	.\base\sysinfo.cc	/^static void SkipWhileWhitespace(char **text_pointer, int c) {$/;"	f	file:
Sleep	.\tests\malloc_hook_test.cc	/^void Sleep(int seconds) {$/;"	f	namespace:__anon35
SleepForMilliseconds	.\base\sysinfo.cc	/^void SleepForMilliseconds(int milliseconds) {$/;"	f
Slot	.\profiledata.h	/^  typedef uintptr_t Slot;$/;"	t	class:ProfileData
SlowLock	.\base\spinlock.cc	/^void SpinLock::SlowLock() {$/;"	f	class:SpinLock
SlowUnlock	.\base\spinlock.cc	/^void SpinLock::SlowUnlock() {$/;"	f	class:SpinLock
SmallSizeClass	.\common.h	/^  static inline size_t SmallSizeClass(size_t s) {$/;"	f	class:tcmalloc::SizeMap
SmallSpanStats	.\page_heap.h	/^  struct SmallSpanStats {$/;"	s	class:tcmalloc::PageHeap
Snapshot	.\heap-profile-table.h	/^  Snapshot(Allocator alloc, DeAllocator dealloc) : map_(alloc, dealloc) {$/;"	f	class:HeapProfileTable::Snapshot
Snapshot	.\heap-profile-table.h	/^class HeapProfileTable::Snapshot {$/;"	c	class:HeapProfileTable
Span	.\span.h	/^struct Span {$/;"	s	namespace:tcmalloc
SpanList	.\page_heap.h	/^  struct SpanList {$/;"	s	class:tcmalloc::PageHeap
SpanToMallocResult	.\tcmalloc.cc	/^static inline void* SpanToMallocResult(Span *span) {$/;"	f	file:
SpecificOpcode	.\windows\mini_disassembler_types.h	/^struct SpecificOpcode {$/;"	s	namespace:sidestep
SpinLock	.\base\spinlock.h	/^  SpinLock() : lockword_(kSpinLockFree) { }$/;"	f	class:SpinLock
SpinLock	.\base\spinlock.h	/^  explicit SpinLock(base::LinkerInitialized \/*x*\/) {$/;"	f	class:SpinLock
SpinLock	.\base\spinlock.h	/^class LOCKABLE SpinLock {$/;"	c
SpinLockDelay	.\base\spinlock_linux-inl.h	/^void SpinLockDelay(volatile Atomic32 *w, int32 value, int loop) {$/;"	f	namespace:base::internal
SpinLockDelay	.\base\spinlock_posix-inl.h	/^void SpinLockDelay(volatile Atomic32 *w, int32 value, int loop) {$/;"	f	namespace:base::internal
SpinLockDelay	.\base\spinlock_win32-inl.h	/^void SpinLockDelay(volatile Atomic32 *w, int32 value, int loop) {$/;"	f	namespace:base::internal
SpinLockHolder	.\base\spinlock.h	/^class SCOPED_LOCKABLE SpinLockHolder {$/;"	c
SpinLockHolder	.\base\spinlock.h	140;"	d
SpinLockWake	.\base\spinlock_linux-inl.h	/^void SpinLockWake(volatile Atomic32 *w, bool all) {$/;"	f	namespace:base::internal
SpinLockWake	.\base\spinlock_posix-inl.h	/^void SpinLockWake(volatile Atomic32 *w, bool all) {$/;"	f	namespace:base::internal
SpinLockWake	.\base\spinlock_win32-inl.h	/^void SpinLockWake(volatile Atomic32 *w, bool all) {$/;"	f	namespace:base::internal
SpinLock_InitHelper	.\base\spinlock.cc	/^  SpinLock_InitHelper() {$/;"	f	struct:__anon11::SpinLock_InitHelper
SpinLock_InitHelper	.\base\spinlock.cc	/^struct SpinLock_InitHelper {$/;"	s	namespace:__anon11	file:
SpinLoop	.\base\spinlock.cc	/^Atomic32 SpinLock::SpinLoop() {$/;"	f	class:SpinLock
SpinlockPause	.\base\spinlock.cc	/^inline void SpinlockPause(void) {$/;"	f	namespace:__anon11
Split	.\page_heap.cc	/^Span* PageHeap::Split(Span* span, Length n) {$/;"	f	class:tcmalloc::PageHeap
StackDirection	.\heap-checker.cc	/^enum StackDirection {$/;"	g	file:
StackTopSet	.\heap-checker.cc	/^           > StackTopSet;$/;"	t	file:
StackTrace	.\common.h	/^struct StackTrace {$/;"	s	namespace:tcmalloc
StackTraceTable	.\stack_trace_table.cc	/^StackTraceTable::StackTraceTable()$/;"	f	class:tcmalloc::StackTraceTable
StackTraceTable	.\stack_trace_table.h	/^class PERFTOOLS_DLL_DECL StackTraceTable {$/;"	c	namespace:tcmalloc
StacktraceArmDummyFunction	.\stacktrace_arm-inl.h	/^void StacktraceArmDummyFunction() { __asm__ volatile(""); }$/;"	f
StacktracePowerPCDummyFunction	.\stacktrace_powerpc-darwin-inl.h	/^void StacktracePowerPCDummyFunction() { __asm__ volatile(""); }$/;"	f
StacktracePowerPCDummyFunction	.\stacktrace_powerpc-inl.h	/^void StacktracePowerPCDummyFunction() { __asm__ volatile(""); }$/;"	f
StacktracePowerPCDummyFunction	.\stacktrace_powerpc-linux-inl.h	/^void StacktracePowerPCDummyFunction() { __asm__ volatile(""); }$/;"	f
StacktraceScope	.\stacktrace.cc	/^    StacktraceScope() {$/;"	f	class:__anon27::StacktraceScope
StacktraceScope	.\stacktrace.cc	/^  class StacktraceScope {$/;"	c	namespace:__anon27	file:
StandardDeviationsErrorInSample	.\tests\sampler_test.cc	/^double StandardDeviationsErrorInSample($/;"	f
Start	.\profiledata.cc	/^bool ProfileData::Start(const char* fname,$/;"	f	class:ProfileData
Start	.\profiler.cc	/^bool CpuProfiler::Start(const char* fname, const ProfilerOptions* options) {$/;"	f	class:CpuProfiler
Start	.\tests\profile-handler_unittest.cc	/^  void Start() {$/;"	f	class:__anon37::Thread
StartLinuxThreadTimer	.\profile-handler.cc	/^static void StartLinuxThreadTimer(int timer_type, int signal_number,$/;"	f	file:
StartWorker	.\tests\profile-handler_unittest.cc	/^  void StartWorker() {$/;"	f	class:__anon37::ProfileHandlerTest
State	.\profiledata.h	/^  struct State {$/;"	s	class:ProfileData
Static	.\static_vars.h	/^class Static {$/;"	c	namespace:tcmalloc
Stats	.\heap-profile-table.h	/^  typedef HeapProfileStats Stats;$/;"	t	class:HeapProfileTable
Stats	.\page_heap.h	/^    Stats() : system_bytes(0), free_bytes(0), unmapped_bytes(0), committed_bytes(0) {}$/;"	f	struct:tcmalloc::PageHeap::Stats
Stats	.\page_heap.h	/^  struct Stats {$/;"	s	class:tcmalloc::PageHeap
StatsCallback	.\debugallocation.cc	/^  static void StatsCallback(const void* ptr, int* type, int dummy) {$/;"	f	class:MallocBlock	file:
Stop	.\profiledata.cc	/^void ProfileData::Stop() {$/;"	f	class:ProfileData
Stop	.\profiledata.cc	/^void ProfileData::Stop(char* fname){$/;"	f	class:ProfileData
Stop	.\profiler.cc	/^void CpuProfiler::Stop(char* fname) {$/;"	f	class:CpuProfiler
StopWorker	.\tests\profile-handler_unittest.cc	/^  void StopWorker() {$/;"	f	class:__anon37::ProfileHandlerTest
StringPrintf	.\tests\sampler_test.cc	/^static std::string StringPrintf(const char* format, ...) {$/;"	f	file:
StringToBool	.\base\commandlineflags.h	/^    inline bool StringToBool(const char *value, bool def) {$/;"	f	namespace:tcmalloc::commandlineflags
StringToDouble	.\base\commandlineflags.h	/^    inline double StringToDouble(const char *value, double def) {$/;"	f	namespace:tcmalloc::commandlineflags
StringToInt	.\base\commandlineflags.h	/^    inline int StringToInt(const char *value, int def) {$/;"	f	namespace:tcmalloc::commandlineflags
StringToInteger	.\base\sysinfo.cc	/^int StringToInteger<int>(char *text, char **endptr, int base) {$/;"	f
StringToInteger	.\base\sysinfo.cc	/^int64 StringToInteger<int64>(char *text, char **endptr, int base) {$/;"	f
StringToInteger	.\base\sysinfo.cc	/^static T StringToInteger(char *text, char **endptr, int base) {$/;"	f	file:
StringToInteger	.\base\sysinfo.cc	/^uint64 StringToInteger<uint64>(char *text, char **endptr, int base) {$/;"	f
StringToIntegerUntilChar	.\base\sysinfo.cc	/^static T StringToIntegerUntilChar($/;"	f	file:
StringToIntegerUntilCharWithCheck	.\base\sysinfo.cc	/^static bool StringToIntegerUntilCharWithCheck($/;"	f	file:
StringToLongLong	.\base\commandlineflags.h	/^    inline long long StringToLongLong(const char *value, long long def) {$/;"	f	namespace:tcmalloc::commandlineflags
SuggestPprofCommand	.\heap-checker.cc	/^static void SuggestPprofCommand(const char* pprof_file_arg) {$/;"	f	file:
SuggestedDelayNS	.\base\spinlock_internal.cc	/^static int SuggestedDelayNS(int loop) {$/;"	f	namespace:base::internal
SymbolInfo	.\base\elf_mem_image.h	/^  struct SymbolInfo {$/;"	s	class:base::ElfMemImage
SymbolInfo	.\base\vdso_support.h	/^  typedef ElfMemImage::SymbolInfo SymbolInfo;$/;"	t	class:base::VDSOSupport
SymbolIterator	.\base\elf_mem_image.cc	/^ElfMemImage::SymbolIterator::SymbolIterator(const void *const image, int index)$/;"	f	class:base::ElfMemImage::SymbolIterator
SymbolIterator	.\base\elf_mem_image.h	/^  class SymbolIterator {$/;"	c	class:base::ElfMemImage
SymbolIterator	.\base\vdso_support.h	/^  typedef ElfMemImage::SymbolIterator SymbolIterator;$/;"	t	class:base::VDSOSupport
SymbolMap	.\symbolize.h	/^  typedef map<const void*, const char*> SymbolMap;$/;"	t	class:SymbolTable
SymbolTable	.\symbolize.h	/^  SymbolTable()$/;"	f	class:SymbolTable
SymbolTable	.\symbolize.h	/^class SymbolTable {$/;"	c
Symbolize	.\symbolize.cc	/^int SymbolTable::Symbolize() {$/;"	f	class:SymbolTable
SysAllocator	.\gperftools\malloc_extension.h	/^  SysAllocator() {$/;"	f	class:SysAllocator
SysAllocator	.\gperftools\malloc_extension.h	/^class PERFTOOLS_DLL_DECL SysAllocator {$/;"	c
SysCalls	.\base\linuxthreads.cc	/^    SysCalls() : my_errno(0) { }$/;"	f	class:__anon2::SysCalls
SysCalls	.\base\linuxthreads.cc	/^  class SysCalls {$/;"	c	namespace:__anon2	file:
TCEntry	.\central_freelist.h	/^  struct TCEntry {$/;"	s	class:tcmalloc::CentralFreeList
TCMALLOC_CENTRAL_FREELIST_H_	.\central_freelist.h	35;"	d
TCMALLOC_COMMON_H_	.\common.h	37;"	d
TCMALLOC_DONT_PREFER_LIBUNWIND	.\stacktrace.cc	196;"	d	file:
TCMALLOC_INTERNAL_LOGGING_H_	.\internal_logging.h	37;"	d
TCMALLOC_LIBC_OVERRIDE_GCC_AND_WEAK_INL_H_	.\libc_override_gcc_and_weak.h	40;"	d
TCMALLOC_LIBC_OVERRIDE_GLIBC_INL_H_	.\libc_override_glibc.h	37;"	d
TCMALLOC_LIBC_OVERRIDE_INL_H_	.\libc_override.h	53;"	d
TCMALLOC_LIBC_OVERRIDE_OSX_INL_H_	.\libc_override_osx.h	73;"	d
TCMALLOC_LIBC_OVERRIDE_REDEFINE_H_	.\libc_override_redefine.h	43;"	d
TCMALLOC_LINKED_LIST_H_	.\linked_list.h	38;"	d
TCMALLOC_PACKED_CACHE_INL_H_	.\packed-cache-inl.h	113;"	d
TCMALLOC_PAGEMAP_H_	.\pagemap.h	47;"	d
TCMALLOC_PAGE_HEAP_ALLOCATOR_H_	.\page_heap_allocator.h	35;"	d
TCMALLOC_PAGE_HEAP_H_	.\page_heap.h	35;"	d
TCMALLOC_SAMPLER_H_	.\sampler.h	37;"	d
TCMALLOC_SPAN_H_	.\span.h	37;"	d
TCMALLOC_STACK_TRACE_TABLE_H_	.\stack_trace_table.h	37;"	d
TCMALLOC_STATIC_VARS_H_	.\static_vars.h	37;"	d
TCMALLOC_SYMBOLIZE_H_	.\symbolize.h	35;"	d
TCMALLOC_SYSTEM_ALLOC_H_	.\system-alloc.h	38;"	d
TCMALLOC_TCMALLOC_GUARD_H_	.\tcmalloc_guard.h	41;"	d
TCMALLOC_TCMALLOC_H_	.\windows\gperftools\tcmalloc.h	37;"	d
TCMALLOC_THREAD_CACHE_H_	.\thread_cache.h	35;"	d
TCMALLOC_TOOLS_TESTUTIL_H_	.\tests\testutil.h	35;"	d
TCMALLOC_USING_DEBUGALLOCATION	.\debugallocation.cc	84;"	d	file:
TCMallocGetenvSafe	.\base\sysinfo.cc	/^  const char* TCMallocGetenvSafe(const char* name) {$/;"	f
TCMallocGuard	.\tcmalloc.cc	/^TCMallocGuard::TCMallocGuard() {$/;"	f	class:TCMallocGuard
TCMallocGuard	.\tcmalloc_guard.h	/^class TCMallocGuard {$/;"	c
TCMallocImplementation	.\tcmalloc.cc	/^  TCMallocImplementation()$/;"	f	class:TCMallocImplementation
TCMallocImplementation	.\tcmalloc.cc	/^class TCMallocImplementation : public MallocExtension {$/;"	c	file:
TCMallocStats	.\tcmalloc.cc	/^struct TCMallocStats {$/;"	s	file:
TCMalloc_ListAllProcessThreads	.\base\linuxthreads.cc	/^int TCMalloc_ListAllProcessThreads(void *parameter,$/;"	f
TCMalloc_ListAllProcessThreads	.\base\thread_lister.c	/^int TCMalloc_ListAllProcessThreads(void *parameter,$/;"	f
TCMalloc_PageMap1	.\pagemap.h	/^  explicit TCMalloc_PageMap1(void* (*allocator)(size_t)) {$/;"	f	class:TCMalloc_PageMap1
TCMalloc_PageMap1	.\pagemap.h	/^class TCMalloc_PageMap1 {$/;"	c
TCMalloc_PageMap2	.\pagemap.h	/^  explicit TCMalloc_PageMap2(void* (*allocator)(size_t)) {$/;"	f	class:TCMalloc_PageMap2
TCMalloc_PageMap2	.\pagemap.h	/^class TCMalloc_PageMap2 {$/;"	c
TCMalloc_PageMap3	.\pagemap.h	/^  explicit TCMalloc_PageMap3(void* (*allocator)(size_t)) {$/;"	f	class:TCMalloc_PageMap3
TCMalloc_PageMap3	.\pagemap.h	/^class TCMalloc_PageMap3 {$/;"	c
TCMalloc_Printer	.\internal_logging.h	/^  TCMalloc_Printer(char* buf, int length) : buf_(buf), left_(length) {$/;"	f	class:TCMalloc_Printer
TCMalloc_Printer	.\internal_logging.h	/^class TCMalloc_Printer {$/;"	c
TCMalloc_ResumeAllProcessThreads	.\base\linuxthreads.cc	/^int TCMalloc_ResumeAllProcessThreads(int num_threads, pid_t *thread_pids) {$/;"	f
TCMalloc_ResumeAllProcessThreads	.\base\thread_lister.c	/^int TCMalloc_ResumeAllProcessThreads(int num_threads, pid_t *thread_pids) {$/;"	f
TCMalloc_SystemAlloc	.\system-alloc.cc	/^void* TCMalloc_SystemAlloc(size_t size, size_t *actual_size,$/;"	f
TCMalloc_SystemAlloc	.\windows\system-alloc.cc	/^void* TCMalloc_SystemAlloc(size_t size, size_t *actual_size,$/;"	f
TCMalloc_SystemCommit	.\system-alloc.cc	/^void TCMalloc_SystemCommit(void* start, size_t length) {$/;"	f
TCMalloc_SystemCommit	.\windows\system-alloc.cc	/^void TCMalloc_SystemCommit(void* start, size_t length) {$/;"	f
TCMalloc_SystemRelease	.\system-alloc.cc	/^bool TCMalloc_SystemRelease(void* start, size_t length) {$/;"	f
TCMalloc_SystemRelease	.\windows\system-alloc.cc	/^bool TCMalloc_SystemRelease(void* start, size_t length) {$/;"	f
TCMalloc_SystemTaken	.\system-alloc.cc	/^size_t TCMalloc_SystemTaken = 0;$/;"	v
TCMalloc_SystemTaken	.\windows\system-alloc.cc	/^size_t TCMalloc_SystemTaken = 0;$/;"	v
TC_ALIAS	.\tcmalloc.cc	1594;"	d	file:
TC_VERSION_MAJOR	.\windows\gperftools\tcmalloc.h	42;"	d
TC_VERSION_MINOR	.\windows\gperftools\tcmalloc.h	43;"	d
TC_VERSION_PATCH	.\windows\gperftools\tcmalloc.h	44;"	d
TC_VERSION_STRING	.\windows\gperftools\tcmalloc.h	45;"	d
TClass	.\tests\heap-checker_unittest.cc	/^  explicit TClass(int a) : ptr(NULL) { }$/;"	f	class:TClass
TClass	.\tests\heap-checker_unittest.cc	/^class TClass {$/;"	c	file:
TEST	.\tests\debugallocation_test.cc	/^TEST(DebugAllocationTest, CurrentlyAllocated) {$/;"	f
TEST	.\tests\debugallocation_test.cc	/^TEST(DebugAllocationTest, DanglingPointerWriteTest) {$/;"	f
TEST	.\tests\debugallocation_test.cc	/^TEST(DebugAllocationTest, DanglingWriteAtExitTest) {$/;"	f
TEST	.\tests\debugallocation_test.cc	/^TEST(DebugAllocationTest, DeallocMismatch) {$/;"	f
TEST	.\tests\debugallocation_test.cc	/^TEST(DebugAllocationTest, DoubleFree) {$/;"	f
TEST	.\tests\debugallocation_test.cc	/^TEST(DebugAllocationTest, FreeQueueTest) {$/;"	f
TEST	.\tests\debugallocation_test.cc	/^TEST(DebugAllocationTest, GetAllocatedSizeTest) {$/;"	f
TEST	.\tests\debugallocation_test.cc	/^TEST(DebugAllocationTest, HugeAlloc) {$/;"	f
TEST	.\tests\debugallocation_test.cc	/^TEST(DebugAllocationTest, ReallocAfterMemalign) {$/;"	f
TEST	.\tests\debugallocation_test.cc	/^TEST(DebugAllocationTest, StackTraceWithDanglingWriteAtExitTest) {$/;"	f
TEST	.\tests\debugallocation_test.cc	/^TEST(DebugAllocationTest, StompAfter) {$/;"	f
TEST	.\tests\debugallocation_test.cc	/^TEST(DebugAllocationTest, StompBefore) {$/;"	f
TEST	.\tests\debugallocation_test.cc	46;"	d	file:
TEST	.\tests\malloc_hook_test.cc	/^TEST(HookListTest, AddAppends) {$/;"	f	namespace:__anon35
TEST	.\tests\malloc_hook_test.cc	/^TEST(HookListTest, AddPrependsAfterRemove) {$/;"	f	namespace:__anon35
TEST	.\tests\malloc_hook_test.cc	/^TEST(HookListTest, CanRemoveInitialValue) {$/;"	f	namespace:__anon35
TEST	.\tests\malloc_hook_test.cc	/^TEST(HookListTest, FillUpTheList) {$/;"	f	namespace:__anon35
TEST	.\tests\malloc_hook_test.cc	/^TEST(HookListTest, InitialValueExists) {$/;"	f	namespace:__anon35
TEST	.\tests\malloc_hook_test.cc	/^TEST(HookListTest, InvalidAddRejected) {$/;"	f	namespace:__anon35
TEST	.\tests\malloc_hook_test.cc	/^TEST(HookListTest, MultithreadedTest) {$/;"	f	namespace:__anon35
TEST	.\tests\malloc_hook_test.cc	/^TEST(HookListTest, RemoveWorksAndWillClearSize) {$/;"	f	namespace:__anon35
TEST	.\tests\malloc_hook_test.cc	/^TEST(MallocMookTest, MmapReplacements) {$/;"	f	namespace:__anon35
TEST	.\tests\malloc_hook_test.cc	66;"	d	file:
TEST	.\tests\raw_printer_test.cc	/^TEST(RawPrinter, Empty) {$/;"	f
TEST	.\tests\raw_printer_test.cc	/^TEST(RawPrinter, ExactlyFilled) {$/;"	f
TEST	.\tests\raw_printer_test.cc	/^TEST(RawPrinter, PartiallyFilled) {$/;"	f
TEST	.\tests\raw_printer_test.cc	/^TEST(RawPrinter, Truncated) {$/;"	f
TEST	.\tests\raw_printer_test.cc	15;"	d	file:
TEST	.\tests\sampler_test.cc	/^TEST(Sample, size_of_class) {$/;"	f
TEST	.\tests\sampler_test.cc	/^TEST(Sampler, FastLog2) {$/;"	f
TEST	.\tests\sampler_test.cc	/^TEST(Sampler, IsMeanRight) {$/;"	f
TEST	.\tests\sampler_test.cc	/^TEST(Sampler, LargeAndSmallAllocs_CombinedTest) {$/;"	f
TEST	.\tests\sampler_test.cc	/^TEST(Sampler, NextRand_range) {$/;"	f
TEST	.\tests\sampler_test.cc	/^TEST(Sampler, TestGetSamplePeriod) {$/;"	f
TEST	.\tests\sampler_test.cc	/^TEST(Sampler, TestNextRandom_MultipleValues) {$/;"	f
TEST	.\tests\sampler_test.cc	/^TEST(Sampler, TestPickNextSample_MultipleValues) {$/;"	f
TEST	.\tests\sampler_test.cc	/^TEST(Sampler, arithmetic_1) {$/;"	f
TEST	.\tests\sampler_test.cc	/^TEST(Sampler, arithmetic_2) {$/;"	f
TEST	.\tests\sampler_test.cc	/^TEST(Sampler, bytes_until_sample_Overflow_Underflow) {$/;"	f
TEST	.\tests\sampler_test.cc	64;"	d	file:
TEST_F	.\tests\profile-handler_unittest.cc	/^TEST_F(ProfileHandlerTest, MultipleCallbacks) {$/;"	f	namespace:__anon37
TEST_F	.\tests\profile-handler_unittest.cc	/^TEST_F(ProfileHandlerTest, RegisterCallbackBeforeThread) {$/;"	f	namespace:__anon37
TEST_F	.\tests\profile-handler_unittest.cc	/^TEST_F(ProfileHandlerTest, RegisterUnregisterCallback) {$/;"	f	namespace:__anon37
TEST_F	.\tests\profile-handler_unittest.cc	/^TEST_F(ProfileHandlerTest, Reset) {$/;"	f	namespace:__anon37
TEST_F	.\tests\profile-handler_unittest.cc	23;"	d	file:
TEST_F	.\tests\profiledata_unittest.cc	/^TEST_F(ProfileDataTest, CollectOne) {$/;"	f	namespace:__anon38
TEST_F	.\tests\profiledata_unittest.cc	/^TEST_F(ProfileDataTest, CollectTwoFlush) {$/;"	f	namespace:__anon38
TEST_F	.\tests\profiledata_unittest.cc	/^TEST_F(ProfileDataTest, CollectTwoMatching) {$/;"	f	namespace:__anon38
TEST_F	.\tests\profiledata_unittest.cc	/^TEST_F(ProfileDataTest, OpsWhenStopped) {$/;"	f	namespace:__anon38
TEST_F	.\tests\profiledata_unittest.cc	/^TEST_F(ProfileDataTest, StartResetRestart) {$/;"	f	namespace:__anon38
TEST_F	.\tests\profiledata_unittest.cc	/^TEST_F(ProfileDataTest, StartStopEmpty) {$/;"	f	namespace:__anon38
TEST_F	.\tests\profiledata_unittest.cc	/^TEST_F(ProfileDataTest, StartStopEmpty2) {$/;"	f	namespace:__anon38
TEST_F	.\tests\profiledata_unittest.cc	/^TEST_F(ProfileDataTest, StartStopNoOptionsEmpty) {$/;"	f	namespace:__anon38
TEST_F	.\tests\profiledata_unittest.cc	/^TEST_F(ProfileDataTest, StartWhenStarted) {$/;"	f	namespace:__anon38
TEST_F	.\tests\profiledata_unittest.cc	55;"	d	file:
TH32CS_SNAPMODULE32	.\base\sysinfo.cc	79;"	d	file:
THREADS	.\base\linuxthreads.h	50;"	d
THREAD_ANNOTATION_ATTRIBUTE__	.\base\thread_annotations.h	52;"	d
THREAD_ANNOTATION_ATTRIBUTE__	.\base\thread_annotations.h	54;"	d
THREAD_ATOMICOPS_H_	.\base\atomicops.h	78;"	d
THREAD_DATA	.\heap-checker.cc	/^  THREAD_DATA,       \/\/ Part of a thread stack and a thread descriptor with TLS$/;"	e	enum:ObjectPlacement	file:
THREAD_REGISTERS	.\heap-checker.cc	/^  THREAD_REGISTERS,  \/\/ Values in registers of some thread$/;"	e	enum:ObjectPlacement	file:
THREAD_REGS	.\heap-checker.cc	1037;"	d	file:
THREAD_REGS	.\heap-checker.cc	1039;"	d	file:
TOP_STACK	.\stacktrace_powerpc-inl.h	106;"	d
TOP_STACK	.\stacktrace_powerpc-inl.h	113;"	d
T_should_fit_in_AtomicWord	.\malloc_hook-inl.h	/^  COMPILE_ASSERT(sizeof(T) <= sizeof(AtomicWord), T_should_fit_in_AtomicWord);$/;"	m	struct:base::internal::HookList
Tag	.\internal_logging.h	/^  enum Tag {$/;"	g	class:tcmalloc::LogItem
TakeSnapshot	.\heap-profile-table.cc	/^HeapProfileTable::Snapshot* HeapProfileTable::TakeSnapshot() {$/;"	f	class:HeapProfileTable
TearDown	.\tests\profile-handler_unittest.cc	/^  virtual void TearDown() {$/;"	f	class:__anon37::ProfileHandlerTest
Test	.\tests\heap-checker-death_unittest.sh	/^Test() {$/;"	f
Test	.\tests\low_level_alloc_unittest.cc	/^static void Test(bool use_new_arena, bool call_malloc_hook, int n) {$/;"	f	file:
TestAggressiveDecommit	.\tests\tcmalloc_unittest.cc	/^static void TestAggressiveDecommit() {$/;"	f	namespace:testing
TestAlignmentForSize	.\tests\tcmalloc_unittest.cc	/^static void TestAlignmentForSize(int size) {$/;"	f	namespace:testing
TestAllocation	.\tests\markidle_unittest.cc	/^static void TestAllocation() {$/;"	f	file:
TestAtomicExchange	.\tests\atomicops_unittest.cc	/^static void TestAtomicExchange(AtomicType (*atomic_exchange_func)$/;"	f	file:
TestAtomicOps	.\tests\atomicops_unittest.cc	/^static void TestAtomicOps() {$/;"	f	file:
TestBasicInvoked	.\tests\system-alloc_unittest.cc	/^static void TestBasicInvoked() {$/;"	f	file:
TestBasicRetryFailTest	.\tests\system-alloc_unittest.cc	/^static void TestBasicRetryFailTest() {$/;"	f	file:
TestCalloc	.\tests\tcmalloc_unittest.cc	/^static void TestCalloc(size_t n, size_t s, bool ok) {$/;"	f	namespace:testing
TestCompareAndSwap	.\tests\atomicops_unittest.cc	/^static void TestCompareAndSwap(AtomicType (*compare_and_swap_func)$/;"	f	file:
TestDeleteHook	.\tests\malloc_extension_c_test.c	/^void TestDeleteHook(const void* ptr) {$/;"	f
TestDisassembler	.\windows\preamble_patcher_test.cc	/^bool TestDisassembler() {$/;"	f	namespace:sidestep
TestDumpHeapProfiler	.\tests\heap-profiler_unittest.cc	/^static void TestDumpHeapProfiler() {$/;"	f	file:
TestErrno	.\tests\tcmalloc_unittest.cc	/^static void TestErrno(void) {$/;"	f	namespace:testing
TestHarness	.\tests\tcmalloc_unittest.cc	/^  TestHarness(int seed)$/;"	f	class:testing::TestHarness
TestHarness	.\tests\tcmalloc_unittest.cc	/^class TestHarness {$/;"	c	namespace:testing	file:
TestHeapLeakChecker	.\tests\heap-checker_unittest.cc	/^static void TestHeapLeakChecker() {$/;"	f	file:
TestHeapLeakCheckerDeathCountLess	.\tests\heap-checker_unittest.cc	/^static void TestHeapLeakCheckerDeathCountLess() {$/;"	f	file:
TestHeapLeakCheckerDeathCountMore	.\tests\heap-checker_unittest.cc	/^static void TestHeapLeakCheckerDeathCountMore() {$/;"	f	file:
TestHeapLeakCheckerDeathInverse	.\tests\heap-checker_unittest.cc	/^static void TestHeapLeakCheckerDeathInverse() {$/;"	f	file:
TestHeapLeakCheckerDeathLoop	.\tests\heap-checker_unittest.cc	/^static void TestHeapLeakCheckerDeathLoop() {$/;"	f	file:
TestHeapLeakCheckerDeathNoLeaks	.\tests\heap-checker_unittest.cc	/^static void TestHeapLeakCheckerDeathNoLeaks() {$/;"	f	file:
TestHeapLeakCheckerDeathSimple	.\tests\heap-checker_unittest.cc	/^static void TestHeapLeakCheckerDeathSimple() {$/;"	f	file:
TestHeapLeakCheckerDeathTrick	.\tests\heap-checker_unittest.cc	/^static void TestHeapLeakCheckerDeathTrick() {$/;"	f	file:
TestHeapLeakCheckerDisabling	.\tests\heap-checker_unittest.cc	/^static void TestHeapLeakCheckerDisabling() {$/;"	f	file:
TestHeapLeakCheckerLiveness	.\tests\heap-checker_unittest.cc	/^static void TestHeapLeakCheckerLiveness() {$/;"	f	file:
TestHeapLeakCheckerNoFalsePositives	.\tests\heap-checker_unittest.cc	/^static void TestHeapLeakCheckerNoFalsePositives() {$/;"	f	file:
TestHeapProfilerStartStopIsRunning	.\tests\heap-profiler_unittest.cc	/^static void TestHeapProfilerStartStopIsRunning() {$/;"	f	file:
TestHiddenPointer	.\tests\heap-checker_unittest.cc	/^static void TestHiddenPointer() {$/;"	f	file:
TestHookList	.\tests\malloc_hook_test.cc	/^typedef base::internal::HookList<MallocHook::NewHook> TestHookList;$/;"	t	namespace:__anon35	file:
TestHookList_Add	.\tests\malloc_hook_test.cc	/^bool TestHookList_Add(TestHookList* list, int val) {$/;"	f	namespace:__anon35
TestHookList_Remove	.\tests\malloc_hook_test.cc	/^bool TestHookList_Remove(TestHookList* list, int val) {$/;"	f	namespace:__anon35
TestHookList_Traverse	.\tests\malloc_hook_test.cc	/^int TestHookList_Traverse(const TestHookList& list, uintptr_t* output_array, int n) {$/;"	f	namespace:__anon35
TestHugeAllocations	.\tests\tcmalloc_unittest.cc	/^static void TestHugeAllocations(AllocatorState* rnd) {$/;"	f	namespace:testing
TestHugeThreadCache	.\tests\tcmalloc_unittest.cc	/^static void TestHugeThreadCache() {$/;"	f	namespace:testing
TestIdleUsage	.\tests\markidle_unittest.cc	/^static void TestIdleUsage() {$/;"	f	file:
TestLRand64Spread	.\tests\sampler_test.cc	/^void TestLRand64Spread() {$/;"	f
TestLeakButTotalsMatch	.\tests\heap-checker_unittest.cc	/^static void TestLeakButTotalsMatch() {$/;"	f	file:
TestLibCAllocate	.\tests\heap-checker_unittest.cc	/^static void TestLibCAllocate() {$/;"	f	file:
TestLoad	.\tests\atomicops_unittest.cc	/^static void TestLoad() {$/;"	f	file:
TestMallocAlignment	.\tests\tcmalloc_unittest.cc	/^static void TestMallocAlignment() {$/;"	f	namespace:testing
TestMallocExtension	.\tests\malloc_extension_c_test.c	/^void TestMallocExtension(void) {$/;"	f
TestMallocHook	.\tests\malloc_extension_c_test.c	/^void TestMallocHook(void) {$/;"	f
TestMap	.\tests\pagemap_unittest.cc	/^void TestMap(int limit, bool limit_is_below_the_overflow_boundary) {$/;"	f
TestNew	.\tests\tcmalloc_unittest.cc	/^static void TestNew(void* (*func)(size_t)) {$/;"	f	namespace:testing
TestNewHandler	.\tests\tcmalloc_unittest.cc	/^static void TestNewHandler() throw (std::bad_alloc) {$/;"	f	namespace:testing
TestNewHook	.\tests\malloc_extension_c_test.c	/^void TestNewHook(const void* ptr, size_t size) {$/;"	f
TestNext	.\tests\pagemap_unittest.cc	/^void TestNext(const char* name) {$/;"	f
TestNextRandom	.\tests\sampler_test.cc	/^void TestNextRandom(int n) {$/;"	f
TestNothrowNew	.\tests\tcmalloc_unittest.cc	/^static void TestNothrowNew(void* (*func)(size_t, const std::nothrow_t&)) {$/;"	f	namespace:testing
TestObjMakers	.\tests\heap-checker_unittest.cc	/^static void TestObjMakers() {$/;"	f	file:
TestOneNew	.\tests\tcmalloc_unittest.cc	/^static void TestOneNew(void* (*func)(size_t)) {$/;"	f	namespace:testing
TestOneNothrowNew	.\tests\tcmalloc_unittest.cc	/^static void TestOneNothrowNew(void* (*func)(size_t, const std::nothrow_t&)) {$/;"	f	namespace:testing
TestPageHeap_Limit	.\tests\page_heap_test.cc	/^static void TestPageHeap_Limit() {$/;"	f	namespace:__anon36
TestPageHeap_Stats	.\tests\page_heap_test.cc	/^static void TestPageHeap_Stats() {$/;"	f	namespace:__anon36
TestPatchUsingDynamicStub	.\windows\preamble_patcher_test.cc	/^bool TestPatchUsingDynamicStub() {$/;"	f	namespace:sidestep
TestPatchWithLongJump	.\windows\preamble_patcher_test.cc	/^bool TestPatchWithLongJump() {$/;"	f	namespace:sidestep
TestPatchWithPreambleAbsoluteJump	.\windows\preamble_patcher_test.cc	/^bool TestPatchWithPreambleAbsoluteJump() {$/;"	f	namespace:sidestep
TestPatchWithPreambleNearRelativeCall	.\windows\preamble_patcher_test.cc	/^bool TestPatchWithPreambleNearRelativeCall() {$/;"	f	namespace:sidestep
TestPatchWithPreambleNearRelativeCondJump	.\windows\preamble_patcher_test.cc	/^bool TestPatchWithPreambleNearRelativeCondJump() {$/;"	f	namespace:sidestep
TestPatchWithPreambleShortCondJump	.\windows\preamble_patcher_test.cc	/^bool TestPatchWithPreambleShortCondJump() {$/;"	f	namespace:sidestep
TestPickNextSample	.\tests\sampler_test.cc	/^void TestPickNextSample(int n) {$/;"	f
TestPointerReach	.\tests\heap-checker_unittest.cc	/^static void TestPointerReach(ObjMakerFunc obj_maker) {$/;"	f	file:
TestPreambleAllocation	.\windows\preamble_patcher_test.cc	/^bool TestPreambleAllocation() {$/;"	f	namespace:sidestep
TestRanges	.\tests\tcmalloc_unittest.cc	/^static void TestRanges() {$/;"	f	namespace:testing
TestRealloc	.\tests\tcmalloc_unittest.cc	/^static void TestRealloc() {$/;"	f	namespace:testing
TestReleaseToSystem	.\tests\tcmalloc_unittest.cc	/^static void TestReleaseToSystem() {$/;"	f	namespace:testing
TestSTLAlloc	.\tests\heap-checker_unittest.cc	/^static void TestSTLAlloc() {$/;"	f	file:
TestSTLAllocInverse	.\tests\heap-checker_unittest.cc	/^static void TestSTLAllocInverse() {$/;"	f	file:
TestSetNewMode	.\tests\tcmalloc_unittest.cc	/^static void TestSetNewMode() {$/;"	f	namespace:testing
TestStore	.\tests\atomicops_unittest.cc	/^static void TestStore() {$/;"	f	file:
TestTemporarilyIdleUsage	.\tests\markidle_unittest.cc	/^static void TestTemporarilyIdleUsage() {$/;"	f	file:
TesterThread	.\tests\tcmalloc_unittest.cc	/^  TesterThread(int id)$/;"	f	class:testing::TesterThread
TesterThread	.\tests\tcmalloc_unittest.cc	/^class TesterThread {$/;"	c	namespace:testing	file:
Thread	.\tests\profile-handler_unittest.cc	/^  Thread() : joinable_(false) { }$/;"	f	class:__anon37::Thread
Thread	.\tests\profile-handler_unittest.cc	/^class Thread {$/;"	c	namespace:__anon37	file:
ThreadCache	.\thread_cache.h	/^class ThreadCache {$/;"	c	namespace:tcmalloc
ThreadDisabledLeaks	.\tests\heap-checker_unittest.cc	/^static void ThreadDisabledLeaks() {$/;"	f	file:
ThreadLocalData	.\thread_cache.h	/^  struct ThreadLocalData {$/;"	s	class:tcmalloc::ThreadCache
ThreadTimerDestructor	.\profile-handler.cc	/^  static void ThreadTimerDestructor(void *arg) {$/;"	f	file:
TickCounter	.\tests\profile-handler_unittest.cc	/^static void TickCounter(int sig, siginfo_t* sig_info, void *vuc,$/;"	f	namespace:__anon37
TooShortFunction	.\windows\shortproc.asm	/^TooShortFunction PROC$/;"	l
TraceFd	.\debugallocation.cc	/^static int TraceFd() {$/;"	f	file:
TracePrintf	.\debugallocation.cc	/^static void TracePrintf(int fd, const char *fmt, ...) {$/;"	f	file:
TraceStack	.\debugallocation.cc	/^static void TraceStack(void) {$/;"	f	file:
TransLeaks	.\tests\heap-checker_unittest.cc	/^static void TransLeaks() {$/;"	f	file:
Traverse	.\malloc_hook.cc	/^int HookList<T>::Traverse(T* output_array, int n) const {$/;"	f	class:base::internal::HookList
TryAllocExpectFail	.\tests\tcmalloc_large_unittest.cc	/^void TryAllocExpectFail(size_t size) {$/;"	f
TryAllocMightFail	.\tests\tcmalloc_large_unittest.cc	/^void TryAllocMightFail(size_t size) {$/;"	f
TryHugeAllocation	.\tests\tcmalloc_unittest.cc	/^static void TryHugeAllocation(size_t s, AllocatorState* rnd) {$/;"	f	namespace:testing
TryLock	.\base\simple_mutex.h	/^bool Mutex::TryLock()      { if (mutex_) return false; Lock(); return true; }$/;"	f	class:MUTEX_NAMESPACE::Mutex
TryLock	.\base\simple_mutex.h	/^bool Mutex::TryLock()      { return is_safe_ ?$/;"	f	class:MUTEX_NAMESPACE::Mutex
TurnItselfOffLocked	.\heap-checker.cc	/^void HeapLeakChecker::TurnItselfOffLocked() {$/;"	f	class:HeapLeakChecker
Type	.\gperftools\malloc_extension.h	/^  enum Type {$/;"	g	struct:base::MallocRange
Type	.\page_heap.h	/^  typedef TCMalloc_PageMap2<32-kPageShift> Type;$/;"	t	class:tcmalloc::MapSelector
Type	.\page_heap.h	/^  typedef TCMalloc_PageMap3<BITS-kPageShift> Type;$/;"	t	class:tcmalloc::MapSelector
Type	.\tests\tcmalloc_unittest.cc	/^  enum Type { ALLOC, FREE, UPDATE, PASS };$/;"	g	class:testing::TesterThread	file:
Type	.\tests\tcmalloc_unittest.cc	/^  struct Type {$/;"	s	class:testing::TestHarness	file:
UNKNOWN	.\gperftools\malloc_extension.h	/^    UNKNOWN$/;"	e	enum:base::MallocRange::Type
UNKNOWN_DIRECTION	.\heap-checker.cc	/^  UNKNOWN_DIRECTION$/;"	e	enum:StackDirection	file:
UNLIKELY	.\common.h	49;"	d
UNLIKELY	.\common.h	52;"	d
UNLOCK_FUNCTION	.\base\thread_annotations.h	127;"	d
UNMAPPED	.\gperftools\malloc_extension.h	/^    UNMAPPED,             \/\/ Backing physical memory has been returned to the OS$/;"	e	enum:base::MallocRange::Type
UNPATCH	.\windows\preamble_patcher_test.cc	63;"	d	file:
UNW_LOCAL_ONLY	.\stacktrace_libunwind-inl.h	42;"	d
UPDATE	.\tests\tcmalloc_unittest.cc	/^  enum Type { ALLOC, FREE, UPDATE, PASS };$/;"	e	enum:testing::TesterThread::Type	file:
UPPER	.\packed-cache-inl.h	/^  typedef T UPPER;$/;"	t	class:PackedCache
USE_RESOURCE	.\tests\testutil.cc	59;"	d	file:
UnHide	.\tests\heap-checker_unittest.cc	/^static void UnHide(T** ptr) {$/;"	f	file:
UnIgnoreObject	.\heap-checker.cc	/^void HeapLeakChecker::UnIgnoreObject(const void* ptr) {$/;"	f	class:HeapLeakChecker
UnMapPages	.\base\low_level_alloc.cc	/^void DefaultPagesAllocator::UnMapPages(int32 flags, void *region, size_t size) {$/;"	f	class:DefaultPagesAllocator
UnMapPages	.\emergency_malloc.cc	/^    void UnMapPages(int32 flags, void *addr, size_t size) {$/;"	f	class:tcmalloc::EmergencyArenaPagesAllocator	file:
UnhookedMMap	.\malloc_hook.cc	/^\/*static*\/void* MallocHook::UnhookedMMap(void *start, size_t length, int prot,$/;"	f	class:MallocHook
UnhookedMMap	.\malloc_hook_mmap_freebsd.h	/^\/*static*\/void* MallocHook::UnhookedMMap(void *start, size_t length, int prot,$/;"	f	class:MallocHook
UnhookedMMap	.\malloc_hook_mmap_linux.h	/^\/*static*\/void* MallocHook::UnhookedMMap(void *start, size_t length, int prot,$/;"	f	class:MallocHook
UnhookedMUnmap	.\malloc_hook.cc	/^\/*static*\/int MallocHook::UnhookedMUnmap(void *start, size_t length) {$/;"	f	class:MallocHook
UnhookedMUnmap	.\malloc_hook_mmap_freebsd.h	/^\/*static*\/int MallocHook::UnhookedMUnmap(void *start, size_t length) {$/;"	f	class:MallocHook
UnhookedMUnmap	.\malloc_hook_mmap_linux.h	/^\/*static*\/int MallocHook::UnhookedMUnmap(void *start, size_t length) {$/;"	f	class:MallocHook
Uniform	.\tests\addressmap_unittest.cc	/^  size_t Uniform(size_t max_size) {$/;"	f	struct:UniformRandomNumberGenerator
Uniform	.\tests\tcmalloc_unittest.cc	/^  int Uniform(int n) {$/;"	f	class:testing::TestHarness
UniformRandomNumberGenerator	.\tests\addressmap_unittest.cc	/^struct UniformRandomNumberGenerator {$/;"	s	file:
UnitTests	.\windows\preamble_patcher_test.cc	/^bool UnitTests() {$/;"	f	namespace:sidestep
Unlock	.\base\simple_mutex.h	/^void Mutex::Unlock()       { SAFE_PTHREAD(pthread_mutex_unlock); }$/;"	f	class:MUTEX_NAMESPACE::Mutex
Unlock	.\base\simple_mutex.h	/^void Mutex::Unlock()       { SAFE_PTHREAD(pthread_rwlock_unlock); }$/;"	f	class:MUTEX_NAMESPACE::Mutex
Unlock	.\base\simple_mutex.h	/^void Mutex::Unlock()       { assert(mutex_++ == -1); }$/;"	f	class:MUTEX_NAMESPACE::Mutex
Unlock	.\base\simple_mutex.h	/^void Mutex::Unlock()       { if (is_safe_) LeaveCriticalSection(&mutex_); }$/;"	f	class:MUTEX_NAMESPACE::Mutex
Unlock	.\base\spinlock.h	/^  inline void Unlock() \/*UNLOCK_FUNCTION()*\/ {$/;"	f	class:SpinLock
Unlock	.\central_freelist.h	/^  void Unlock() {$/;"	f	class:tcmalloc::CentralFreeList
Unlock	.\memory_region_map.cc	/^void MemoryRegionMap::Unlock() {$/;"	f	class:MemoryRegionMap
UnmapSize	.\memory_region_map.h	/^  static int64 UnmapSize() { return unmap_size_; }$/;"	f	class:MemoryRegionMap
UnparseBucket	.\heap-profile-table.cc	/^int HeapProfileTable::UnparseBucket(const Bucket& b,$/;"	f	class:HeapProfileTable
Unpatch	.\windows\patch_functions.cc	/^void LibcInfoWithPatchFunctions<T>::Unpatch() {$/;"	f	class:__anon52::LibcInfoWithPatchFunctions
Unpatch	.\windows\patch_functions.cc	/^void WindowsInfo::Unpatch() {$/;"	f	class:__anon52::WindowsInfo
Unpatch	.\windows\preamble_patcher.cc	/^SideStepError PreamblePatcher::Unpatch(void* target_function,$/;"	f	class:sidestep::PreamblePatcher
UnregisterCallback	.\profile-handler.cc	/^void ProfileHandler::UnregisterCallback(ProfileHandlerToken* token) {$/;"	f	class:ProfileHandler
UnregisterCallback	.\tests\profile-handler_unittest.cc	/^  void UnregisterCallback(ProfileHandlerToken* token) {$/;"	f	class:__anon37::ProfileHandlerTest
Update	.\base\elf_mem_image.cc	/^void ElfMemImage::SymbolIterator::Update(int increment) {$/;"	f	class:base::ElfMemImage::SymbolIterator
UpdateObject	.\tests\tcmalloc_unittest.cc	/^  void UpdateObject() {$/;"	f	class:testing::TesterThread
UpdateTimer	.\profile-handler.cc	/^void ProfileHandler::UpdateTimer(bool enable) {$/;"	f	class:ProfileHandler
Use	.\tests\heap-checker_unittest.cc	/^static void Use(T** foo) {$/;"	f	file:
UseProcMapsLocked	.\heap-checker.cc	/^HeapLeakChecker::ProcMapsResult HeapLeakChecker::UseProcMapsLocked($/;"	f	class:HeapLeakChecker
V	.\packed-cache-inl.h	/^  typedef size_t V;$/;"	t	class:PackedCache
V	.\tests\profiledata_unittest.cc	/^inline void* V(intptr_t x) { return reinterpret_cast<void*>(x); }$/;"	f	namespace:__anon38
VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R11	.\third_party\valgrind.h	337;"	d
VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R11	.\third_party\valgrind.h	402;"	d
VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R11	.\third_party\valgrind.h	474;"	d
VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R11	.\third_party\valgrind.h	546;"	d
VALGRIND_CALL_NOREDIR_EAX	.\third_party\valgrind.h	223;"	d
VALGRIND_CALL_NOREDIR_RAX	.\third_party\valgrind.h	277;"	d
VALGRIND_COUNT_ERRORS	.\third_party\valgrind.h	3773;"	d
VALGRIND_CREATE_MEMPOOL	.\third_party\valgrind.h	3826;"	d
VALGRIND_DESTROY_MEMPOOL	.\third_party\valgrind.h	3834;"	d
VALGRIND_DISCARD_TRANSLATIONS	.\third_party\valgrind.h	3652;"	d
VALGRIND_DO_CLIENT_REQUEST	.\third_party\valgrind.h	131;"	d
VALGRIND_DO_CLIENT_REQUEST	.\third_party\valgrind.h	189;"	d
VALGRIND_DO_CLIENT_REQUEST	.\third_party\valgrind.h	243;"	d
VALGRIND_DO_CLIENT_REQUEST	.\third_party\valgrind.h	297;"	d
VALGRIND_DO_CLIENT_REQUEST	.\third_party\valgrind.h	358;"	d
VALGRIND_DO_CLIENT_REQUEST	.\third_party\valgrind.h	424;"	d
VALGRIND_DO_CLIENT_REQUEST	.\third_party\valgrind.h	496;"	d
VALGRIND_FREELIKE_BLOCK	.\third_party\valgrind.h	3818;"	d
VALGRIND_GET_NR_CONTEXT	.\third_party\valgrind.h	210;"	d
VALGRIND_GET_NR_CONTEXT	.\third_party\valgrind.h	264;"	d
VALGRIND_GET_NR_CONTEXT	.\third_party\valgrind.h	323;"	d
VALGRIND_GET_NR_CONTEXT	.\third_party\valgrind.h	381;"	d
VALGRIND_GET_NR_CONTEXT	.\third_party\valgrind.h	451;"	d
VALGRIND_GET_NR_CONTEXT	.\third_party\valgrind.h	523;"	d
VALGRIND_GET_ORIG_FN	.\third_party\valgrind.h	594;"	d
VALGRIND_MALLOCLIKE_BLOCK	.\third_party\valgrind.h	3807;"	d
VALGRIND_MEMPOOL_ALLOC	.\third_party\valgrind.h	3842;"	d
VALGRIND_MEMPOOL_CHANGE	.\third_party\valgrind.h	3874;"	d
VALGRIND_MEMPOOL_EXISTS	.\third_party\valgrind.h	3882;"	d
VALGRIND_MEMPOOL_FREE	.\third_party\valgrind.h	3850;"	d
VALGRIND_MEMPOOL_TRIM	.\third_party\valgrind.h	3858;"	d
VALGRIND_MOVE_MEMPOOL	.\third_party\valgrind.h	3866;"	d
VALGRIND_NON_SIMD_CALL0	.\third_party\valgrind.h	3728;"	d
VALGRIND_NON_SIMD_CALL1	.\third_party\valgrind.h	3738;"	d
VALGRIND_NON_SIMD_CALL2	.\third_party\valgrind.h	3748;"	d
VALGRIND_NON_SIMD_CALL3	.\third_party\valgrind.h	3758;"	d
VALGRIND_PRINTF	.\third_party\valgrind.h	/^VALGRIND_PRINTF(const char *format, ...)$/;"	f
VALGRIND_PRINTF	.\third_party\valgrind.h	3665;"	d
VALGRIND_PRINTF_BACKTRACE	.\third_party\valgrind.h	/^VALGRIND_PRINTF_BACKTRACE(const char *format, ...)$/;"	f
VALGRIND_PRINTF_BACKTRACE	.\third_party\valgrind.h	3666;"	d
VALGRIND_STACK_CHANGE	.\third_party\valgrind.h	3909;"	d
VALGRIND_STACK_DEREGISTER	.\third_party\valgrind.h	3901;"	d
VALGRIND_STACK_REGISTER	.\third_party\valgrind.h	3891;"	d
VDSOInitHelper	.\base\vdso_support.cc	/^  VDSOInitHelper() { VDSOSupport::Init(); }$/;"	f	class:base::VDSOInitHelper
VDSOInitHelper	.\base\vdso_support.cc	/^static class VDSOInitHelper {$/;"	c	namespace:base	file:
VDSOSupport	.\base\vdso_support.cc	/^VDSOSupport::VDSOSupport()$/;"	f	class:base::VDSOSupport
VDSOSupport	.\base\vdso_support.h	/^class VDSOSupport {$/;"	c	namespace:base
VERSION	.\windows\config.h	290;"	d
VERSYM_VERSION	.\base\elf_mem_image.cc	55;"	d	file:
VG_CONTRACT_FRAME_BY	.\third_party\valgrind.h	2462;"	d
VG_CONTRACT_FRAME_BY	.\third_party\valgrind.h	3023;"	d
VG_EXPAND_FRAME_BY_trashes_r3	.\third_party\valgrind.h	2457;"	d
VG_EXPAND_FRAME_BY_trashes_r3	.\third_party\valgrind.h	3018;"	d
VG_IS_TOOL_USERREQ	.\third_party\valgrind.h	3581;"	d
VG_USERREQ_TOOL_BASE	.\third_party\valgrind.h	3579;"	d
VG_USERREQ__CLIENT_CALL0	.\third_party\valgrind.h	/^          VG_USERREQ__CLIENT_CALL0 = 0x1101,$/;"	e	enum:__anon48
VG_USERREQ__CLIENT_CALL1	.\third_party\valgrind.h	/^          VG_USERREQ__CLIENT_CALL1 = 0x1102,$/;"	e	enum:__anon48
VG_USERREQ__CLIENT_CALL2	.\third_party\valgrind.h	/^          VG_USERREQ__CLIENT_CALL2 = 0x1103,$/;"	e	enum:__anon48
VG_USERREQ__CLIENT_CALL3	.\third_party\valgrind.h	/^          VG_USERREQ__CLIENT_CALL3 = 0x1104,$/;"	e	enum:__anon48
VG_USERREQ__COUNT_ERRORS	.\third_party\valgrind.h	/^          VG_USERREQ__COUNT_ERRORS = 0x1201,$/;"	e	enum:__anon48
VG_USERREQ__CREATE_MEMPOOL	.\third_party\valgrind.h	/^          VG_USERREQ__CREATE_MEMPOOL   = 0x1303,$/;"	e	enum:__anon48
VG_USERREQ__DESTROY_MEMPOOL	.\third_party\valgrind.h	/^          VG_USERREQ__DESTROY_MEMPOOL  = 0x1304,$/;"	e	enum:__anon48
VG_USERREQ__DISCARD_TRANSLATIONS	.\third_party\valgrind.h	/^          VG_USERREQ__DISCARD_TRANSLATIONS = 0x1002,$/;"	e	enum:__anon48
VG_USERREQ__FREELIKE_BLOCK	.\third_party\valgrind.h	/^          VG_USERREQ__FREELIKE_BLOCK   = 0x1302,$/;"	e	enum:__anon48
VG_USERREQ__MALLOCLIKE_BLOCK	.\third_party\valgrind.h	/^          VG_USERREQ__MALLOCLIKE_BLOCK = 0x1301,$/;"	e	enum:__anon48
VG_USERREQ__MEMPOOL_ALLOC	.\third_party\valgrind.h	/^          VG_USERREQ__MEMPOOL_ALLOC    = 0x1305,$/;"	e	enum:__anon48
VG_USERREQ__MEMPOOL_CHANGE	.\third_party\valgrind.h	/^          VG_USERREQ__MEMPOOL_CHANGE   = 0x1309,$/;"	e	enum:__anon48
VG_USERREQ__MEMPOOL_EXISTS	.\third_party\valgrind.h	/^          VG_USERREQ__MEMPOOL_EXISTS   = 0x130a,$/;"	e	enum:__anon48
VG_USERREQ__MEMPOOL_FREE	.\third_party\valgrind.h	/^          VG_USERREQ__MEMPOOL_FREE     = 0x1306,$/;"	e	enum:__anon48
VG_USERREQ__MEMPOOL_TRIM	.\third_party\valgrind.h	/^          VG_USERREQ__MEMPOOL_TRIM     = 0x1307,$/;"	e	enum:__anon48
VG_USERREQ__MOVE_MEMPOOL	.\third_party\valgrind.h	/^          VG_USERREQ__MOVE_MEMPOOL     = 0x1308,$/;"	e	enum:__anon48
VG_USERREQ__PRINTF	.\third_party\valgrind.h	/^          VG_USERREQ__PRINTF           = 0x1401,$/;"	e	enum:__anon48
VG_USERREQ__PRINTF_BACKTRACE	.\third_party\valgrind.h	/^          VG_USERREQ__PRINTF_BACKTRACE = 0x1402,$/;"	e	enum:__anon48
VG_USERREQ__RUNNING_ON_VALGRIND	.\third_party\valgrind.h	/^   enum { VG_USERREQ__RUNNING_ON_VALGRIND  = 0x1001,$/;"	e	enum:__anon48
VG_USERREQ__STACK_CHANGE	.\third_party\valgrind.h	/^          VG_USERREQ__STACK_CHANGE     = 0x1503$/;"	e	enum:__anon48
VG_USERREQ__STACK_DEREGISTER	.\third_party\valgrind.h	/^          VG_USERREQ__STACK_DEREGISTER = 0x1502,$/;"	e	enum:__anon48
VG_USERREQ__STACK_REGISTER	.\third_party\valgrind.h	/^          VG_USERREQ__STACK_REGISTER   = 0x1501,$/;"	e	enum:__anon48
VLOG	.\base\logging.h	/^inline void VLOG(int lvl, const char* pat, ...)     { LOG_PRINTF(lvl, pat); }$/;"	f
VLOG	.\tests\heap-checker_unittest.cc	166;"	d	file:
VLOG	.\tests\heap-checker_unittest.cc	167;"	d	file:
VLOG_IS_ON	.\base\logging.h	215;"	d
ValgrindSlowdown	.\base\dynamic_annotations.c	/^double ValgrindSlowdown(void) {$/;"	f
Valid	.\base\sysinfo.cc	/^bool ProcMapsIterator::Valid() const {$/;"	f	class:ProcMapsIterator
Valid	.\tests\memalign_unittest.cc	/^static bool Valid(const void* p, int n, char seed) {$/;"	f	file:
Valid	.\tests\realloc_unittest.cc	/^static bool Valid(unsigned char* buffer, int n) {$/;"	f	file:
ValidateProfile	.\tests\profiledata_unittest.cc	/^string ProfileDataChecker::ValidateProfile() {$/;"	f	class:__anon38::ProfileDataChecker
ValueSizeFunc	.\addressmap-inl.h	/^  typedef size_t (*ValueSizeFunc)(const Value& v);$/;"	t	class:AddressMap
ValueT	.\tests\addressmap_unittest.cc	/^typedef pair<int, size_t> ValueT;$/;"	t	file:
VerifyAcrossThreads	.\tests\profiler_unittest.sh	/^VerifyAcrossThreads() {$/;"	f
VerifyAllMemory	.\debugallocation.cc	/^  virtual bool VerifyAllMemory() {$/;"	f	class:DebugMallocImplementation
VerifyAllMemory	.\malloc_extension.cc	/^bool MallocExtension::VerifyAllMemory() { return true; }$/;"	f	class:MallocExtension
VerifyArrayNewMemory	.\debugallocation.cc	/^  virtual bool VerifyArrayNewMemory(const void* p) {$/;"	f	class:DebugMallocImplementation
VerifyArrayNewMemory	.\malloc_extension.cc	/^bool MallocExtension::VerifyArrayNewMemory(const void* p) { return true; }$/;"	f	class:MallocExtension
VerifyDisabled	.\tests\profile-handler_unittest.cc	/^  void VerifyDisabled() {$/;"	f	class:__anon37::ProfileHandlerTest
VerifyHeapProfileTableStackGet	.\tests\heap-checker_unittest.cc	/^extern void VerifyHeapProfileTableStackGet() {$/;"	f
VerifyIdentical	.\tests\profiler_unittest.sh	/^VerifyIdentical() {$/;"	f
VerifyLeaks	.\tests\heap-checker_unittest.cc	/^static void VerifyLeaks(HeapLeakChecker* check, CheckType type,$/;"	f	file:
VerifyMallocMemory	.\debugallocation.cc	/^  virtual bool VerifyMallocMemory(const void* p) {$/;"	f	class:DebugMallocImplementation
VerifyMallocMemory	.\malloc_extension.cc	/^bool MallocExtension::VerifyMallocMemory(const void* p) { return true; }$/;"	f	class:MallocExtension
VerifyMemFunction	.\tests\heap-profiler_unittest.sh	/^VerifyMemFunction() {$/;"	f
VerifyMemoryRegionMapStackGet	.\tests\heap-checker_unittest.cc	/^static void VerifyMemoryRegionMapStackGet() {$/;"	f	file:
VerifyNewMemory	.\debugallocation.cc	/^  virtual bool VerifyNewMemory(const void* p) {$/;"	f	class:DebugMallocImplementation
VerifyNewMemory	.\malloc_extension.cc	/^bool MallocExtension::VerifyNewMemory(const void* p) { return true; }$/;"	f	class:MallocExtension
VerifyOutputContains	.\tests\heap-profiler_unittest.sh	/^VerifyOutputContains() {$/;"	f
VerifyRegistration	.\tests\profile-handler_unittest.cc	/^  void VerifyRegistration(const int& tick_counter) {$/;"	f	class:__anon37::ProfileHandlerTest
VerifySimilar	.\tests\profiler_unittest.sh	/^VerifySimilar() {$/;"	f
VerifyUnregistration	.\tests\profile-handler_unittest.cc	/^  void VerifyUnregistration(const int& tick_counter) {$/;"	f	class:__anon37::ProfileHandlerTest
Vg_ClientRequest	.\third_party\valgrind.h	/^   } Vg_ClientRequest;$/;"	t	typeref:enum:__anon48
VirtualSysAllocator	.\windows\system-alloc.cc	/^  VirtualSysAllocator() : SysAllocator() {$/;"	f	class:VirtualSysAllocator
VirtualSysAllocator	.\windows\system-alloc.cc	/^class VirtualSysAllocator : public SysAllocator {$/;"	c	file:
VoidFunction	.\base\googleinit.h	/^  typedef void (*VoidFunction)(void);$/;"	t	class:GoogleInitializer
WARNING	.\base\logging.h	/^enum LogSeverity {INFO = -1, WARNING = -2, ERROR = -3, FATAL = -4};$/;"	e	enum:LogSeverity
WARN_IF	.\tests\heap-checker_unittest.cc	163;"	d	file:
WEBSYM	.\windows\addr2line-pdb.c	49;"	d	file:
WEBSYM	.\windows\nm-pdb.c	60;"	d	file:
WIN32_DO_PATCHING	.\tcmalloc.cc	146;"	d	file:
WIN32_LEAN_AND_MEAN	.\base\simple_mutex.h	114;"	d
WIN32_LEAN_AND_MEAN	.\tests\testutil.cc	104;"	d	file:
WIN32_LEAN_AND_MEAN	.\windows\addr2line-pdb.c	38;"	d	file:
WIN32_LEAN_AND_MEAN	.\windows\nm-pdb.c	38;"	d	file:
WIN32_LEAN_AND_MEAN	.\windows\port.h	54;"	d
WIN32_LEAN_AND_MEAN	.\windows\preamble_patcher_test.cc	46;"	d	file:
WIN32_OVERRIDE_ALLOCATORS	.\windows\config.h	26;"	d
WRITE_TO_STDERR	.\base\logging.h	58;"	d
WRITE_TO_STDERR	.\base\logging.h	61;"	d
WRITE_TO_STDERR	.\base\logging.h	63;"	d
WindowsInfo	.\windows\patch_functions.cc	/^class WindowsInfo {$/;"	c	namespace:__anon52	file:
WipeStack	.\tests\heap-checker_unittest.cc	/^static void WipeStack() { DoWipeStack(20); }$/;"	f	file:
WriteMessage	.\internal_logging.cc	/^static void WriteMessage(const char* msg, int length) {$/;"	f	namespace:tcmalloc
WriteProfile	.\heap-profile-table.cc	/^bool HeapProfileTable::WriteProfile(const char* file_name,$/;"	f	class:HeapProfileTable
WriteStringToFile	.\tests\sampling_test.cc	/^static void WriteStringToFile(const string& s, const string& filename) {$/;"	f	file:
WriteToStderr	.\windows\port.cc	/^extern "C" PERFTOOLS_DLL_DECL void WriteToStderr(const char* buf, int len) {$/;"	f
WriterLock	.\base\simple_mutex.h	/^  inline void WriterLock() { Lock(); }     \/\/ Acquire an exclusive lock$/;"	f	class:MUTEX_NAMESPACE::Mutex
WriterMutexLock	.\base\simple_mutex.h	/^  explicit WriterMutexLock(Mutex *mu) : mu_(mu) { mu_->WriterLock(); }$/;"	f	class:MUTEX_NAMESPACE::WriterMutexLock
WriterMutexLock	.\base\simple_mutex.h	/^class WriterMutexLock {$/;"	c	namespace:MUTEX_NAMESPACE
WriterMutexLock	.\base\simple_mutex.h	324;"	d
WriterUnlock	.\base\simple_mutex.h	/^  inline void WriterUnlock() { Unlock(); } \/\/ Release a lock from WriterLock()$/;"	f	class:MUTEX_NAMESPACE::Mutex
_BASE_LOW_LEVEL_ALLOC_H_	.\base\low_level_alloc.h	33;"	d
_BASICTYPES_H_	.\base\basictypes.h	32;"	d
_CRT_SECURE_NO_DEPRECATE	.\windows\addr2line-pdb.c	40;"	d	file:
_CRT_SECURE_NO_DEPRECATE	.\windows\nm-pdb.c	40;"	d	file:
_CRT_SECURE_NO_WARNINGS	.\windows\addr2line-pdb.c	39;"	d	file:
_CRT_SECURE_NO_WARNINGS	.\windows\nm-pdb.c	39;"	d	file:
_CrtDbgReport	.\windows\override_functions.cc	/^int _CrtDbgReport(int, const char*, int, const char*, const char*, ...) {$/;"	f
_CrtDbgReportW	.\windows\override_functions.cc	/^int _CrtDbgReportW(int, const wchar_t*, int, const wchar_t*, const wchar_t*, ...) {$/;"	f
_CrtSetReportMode	.\windows\override_functions.cc	/^int _CrtSetReportMode(int, int) {$/;"	f
_ELFCORE_H	.\base\elfcore.h	36;"	d
_GNU_SOURCE	.\getpc.h	52;"	d
_GOOGLEINIT_H	.\base\googleinit.h	35;"	d
_LINUXTHREADS_H	.\base\linuxthreads.h	35;"	d
_LOGGING_H_	.\base\logging.h	37;"	d
_LSS_BODY	.\base\linux_syscall_support.h	1223;"	d
_LSS_BODY	.\base\linux_syscall_support.h	1224;"	d
_LSS_RETURN	.\base\linux_syscall_support.h	1211;"	d
_LSS_RETURN	.\base\linux_syscall_support.h	1212;"	d
_MALLOC_EXTENSION_C_H_	.\gperftools\malloc_extension_c.h	40;"	d
_MALLOC_HOOK_C_H_	.\gperftools\malloc_hook_c.h	38;"	d
_MALLOC_HOOK_H_	.\gperftools\malloc_hook.h	68;"	d
_MALLOC_HOOK_INL_H_	.\malloc_hook-inl.h	39;"	d
_SYSINFO_H_	.\base\sysinfo.h	35;"	d
_THREAD_LISTER_H	.\base\thread_lister.h	36;"	d
_TIMESPEC_DEFINED	.\windows\port.h	68;"	d
_WIN32_WINNT	.\base\simple_mutex.h	120;"	d
_WIN32_WINNT	.\windows\config.h	311;"	d
_WIN32_WINNT	.\windows\mingw.h	54;"	d
_XOPEN_SOURCE	.\base\simple_mutex.h	130;"	d
_XOPEN_SOURCE	.\tcmalloc.h	41;"	d
__CALLER_SAVED_REGS	.\third_party\valgrind.h	1019;"	d
__CALLER_SAVED_REGS	.\third_party\valgrind.h	1478;"	d
__CALLER_SAVED_REGS	.\third_party\valgrind.h	1924;"	d
__CALLER_SAVED_REGS	.\third_party\valgrind.h	2448;"	d
__CALLER_SAVED_REGS	.\third_party\valgrind.h	3009;"	d
__CALLER_SAVED_REGS	.\third_party\valgrind.h	621;"	d
__NR__exit	.\base\linux_syscall_support.h	2350;"	d
__NR__gettid	.\base\linux_syscall_support.h	2351;"	d
__NR__mremap	.\base\linux_syscall_support.h	2352;"	d
__NR__sigaction	.\base\linux_syscall_support.h	2548;"	d
__NR__sigprocmask	.\base\linux_syscall_support.h	2549;"	d
__NR_clock_getres	.\base\linux_syscall_support.h	826;"	d
__NR_clock_gettime	.\base\linux_syscall_support.h	823;"	d
__NR_fadvise64	.\base\linux_syscall_support.h	820;"	d
__NR_fallocate	.\base\linux_syscall_support.h	856;"	d
__NR_fstat64	.\base\linux_syscall_support.h	559;"	d
__NR_fstat64	.\base\linux_syscall_support.h	603;"	d
__NR_fstat64	.\base\linux_syscall_support.h	639;"	d
__NR_fstat64	.\base\linux_syscall_support.h	705;"	d
__NR_fstatat	.\base\linux_syscall_support.h	654;"	d
__NR_fstatat	.\base\linux_syscall_support.h	671;"	d
__NR_fstatat	.\base\linux_syscall_support.h	688;"	d
__NR_fstatat	.\base\linux_syscall_support.h	728;"	d
__NR_fstatfs64	.\base\linux_syscall_support.h	832;"	d
__NR_futex	.\base\linux_syscall_support.h	568;"	d
__NR_futex	.\base\linux_syscall_support.h	612;"	d
__NR_futex	.\base\linux_syscall_support.h	620;"	d
__NR_futex	.\base\linux_syscall_support.h	648;"	d
__NR_futex	.\base\linux_syscall_support.h	665;"	d
__NR_futex	.\base\linux_syscall_support.h	682;"	d
__NR_futex	.\base\linux_syscall_support.h	717;"	d
__NR_futex	.\base\linux_syscall_support.h	808;"	d
__NR_getcpu	.\base\linux_syscall_support.h	574;"	d
__NR_getcpu	.\base\linux_syscall_support.h	657;"	d
__NR_getcpu	.\base\linux_syscall_support.h	674;"	d
__NR_getcpu	.\base\linux_syscall_support.h	691;"	d
__NR_getcpu	.\base\linux_syscall_support.h	723;"	d
__NR_getcpu	.\base\linux_syscall_support.h	853;"	d
__NR_getdents64	.\base\linux_syscall_support.h	562;"	d
__NR_getdents64	.\base\linux_syscall_support.h	606;"	d
__NR_getdents64	.\base\linux_syscall_support.h	623;"	d
__NR_getdents64	.\base\linux_syscall_support.h	642;"	d
__NR_getdents64	.\base\linux_syscall_support.h	711;"	d
__NR_getdents64	.\base\linux_syscall_support.h	778;"	d
__NR_getresgid	.\base\linux_syscall_support.h	769;"	d
__NR_getresuid	.\base\linux_syscall_support.h	763;"	d
__NR_getrlimit	.\base\linux_syscall_support.h	757;"	d
__NR_gettid	.\base\linux_syscall_support.h	565;"	d
__NR_gettid	.\base\linux_syscall_support.h	609;"	d
__NR_gettid	.\base\linux_syscall_support.h	617;"	d
__NR_gettid	.\base\linux_syscall_support.h	645;"	d
__NR_gettid	.\base\linux_syscall_support.h	662;"	d
__NR_gettid	.\base\linux_syscall_support.h	679;"	d
__NR_gettid	.\base\linux_syscall_support.h	714;"	d
__NR_gettid	.\base\linux_syscall_support.h	802;"	d
__NR_getxattr	.\base\linux_syscall_support.h	790;"	d
__NR_ioprio_get	.\base\linux_syscall_support.h	838;"	d
__NR_ioprio_set	.\base\linux_syscall_support.h	835;"	d
__NR_lgetxattr	.\base\linux_syscall_support.h	793;"	d
__NR_listxattr	.\base\linux_syscall_support.h	796;"	d
__NR_llistxattr	.\base\linux_syscall_support.h	799;"	d
__NR_lsetxattr	.\base\linux_syscall_support.h	787;"	d
__NR_move_pages	.\base\linux_syscall_support.h	850;"	d
__NR_newfstatat	.\base\linux_syscall_support.h	844;"	d
__NR_openat	.\base\linux_syscall_support.h	571;"	d
__NR_openat	.\base\linux_syscall_support.h	626;"	d
__NR_openat	.\base\linux_syscall_support.h	651;"	d
__NR_openat	.\base\linux_syscall_support.h	668;"	d
__NR_openat	.\base\linux_syscall_support.h	685;"	d
__NR_openat	.\base\linux_syscall_support.h	720;"	d
__NR_openat	.\base\linux_syscall_support.h	841;"	d
__NR_pread64	.\base\linux_syscall_support.h	751;"	d
__NR_pwrite64	.\base\linux_syscall_support.h	754;"	d
__NR_quotactl	.\base\linux_syscall_support.h	733;"	d
__NR_readahead	.\base\linux_syscall_support.h	781;"	d
__NR_rt_sigaction	.\base\linux_syscall_support.h	552;"	d
__NR_rt_sigaction	.\base\linux_syscall_support.h	596;"	d
__NR_rt_sigaction	.\base\linux_syscall_support.h	632;"	d
__NR_rt_sigaction	.\base\linux_syscall_support.h	698;"	d
__NR_rt_sigaction	.\base\linux_syscall_support.h	739;"	d
__NR_rt_sigpending	.\base\linux_syscall_support.h	745;"	d
__NR_rt_sigprocmask	.\base\linux_syscall_support.h	553;"	d
__NR_rt_sigprocmask	.\base\linux_syscall_support.h	597;"	d
__NR_rt_sigprocmask	.\base\linux_syscall_support.h	633;"	d
__NR_rt_sigprocmask	.\base\linux_syscall_support.h	699;"	d
__NR_rt_sigprocmask	.\base\linux_syscall_support.h	742;"	d
__NR_rt_sigreturn	.\base\linux_syscall_support.h	736;"	d
__NR_rt_sigsuspend	.\base\linux_syscall_support.h	748;"	d
__NR_sched_getaffinity	.\base\linux_syscall_support.h	814;"	d
__NR_sched_setaffinity	.\base\linux_syscall_support.h	811;"	d
__NR_set_tid_address	.\base\linux_syscall_support.h	817;"	d
__NR_setfsgid	.\base\linux_syscall_support.h	775;"	d
__NR_setfsuid	.\base\linux_syscall_support.h	772;"	d
__NR_setresgid	.\base\linux_syscall_support.h	766;"	d
__NR_setresuid	.\base\linux_syscall_support.h	760;"	d
__NR_setxattr	.\base\linux_syscall_support.h	784;"	d
__NR_socket	.\base\linux_syscall_support.h	708;"	d
__NR_stat64	.\base\linux_syscall_support.h	556;"	d
__NR_stat64	.\base\linux_syscall_support.h	600;"	d
__NR_stat64	.\base\linux_syscall_support.h	636;"	d
__NR_stat64	.\base\linux_syscall_support.h	702;"	d
__NR_statfs64	.\base\linux_syscall_support.h	829;"	d
__NR_tkill	.\base\linux_syscall_support.h	805;"	d
__NR_unlinkat	.\base\linux_syscall_support.h	847;"	d
__SPECIAL_INSTRUCTION_PREAMBLE	.\third_party\valgrind.h	185;"	d
__SPECIAL_INSTRUCTION_PREAMBLE	.\third_party\valgrind.h	239;"	d
__SPECIAL_INSTRUCTION_PREAMBLE	.\third_party\valgrind.h	293;"	d
__SPECIAL_INSTRUCTION_PREAMBLE	.\third_party\valgrind.h	354;"	d
__SPECIAL_INSTRUCTION_PREAMBLE	.\third_party\valgrind.h	420;"	d
__SPECIAL_INSTRUCTION_PREAMBLE	.\third_party\valgrind.h	492;"	d
__STDC_FORMAT_MACROS	.\windows\config.h	294;"	d
__SYS_REG	.\base\linux_syscall_support.h	580;"	d
__SYS_REG	.\base\linux_syscall_support.h	589;"	d
__SYS_REG_LIST	.\base\linux_syscall_support.h	581;"	d
__SYS_REG_LIST	.\base\linux_syscall_support.h	590;"	d
__THROW	.\debugallocation.cc	91;"	d	file:
__THROW	.\libc_override_gcc_and_weak.h	51;"	d
__THROW	.\malloc_hook.cc	70;"	d	file:
__THROW	.\maybe_threads.cc	57;"	d	file:
__THROW	.\tcmalloc.h	53;"	d
__THROW	.\windows\patch_functions.cc	/^                                            const std::nothrow_t&) __THROW;$/;"	m	class:__anon52::LibcInfoWithPatchFunctions	file:
__THROW	.\windows\patch_functions.cc	/^                                          const std::nothrow_t&) __THROW;$/;"	m	class:__anon52::LibcInfoWithPatchFunctions	file:
__THROW	.\windows\patch_functions.cc	/^                                       const std::nothrow_t&) __THROW;$/;"	m	class:__anon52::LibcInfoWithPatchFunctions	file:
__THROW	.\windows\patch_functions.cc	/^                                     const std::nothrow_t&) __THROW;$/;"	m	class:__anon52::LibcInfoWithPatchFunctions	file:
__THROW	.\windows\patch_functions.cc	/^  static size_t Perftools__msize(void *ptr) __THROW;$/;"	m	class:__anon52::LibcInfoWithPatchFunctions	file:
__THROW	.\windows\patch_functions.cc	/^  static void Perftools_free(void* ptr) __THROW;$/;"	m	class:__anon52::LibcInfoWithPatchFunctions	file:
__THROW	.\windows\patch_functions.cc	/^  static void* Perftools__expand(void *ptr, size_t size) __THROW;$/;"	m	class:__anon52::LibcInfoWithPatchFunctions	file:
__THROW	.\windows\patch_functions.cc	/^  static void* Perftools_calloc(size_t nmemb, size_t size) __THROW;$/;"	m	class:__anon52::LibcInfoWithPatchFunctions	file:
__THROW	.\windows\patch_functions.cc	/^  static void* Perftools_malloc(size_t size) __THROW;$/;"	m	class:__anon52::LibcInfoWithPatchFunctions	file:
__THROW	.\windows\patch_functions.cc	/^  static void* Perftools_realloc(void* ptr, size_t size) __THROW;$/;"	m	class:__anon52::LibcInfoWithPatchFunctions	file:
__THROW	.\windows\port.h	485;"	d
__VALGRIND_H	.\third_party\valgrind.h	74;"	d
__cyg_profile_func_enter	.\stacktrace_instrument-inl.h	/^void __cyg_profile_func_enter(void *func_address, void *call_site) {$/;"	f
__cyg_profile_func_exit	.\stacktrace_instrument-inl.h	/^void __cyg_profile_func_exit(void *func_address, void *call_site) {$/;"	f
__extension__	.\third_party\valgrind.h	3632;"	d
__free_hook	.\libc_override_glibc.h	/^void (* MALLOC_HOOK_MAYBE_VOLATILE __free_hook)(void*, const void*)$/;"	v
__malloc_hook	.\libc_override_glibc.h	/^void* (* MALLOC_HOOK_MAYBE_VOLATILE __malloc_hook)(size_t, const void*)$/;"	v
__malloctrace_write	.\debugallocation.cc	/^void __malloctrace_write(const char *buf, size_t size) {$/;"	f
__memalign_hook	.\libc_override_glibc.h	/^void* (* MALLOC_HOOK_MAYBE_VOLATILE __memalign_hook)(size_t,size_t, const void*)$/;"	v
__pad0	.\base\linux_syscall_support.h	/^  unsigned           __pad0;$/;"	m	struct:kernel_stat
__pad0	.\base\linux_syscall_support.h	/^  unsigned           __pad0[3];$/;"	m	struct:kernel_stat
__pad0	.\base\linux_syscall_support.h	/^  unsigned char      __pad0[4];$/;"	m	struct:kernel_stat64
__pad1	.\base\linux_syscall_support.h	/^  unsigned           __pad1[3];$/;"	m	struct:kernel_stat
__pad1	.\base\linux_syscall_support.h	/^  unsigned int       __pad1;$/;"	m	struct:kernel_stat
__pad1	.\base\linux_syscall_support.h	/^  unsigned long      __pad1;$/;"	m	struct:kernel_stat
__pad2	.\base\linux_syscall_support.h	/^  int                __pad2;$/;"	m	struct:kernel_stat
__pad2	.\base\linux_syscall_support.h	/^  int                __pad2;$/;"	m	struct:kernel_stat64
__pad2	.\base\linux_syscall_support.h	/^  unsigned           __pad2;$/;"	m	struct:kernel_stat
__pad3	.\base\linux_syscall_support.h	/^  unsigned char      __pad3[4];$/;"	m	struct:kernel_stat64
__realloc_hook	.\libc_override_glibc.h	/^void* (* MALLOC_HOOK_MAYBE_VOLATILE __realloc_hook)(void*, size_t, const void*)$/;"	v
__sbrk	.\windows\port.cc	/^extern "C" PERFTOOLS_DLL_DECL void* __sbrk(ptrdiff_t increment) {$/;"	f
__st_ino	.\base\linux_syscall_support.h	/^  unsigned           __st_ino;$/;"	m	struct:kernel_stat64
__sync_val_compare_and_swap	.\base\atomicops-internals-x86.h	/^inline Atomic64 __sync_val_compare_and_swap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
__syscall	.\base\linux_syscall_support.h	582;"	d
__syscall	.\base\linux_syscall_support.h	591;"	d
__syscall_safe	.\base\linux_syscall_support.h	583;"	d
__syscall_safe	.\base\linux_syscall_support.h	592;"	d
__tcmalloc	.\windows\patch_functions.cc	/^void __tcmalloc() { }$/;"	f
__thread	.\windows\port.h	192;"	d
__unused	.\base\linux_syscall_support.h	/^  int64_t            __unused[3];$/;"	m	struct:kernel_stat
__unused	.\base\linux_syscall_support.h	/^  unsigned long      __unused[3];$/;"	m	struct:kernel_stat
__unused4	.\base\linux_syscall_support.h	/^  unsigned           __unused4;$/;"	m	struct:kernel_stat
__unused4	.\base\linux_syscall_support.h	/^  unsigned int       __unused4;$/;"	m	struct:kernel_stat
__unused4	.\base\linux_syscall_support.h	/^  unsigned long      __unused4;$/;"	m	struct:kernel_stat
__unused4	.\base\linux_syscall_support.h	/^  unsigned long      __unused4;$/;"	m	struct:kernel_stat64
__unused5	.\base\linux_syscall_support.h	/^  unsigned           __unused5;$/;"	m	struct:kernel_stat
__unused5	.\base\linux_syscall_support.h	/^  unsigned int       __unused5;$/;"	m	struct:kernel_stat
__unused5	.\base\linux_syscall_support.h	/^  unsigned long      __unused5;$/;"	m	struct:kernel_stat
__unused5	.\base\linux_syscall_support.h	/^  unsigned long      __unused5;$/;"	m	struct:kernel_stat64
__unused6	.\base\linux_syscall_support.h	/^  unsigned long      __unused6;$/;"	m	struct:kernel_stat
__unused6	.\base\linux_syscall_support.h	/^  unsigned long      __unused6;$/;"	m	struct:kernel_stat64
_calloc_dbg	.\windows\override_functions.cc	/^extern "C" void* _calloc_dbg(size_t n, size_t size, int, const char*, int) {$/;"	f
_calloc_impl	.\windows\override_functions.cc	/^extern "C" void* _calloc_impl(size_t n, size_t size) {$/;"	f
_crtheap	.\windows\override_functions.cc	/^extern "C" void* _crtheap = reinterpret_cast<void*>(1);$/;"	v
_free_dbg	.\windows\override_functions.cc	/^extern "C" void _free_dbg(void* ptr, int) {$/;"	f
_get_heap_handle	.\windows\override_functions.cc	/^extern "C" intptr_t _get_heap_handle() {$/;"	f
_heap_init	.\windows\override_functions.cc	/^extern "C" int _heap_init() {$/;"	f
_heap_term	.\windows\override_functions.cc	/^extern "C" void _heap_term() {$/;"	f
_isync	.\base\atomicops-internals-linuxppc.h	/^static inline void _isync(void) {$/;"	f	namespace:base::subtle
_lwsync	.\base\atomicops-internals-linuxppc.h	/^static inline void _lwsync(void) {$/;"	f	namespace:base::subtle
_malloc_dbg	.\windows\override_functions.cc	/^extern "C" void* _malloc_dbg(size_t size, int , const char*, int) {$/;"	f
_msize	.\windows\override_functions.cc	/^extern "C" size_t _msize(void* p) {$/;"	f
_recalloc	.\windows\override_functions.cc	/^extern "C" void* _recalloc(void* p, size_t n, size_t size) {$/;"	f
_set_new_mode	.\windows\override_functions.cc	/^extern "C" int _set_new_mode(int flag) {$/;"	f
_sync	.\base\atomicops-internals-linuxppc.h	/^static inline void _sync(void) {$/;"	f	namespace:base::subtle
_syscall0	.\base\linux_syscall_support.h	1286;"	d
_syscall0	.\base\linux_syscall_support.h	1287;"	d
_syscall0	.\base\linux_syscall_support.h	1459;"	d
_syscall0	.\base\linux_syscall_support.h	1460;"	d
_syscall0	.\base\linux_syscall_support.h	1644;"	d
_syscall0	.\base\linux_syscall_support.h	1645;"	d
_syscall0	.\base\linux_syscall_support.h	1918;"	d
_syscall0	.\base\linux_syscall_support.h	1919;"	d
_syscall0	.\base\linux_syscall_support.h	2131;"	d
_syscall0	.\base\linux_syscall_support.h	2132;"	d
_syscall0	.\base\linux_syscall_support.h	2254;"	d
_syscall0	.\base\linux_syscall_support.h	2255;"	d
_syscall0	.\base\linux_syscall_support.h	989;"	d
_syscall0	.\base\linux_syscall_support.h	990;"	d
_syscall1	.\base\linux_syscall_support.h	1000;"	d
_syscall1	.\base\linux_syscall_support.h	1291;"	d
_syscall1	.\base\linux_syscall_support.h	1292;"	d
_syscall1	.\base\linux_syscall_support.h	1464;"	d
_syscall1	.\base\linux_syscall_support.h	1465;"	d
_syscall1	.\base\linux_syscall_support.h	1650;"	d
_syscall1	.\base\linux_syscall_support.h	1651;"	d
_syscall1	.\base\linux_syscall_support.h	1923;"	d
_syscall1	.\base\linux_syscall_support.h	1924;"	d
_syscall1	.\base\linux_syscall_support.h	2136;"	d
_syscall1	.\base\linux_syscall_support.h	2137;"	d
_syscall1	.\base\linux_syscall_support.h	2259;"	d
_syscall1	.\base\linux_syscall_support.h	2260;"	d
_syscall1	.\base\linux_syscall_support.h	999;"	d
_syscall2	.\base\linux_syscall_support.h	1006;"	d
_syscall2	.\base\linux_syscall_support.h	1007;"	d
_syscall2	.\base\linux_syscall_support.h	1296;"	d
_syscall2	.\base\linux_syscall_support.h	1297;"	d
_syscall2	.\base\linux_syscall_support.h	1471;"	d
_syscall2	.\base\linux_syscall_support.h	1472;"	d
_syscall2	.\base\linux_syscall_support.h	1656;"	d
_syscall2	.\base\linux_syscall_support.h	1657;"	d
_syscall2	.\base\linux_syscall_support.h	1928;"	d
_syscall2	.\base\linux_syscall_support.h	1929;"	d
_syscall2	.\base\linux_syscall_support.h	2141;"	d
_syscall2	.\base\linux_syscall_support.h	2142;"	d
_syscall2	.\base\linux_syscall_support.h	2265;"	d
_syscall2	.\base\linux_syscall_support.h	2266;"	d
_syscall3	.\base\linux_syscall_support.h	1013;"	d
_syscall3	.\base\linux_syscall_support.h	1014;"	d
_syscall3	.\base\linux_syscall_support.h	1301;"	d
_syscall3	.\base\linux_syscall_support.h	1302;"	d
_syscall3	.\base\linux_syscall_support.h	1480;"	d
_syscall3	.\base\linux_syscall_support.h	1481;"	d
_syscall3	.\base\linux_syscall_support.h	1663;"	d
_syscall3	.\base\linux_syscall_support.h	1664;"	d
_syscall3	.\base\linux_syscall_support.h	1933;"	d
_syscall3	.\base\linux_syscall_support.h	1934;"	d
_syscall3	.\base\linux_syscall_support.h	2147;"	d
_syscall3	.\base\linux_syscall_support.h	2148;"	d
_syscall3	.\base\linux_syscall_support.h	2271;"	d
_syscall3	.\base\linux_syscall_support.h	2272;"	d
_syscall4	.\base\linux_syscall_support.h	1021;"	d
_syscall4	.\base\linux_syscall_support.h	1022;"	d
_syscall4	.\base\linux_syscall_support.h	1307;"	d
_syscall4	.\base\linux_syscall_support.h	1308;"	d
_syscall4	.\base\linux_syscall_support.h	1491;"	d
_syscall4	.\base\linux_syscall_support.h	1492;"	d
_syscall4	.\base\linux_syscall_support.h	1670;"	d
_syscall4	.\base\linux_syscall_support.h	1671;"	d
_syscall4	.\base\linux_syscall_support.h	1938;"	d
_syscall4	.\base\linux_syscall_support.h	1939;"	d
_syscall4	.\base\linux_syscall_support.h	2153;"	d
_syscall4	.\base\linux_syscall_support.h	2154;"	d
_syscall4	.\base\linux_syscall_support.h	2277;"	d
_syscall4	.\base\linux_syscall_support.h	2278;"	d
_syscall5	.\base\linux_syscall_support.h	1029;"	d
_syscall5	.\base\linux_syscall_support.h	1030;"	d
_syscall5	.\base\linux_syscall_support.h	1313;"	d
_syscall5	.\base\linux_syscall_support.h	1314;"	d
_syscall5	.\base\linux_syscall_support.h	1505;"	d
_syscall5	.\base\linux_syscall_support.h	1506;"	d
_syscall5	.\base\linux_syscall_support.h	1677;"	d
_syscall5	.\base\linux_syscall_support.h	1682;"	d
_syscall5	.\base\linux_syscall_support.h	1704;"	d
_syscall5	.\base\linux_syscall_support.h	1944;"	d
_syscall5	.\base\linux_syscall_support.h	1945;"	d
_syscall5	.\base\linux_syscall_support.h	2160;"	d
_syscall5	.\base\linux_syscall_support.h	2161;"	d
_syscall5	.\base\linux_syscall_support.h	2287;"	d
_syscall5	.\base\linux_syscall_support.h	2288;"	d
_syscall6	.\base\linux_syscall_support.h	1047;"	d
_syscall6	.\base\linux_syscall_support.h	1048;"	d
_syscall6	.\base\linux_syscall_support.h	1322;"	d
_syscall6	.\base\linux_syscall_support.h	1323;"	d
_syscall6	.\base\linux_syscall_support.h	1522;"	d
_syscall6	.\base\linux_syscall_support.h	1523;"	d
_syscall6	.\base\linux_syscall_support.h	1714;"	d
_syscall6	.\base\linux_syscall_support.h	1719;"	d
_syscall6	.\base\linux_syscall_support.h	1744;"	d
_syscall6	.\base\linux_syscall_support.h	1951;"	d
_syscall6	.\base\linux_syscall_support.h	1952;"	d
_syscall6	.\base\linux_syscall_support.h	2170;"	d
_syscall6	.\base\linux_syscall_support.h	2171;"	d
_syscall6	.\base\linux_syscall_support.h	2297;"	d
_syscall6	.\base\linux_syscall_support.h	2298;"	d
_tcmalloc	.\windows\patch_functions.cc	/^void _tcmalloc() { }$/;"	f
_tmain	.\windows\preamble_patcher_test.cc	/^int _tmain(int argc, _TCHAR* argv[])$/;"	f
a	.\tests\system-alloc_unittest.cc	/^ArraySysAllocator a;$/;"	v
access	.\windows\port.h	/^inline int access(const char *pathname, int mode) {$/;"	f
adaptive_spin_count	.\base\spinlock.cc	/^static int adaptive_spin_count = 0;$/;"	v	file:
addr	.\windows\nm-pdb.c	/^  ULONG64 addr;$/;"	m	struct:__anon50	file:
address	.\base\elf_mem_image.h	/^    const void      *address;   \/\/ Relocated symbol address.$/;"	m	struct:base::ElfMemImage::SymbolInfo
address	.\base\stl_allocator.h	/^  const_pointer address(const_reference x) const { return &x; }$/;"	f	class:STL_Allocator
address	.\base\stl_allocator.h	/^  pointer address(reference x) const { return &x; }$/;"	f	class:STL_Allocator
address	.\gperftools\malloc_extension.h	/^  uintptr_t address;    \/\/ Address of range$/;"	m	struct:base::MallocRange
address_default_is_32_bits_	.\windows\mini_disassembler.h	/^  bool address_default_is_32_bits_;$/;"	m	class:sidestep::MiniDisassembler
address_is_32_bits_	.\windows\mini_disassembler.h	/^  bool address_is_32_bits_;$/;"	m	class:sidestep::MiniDisassembler
address_map_	.\heap-profile-table.h	/^  AllocationMap* address_map_;$/;"	m	class:HeapProfileTable
aggressive_decommit_	.\page_heap.h	/^  bool aggressive_decommit_;$/;"	m	class:tcmalloc::PageHeap
align	.\debugallocation.cc	/^  size_t align;$/;"	m	struct:memalign_retry_data	file:
align	.\tcmalloc.cc	/^  size_t align;$/;"	m	struct:__anon34::retry_memaligh_data	file:
align_it	.\memory_region_map.cc	/^  void* align_it;  \/\/ do not need a better alignment for 'rep' than this$/;"	m	union:MemoryRegionMap::RegionSetRep	file:
all_impls	.\stacktrace.cc	/^static GetStackImplementation *all_impls[] = {$/;"	v	file:
alloc	.\tests\tcmalloc_unittest.cc	/^  void* alloc(size_t size) {$/;"	f	class:testing::AllocatorState
alloc_	.\addressmap-inl.h	/^  Allocator     alloc_;                 \/\/ The allocator$/;"	m	class:AddressMap
alloc_	.\heap-profile-table.h	/^  Allocator alloc_;$/;"	m	class:HeapProfileTable
alloc_count	.\heap-checker.cc	/^  static int alloc_count() {$/;"	f	class:HeapLeakChecker::Allocator
alloc_count_	.\heap-checker.cc	/^  static int alloc_count_;$/;"	m	class:HeapLeakChecker::Allocator	file:
alloc_count_	.\heap-checker.cc	/^int HeapLeakChecker::Allocator::alloc_count_ = 0;$/;"	m	class:HeapLeakChecker::Allocator	file:
alloc_map_	.\debugallocation.cc	/^  static AllocMap* alloc_map_;$/;"	m	class:MallocBlock	file:
alloc_map_	.\debugallocation.cc	/^MallocBlock::AllocMap* MallocBlock::alloc_map_ = NULL;$/;"	m	class:MallocBlock	file:
alloc_map_lock_	.\debugallocation.cc	/^  static SpinLock alloc_map_lock_;$/;"	m	class:MallocBlock	file:
alloc_size	.\heap-profile-stats.h	/^  int64 alloc_size;  \/\/ Total size of all allocated objects so far.$/;"	m	struct:HeapProfileStats
alloc_type_	.\debugallocation.cc	/^  size_t alloc_type_;$/;"	m	class:MallocBlock	file:
allocate	.\base\stl_allocator.h	/^  pointer allocate(size_type n, const void* = 0) {$/;"	f	class:STL_Allocator
allocated_	.\addressmap-inl.h	/^  Object*       allocated_;             \/\/ List of allocated objects$/;"	m	class:AddressMap
allocates	.\tests\low_level_alloc_unittest.cc	/^static int32 allocates;$/;"	v	file:
allocation_count	.\base\low_level_alloc.cc	/^  int32 allocation_count; \/\/ count of allocated blocks (under mu)$/;"	m	struct:LowLevelAlloc::Arena	file:
allocator	.\base\low_level_alloc.cc	/^  PagesAllocator *allocator;$/;"	m	struct:LowLevelAlloc::Arena	file:
allocator_	.\pagemap.h	/^  void* (*allocator_)(size_t);          \/\/ Memory allocator$/;"	m	class:TCMalloc_PageMap2
allocator_	.\pagemap.h	/^  void* (*allocator_)(size_t);          \/\/ Memory allocator$/;"	m	class:TCMalloc_PageMap3
allocs	.\heap-profile-stats.h	/^  int32 allocs;      \/\/ Number of allocation calls.$/;"	m	struct:HeapProfileStats
allocs_	.\system-alloc.cc	/^  SysAllocator* allocs_[kMaxAllocators];$/;"	m	class:DefaultSysAllocator	file:
allowed	.\profile-handler.h	/^  bool allowed; \/* Profiling is allowed *\/$/;"	m	struct:ProfileHandlerState
allowed_	.\profile-handler.cc	/^  bool allowed_;$/;"	m	class:ProfileHandler	file:
altstack_mem	.\base\linuxthreads.cc	/^  char        *altstack_mem;$/;"	m	struct:ListerParams	file:
ap	.\base\linuxthreads.cc	/^  va_list     ap;$/;"	m	struct:ListerParams	file:
append	.\tests\heap-checker_unittest.cc	/^  void append(const Array& x) {$/;"	f	struct:Array
arena	.\base\low_level_alloc.cc	/^      LowLevelAlloc::Arena *arena; \/\/ pointer to parent arena$/;"	m	struct:low_level_alloc_internal::AllocList::Header	file:
arena_	.\base\low_level_alloc.cc	/^        : left_(false), mask_valid_(false), arena_(arena) {$/;"	f	class:__anon8::ArenaLock
arena_	.\base\low_level_alloc.cc	/^    LowLevelAlloc::Arena *arena_;$/;"	m	class:__anon8::ArenaLock	file:
arena_	.\heap-checker.cc	/^  static LowLevelAlloc::Arena* arena_;$/;"	m	class:HeapLeakChecker::Allocator	file:
arena_	.\heap-checker.cc	/^LowLevelAlloc::Arena* HeapLeakChecker::Allocator::arena_ = NULL;$/;"	m	class:HeapLeakChecker::Allocator	file:
arena_	.\memory_region_map.cc	/^LowLevelAlloc::Arena* MemoryRegionMap::arena_ = NULL;$/;"	m	class:MemoryRegionMap	file:
arena_	.\memory_region_map.h	/^  static LowLevelAlloc::Arena* arena_;$/;"	m	class:MemoryRegionMap
arm	.\base\elfcore.h	/^    struct arm_regs arm;$/;"	m	struct:Frame	typeref:struct:Frame::arm_regs
arm_regs	.\base\elfcore.h	/^  typedef struct arm_regs {     \/* General purpose registers                 *\/$/;"	s
arm_regs	.\base\elfcore.h	/^  } arm_regs;$/;"	t	typeref:struct:arm_regs
array	.\stacktrace_libgcc-inl.h	/^  void **array;$/;"	m	struct:libgcc_backtrace_data
array_	.\packed-cache-inl.h	/^  volatile T array_[1 << kHashbits];$/;"	m	class:PackedCache
array_	.\pagemap.h	/^  void** array_;$/;"	m	class:TCMalloc_PageMap1
array_	.\tests\system-alloc_unittest.cc	/^  char array_[kArraySize];$/;"	m	class:ArraySysAllocator	file:
array_	.\windows\preamble_patcher.cc	/^  unsigned char* array_;$/;"	m	class:sidestep::DeleteUnsignedCharArray	file:
arraysize	.\base\basictypes.h	198;"	d
atoll	.\windows\port.h	/^inline long long atoll(const char *nptr) {$/;"	f
atomic_word_is_atomic	.\base\atomicops-internals-windows.h	/^COMPILE_ASSERT(sizeof(Atomic64) == sizeof(PVOID), atomic_word_is_atomic);$/;"	m	namespace:base::subtle
b	.\tests\heap-checker_unittest.cc	/^  char b[7];$/;"	m	class:ClassB	file:
b2	.\tests\heap-checker_unittest.cc	/^  char b2[11];$/;"	m	class:ClassB2	file:
base	.\base\atomicops-internals-arm-generic.h	/^namespace base {$/;"	n
base	.\base\atomicops-internals-arm-v6plus.h	/^namespace base {$/;"	n
base	.\base\atomicops-internals-gcc.h	/^namespace base {$/;"	n
base	.\base\atomicops-internals-linuxppc.h	/^namespace base {$/;"	n
base	.\base\atomicops-internals-macosx.h	/^namespace base {$/;"	n
base	.\base\atomicops-internals-mips.h	/^namespace base {$/;"	n
base	.\base\atomicops-internals-windows.h	/^namespace base {$/;"	n
base	.\base\atomicops-internals-x86.h	/^namespace base {$/;"	n
base	.\base\atomicops.h	/^namespace base {$/;"	n
base	.\base\basictypes.h	/^namespace base {$/;"	n
base	.\base\elf_mem_image.cc	/^namespace base {$/;"	n	file:
base	.\base\elf_mem_image.h	/^namespace base {$/;"	n
base	.\base\spinlock_internal.cc	/^namespace base { namespace internal { static int SuggestedDelayNS(int loop); }}$/;"	n	file:
base	.\base\spinlock_internal.cc	/^namespace base {$/;"	n	file:
base	.\base\spinlock_internal.h	/^namespace base {$/;"	n
base	.\base\spinlock_linux-inl.h	/^namespace base {$/;"	n
base	.\base\spinlock_posix-inl.h	/^namespace base {$/;"	n
base	.\base\spinlock_win32-inl.h	/^namespace base {$/;"	n
base	.\base\vdso_support.cc	/^namespace base {$/;"	n	file:
base	.\base\vdso_support.h	/^namespace base {$/;"	n
base	.\gperftools\malloc_extension.h	/^namespace base {$/;"	n
base	.\heap-profile-table.h	/^    Snapshot* base;$/;"	m	struct:HeapProfileTable::AddNonLiveArgs
base	.\malloc_hook-inl.h	/^namespace base { namespace internal {$/;"	n
base	.\malloc_hook.cc	/^namespace base { namespace internal {$/;"	n	file:
base	.\page_heap.h	/^namespace base {$/;"	n
base	.\raw_printer.cc	/^namespace base {$/;"	n	file:
base	.\raw_printer.h	/^namespace base {$/;"	n
base_	.\raw_printer.h	/^  char* base_;          \/\/ Initial pointer$/;"	m	class:base::RawPrinter
begin	.\base\elf_mem_image.cc	/^ElfMemImage::SymbolIterator ElfMemImage::begin() const {$/;"	f	class:base::ElfMemImage
begin	.\base\vdso_support.h	/^  SymbolIterator begin() const { return image_.begin(); }$/;"	f	class:base::VDSOSupport
big_page_size_	.\memfs_malloc.cc	/^  int64 big_page_size_;$/;"	m	class:HugetlbSysAllocator	file:
bit_cast	.\base\basictypes.h	/^inline Dest bit_cast(const Source& source) {$/;"	f
block	.\debugallocation.cc	/^  MallocBlock* block;$/;"	m	struct:MallocBlockQueueEntry	file:
blocks	.\addressmap-inl.h	/^    Entry*   blocks[kClusterBlocks];    \/\/ Per-block linked-lists$/;"	m	struct:AddressMap::Cluster
bucket	.\heap-profile-table.cc	/^  Bucket* bucket;$/;"	m	struct:HeapProfileTable::Snapshot::Entry	file:
bucket	.\heap-profile-table.h	/^    Bucket* bucket() const {$/;"	f	struct:HeapProfileTable::AllocValue
bucket_allocator	.\static_vars.h	/^  static PageHeapAllocator<StackTraceTable::Bucket>* bucket_allocator() {$/;"	f	class:tcmalloc::Static
bucket_allocator_	.\static_vars.cc	/^PageHeapAllocator<StackTraceTable::Bucket> Static::bucket_allocator_;$/;"	m	class:tcmalloc::Static	file:
bucket_allocator_	.\static_vars.h	/^  static PageHeapAllocator<StackTraceTable::Bucket> bucket_allocator_;$/;"	m	class:tcmalloc::Static
bucket_rep	.\heap-profile-table.h	/^    uintptr_t bucket_rep;$/;"	m	struct:HeapProfileTable::AllocValue
bucket_table_	.\heap-profile-table.h	/^  Bucket** bucket_table_;$/;"	m	class:HeapProfileTable
bucket_table_	.\memory_region_map.cc	/^HeapProfileBucket** MemoryRegionMap::bucket_table_ = NULL;  \/\/ GUARDED_BY(lock_)$/;"	m	class:MemoryRegionMap	file:
bucket_total	.\stack_trace_table.h	/^  int bucket_total() const { return bucket_total_; }$/;"	f	class:tcmalloc::StackTraceTable
bucket_total_	.\stack_trace_table.h	/^  int bucket_total_;$/;"	m	class:tcmalloc::StackTraceTable
buckets_	.\heap-profile-table.cc	/^  map<Bucket*, Entry> buckets_;$/;"	m	struct:HeapProfileTable::Snapshot::ReportState	file:
buf	.\heap-profile-table.h	/^    char* buf;$/;"	m	struct:HeapProfileTable::BufferArgs
buf	.\memfs_malloc.cc	/^  char buf[sizeof(HugetlbSysAllocator)];$/;"	m	union:__anon25	file:
buf	.\system-alloc.cc	/^  char buf[sizeof(DefaultSysAllocator)];$/;"	m	union:__anon32	file:
buf	.\system-alloc.cc	/^  char buf[sizeof(MmapSysAllocator)];$/;"	m	union:__anon31	file:
buf	.\system-alloc.cc	/^  char buf[sizeof(SbrkSysAllocator)];$/;"	m	union:__anon30	file:
buf_	.\base\sysinfo.h	/^    char buf_[kBufSize];$/;"	m	struct:ProcMapsIterator::Buffer
buf_	.\internal_logging.cc	/^  char buf_[kBufSize];$/;"	m	class:tcmalloc::Logger	file:
buf_	.\internal_logging.h	/^  char* buf_;           \/\/ Where should we write next$/;"	m	class:TCMalloc_Printer
buflen	.\heap-profile-table.h	/^    int buflen;$/;"	m	struct:HeapProfileTable::BufferArgs
bufsize	.\heap-profile-table.h	/^    int bufsize;$/;"	m	struct:HeapProfileTable::BufferArgs
busy_worker_	.\tests\profile-handler_unittest.cc	/^  BusyThread* busy_worker_;$/;"	m	class:__anon37::ProfileHandlerTest	file:
bytes	.\emergency_malloc.cc	/^    char bytes[sizeof(EmergencyArenaPagesAllocator)];$/;"	m	union:tcmalloc::__anon18	file:
bytes	.\heap-profile-table.cc	/^  int bytes;$/;"	m	struct:HeapProfileTable::Snapshot::Entry	file:
bytes	.\heap-profile-table.h	/^    size_t  bytes;   \/\/ Number of bytes in this allocation$/;"	m	struct:HeapProfileTable::AllocValue
bytes_until_sample_	.\sampler.h	/^  size_t        bytes_until_sample_;    \/\/ Bytes until we sample next$/;"	m	class:tcmalloc::Sampler
bytes_until_sample_	.\tests\sampler_test.cc	/^  size_t bytes_until_sample_;$/;"	m	class:OldSampler	file:
c_open	.\base\linuxthreads.cc	/^static int c_open(const char *fname, int flags, int mode) {$/;"	f	file:
cache_size_	.\central_freelist.h	/^  int32_t cache_size_;$/;"	m	class:tcmalloc::CentralFreeList
call_stack	.\heap-profile-table.h	/^    const void* const* call_stack;  \/\/ Stack trace$/;"	m	struct:HeapProfileTable::AllocContextInfo
call_stack	.\heap-profile-table.h	/^    const void* const* call_stack;  \/\/ call stack that made the allocation call$/;"	m	struct:HeapProfileTable::AllocInfo
call_stack	.\memory_region_map.h	/^    const void* call_stack[kMaxStackDepth];  \/\/ caller address stack array$/;"	m	struct:MemoryRegionMap::Region
call_stack_depth	.\memory_region_map.h	/^    int call_stack_depth;  \/\/ number of caller stack frames that we saved$/;"	m	struct:MemoryRegionMap::Region
callback	.\base\linuxthreads.cc	/^  ListAllProcessThreadsCallBack callback;$/;"	m	struct:ListerParams	file:
callback	.\profile-handler.cc	/^  ProfileHandlerCallback callback;$/;"	m	struct:ProfileHandlerToken	file:
callback_arg	.\profile-handler.cc	/^  void* callback_arg;$/;"	m	struct:ProfileHandlerToken	file:
callback_count	.\profile-handler.h	/^  int32 callback_count;  \/* Number of callbacks registered *\/$/;"	m	struct:ProfileHandlerState
caller	.\memory_region_map.h	/^    uintptr_t caller() const {$/;"	f	struct:MemoryRegionMap::Region
calloc	.\libc_override_redefine.h	/^  void* calloc(size_t n, size_t s)               { return tc_calloc(n, s);    }$/;"	f
calloc	.\windows\override_functions.cc	93;"	d	file:
callunrollinfo	.\getpc.h	/^static const CallUnrollInfo callunrollinfo[] = {$/;"	v
can_create_leaks_reliably	.\tests\heap-checker_unittest.cc	/^static bool can_create_leaks_reliably = false;$/;"	v	file:
ccr	.\base\elfcore.h	/^    unsigned long ccr;$/;"	m	struct:ppc_regs
central_bytes	.\tcmalloc.cc	/^  uint64_t central_bytes;     \/\/ Bytes in central cache$/;"	m	struct:TCMallocStats	file:
central_cache	.\static_vars.h	/^  static CentralFreeListPadded* central_cache() { return central_cache_; }$/;"	f	class:tcmalloc::Static
central_cache_	.\static_vars.cc	/^CentralFreeListPadded Static::central_cache_[kNumClasses];$/;"	m	class:tcmalloc::Static	file:
central_cache_	.\static_vars.h	/^  static CentralFreeListPadded central_cache_[kNumClasses];$/;"	m	class:tcmalloc::Static
cfree	.\libc_override_osx.h	/^  void  cfree(void* p)                   { tc_cfree(p);               }$/;"	f
cfree	.\libc_override_redefine.h	/^  void  cfree(void* p)                           { tc_cfree(p);               }$/;"	f
cfree	.\tests\tcmalloc_unittest.cc	102;"	d	file:
chars	.\base\low_level_alloc.cc	/^  char chars[sizeof(DefaultPagesAllocator)];$/;"	m	union:__anon9	file:
chars	.\debugallocation.cc	/^  char chars[sizeof(DebugMallocImplementation)];$/;"	m	union:__anon17	file:
checked_sections	.\malloc_hook.cc	/^static bool checked_sections = false;$/;"	v	file:
checker_	.\tests\profiledata_unittest.cc	/^  ProfileDataChecker checker_;$/;"	m	class:__anon38::ProfileDataTest	file:
class_array_	.\common.h	/^  unsigned char class_array_[kClassArraySize];$/;"	m	class:tcmalloc::SizeMap
class_to_pages	.\common.h	/^  inline size_t class_to_pages(size_t cl) {$/;"	f	class:tcmalloc::SizeMap
class_to_pages_	.\common.h	/^  size_t class_to_pages_[kNumClasses];$/;"	m	class:tcmalloc::SizeMap
class_to_size	.\common.h	/^  inline size_t class_to_size(size_t cl) {$/;"	f	class:tcmalloc::SizeMap
class_to_size_	.\common.h	/^  size_t class_to_size_[kNumClasses];$/;"	m	class:tcmalloc::SizeMap
clear_lowwatermark	.\thread_cache.h	/^    void clear_lowwatermark() { lowater_ = length_; }$/;"	f	class:tcmalloc::ThreadCache::FreeList
client_count_	.\memory_region_map.cc	/^int MemoryRegionMap::client_count_ = 0;$/;"	m	class:MemoryRegionMap	file:
client_count_	.\memory_region_map.h	/^  static int client_count_;$/;"	m	class:MemoryRegionMap
clone	.\base\linux_syscall_support.h	/^    LSS_INLINE int LSS_NAME(clone)(int (*fn)(void *), void *child_stack,$/;"	f
close	.\windows\port.h	/^inline int close(int fd) {$/;"	f
collector_	.\profiler.cc	/^  ProfileData   collector_;$/;"	m	class:CpuProfiler	file:
collector_	.\tests\profiledata_unittest.cc	/^  ProfileData        collector_;$/;"	m	class:__anon38::ProfileDataTest	file:
commandlineflags	.\base\commandlineflags.h	/^  namespace commandlineflags {$/;"	n	namespace:tcmalloc
committed_bytes	.\page_heap.h	/^    uint64_t committed_bytes;  \/\/ Bytes committed, always <= system_bytes_.$/;"	m	struct:tcmalloc::PageHeap::Stats
condition_register	.\stacktrace_powerpc-inl.h	/^  long condition_register;$/;"	m	struct:layout_ppc
condition_register	.\stacktrace_powerpc-linux-inl.h	/^  long condition_register;$/;"	m	struct:layout_ppc
const_pointer	.\base\stl_allocator.h	/^  typedef const T*   const_pointer;$/;"	t	class:STL_Allocator
const_reference	.\base\stl_allocator.h	/^  typedef const T&   const_reference;$/;"	t	class:STL_Allocator
construct	.\base\stl_allocator.h	/^  void construct(pointer p) { ::new(p) T(); }$/;"	f	class:STL_Allocator
construct	.\base\stl_allocator.h	/^  void construct(pointer p, const T& val) { ::new(p) T(val); }$/;"	f	class:STL_Allocator
constructor_heap_profiling	.\heap-checker.cc	/^static bool constructor_heap_profiling = false;$/;"	v	file:
count	.\heap-profile-table.cc	/^  int count;$/;"	m	struct:HeapProfileTable::Snapshot::Entry	file:
count	.\profiledata.h	/^    Slot count;                  \/\/ Number of hits$/;"	m	struct:ProfileData::Entry
count	.\stack_trace_table.h	/^    int count;$/;"	m	struct:tcmalloc::StackTraceTable::Bucket
count_	.\heap-checker-bcad.cc	/^  static int count_;$/;"	m	class:HeapLeakCheckerGlobalPrePost	file:
count_	.\heap-checker-bcad.cc	/^int HeapLeakCheckerGlobalPrePost::count_ = 0;$/;"	m	class:HeapLeakCheckerGlobalPrePost	file:
count_	.\profiledata.h	/^  int           count_;         \/\/ How many samples recorded$/;"	m	class:ProfileData
counter_	.\central_freelist.h	/^  size_t   counter_;        \/\/ Number of free objects in cache entry$/;"	m	class:tcmalloc::CentralFreeList
cp0_badvaddr	.\base\elfcore.h	/^    unsigned long cp0_badvaddr;$/;"	m	struct:mips_regs
cp0_cause	.\base\elfcore.h	/^    unsigned long cp0_cause;$/;"	m	struct:mips_regs
cp0_epc	.\base\elfcore.h	/^    unsigned long cp0_epc;      \/* Program counter.                          *\/$/;"	m	struct:mips_regs
cp0_status	.\base\elfcore.h	/^    unsigned long cp0_status;$/;"	m	struct:mips_regs
cpp_alloc	.\tcmalloc.cc	/^inline void* cpp_alloc(size_t size, bool nothrow) {$/;"	f	namespace:__anon34
cpuid	.\base\atomicops-internals-x86.cc	52;"	d	file:
cpuid	.\base\atomicops-internals-x86.cc	58;"	d	file:
crashed	.\internal_logging.cc	/^static bool crashed = false;$/;"	v	file:
cs	.\base\elfcore.h	/^    uint64_t  rip,cs,eflags;$/;"	m	struct:i386_regs
ctr	.\base\elfcore.h	/^    unsigned long ctr;$/;"	m	struct:ppc_regs
ctrgProcAddress	.\windows\patch_functions.cc	/^  static const int ctrgProcAddress = kNumFunctions;$/;"	m	class:__anon52::LibcInfo	file:
current_filename_	.\base\sysinfo.h	/^  char current_filename_[PATH_MAX];$/;"	m	class:ProcMapsIterator
current_image_	.\base\sysinfo.h	/^  int current_image_; \/\/ dll's are called "images" in macos parlance$/;"	m	class:ProcMapsIterator
current_instance	.\malloc_extension.cc	/^static MallocExtension* current_instance;$/;"	v	file:
current_load_cmd_	.\base\sysinfo.h	/^  int current_load_cmd_;   \/\/ the segment of this dll we're examining$/;"	m	class:ProcMapsIterator
current_thread_is	.\memory_region_map.cc	/^static inline bool current_thread_is(pthread_t should_be) {$/;"	f	file:
cyg_backtrace	.\stacktrace_instrument-inl.h	/^static int cyg_backtrace(void **buffer, int size) {$/;"	f
d	.\base\basictypes.h	/^  double d;$/;"	m	union:MemoryAligner
d	.\tests\heap-checker_unittest.cc	/^  char d[3];$/;"	m	class:ClassD	file:
d1	.\tests\heap-checker_unittest.cc	/^  char d1[11];$/;"	m	class:ClassMltD1	file:
d1	.\tests\heap-checker_unittest.cc	/^  char d1[15];$/;"	m	class:ClassD1	file:
d2	.\tests\heap-checker_unittest.cc	/^  char d2[15];$/;"	m	class:ClassMltD2	file:
d2	.\tests\heap-checker_unittest.cc	/^  char d2[19];$/;"	m	class:ClassD2	file:
d_ino	.\base\linux_syscall_support.h	/^  long               d_ino;$/;"	m	struct:kernel_dirent
d_ino	.\base\linux_syscall_support.h	/^  unsigned long long d_ino;$/;"	m	struct:kernel_dirent64
d_name	.\base\linux_syscall_support.h	/^  char               d_name[256];$/;"	m	struct:kernel_dirent
d_name	.\base\linux_syscall_support.h	/^  char               d_name[256];$/;"	m	struct:kernel_dirent64
d_off	.\base\linux_syscall_support.h	/^  long               d_off;$/;"	m	struct:kernel_dirent
d_off	.\base\linux_syscall_support.h	/^  long long          d_off;$/;"	m	struct:kernel_dirent64
d_reclen	.\base\linux_syscall_support.h	/^  unsigned short     d_reclen;$/;"	m	struct:kernel_dirent
d_reclen	.\base\linux_syscall_support.h	/^  unsigned short     d_reclen;$/;"	m	struct:kernel_dirent64
d_type	.\base\linux_syscall_support.h	/^  unsigned char      d_type;$/;"	m	struct:kernel_dirent64
data_	.\tests\profiledata_unittest.cc	/^  T* const data_;$/;"	m	class:__anon38::scoped_array	file:
data_addr	.\debugallocation.cc	/^  const void* data_addr() const { return (const void*)&size2_; }$/;"	f	class:MallocBlock
data_addr	.\debugallocation.cc	/^  void* data_addr() { return (void*)&size2_; }$/;"	f	class:MallocBlock
data_offset	.\debugallocation.cc	/^  static size_t data_offset() { return OFFSETOF_MEMBER(MallocBlock, size2_); }$/;"	f	class:MallocBlock
data_size	.\debugallocation.cc	/^  size_t data_size() const { return size1_; }$/;"	f	class:MallocBlock
dealloc_	.\addressmap-inl.h	/^  DeAllocator   dealloc_;               \/\/ The deallocator$/;"	m	class:AddressMap
dealloc_	.\heap-profile-table.h	/^  DeAllocator dealloc_;$/;"	m	class:HeapProfileTable
deallocate	.\base\stl_allocator.h	/^  void deallocate(pointer p, size_type n) { Alloc::Free(p, n * sizeof(T)); }$/;"	f	class:STL_Allocator
debug_alloc_retry_data	.\debugallocation.cc	/^struct debug_alloc_retry_data {$/;"	s	file:
debug_cpp_alloc	.\debugallocation.cc	/^inline void* debug_cpp_alloc(size_t size, int new_type, bool nothrow) {$/;"	f
debug_malloc_implementation_space	.\debugallocation.cc	/^} debug_malloc_implementation_space;$/;"	v	typeref:union:__anon17	file:
debug_pages_allocator_space	.\base\low_level_alloc.cc	/^} debug_pages_allocator_space;$/;"	v	typeref:union:__anon9	file:
default_arena	.\base\low_level_alloc.cc	/^static struct LowLevelAlloc::Arena default_arena;$/;"	v	typeref:struct:Arena	file:
default_pages_allocator	.\base\low_level_alloc.cc	/^static DefaultPagesAllocator *default_pages_allocator;$/;"	v	file:
default_space	.\system-alloc.cc	/^} default_space;$/;"	v	typeref:union:__anon32	file:
delegate_sized_delete	.\libc_override_gcc_and_weak.h	/^static void delegate_sized_delete(void *p, size_t s) throw() {$/;"	f
delegate_sized_deletearray	.\libc_override_gcc_and_weak.h	/^static void delegate_sized_deletearray(void *p, size_t s) throw() {$/;"	f
delete_hooks_	.\malloc_hook.cc	/^HookList<MallocHook::DeleteHook> delete_hooks_ = INIT_HOOK_LIST;$/;"	m	namespace:base::internal	file:
deleted_buffer_initialized_	.\debugallocation.cc	/^  static pthread_once_t deleted_buffer_initialized_;$/;"	m	class:MallocBlock	file:
deleted_buffer_initialized_	.\debugallocation.cc	/^pthread_once_t MallocBlock::deleted_buffer_initialized_ = PTHREAD_ONCE_INIT;$/;"	m	class:MallocBlock	file:
deleted_buffer_initialized_no_pthreads_	.\debugallocation.cc	/^  static bool deleted_buffer_initialized_no_pthreads_;$/;"	m	class:MallocBlock	file:
deleted_buffer_initialized_no_pthreads_	.\debugallocation.cc	/^bool MallocBlock::deleted_buffer_initialized_no_pthreads_ = false;$/;"	m	class:MallocBlock	file:
deleter_pcs	.\debugallocation.cc	/^  void* deleter_pcs[16];$/;"	m	struct:MallocBlockQueueEntry	file:
deleter_threadid	.\debugallocation.cc	/^  pthread_t deleter_threadid;$/;"	m	struct:MallocBlockQueueEntry	file:
depth	.\common.h	/^  uintptr_t depth;         \/\/ Number of PC values stored in array below$/;"	m	struct:tcmalloc::StackTrace
depth	.\heap-profile-stats.h	/^  int depth;                \/\/ Depth of stack trace.$/;"	m	struct:HeapProfileBucket
depth	.\profiledata.h	/^    Slot depth;                  \/\/ Stack depth$/;"	m	struct:ProfileData::Entry
depth_total	.\stack_trace_table.h	/^  int depth_total() const { return depth_total_; }$/;"	f	class:tcmalloc::StackTraceTable
depth_total_	.\stack_trace_table.h	/^  int depth_total_;$/;"	m	class:tcmalloc::StackTraceTable
dest	.\heap-profile-table.h	/^    Snapshot* dest;$/;"	m	struct:HeapProfileTable::AddNonLiveArgs
destr_fn	.\windows\port.cc	/^  void (*destr_fn)(void*);$/;"	m	struct:DestrFnClosure	file:
destr_fn_info	.\windows\port.cc	/^static DestrFnClosure destr_fn_info;   \/\/ initted to all NULL\/0.$/;"	v	file:
destroy	.\base\stl_allocator.h	/^  void destroy(pointer p) { p->~T(); }$/;"	f	class:STL_Allocator
destroy_	.\base\simple_mutex.h	/^  bool destroy_;$/;"	m	class:MUTEX_NAMESPACE::Mutex
destructor_	.\base\googleinit.h	/^  const VoidFunction destructor_;$/;"	m	class:GoogleInitializer
did_it_	.\windows\auto_testing_hook.h	/^  bool did_it_;  \/\/ Remember if we did it or not...$/;"	m	class:sidestep::AutoTestingHookImpl
die	.\tests\sampling_test.sh	/^die() {    # runs the command given as arguments, and then dies.$/;"	f
difference_type	.\base\stl_allocator.h	/^  typedef ptrdiff_t  difference_type;$/;"	t	class:STL_Allocator
disabled_ranges	.\heap-checker.cc	/^static DisabledRangeMap* disabled_ranges = NULL;$/;"	v	file:
do_calloc	.\tcmalloc.cc	/^ALWAYS_INLINE void* do_calloc(size_t n, size_t elem_size) {$/;"	f	namespace:__anon34
do_debug_malloc_or_debug_cpp_alloc	.\debugallocation.cc	/^inline void* do_debug_malloc_or_debug_cpp_alloc(size_t size) {$/;"	f
do_debug_memalign	.\debugallocation.cc	/^static void *do_debug_memalign(size_t alignment, size_t size) {$/;"	f	file:
do_debug_memalign_or_debug_cpp_memalign	.\debugallocation.cc	/^inline void* do_debug_memalign_or_debug_cpp_memalign(size_t align,$/;"	f
do_free	.\tcmalloc.cc	/^ALWAYS_INLINE void do_free(void* ptr) {$/;"	f	namespace:__anon34
do_free_helper	.\tcmalloc.cc	/^ALWAYS_INLINE void do_free_helper(void* ptr,$/;"	f	namespace:__anon34
do_free_with_callback	.\tcmalloc.cc	/^ALWAYS_INLINE void do_free_with_callback(void* ptr,$/;"	f	namespace:__anon34
do_main_heap_check	.\heap-checker.cc	/^static bool do_main_heap_check = false;$/;"	v	file:
do_mallinfo	.\tcmalloc.cc	/^inline struct mallinfo do_mallinfo() {$/;"	f	namespace:__anon34
do_malloc	.\tcmalloc.cc	/^ALWAYS_INLINE void* do_malloc(size_t size) {$/;"	f	namespace:__anon34
do_malloc_or_cpp_alloc	.\tcmalloc.cc	/^ALWAYS_INLINE void* do_malloc_or_cpp_alloc(size_t size) {$/;"	f	namespace:__anon34
do_malloc_pages	.\tcmalloc.cc	/^inline void* do_malloc_pages(ThreadCache* heap, size_t size) {$/;"	f	namespace:__anon34
do_malloc_small	.\tcmalloc.cc	/^ALWAYS_INLINE void* do_malloc_small(ThreadCache* heap, size_t size) {$/;"	f	namespace:__anon34
do_malloc_stats	.\tcmalloc.cc	/^inline void do_malloc_stats() {$/;"	f	namespace:__anon34
do_mallopt	.\tcmalloc.cc	/^inline int do_mallopt(int cmd, int value) {$/;"	f	namespace:__anon34
do_memalign	.\tcmalloc.cc	/^void* do_memalign(size_t align, size_t size) {$/;"	f	namespace:__anon34
do_memalign_or_cpp_memalign	.\tcmalloc.cc	/^inline void* do_memalign_or_cpp_memalign(size_t align, size_t size) {$/;"	f	namespace:__anon34
do_realloc	.\tcmalloc.cc	/^ALWAYS_INLINE void* do_realloc(void* old_ptr, size_t new_size) {$/;"	f	namespace:__anon34
do_realloc_with_callback	.\tcmalloc.cc	/^ALWAYS_INLINE void* do_realloc_with_callback($/;"	f	namespace:__anon34
do_sbrk	.\malloc_hook_mmap_freebsd.h	/^static inline void* do_sbrk(intptr_t increment) {$/;"	f
ds	.\base\elfcore.h	/^    uint64_t  ds,es,fs,gs;$/;"	m	struct:i386_regs
dummy_ap	.\heap-checker.cc	/^static va_list dummy_ap;$/;"	v	file:
dummy_for_alignment	.\base\low_level_alloc.cc	/^      void *dummy_for_alignment;   \/\/ aligns regions to 0 mod 2*sizeof(void*)$/;"	m	struct:low_level_alloc_internal::AllocList::Header	file:
dump_count	.\heap-profiler.cc	/^static int   dump_count = 0;          \/\/ How many dumps so far$/;"	v	file:
dumping	.\heap-profiler.cc	/^static bool  dumping = false;         \/\/ Dumping status to prevent recursion$/;"	v	file:
dynamic_buffer_	.\base\sysinfo.h	/^  Buffer* dynamic_buffer_;  \/\/ dynamically-allocated Buffer$/;"	m	class:ProcMapsIterator
dynstr_	.\base\elf_mem_image.h	/^  const char *dynstr_;$/;"	m	class:base::ElfMemImage
dynsym_	.\base\elf_mem_image.h	/^  const ElfW(Sym) *dynsym_;$/;"	m	class:base::ElfMemImage
ebuf_	.\base\sysinfo.h	/^  char *ebuf_;        \/\/ end of buffer (1 char for a nul)$/;"	m	class:ProcMapsIterator
eflags	.\base\elfcore.h	/^    uint64_t  rip,cs,eflags;$/;"	m	struct:i386_regs
ehdr	.\base\elf_mem_image.cc	/^const T* GetTableElement(const ElfW(Ehdr) *ehdr,$/;"	m	namespace:base::__anon1	file:
ehdr_	.\base\elf_mem_image.h	/^  const ElfW(Ehdr) *ehdr_;$/;"	m	class:base::ElfMemImage
element_size	.\base\elf_mem_image.cc	/^                         ElfW(Word) element_size,$/;"	m	namespace:base::__anon1	file:
emergency_arena	.\emergency_malloc.cc	/^  static LowLevelAlloc::Arena *emergency_arena;$/;"	m	namespace:tcmalloc	file:
emergency_arena_end	.\emergency_malloc.cc	/^  static char *emergency_arena_end;$/;"	m	namespace:tcmalloc	file:
emergency_arena_start	.\emergency_malloc.cc	/^  __attribute__ ((visibility("internal"))) char *emergency_arena_start;$/;"	m	namespace:tcmalloc	file:
emergency_arena_start_shifted	.\emergency_malloc.cc	/^  __attribute__ ((visibility("internal"))) uintptr_t emergency_arena_start_shifted;$/;"	m	namespace:tcmalloc	file:
empty	.\malloc_hook-inl.h	/^  bool empty() const {$/;"	f	struct:base::internal::HookList
empty	.\thread_cache.h	/^    bool empty() const {$/;"	f	class:tcmalloc::ThreadCache::FreeList
empty_	.\central_freelist.h	/^  Span     empty_;          \/\/ Dummy header for list of empty spans$/;"	m	class:tcmalloc::CentralFreeList
enabled	.\gperftools\profiler.h	/^  int    enabled;             \/* Is profiling currently enabled? *\/$/;"	m	struct:ProfilerState
enabled	.\profiledata.h	/^    bool     enabled;             \/\/ Is profiling currently enabled?$/;"	m	struct:ProfileData::State
enabled	.\profiledata.h	/^  bool enabled() const { return out_ >= 0; }$/;"	f	class:ProfileData
end	.\base\elf_mem_image.cc	/^ElfMemImage::SymbolIterator ElfMemImage::end() const {$/;"	f	class:base::ElfMemImage
end	.\base\vdso_support.h	/^  SymbolIterator end() const { return image_.end(); }$/;"	f	class:base::VDSOSupport
end	.\tests\stacktrace_unittest.cc	/^  const void *start, *end;$/;"	m	struct:__anon40::AddressRange	file:
end_	.\internal_logging.cc	/^  char* end_;$/;"	m	class:tcmalloc::Logger	file:
end_addr	.\memory_region_map.h	/^    uintptr_t end_addr;  \/\/ region end address$/;"	m	struct:MemoryRegionMap::Region
entry	.\profiledata.h	/^    Entry entry[kAssociativity];$/;"	m	struct:ProfileData::Bucket
err	.\base\linuxthreads.cc	/^  int         result, err;$/;"	m	struct:ListerParams	file:
errno_	.\base\elfcore.h	/^    int              errno_;$/;"	m	struct:Frame
errno_	.\base\elfcore.h	/^    int             errno_;$/;"	m	struct:Frame
error_	.\stack_trace_table.h	/^  bool error_;$/;"	m	class:tcmalloc::StackTraceTable
es	.\base\elfcore.h	/^    uint64_t  ds,es,fs,gs;$/;"	m	struct:i386_regs
etext_	.\base\sysinfo.h	/^  char *etext_;       \/\/ end of text$/;"	m	class:ProcMapsIterator
evict_	.\profiledata.h	/^  Slot*         evict_;         \/\/ evicted entries$/;"	m	class:ProfileData
evictions_	.\profiledata.h	/^  int           evictions_;     \/\/ How many evictions$/;"	m	class:ProfileData
expected_range	.\tests\stacktrace_unittest.cc	/^AddressRange expected_range[BACKTRACE_STEPS];$/;"	m	namespace:__anon40	file:
expected_type	.\tests\tcmalloc_unittest.cc	/^  base::MallocRange::Type expected_type;$/;"	m	struct:testing::__anon41::RangeCallbackState	file:
extra_bytes_released_	.\tcmalloc.cc	/^  size_t extra_bytes_released_;$/;"	m	class:TCMallocImplementation	file:
f	.\tests\heap-checker_unittest.cc	/^  virtual void f() { }$/;"	f	class:ClassB
f	.\tests\heap-checker_unittest.cc	/^  virtual void f() { }$/;"	f	class:ClassD	file:
f	.\tests\heap-checker_unittest.cc	/^  virtual void f() { }$/;"	f	class:ClassD1	file:
f	.\tests\heap-checker_unittest.cc	/^  virtual void f() { }$/;"	f	class:ClassMltD1
f	.\tests\heap-checker_unittest.cc	/^  virtual void f() { }$/;"	f	class:ClassMltD2
f2	.\tests\heap-checker_unittest.cc	/^  virtual void f2() { }$/;"	f	class:ClassB2
f2	.\tests\heap-checker_unittest.cc	/^  virtual void f2() { }$/;"	f	class:ClassD	file:
f2	.\tests\heap-checker_unittest.cc	/^  virtual void f2() { }$/;"	f	class:ClassD2	file:
f_	.\tests\heap-checker_unittest.cc	/^  FunctionSignature f_;$/;"	m	class:Callback0	file:
f_	.\tests\heap-checker_unittest.cc	/^  FunctionSignature f_;$/;"	m	class:Callback1	file:
f_	.\tests\heap-checker_unittest.cc	/^  FunctionSignature f_;$/;"	m	class:Callback2	file:
failed_	.\memfs_malloc.cc	/^  bool failed_;          \/\/ Whether failed to allocate memory.$/;"	m	class:HugetlbSysAllocator	file:
failed_	.\system-alloc.cc	/^  bool failed_[kMaxAllocators];$/;"	m	class:DefaultSysAllocator	file:
fallback_	.\memfs_malloc.cc	/^  SysAllocator* fallback_;  \/\/ Default system allocator to fall back to.$/;"	m	class:HugetlbSysAllocator	file:
fd	.\heap-profile-table.h	/^    RawFD fd;  \/\/ file to write to$/;"	m	struct:HeapProfileTable::DumpArgs
fd_	.\base\sysinfo.h	/^  int fd_;            \/\/ filehandle on \/proc\/*\/maps$/;"	m	class:ProcMapsIterator
fd_	.\base\sysinfo.h	/^  int fd_;$/;"	m	class:ProcMapsIterator
fd_	.\tests\profiledata_unittest.cc	/^  const int fd_;$/;"	m	struct:__anon38::FileDescriptor	file:
filename	.\tests\profiledata_unittest.cc	/^  string filename() const { return filename_; }$/;"	f	class:__anon38::ProfileDataChecker
filename_	.\tests\profiledata_unittest.cc	/^  string filename_;$/;"	m	class:__anon38::ProfileDataChecker	file:
filename_prefix	.\heap-profiler.cc	/^static char* filename_prefix = NULL;  \/\/ Prefix used for profile file names$/;"	v	file:
fill	.\tests\low_level_alloc_unittest.cc	/^  int fill;       \/\/ filled with data starting with this$/;"	m	struct:BlockDesc	file:
filter_	.\profiler.cc	/^  int           (*filter_)(void*);$/;"	m	class:CpuProfiler	file:
filter_arg_	.\profiler.cc	/^  void*         filter_arg_;$/;"	m	class:CpuProfiler	file:
filter_in_thread	.\gperftools\profiler.h	/^  int (*filter_in_thread)(void *arg);$/;"	m	struct:ProfilerOptions
filter_in_thread_arg	.\gperftools\profiler.h	/^  void *filter_in_thread_arg;$/;"	m	struct:ProfilerOptions
flag_aux_	.\windows\mini_disassembler_types.h	/^  int flag_aux_;$/;"	m	struct:sidestep::Opcode
flag_aux_	.\windows\mini_disassembler_types.h	/^  int flag_aux_;$/;"	m	struct:sidestep::SpecificOpcode
flag_dest_	.\windows\mini_disassembler_types.h	/^  int flag_dest_;$/;"	m	struct:sidestep::Opcode
flag_dest_	.\windows\mini_disassembler_types.h	/^  int flag_dest_;$/;"	m	struct:sidestep::SpecificOpcode
flag_source_	.\windows\mini_disassembler_types.h	/^  int flag_source_;$/;"	m	struct:sidestep::Opcode
flag_source_	.\windows\mini_disassembler_types.h	/^  int flag_source_;$/;"	m	struct:sidestep::SpecificOpcode
flags	.\base\low_level_alloc.cc	/^  int32 flags;            \/\/ flags passed to NewArena (ro after init)$/;"	m	struct:LowLevelAlloc::Arena	file:
flags	.\windows\nm-pdb.c	/^  ULONG flags;$/;"	m	struct:__anon50	file:
flags_	.\base\sysinfo.h	/^  char flags_[10];$/;"	m	class:ProcMapsIterator
fname	.\profiler.cc	/^char fname[PATH_MAX];$/;"	v
fname_	.\profiledata.h	/^  char*         fname_;         \/\/ Profile file name$/;"	m	class:ProfileData
forced_malloc	.\tests\malloc_extension_c_test.c	/^void *forced_malloc(size_t size)$/;"	f	file:
fpr	.\base\elfcore.h	/^    double        fpr[32];	\/* Floating-Point Registers - f0-f31.        *\/$/;"	m	struct:ppc_regs
fraction	.\gperftools\malloc_extension.h	/^  double fraction;      \/\/ Fraction of range that is being used (0 if !INUSE)$/;"	m	struct:base::MallocRange
frame	.\stacktrace_instrument-inl.h	/^  void* frame[MAX_DEPTH];$/;"	m	struct:__anon28
frame_forcer	.\stacktrace.cc	/^static int ATTRIBUTE_NOINLINE frame_forcer(int rv) {$/;"	f	file:
free	.\libc_override_redefine.h	/^  void  free(void* p)                            { tc_free(p);                }$/;"	f
free	.\windows\override_functions.cc	92;"	d	file:
free_	.\addressmap-inl.h	/^  Entry*        free_;                   \/\/ Free list of unused Entry objects$/;"	m	class:AddressMap
free_	.\page_heap.h	/^  SpanList free_[kMaxPages];$/;"	m	class:tcmalloc::PageHeap
free_	.\windows\preamble_patcher.h	/^    void* free_;$/;"	m	struct:sidestep::PreamblePatcher::PreamblePage
free_area_	.\page_heap_allocator.h	/^  char* free_area_;$/;"	m	class:tcmalloc::PageHeapAllocator
free_avail_	.\page_heap_allocator.h	/^  size_t free_avail_;$/;"	m	class:tcmalloc::PageHeapAllocator
free_bytes	.\page_heap.h	/^    uint64_t free_bytes;      \/\/ Total bytes on normal freelists$/;"	m	struct:tcmalloc::PageHeap::Stats
free_list_	.\page_heap_allocator.h	/^  void* free_list_;$/;"	m	class:tcmalloc::PageHeapAllocator
free_null_or_invalid	.\tcmalloc.cc	/^inline void free_null_or_invalid(void* ptr, void (*invalid_free_fn)(void*)) {$/;"	f	namespace:__anon34
free_queue_	.\debugallocation.cc	/^  static FreeQueue<MallocBlockQueueEntry>* free_queue_;$/;"	m	class:MallocBlock	file:
free_queue_	.\debugallocation.cc	/^FreeQueue<MallocBlockQueueEntry>* MallocBlock::free_queue_ = NULL;$/;"	m	class:MallocBlock	file:
free_queue_lock_	.\debugallocation.cc	/^  static SpinLock free_queue_lock_;$/;"	m	class:MallocBlock	file:
free_queue_size_	.\debugallocation.cc	/^  static size_t free_queue_size_;  \/\/ total size of blocks in free_queue_$/;"	m	class:MallocBlock	file:
free_queue_size_	.\debugallocation.cc	/^size_t MallocBlock::free_queue_size_ = 0;$/;"	m	class:MallocBlock	file:
free_size	.\heap-profile-stats.h	/^  int64 free_size;   \/\/ Total size of all freed objects so far.$/;"	m	struct:HeapProfileStats
freelist	.\base\low_level_alloc.cc	/^  AllocList freelist;     \/\/ head of free list; sorted by addr (under mu)$/;"	m	struct:LowLevelAlloc::Arena	file:
freelist_length	.\thread_cache.h	/^  int freelist_length(size_t cl) const { return list_[cl].length(); }$/;"	f	class:tcmalloc::ThreadCache
frees	.\heap-profile-stats.h	/^  int32 frees;       \/\/ Number of free calls.$/;"	m	struct:HeapProfileStats
frees	.\tests\low_level_alloc_unittest.cc	/^static int32 frees;$/;"	v	file:
frequency	.\profile-handler.h	/^  int32 frequency;  \/* Profiling frequency *\/$/;"	m	struct:ProfileHandlerState
frequency	.\profiledata.h	/^    int frequency() const {$/;"	f	class:ProfileData::Options
frequency_	.\profile-handler.cc	/^  int32 frequency_;$/;"	m	class:ProfileHandler	file:
frequency_	.\profiledata.h	/^    int      frequency_;                  \/\/ Sample frequency.$/;"	m	class:ProfileData::Options
fs	.\base\elfcore.h	/^    uint64_t  ds,es,fs,gs;$/;"	m	struct:i386_regs
fs_base	.\base\elfcore.h	/^    uint64_t  fs_base, gs_base;$/;"	m	struct:i386_regs
function_info_	.\windows\patch_functions.cc	/^  static FunctionInfo function_info_[kNumFunctions];$/;"	m	class:__anon52::WindowsInfo	file:
function_info_	.\windows\patch_functions.cc	/^\/*static*\/ WindowsInfo::FunctionInfo WindowsInfo::function_info_[] = {$/;"	m	class:__anon52::WindowsInfo	file:
function_name	.\windows\patch_functions.cc	/^  static const char* const function_name(int ifunction) {$/;"	f	class:__anon52::LibcInfo
function_name_	.\windows\patch_functions.cc	/^  static const char* const function_name_[kNumFunctions];$/;"	m	class:__anon52::LibcInfo	file:
function_name_	.\windows\patch_functions.cc	/^const char* const LibcInfo::function_name_[] = {$/;"	m	class:__anon52::LibcInfo	file:
futex_private_flag	.\base\spinlock_linux-inl.h	/^static int futex_private_flag = FUTEX_PRIVATE_FLAG;$/;"	v
g_array	.\tests\heap-profiler_unittest.cc	/^int* g_array[kMaxCount];              \/\/ an array of int-vectors$/;"	v
g_delete_hook_calls	.\tests\malloc_extension_c_test.c	/^static int g_delete_hook_calls = 0;$/;"	v	file:
g_have_exited_main	.\tests\heap-checker_unittest.cc	/^static bool g_have_exited_main = false;$/;"	v	file:
g_iters	.\tests\profiler_unittest.cc	/^static int g_iters = 0;   \/\/ argv[1]$/;"	v	file:
g_last_loaded	.\windows\patch_functions.cc	/^static std::set<HMODULE> *g_last_loaded;$/;"	m	namespace:__anon52	file:
g_load_map	.\windows\patch_functions.cc	/^static std::map<HMODULE, int>* g_load_map = NULL;$/;"	v	file:
g_module_libcs	.\windows\patch_functions.cc	/^static LibcInfo* g_module_libcs[] = {$/;"	m	namespace:__anon52	file:
g_new_hook_calls	.\tests\malloc_extension_c_test.c	/^static int g_new_hook_calls = 0;$/;"	v	file:
g_no_memory	.\tests\tcmalloc_unittest.cc	/^volatile bool g_no_memory = false;$/;"	m	namespace:testing	file:
g_old_handler	.\tests\tcmalloc_unittest.cc	/^std::new_handler g_old_handler = NULL;$/;"	m	namespace:testing	file:
g_pprof_path	.\symbolize.cc	/^static string* g_pprof_path = new string(FLAGS_symbolize_pprof);$/;"	v	file:
generation	.\tests\tcmalloc_unittest.cc	/^    int         generation;             \/\/ Generation counter of object contents$/;"	m	struct:testing::TesterThread::Object	file:
get	.\gperftools\heap-checker.h	/^  T* get() const { return reinterpret_cast<T*>(masked_t_ ^ kHideMask); }$/;"	f	class:HiddenPointer
get	.\pagemap.h	/^  void* get(Number k) const {$/;"	f	class:TCMalloc_PageMap1
get	.\pagemap.h	/^  void* get(Number k) const {$/;"	f	class:TCMalloc_PageMap2
get	.\pagemap.h	/^  void* get(Number k) const {$/;"	f	class:TCMalloc_PageMap3
get	.\tests\profiledata_unittest.cc	/^  T* get() { return data_; }$/;"	f	class:__anon38::scoped_array
get	.\tests\profiledata_unittest.cc	/^  int get() { return fd_; }$/;"	f	struct:__anon38::FileDescriptor
get	.\tests\sampler_test.cc	/^  T* get() { return p_; }$/;"	f	class:__anon39::scoped_array
get	.\tests\sampler_test.cc	/^  const T* get() const { return p_; }$/;"	f	class:__anon39::scoped_array
get_stack_impl	.\stacktrace.cc	/^static GetStackImplementation *get_stack_impl = &impl__arm;$/;"	v	file:
get_stack_impl	.\stacktrace.cc	/^static GetStackImplementation *get_stack_impl = &impl__generic;$/;"	v	file:
get_stack_impl	.\stacktrace.cc	/^static GetStackImplementation *get_stack_impl = &impl__instrument;$/;"	v	file:
get_stack_impl	.\stacktrace.cc	/^static GetStackImplementation *get_stack_impl = &impl__libgcc;$/;"	v	file:
get_stack_impl	.\stacktrace.cc	/^static GetStackImplementation *get_stack_impl = &impl__libunwind;$/;"	v	file:
get_stack_impl	.\stacktrace.cc	/^static GetStackImplementation *get_stack_impl = &impl__ppc;$/;"	v	file:
get_stack_impl	.\stacktrace.cc	/^static GetStackImplementation *get_stack_impl = &impl__win32;$/;"	v	file:
get_stack_impl	.\stacktrace.cc	/^static GetStackImplementation *get_stack_impl = &impl__x86;$/;"	v	file:
get_stack_impl_inited	.\stacktrace.cc	/^static bool get_stack_impl_inited;$/;"	v	file:
get_thread_disable_counter	.\heap-checker.cc	/^inline int get_thread_disable_counter() {$/;"	f
getcwd	.\windows\port.h	/^inline char *getcwd(char *buf, size_t size) {$/;"	f
getpagesize	.\windows\port.cc	/^int getpagesize() {$/;"	f
getpc_retval	.\tests\getpc_test.cc	/^static volatile void* getpc_retval = NULL;    \/\/ what GetPC returns$/;"	v	file:
getpid	.\windows\port.h	/^inline pid_t getpid(void) { return _getpid(); }$/;"	f
getppid	.\windows\port.h	/^inline pid_t getppid(void) { return 0; }$/;"	f
gettid	.\base\linux_syscall_support.h	/^  LSS_INLINE pid_t LSS_NAME(gettid)() {$/;"	f
gettid	.\stacktrace_instrument-inl.h	56;"	d
glibc_override_free	.\libc_override_glibc.h	/^static void glibc_override_free(void *ptr, const void *caller) {$/;"	f
glibc_override_malloc	.\libc_override_glibc.h	/^static void* glibc_override_malloc(size_t size, const void *caller) {$/;"	f
glibc_override_memalign	.\libc_override_glibc.h	/^static void* glibc_override_memalign(size_t align, size_t size,$/;"	f
glibc_override_realloc	.\libc_override_glibc.h	/^static void* glibc_override_realloc(void *ptr, size_t size,$/;"	f
global_profiler_buffer	.\heap-profiler.cc	/^static char* global_profiler_buffer = NULL;$/;"	v	file:
global_region_caller_ranges	.\heap-checker.cc	/^static GlobalRegionCallerRangeMap* global_region_caller_ranges = NULL;$/;"	v	file:
google_malloc	.\malloc_hook.cc	/^DECLARE_ATTRIBUTE_SECTION_VARS(google_malloc);$/;"	v
google_malloc	.\malloc_hook.cc	/^DEFINE_ATTRIBUTE_SECTION_VARS(google_malloc);$/;"	v
google_malloc	.\tcmalloc.cc	/^      ATTRIBUTE_SECTION(google_malloc);$/;"	v
got_66_prefix_	.\windows\mini_disassembler.h	/^  bool got_f2_prefix_, got_f3_prefix_, got_66_prefix_;$/;"	m	class:sidestep::MiniDisassembler
got_f2_prefix_	.\windows\mini_disassembler.h	/^  bool got_f2_prefix_, got_f3_prefix_, got_66_prefix_;$/;"	m	class:sidestep::MiniDisassembler
got_f3_prefix_	.\windows\mini_disassembler.h	/^  bool got_f2_prefix_, got_f3_prefix_, got_66_prefix_;$/;"	m	class:sidestep::MiniDisassembler
granularity_	.\windows\preamble_patcher.cc	/^long PreamblePatcher::granularity_ = 0;$/;"	m	class:sidestep::PreamblePatcher	file:
granularity_	.\windows\preamble_patcher.h	/^  static long granularity_;$/;"	m	class:sidestep::PreamblePatcher
growth_stacks	.\static_vars.h	/^  static StackTrace* growth_stacks() { return growth_stacks_; }$/;"	f	class:tcmalloc::Static
growth_stacks_	.\static_vars.cc	/^StackTrace* Static::growth_stacks_ = NULL;$/;"	m	class:tcmalloc::Static	file:
growth_stacks_	.\static_vars.h	/^  static StackTrace* growth_stacks_;$/;"	m	class:tcmalloc::Static
grp	.\tests\heap-checker_unittest.cc	/^static struct group* grp = NULL;$/;"	v	typeref:struct:group	file:
gs	.\base\elfcore.h	/^    uint64_t  ds,es,fs,gs;$/;"	m	struct:i386_regs
gs_base	.\base\elfcore.h	/^    uint64_t  fs_base, gs_base;$/;"	m	struct:i386_regs
handle_oom	.\tcmalloc.cc	/^void* handle_oom(malloc_fn retry_fn,$/;"	f	namespace:__anon34
has_called_before_constructors	.\heap-checker.cc	/^static bool has_called_before_constructors = false;$/;"	v	file:
has_checked_	.\gperftools\heap-checker.h	/^  bool has_checked_;  \/\/ if we have done the leak check, so these are ready:$/;"	m	class:HeapLeakChecker
has_cmpxchg16b	.\base\atomicops-internals-x86.h	/^  bool has_cmpxchg16b;      \/\/ Processor supports cmpxchg16b instruction.$/;"	m	struct:AtomicOps_x86CPUFeatureStruct
has_sse2	.\base\atomicops-internals-x86.h	/^  bool has_sse2;            \/\/ Processor has SSE2.$/;"	m	struct:AtomicOps_x86CPUFeatureStruct
hash	.\heap-profile-stats.h	/^  uintptr_t hash;           \/\/ Hash value of the stack trace.$/;"	m	struct:HeapProfileBucket
hash	.\stack_trace_table.h	/^    uintptr_t hash;$/;"	m	struct:tcmalloc::StackTraceTable::Bucket
hash_	.\base\elf_mem_image.h	/^  const ElfW(Word) *hash_;$/;"	m	class:base::ElfMemImage
hash_	.\profiledata.h	/^  Bucket*       hash_;          \/\/ hash table$/;"	m	class:ProfileData
hashtable_	.\addressmap-inl.h	/^  Cluster**     hashtable_;              \/\/ The hash-table$/;"	m	class:AddressMap
have_futex	.\base\spinlock_linux-inl.h	/^static bool have_futex;$/;"	v
have_modrm_	.\windows\mini_disassembler.h	/^  bool have_modrm_;$/;"	m	class:sidestep::MiniDisassembler
have_tls	.\thread_cache.h	/^  enum { have_tls = true };$/;"	e	enum:tcmalloc::ThreadCache::__anon49
hc_strstr	.\heap-checker.cc	/^static const char* hc_strstr(const char* s1, const char* s2) {$/;"	f	file:
head	.\central_freelist.h	/^    void *head;  \/\/ Head of chain of objects.$/;"	m	struct:tcmalloc::CentralFreeList::TCEntry
header	.\base\low_level_alloc.cc	/^    } header;$/;"	m	struct:low_level_alloc_internal::AllocList	typeref:struct:low_level_alloc_internal::AllocList::Header	file:
heap	.\thread_cache.h	/^    ThreadCache* heap;$/;"	m	struct:tcmalloc::ThreadCache::ThreadLocalData
heap_	.\tests\tcmalloc_unittest.cc	/^  vector<Object>        heap_;          \/\/ This thread's heap$/;"	m	class:testing::TesterThread	file:
heap_check	.\tests\heap-checker_unittest.cc	/^DECLARE_string(heap_check);  \/\/ in heap-checker.cc$/;"	v
heap_check_max_pointer_offset	.\tests\heap-checker_unittest.cc	/^DECLARE_int64(heap_check_max_pointer_offset);   \/\/ heap-checker.cc$/;"	v
heap_checker_h	.\tests\simple_compat_test.cc	/^HeapLeakChecker::Disabler* heap_checker_h;$/;"	v
heap_checker_info_level	.\heap-checker.cc	/^static const int heap_checker_info_level = 0;$/;"	v	file:
heap_checker_on	.\heap-checker.cc	/^static bool heap_checker_on = false;$/;"	v	file:
heap_checker_pid	.\heap-checker.cc	/^static pid_t heap_checker_pid = 0;$/;"	v	file:
heap_cleanups_	.\gperftools\heap-checker.h	/^  static std::vector<void_function>* heap_cleanups_;$/;"	m	class:HeapCleaner
heap_cleanups_	.\heap-checker.cc	/^vector<HeapCleaner::void_function>* HeapCleaner::heap_cleanups_ = NULL;$/;"	m	class:HeapCleaner	file:
heap_key_	.\thread_cache.cc	/^pthread_key_t ThreadCache::heap_key_;$/;"	m	class:tcmalloc::ThreadCache	file:
heap_key_	.\thread_cache.h	/^  static pthread_key_t heap_key_;$/;"	m	class:tcmalloc::ThreadCache
heap_leak_checker_bcad_variable	.\heap-checker-bcad.cc	/^bool heap_leak_checker_bcad_variable;$/;"	v
heap_leak_checker_global_pre_post	.\heap-checker-bcad.cc	/^static const HeapLeakCheckerGlobalPrePost heap_leak_checker_global_pre_post;$/;"	v	file:
heap_profile	.\heap-checker.cc	/^static HeapProfileTable* heap_profile = NULL;$/;"	v	file:
heap_profile	.\heap-profiler.cc	/^static HeapProfileTable* heap_profile = NULL;  \/\/ the heap profile table$/;"	v	file:
heap_profile_end_writer	.\heap-profiler.cc	/^static HeapProfileEndWriter heap_profile_end_writer;$/;"	v	file:
heap_profiler_h	.\tests\simple_compat_test.cc	/^void (*heap_profiler_h)(const char*) = &HeapProfilerStart;$/;"	v
heap_profiler_memory	.\heap-profiler.cc	/^static LowLevelAlloc::Arena *heap_profiler_memory;$/;"	v	file:
heap_size_	.\tests\tcmalloc_unittest.cc	/^  size_t                heap_size_;     \/\/ Current heap size$/;"	m	class:testing::TesterThread	file:
held_	.\central_freelist.cc	/^  SpinLock *held_, *temp_;$/;"	m	class:tcmalloc::__anon16::LockInverter	file:
hi	.\base\elfcore.h	/^    unsigned long hi;           \/* Used for multiplication and division.     *\/$/;"	m	struct:mips_regs
high_water_mark	.\heap-profiler.cc	/^static int64 high_water_mark = 0;     \/\/ In-use-bytes at last high-water dump$/;"	v	file:
history	.\span.h	/^  char history[64];$/;"	m	struct:tcmalloc::Span
hmodule	.\windows\patch_functions.cc	/^  HMODULE hmodule() const {$/;"	f	class:__anon52::LibcInfo
hook_	.\windows\auto_testing_hook.h	/^  AutoTestingHookBase* hook_;$/;"	m	class:sidestep::AutoTestingHookHolder
hugetlb_base_	.\memfs_malloc.cc	/^  off_t hugetlb_base_;$/;"	m	class:HugetlbSysAllocator	file:
hugetlb_fd_	.\memfs_malloc.cc	/^  int hugetlb_fd_;       \/\/ file descriptor for hugetlb$/;"	m	class:HugetlbSysAllocator	file:
hugetlb_space	.\memfs_malloc.cc	/^} hugetlb_space;$/;"	v	typeref:union:__anon25	file:
i0	.\tests\heap-checker_unittest.cc	/^  Inner i0;$/;"	m	struct:Nesting	file:
i1	.\tests\heap-checker_unittest.cc	/^  Inner i1;$/;"	m	struct:Nesting	file:
i2	.\tests\heap-checker_unittest.cc	/^  Inner i2;$/;"	m	struct:Nesting	file:
i3	.\tests\heap-checker_unittest.cc	/^  Inner i3;$/;"	m	struct:Nesting	file:
i386_regs	.\base\elfcore.h	/^  typedef struct i386_regs {    \/* Normal (non-FPU) CPU registers            *\/$/;"	s
i386_regs	.\base\elfcore.h	/^  } i386_regs;$/;"	t	typeref:struct:i386_regs
ibuf_	.\base\sysinfo.h	/^  char *ibuf_;        \/\/ input buffer$/;"	m	class:ProcMapsIterator
id	.\addressmap-inl.h	/^    Number   id;                        \/\/ Cluster ID$/;"	m	struct:AddressMap::Cluster
id	.\tests\testutil.cc	/^  int id;$/;"	m	struct:FunctionAndId	file:
id_	.\tests\tcmalloc_unittest.cc	/^  int                   id_;            \/\/ My thread id$/;"	m	class:testing::TesterThread	file:
ignore	.\heap-profile-table.h	/^    bool ignore() const { return bucket_rep & kIgnore; }$/;"	f	struct:HeapProfileTable::AllocValue
ignored	.\heap-profile-table.h	/^    bool ignored;$/;"	m	struct:HeapProfileTable::AllocInfo
ignored_objects	.\heap-checker.cc	/^static IgnoredObjectsMap* ignored_objects = NULL;$/;"	v	file:
image_	.\base\elf_mem_image.h	/^    const void *const image_;$/;"	m	class:base::ElfMemImage::SymbolIterator
image_	.\base\vdso_support.h	/^  ElfMemImage image_;$/;"	m	class:base::VDSOSupport
in_setspecific_	.\thread_cache.h	/^  bool          in_setspecific_;        \/\/ In call to pthread_setspecific?$/;"	m	class:tcmalloc::ThreadCache
index_	.\base\elf_mem_image.h	/^    int index_;$/;"	m	class:base::ElfMemImage::SymbolIterator
info_	.\base\elf_mem_image.h	/^    SymbolInfo info_;$/;"	m	class:base::ElfMemImage::SymbolIterator
init_default_stack_impl	.\stacktrace.cc	/^static void init_default_stack_impl(void) {$/;"	f	file:
init_default_stack_impl_inner	.\stacktrace.cc	/^static void init_default_stack_impl_inner(void) {$/;"	f	file:
init_forcer	.\tests\heap-checker_unittest.cc	/^void (* volatile init_forcer)(...);$/;"	v
init_helper	.\base\spinlock.cc	/^static SpinLock_InitHelper init_helper;$/;"	m	namespace:__anon11	file:
init_module	.\base\spinlock_linux-inl.h	/^} init_module;$/;"	m	namespace:__anon15	typeref:struct:__anon15::InitModule
init_thread_disable_counter	.\heap-checker.cc	/^InitThreadDisableCounter init_thread_disable_counter;$/;"	v
initialized	.\tests\heap-checker_unittest.cc	/^static Initialized initialized;$/;"	v	file:
initialized_	.\windows\preamble_patcher.cc	/^bool PreamblePatcher::initialized_ = false;$/;"	m	class:sidestep::PreamblePatcher	file:
initialized_	.\windows\preamble_patcher.h	/^  static bool initialized_;$/;"	m	class:sidestep::PreamblePatcher
inline	.\windows\config.h	300;"	d
inline	.\windows\port.h	494;"	d
inline	.\windows\port.h	89;"	d
inline	.\windows\port.h	91;"	d
ins	.\getpc.h	/^  unsigned char ins[16];$/;"	m	struct:CallUnrollInfo
ins_size	.\getpc.h	/^  int ins_size;$/;"	m	struct:CallUnrollInfo
instance	.\malloc_extension.cc	/^MallocExtension* MallocExtension::instance() {$/;"	f	class:MallocExtension
instance_	.\profile-handler.cc	/^  static ProfileHandler* instance_;$/;"	m	class:ProfileHandler	file:
instance_	.\profile-handler.cc	/^ProfileHandler* ProfileHandler::instance_ = NULL;$/;"	m	class:ProfileHandler	file:
instance_	.\profiler.cc	/^  static CpuProfiler instance_;$/;"	m	class:CpuProfiler	file:
instance_	.\profiler.cc	/^CpuProfiler CpuProfiler::instance_;$/;"	m	class:CpuProfiler	file:
instruction_type_	.\windows\mini_disassembler.h	/^  InstructionType instruction_type_;$/;"	m	class:sidestep::MiniDisassembler
int16	.\base\basictypes.h	/^typedef int16_t             int16;$/;"	t
int16_t	.\windows\port.h	/^typedef __int16 int16_t;$/;"	t
int32	.\base\basictypes.h	/^typedef int32_t             int32;$/;"	t
int32_t	.\windows\port.h	/^typedef __int32 int32_t;$/;"	t
int64	.\base\basictypes.h	/^typedef int64_t             int64;$/;"	t
int64_t	.\windows\port.h	/^typedef __int64 int64_t;$/;"	t
int8	.\base\basictypes.h	/^typedef int8_t              int8;$/;"	t
int8_t	.\windows\port.h	/^typedef __int8 int8_t;$/;"	t
internal	.\base\spinlock_internal.cc	/^namespace base { namespace internal { static int SuggestedDelayNS(int loop); }}$/;"	n	namespace:base	file:
internal	.\base\spinlock_internal.cc	/^namespace internal {$/;"	n	namespace:base	file:
internal	.\base\spinlock_internal.h	/^namespace internal {$/;"	n	namespace:base
internal	.\base\spinlock_linux-inl.h	/^namespace internal {$/;"	n	namespace:base
internal	.\base\spinlock_posix-inl.h	/^namespace internal {$/;"	n	namespace:base
internal	.\base\spinlock_win32-inl.h	/^namespace internal {$/;"	n	namespace:base
internal	.\malloc_hook-inl.h	/^namespace base { namespace internal {$/;"	n	namespace:base
internal	.\malloc_hook.cc	/^namespace base { namespace internal {$/;"	n	namespace:base	file:
internal_init_start_has_run	.\heap-checker.cc	/^static bool internal_init_start_has_run = false;$/;"	v	file:
interrupts	.\profile-handler.h	/^  int64 interrupts;  \/* Number of interrupts received *\/$/;"	m	struct:ProfileHandlerState
inuse	.\page_heap_allocator.h	/^  int inuse() const { return inuse_; }$/;"	f	class:tcmalloc::PageHeapAllocator
inuse_	.\page_heap_allocator.h	/^  int inuse_;$/;"	m	class:tcmalloc::PageHeapAllocator
inuse_allocs_increase_	.\gperftools\heap-checker.h	/^  ssize_t inuse_allocs_increase_;  \/\/ allocations-in-use increase$/;"	m	class:HeapLeakChecker
inuse_bytes_increase_	.\gperftools\heap-checker.h	/^  ssize_t inuse_bytes_increase_;  \/\/ bytes-in-use increase for this checker$/;"	m	class:HeapLeakChecker
invocation_name	.\heap-checker.cc	/^static const char* invocation_name() { return "<your binary>"; }$/;"	f	file:
invocation_name	.\heap-checker.cc	/^static const char* invocation_name() { return program_invocation_short_name; }$/;"	f	file:
invocation_path	.\heap-checker.cc	/^static string invocation_path() { return "<your binary>"; }$/;"	f	file:
invocation_path	.\heap-checker.cc	/^static string invocation_path() { return program_invocation_name; }$/;"	f	file:
invoked_	.\tests\system-alloc_unittest.cc	/^  bool invoked_;$/;"	m	class:ArraySysAllocator	file:
is_encoded_in_instruction_	.\windows\mini_disassembler_types.h	/^  bool is_encoded_in_instruction_;$/;"	m	struct:sidestep::ModrmEntry
is_on	.\heap-profiler.cc	/^static bool  is_on = false;           \/\/ If are on as a subsytem.$/;"	v	file:
is_prefix_dependent_	.\windows\mini_disassembler_types.h	/^  bool is_prefix_dependent_;$/;"	m	struct:sidestep::Opcode
is_safe_	.\base\simple_mutex.h	/^  volatile bool is_safe_;$/;"	m	class:MUTEX_NAMESPACE::Mutex
is_stack	.\memory_region_map.h	/^    bool is_stack;  \/\/ does this region contain a thread's stack:$/;"	m	struct:MemoryRegionMap::Region
is_valid	.\windows\patch_functions.cc	/^  bool is_valid() const { return is_valid_; }$/;"	f	class:__anon52::LibcInfo
is_valid_	.\windows\patch_functions.cc	/^  bool is_valid_;$/;"	m	class:__anon52::LibcInfo	file:
joinable_	.\tests\profile-handler_unittest.cc	/^  bool joinable_;$/;"	m	class:__anon37::Thread	file:
jumpspot	.\windows\shortproc.asm	/^jumpspot:$/;"	l
kAddressBits	.\common.h	/^static const int kAddressBits = (sizeof(void*) < 8 ? (8 * sizeof(void*)) : 48);$/;"	v
kAddressBits	.\common.h	/^static const int kAddressBits = 8 * sizeof(void*);$/;"	v
kAlignment	.\common.h	/^static const size_t kAlignment  = 8;$/;"	v
kAllocIncrement	.\page_heap_allocator.h	/^  static const int kAllocIncrement = 128 << 10;$/;"	m	class:tcmalloc::PageHeapAllocator
kAllocName	.\debugallocation.cc	/^  static const char* const kAllocName[];$/;"	m	class:MallocBlock	file:
kAllocName	.\debugallocation.cc	/^const char* const MallocBlock::kAllocName[] = {$/;"	m	class:MallocBlock	file:
kAllocTypeMask	.\debugallocation.cc	/^  static const int kAllocTypeMask = 0x3;$/;"	m	class:MallocBlock	file:
kArrayNewType	.\debugallocation.cc	/^  static const int kArrayNewType = 0xBCEADF72;$/;"	m	class:MallocBlock	file:
kArraySize	.\tests\system-alloc_unittest.cc	/^  static const int kArraySize = 8 * 1024 * 1024;$/;"	m	class:ArraySysAllocator	file:
kArraySize	.\tests\system-alloc_unittest.cc	/^const int ArraySysAllocator::kArraySize;$/;"	m	class:ArraySysAllocator	file:
kAssociativity	.\profiledata.cc	/^const int ProfileData::kAssociativity;$/;"	m	class:ProfileData	file:
kAssociativity	.\profiledata.h	/^  static const int kAssociativity = 4;          \/\/ For hashtable$/;"	m	class:ProfileData
kAsyncSignalSafe	.\base\low_level_alloc.h	/^    kAsyncSignalSafe = 0x0002,$/;"	e	enum:LowLevelAlloc::__anon10
kBaseClasses	.\common.h	/^static const size_t kBaseClasses = 16;$/;"	v
kBaseClasses	.\common.h	/^static const size_t kBaseClasses = 9;$/;"	v
kBlockBits	.\addressmap-inl.h	/^  static const int kBlockBits = 7;$/;"	m	class:AddressMap
kBlockSize	.\addressmap-inl.h	/^  static const int kBlockSize = 1 << kBlockBits;$/;"	m	class:AddressMap
kBuckets	.\profiledata.cc	/^const int ProfileData::kBuckets;$/;"	m	class:ProfileData	file:
kBuckets	.\profiledata.h	/^  static const int kBuckets = 1 << 10;          \/\/ For hashtable$/;"	m	class:ProfileData
kBufSize	.\base\sysinfo.h	/^    static const size_t kBufSize = 102400;$/;"	m	struct:ProcMapsIterator::Buffer
kBufSize	.\internal_logging.cc	/^  static const int kBufSize = 200;$/;"	m	class:tcmalloc::Logger	file:
kBufferLength	.\profiledata.cc	/^const int ProfileData::kBufferLength;$/;"	m	class:ProfileData	file:
kBufferLength	.\profiledata.h	/^  static const int kBufferLength = 1 << 18;     \/\/ For eviction buffer$/;"	m	class:ProfileData
kCallMallocHook	.\base\low_level_alloc.h	/^    kCallMallocHook = 0x0001,$/;"	e	enum:LowLevelAlloc::__anon10
kCalloc	.\windows\patch_functions.cc	/^    kMalloc, kFree, kRealloc, kCalloc,$/;"	e	enum:__anon52::LibcInfo::__anon53	file:
kClassArraySize	.\common.h	/^  static const size_t kClassArraySize =$/;"	m	class:tcmalloc::SizeMap
kClusterBits	.\addressmap-inl.h	/^  static const int kClusterBits = 13;$/;"	m	class:AddressMap
kClusterBlocks	.\addressmap-inl.h	/^  static const int kClusterBlocks = 1 << kClusterBits;$/;"	m	class:AddressMap
kClusterSize	.\addressmap-inl.h	/^  static const Number kClusterSize = 1 << (kBlockBits + kClusterBits);$/;"	m	class:AddressMap
kCrash	.\internal_logging.h	/^  kCrash,                     \/\/ Print the message and crash$/;"	e	enum:tcmalloc::LogMode
kCrashWithStats	.\internal_logging.h	/^  kCrashWithStats             \/\/ Print the message, some stats, and crash$/;"	e	enum:tcmalloc::LogMode
kDeallocName	.\debugallocation.cc	/^  static const char* const kDeallocName[];$/;"	m	class:MallocBlock	file:
kDeallocName	.\debugallocation.cc	/^const char* const MallocBlock::kDeallocName[] = {$/;"	m	class:MallocBlock	file:
kDeallocatedTypeBit	.\debugallocation.cc	/^  static const int kDeallocatedTypeBit = 0x4;$/;"	m	class:MallocBlock	file:
kDebugMode	.\system-alloc.cc	/^static const bool kDebugMode = false;$/;"	v	file:
kDebugMode	.\system-alloc.cc	/^static const bool kDebugMode = true;$/;"	v	file:
kDefaultFrequency	.\profile-handler.cc	/^  static const int32 kDefaultFrequency = 100;$/;"	m	class:ProfileHandler	file:
kDefaultFrequency	.\profile-handler.cc	/^const int32 ProfileHandler::kDefaultFrequency;$/;"	m	class:ProfileHandler	file:
kDefaultLargeAllocReportThreshold	.\tcmalloc.cc	/^const int64 kDefaultLargeAllocReportThreshold = static_cast<int64>(1) << 30;$/;"	v
kDefaultLargeAllocReportThreshold	.\tcmalloc.cc	/^const int64 kDefaultLargeAllocReportThreshold = static_cast<int64>(1) << 62;$/;"	v
kDefaultOverallThreadCacheSize	.\common.h	/^static const size_t kDefaultOverallThreadCacheSize = 8u * kMaxThreadCacheSize;$/;"	v
kDefaultOverallThreadCacheSize	.\common.h	/^static const size_t kDefaultOverallThreadCacheSize = kMaxThreadCacheSize;$/;"	v
kDefaultReleaseDelay	.\page_heap.h	/^  static const int kDefaultReleaseDelay = 1 << 18;$/;"	m	class:tcmalloc::PageHeap
kDefaultTransferNumObjecs	.\common.cc	/^static const int32 kDefaultTransferNumObjecs = 512;$/;"	m	namespace:tcmalloc	file:
kDelete	.\windows\patch_functions.cc	/^    kNew, kNewArray, kDelete, kDeleteArray,$/;"	e	enum:__anon52::LibcInfo::__anon53	file:
kDeleteArray	.\windows\patch_functions.cc	/^    kNew, kNewArray, kDelete, kDeleteArray,$/;"	e	enum:__anon52::LibcInfo::__anon53	file:
kDeleteArrayNothrow	.\windows\patch_functions.cc	/^    kNewNothrow, kNewArrayNothrow, kDeleteNothrow, kDeleteArrayNothrow,$/;"	e	enum:__anon52::LibcInfo::__anon53	file:
kDeleteNothrow	.\windows\patch_functions.cc	/^    kNewNothrow, kNewArrayNothrow, kDeleteNothrow, kDeleteArrayNothrow,$/;"	e	enum:__anon52::LibcInfo::__anon53	file:
kElfClass	.\base\elf_mem_image.cc	/^  static const int kElfClass = -1;$/;"	m	class:base::__anon1::ElfClass	file:
kElfClass	.\base\elf_mem_image.cc	/^  static const int kElfClass = ELFCLASS32;$/;"	m	class:base::__anon1::ElfClass	file:
kElfClass	.\base\elf_mem_image.cc	/^  static const int kElfClass = ELFCLASS64;$/;"	m	class:base::__anon1::ElfClass	file:
kEmergencyArenaShift	.\emergency_malloc.h	/^  static const uintptr_t kEmergencyArenaShift = 20+4; \/\/ 16 megs$/;"	m	namespace:tcmalloc
kEmergencyArenaSize	.\emergency_malloc.h	/^  static const uintptr_t kEmergencyArenaSize = 1 << kEmergencyArenaShift;$/;"	m	namespace:tcmalloc
kEnd	.\internal_logging.h	/^    kEnd$/;"	e	enum:tcmalloc::LogItem::Tag
kFastlogMask	.\sampler.h	/^  static const int kFastlogMask = (1 << kFastlogNumBits) - 1;$/;"	m	class:tcmalloc::Sampler
kFastlogNumBits	.\sampler.h	/^  static const int kFastlogNumBits = 10;$/;"	m	class:tcmalloc::Sampler
kFileExt	.\heap-profile-table.cc	/^const char HeapProfileTable::kFileExt[] = ".heap";$/;"	m	class:HeapProfileTable	file:
kFileExt	.\heap-profile-table.h	/^  static const char kFileExt[];$/;"	m	class:HeapProfileTable
kForcedCoalesceInterval	.\page_heap.cc	/^static const size_t kForcedCoalesceInterval = 128*1024*1024;$/;"	m	namespace:tcmalloc	file:
kFree	.\windows\patch_functions.cc	/^    kMalloc, kFree, kRealloc, kCalloc,$/;"	e	enum:__anon52::LibcInfo::__anon53	file:
kFreeLibrary	.\windows\patch_functions.cc	/^    kMapViewOfFileEx, kUnmapViewOfFile, kLoadLibraryExW, kFreeLibrary,$/;"	e	enum:__anon52::WindowsInfo::__anon54	file:
kFreeQueueSize	.\debugallocation.cc	/^  static const int kFreeQueueSize = 1024;$/;"	m	class:FreeQueue	file:
kHashBits	.\addressmap-inl.h	/^  static const int kHashBits = 12;$/;"	m	class:AddressMap
kHashMultiplier	.\addressmap-inl.h	/^  static const uint32_t kHashMultiplier = 2654435769u;$/;"	m	class:AddressMap
kHashSize	.\addressmap-inl.h	/^  static const int kHashSize = 1 << 12;$/;"	m	class:AddressMap
kHashTableSize	.\heap-profile-table.cc	/^static const int kHashTableSize = 179999;   \/\/ Size for bucket_table_.$/;"	v	file:
kHashTableSize	.\memory_region_map.h	/^  static const int kHashTableSize = 179999;$/;"	m	class:MemoryRegionMap
kHashTableSize	.\stack_trace_table.h	/^  static const int kHashTableSize = 1 << 14; \/\/ => table_ is 128k$/;"	m	class:tcmalloc::StackTraceTable
kHashbits	.\packed-cache-inl.h	/^  static const int kHashbits = 12;$/;"	m	class:PackedCache
kHashbits	.\packed-cache-inl.h	/^  static const int kHashbits = 16;$/;"	m	class:PackedCache
kHashbits	.\tests\packed-cache_test.cc	/^static const int kHashbits = PackedCache<64, uint64>::kHashbits;$/;"	v	file:
kHeapAlloc	.\windows\patch_functions.cc	/^    kHeapAlloc, kHeapFree, kVirtualAllocEx, kVirtualFreeEx,$/;"	e	enum:__anon52::WindowsInfo::__anon54	file:
kHeapCheckMaxPointerOffset	.\heap-checker.cc	/^static const int64 kHeapCheckMaxPointerOffset = 1024;$/;"	v	file:
kHeapFree	.\windows\patch_functions.cc	/^    kHeapAlloc, kHeapFree, kVirtualAllocEx, kVirtualFreeEx,$/;"	e	enum:__anon52::WindowsInfo::__anon54	file:
kHideMask	.\gperftools\heap-checker.h	/^  static const uintptr_t kHideMask =$/;"	m	class:HiddenPointer
kHideMask	.\tests\heap-checker_unittest.cc	/^static const uintptr_t kHideMask =$/;"	v	file:
kHookListCapacity	.\malloc_hook-inl.h	/^static const int kHookListCapacity = 8;$/;"	m	namespace:base::internal
kHookListMaxValues	.\malloc_hook-inl.h	/^static const int kHookListMaxValues = 7;$/;"	m	namespace:base::internal
kHookListSingularIdx	.\malloc_hook-inl.h	/^static const int kHookListSingularIdx = 7;$/;"	m	namespace:base::internal
kIgnore	.\heap-profile-table.h	/^    static const int kIgnore = 2;$/;"	m	struct:HeapProfileTable::AllocValue
kIllegalRawFD	.\base\logging.h	/^const RawFD kIllegalRawFD = -1;   \/\/ what open returns if it fails$/;"	v
kIllegalRawFD	.\base\logging.h	/^const RawFD kIllegalRawFD = INVALID_HANDLE_VALUE;$/;"	v
kInvalidBase	.\base\elf_mem_image.cc	/^const void *const ElfMemImage::kInvalidBase =$/;"	m	class:base::ElfMemImage	file:
kInvalidBase	.\base\elf_mem_image.h	/^  static const void *const kInvalidBase;$/;"	m	class:base::ElfMemImage
kIs64BitBinary	.\windows\preamble_patcher.h	/^static const bool kIs64BitBinary = false;$/;"	v
kIs64BitBinary	.\windows\preamble_patcher.h	/^static const bool kIs64BitBinary = true;$/;"	v
kKeyMask	.\packed-cache-inl.h	/^  static const K kKeyMask = N_ONES_(K, kKeybits);$/;"	m	class:PackedCache
kKeys	.\tests\heap-checker_unittest.cc	/^static const int kKeys = 50;$/;"	v	file:
kLargeSizeClass	.\common.h	/^static const size_t kLargeSizeClass = 0;$/;"	v
kLive	.\heap-profile-table.h	/^    static const int kLive = 1;$/;"	m	struct:HeapProfileTable::AllocValue
kLoadLibraryExW	.\windows\patch_functions.cc	/^    kMapViewOfFileEx, kUnmapViewOfFile, kLoadLibraryExW, kFreeLibrary,$/;"	e	enum:__anon52::WindowsInfo::__anon54	file:
kLog	.\internal_logging.h	/^  kLog,                       \/\/ Just print the message$/;"	e	enum:tcmalloc::LogMode
kMagicAllocated	.\base\low_level_alloc.cc	/^static const intptr_t kMagicAllocated = 0x4c833e95;$/;"	v	file:
kMagicDeletedBuffer	.\debugallocation.cc	/^  static unsigned char kMagicDeletedBuffer[1024];$/;"	m	class:MallocBlock	file:
kMagicDeletedBuffer	.\debugallocation.cc	/^unsigned char MallocBlock::kMagicDeletedBuffer[1024];$/;"	m	class:MallocBlock	file:
kMagicDeletedByte	.\debugallocation.cc	/^  static const int kMagicDeletedByte = 0xCD;$/;"	m	class:MallocBlock	file:
kMagicDeletedSizeT	.\debugallocation.cc	/^  static const size_t kMagicDeletedSizeT =$/;"	m	class:MallocBlock	file:
kMagicMMap	.\debugallocation.cc	/^  static const int kMagicMMap = 0xABCDEFAB;$/;"	m	class:MallocBlock	file:
kMagicMMap	.\debugallocation.cc	/^const int MallocBlock::kMagicMMap;$/;"	m	class:MallocBlock	file:
kMagicMalloc	.\debugallocation.cc	/^  static const int kMagicMalloc = 0xDEADBEEF;$/;"	m	class:MallocBlock	file:
kMagicMalloc	.\debugallocation.cc	/^const int MallocBlock::kMagicMalloc;$/;"	m	class:MallocBlock	file:
kMagicUnallocated	.\base\low_level_alloc.cc	/^static const intptr_t kMagicUnallocated = ~kMagicAllocated;$/;"	v	file:
kMagicUninitializedByte	.\debugallocation.cc	/^  static const int kMagicUninitializedByte = 0xAB;$/;"	m	class:MallocBlock	file:
kMalloc	.\windows\patch_functions.cc	/^    kMalloc, kFree, kRealloc, kCalloc,$/;"	e	enum:__anon52::LibcInfo::__anon53	file:
kMallocExtensionHistogramSize	.\gperftools\malloc_extension_c.h	58;"	d
kMallocHistogramSize	.\gperftools\malloc_extension.h	/^static const int kMallocHistogramSize = 64;$/;"	v
kMallocType	.\debugallocation.cc	/^  static const int kMallocType = 0xEFCDAB90;$/;"	m	class:MallocBlock	file:
kMangledDelete	.\windows\patch_functions.cc	/^const char kMangledDelete[] = "??3@YAXPAX@Z";$/;"	v
kMangledDelete	.\windows\patch_functions.cc	/^const char kMangledDelete[] = "??3@YAXPEAX@Z";$/;"	v
kMangledDeleteArray	.\windows\patch_functions.cc	/^const char kMangledDeleteArray[] = "??_V@YAXPAX@Z";$/;"	v
kMangledDeleteArray	.\windows\patch_functions.cc	/^const char kMangledDeleteArray[] = "??_V@YAXPEAX@Z";$/;"	v
kMangledDeleteArrayNothrow	.\windows\patch_functions.cc	/^const char kMangledDeleteArrayNothrow[] = "??_V@YAXPAXABUnothrow_t@std@@@Z";$/;"	v
kMangledDeleteArrayNothrow	.\windows\patch_functions.cc	/^const char kMangledDeleteArrayNothrow[] = "??_V@YAXPEAXAEBUnothrow_t@std@@@Z";$/;"	v
kMangledDeleteNothrow	.\windows\patch_functions.cc	/^const char kMangledDeleteNothrow[] = "??3@YAXPAXABUnothrow_t@std@@@Z";$/;"	v
kMangledDeleteNothrow	.\windows\patch_functions.cc	/^const char kMangledDeleteNothrow[] = "??3@YAXPEAXAEBUnothrow_t@std@@@Z";$/;"	v
kMangledNew	.\windows\patch_functions.cc	/^const char kMangledNew[] = "??2@YAPAXI@Z";$/;"	v
kMangledNew	.\windows\patch_functions.cc	/^const char kMangledNew[] = "??2@YAPEAX_K@Z";$/;"	v
kMangledNewArray	.\windows\patch_functions.cc	/^const char kMangledNewArray[] = "??_U@YAPAXI@Z";$/;"	v
kMangledNewArray	.\windows\patch_functions.cc	/^const char kMangledNewArray[] = "??_U@YAPEAX_K@Z";$/;"	v
kMangledNewArrayNothrow	.\windows\patch_functions.cc	/^const char kMangledNewArrayNothrow[] = "??_U@YAPAXIABUnothrow_t@std@@@Z";$/;"	v
kMangledNewArrayNothrow	.\windows\patch_functions.cc	/^const char kMangledNewArrayNothrow[] = "??_U@YAPEAX_KAEBUnothrow_t@std@@@Z";$/;"	v
kMangledNewNothrow	.\windows\patch_functions.cc	/^const char kMangledNewNothrow[] = "??2@YAPAXIABUnothrow_t@std@@@Z";$/;"	v
kMangledNewNothrow	.\windows\patch_functions.cc	/^const char kMangledNewNothrow[] = "??2@YAPEAX_KAEBUnothrow_t@std@@@Z";$/;"	v
kMapViewOfFileEx	.\windows\patch_functions.cc	/^    kMapViewOfFileEx, kUnmapViewOfFile, kLoadLibraryExW, kFreeLibrary,$/;"	e	enum:__anon52::WindowsInfo::__anon54	file:
kMask	.\heap-profile-table.h	/^    static const int kMask = kLive | kIgnore;$/;"	m	struct:HeapProfileTable::AllocValue
kMaxAllocators	.\system-alloc.cc	/^  static const int kMaxAllocators = 2;$/;"	m	class:DefaultSysAllocator	file:
kMaxBytes	.\stacktrace_x86-inl.h	/^static const int kMaxBytes = 10;$/;"	v
kMaxCount	.\tests\heap-profiler_unittest.cc	/^static const int kMaxCount = 100000;$/;"	v	file:
kMaxDynamicFreeListLength	.\common.h	/^static const int kMaxDynamicFreeListLength = 8192;$/;"	v
kMaxFrequency	.\profile-handler.cc	/^  static const int32 kMaxFrequency = 4000;$/;"	m	class:ProfileHandler	file:
kMaxFrequency	.\profile-handler.cc	/^const int32 ProfileHandler::kMaxFrequency;$/;"	m	class:ProfileHandler	file:
kMaxLevel	.\base\low_level_alloc.cc	/^static const int kMaxLevel = 30;$/;"	v	file:
kMaxModules	.\windows\patch_functions.cc	/^const int kMaxModules = 8182;$/;"	v
kMaxNumTransferEntries	.\central_freelist.h	/^  static const int kMaxNumTransferEntries = 0;$/;"	m	class:tcmalloc::CentralFreeList
kMaxNumTransferEntries	.\central_freelist.h	/^  static const int kMaxNumTransferEntries = 64;$/;"	m	class:tcmalloc::CentralFreeList
kMaxOverages	.\common.h	/^static const int kMaxOverages = 3;$/;"	v
kMaxPages	.\common.h	/^static const size_t kMaxPages = 1 << (20 - kPageShift);$/;"	v
kMaxReleaseDelay	.\page_heap.h	/^  static const int kMaxReleaseDelay = 1 << 20;$/;"	m	class:tcmalloc::PageHeap
kMaxSignedSize	.\tests\tcmalloc_unittest.cc	/^static const size_t kMaxSignedSize = ((size_t(1) << (kSizeBits-1)) - 1);$/;"	m	namespace:testing	file:
kMaxSize	.\common.h	/^static const size_t kMaxSize    = 256 * 1024;$/;"	v
kMaxSize	.\tests\tcmalloc_unittest.cc	/^static const size_t kMaxSize = ~static_cast<size_t>(0);$/;"	m	namespace:testing	file:
kMaxSmallSize	.\common.h	/^  static const int kMaxSmallSize = 1024;$/;"	m	class:tcmalloc::SizeMap
kMaxStackDepth	.\common.h	/^static const int kMaxStackDepth = 31;$/;"	m	namespace:tcmalloc
kMaxStackDepth	.\heap-profile-stats.h	/^  static const int kMaxStackDepth = 32;$/;"	m	struct:HeapProfileBucket
kMaxStackDepth	.\heap-profile-table.cc	/^\/*static*\/ const int HeapProfileTable::kMaxStackDepth;$/;"	m	class:HeapProfileTable	file:
kMaxStackDepth	.\heap-profile-table.h	/^  static const int kMaxStackDepth = 32;$/;"	m	class:HeapProfileTable
kMaxStackDepth	.\memory_region_map.h	/^  static const int kMaxStackDepth = 32;$/;"	m	class:MemoryRegionMap
kMaxStackDepth	.\profiledata.cc	/^const int ProfileData::kMaxStackDepth;$/;"	m	class:ProfileData	file:
kMaxStackDepth	.\profiledata.h	/^  static const int kMaxStackDepth = 64;  \/\/ Max stack depth stored in profile$/;"	m	class:ProfileData
kMaxThreadCacheSize	.\common.h	/^static const size_t kMaxThreadCacheSize = 4 << 20;$/;"	v
kMaxValidPages	.\common.h	/^static const Length kMaxValidPages = (~static_cast<Length>(0)) >> kPageShift;$/;"	v
kMetadataAllignment	.\common.cc	/^static const size_t kMetadataAllignment = sizeof(MemoryAligner);$/;"	m	namespace:tcmalloc	file:
kMetadataAllocChunkSize	.\common.cc	/^static const size_t kMetadataAllocChunkSize = 8*1024*1024;$/;"	m	namespace:tcmalloc	file:
kMinAlign	.\common.h	/^static const size_t kMinAlign   = 16;$/;"	v
kMinAlign	.\common.h	/^static const size_t kMinAlign   = 8;$/;"	v
kMinSystemAlloc	.\page_heap.h	/^  static const int kMinSystemAlloc = kMaxPages;$/;"	m	class:tcmalloc::PageHeap
kMinThreadCacheSize	.\common.h	/^static const size_t kMinThreadCacheSize = kMaxSize * 2;$/;"	v
kMmapMagicFd	.\tests\malloc_hook_test.cc	/^const int kMmapMagicFd = 1;$/;"	m	namespace:__anon35	file:
kMmapMagicPointer	.\tests\malloc_hook_test.cc	/^void* const kMmapMagicPointer = reinterpret_cast<void*>(1);$/;"	m	namespace:__anon35	file:
kNew	.\windows\patch_functions.cc	/^    kNew, kNewArray, kDelete, kDeleteArray,$/;"	e	enum:__anon52::LibcInfo::__anon53	file:
kNewArray	.\windows\patch_functions.cc	/^    kNew, kNewArray, kDelete, kDeleteArray,$/;"	e	enum:__anon52::LibcInfo::__anon53	file:
kNewArrayNothrow	.\windows\patch_functions.cc	/^    kNewNothrow, kNewArrayNothrow, kDeleteNothrow, kDeleteArrayNothrow,$/;"	e	enum:__anon52::LibcInfo::__anon53	file:
kNewNothrow	.\windows\patch_functions.cc	/^    kNewNothrow, kNewArrayNothrow, kDeleteNothrow, kDeleteArrayNothrow,$/;"	e	enum:__anon52::LibcInfo::__anon53	file:
kNewType	.\debugallocation.cc	/^  static const int kNewType = 0xFEBADC81;$/;"	m	class:MallocBlock	file:
kNoError	.\tests\profiledata_unittest.cc	/^const char kNoError[] = "";$/;"	m	namespace:__anon38	file:
kNotOwned	.\gperftools\malloc_extension.h	/^    kNotOwned$/;"	e	enum:MallocExtension::Ownership
kNotTooBig	.\tests\tcmalloc_unittest.cc	/^static const size_t kNotTooBig = 100000;$/;"	m	namespace:testing	file:
kNumClasses	.\common.h	/^static const size_t kNumClasses = kBaseClasses + 69;$/;"	v
kNumClasses	.\common.h	/^static const size_t kNumClasses = kBaseClasses + 73;$/;"	v
kNumClasses	.\common.h	/^static const size_t kNumClasses = kBaseClasses + 79;$/;"	v
kNumFunctions	.\windows\patch_functions.cc	/^    kNumFunctions$/;"	e	enum:__anon52::LibcInfo::__anon53	file:
kNumFunctions	.\windows\patch_functions.cc	/^    kNumFunctions$/;"	e	enum:__anon52::WindowsInfo::__anon54	file:
kNumObjects	.\tests\thread_dealloc_unittest.cc	/^static const int kNumObjects = 1024;$/;"	v	file:
kNumThreads	.\tests\thread_dealloc_unittest.cc	/^static const int kNumThreads = 1000;$/;"	v	file:
kOSSupportsMemalign	.\tests\tcmalloc_unittest.cc	/^static bool kOSSupportsMemalign = false;$/;"	v	file:
kOSSupportsMemalign	.\tests\tcmalloc_unittest.cc	/^static bool kOSSupportsMemalign = true;$/;"	v	file:
kObjectSize	.\tests\thread_dealloc_unittest.cc	/^static const int kObjectSize = 1024;$/;"	v	file:
kOwned	.\gperftools\malloc_extension.h	/^    kOwned,$/;"	e	enum:MallocExtension::Ownership
kPageMapBigAllocationThreshold	.\page_heap.h	/^  static const size_t kPageMapBigAllocationThreshold = 128 << 20;$/;"	m	class:tcmalloc::PageHeap
kPageShift	.\common.h	/^static const size_t kPageShift  = 13;$/;"	v
kPageShift	.\common.h	/^static const size_t kPageShift  = 15;$/;"	v
kPageShift	.\common.h	/^static const size_t kPageShift  = 16;$/;"	v
kPageSize	.\common.h	/^static const size_t kPageSize   = 1 << kPageShift;$/;"	v
kPointerSourceAlignment	.\heap-checker.cc	/^static const size_t kPointerSourceAlignment = sizeof(void*);$/;"	v	file:
kPreamblePageMagic	.\windows\preamble_patcher.cc	/^static const unsigned int kPreamblePageMagic = 0x4347414D; \/\/ "MAGC"$/;"	m	namespace:sidestep	file:
kProcSelfMapsHeader	.\heap-profile-table.cc	/^static const char kProcSelfMapsHeader[] = "\\nMAPPED_LIBRARIES:\\n";$/;"	v	file:
kProfileBufferSize	.\heap-profiler.cc	/^static const int kProfileBufferSize = 1 << 20;$/;"	v	file:
kProfileHeader	.\heap-profile-table.cc	/^static const char kProfileHeader[] = "heap profile: ";$/;"	v	file:
kPtr	.\internal_logging.h	/^    kPtr,$/;"	e	enum:tcmalloc::LogItem::Tag
kRealloc	.\windows\patch_functions.cc	/^    kMalloc, kFree, kRealloc, kCalloc,$/;"	e	enum:__anon52::LibcInfo::__anon53	file:
kRoutineSize	.\tests\getpc_test.cc	/^const int kRoutineSize = 512 * sizeof(void*)\/4;    \/\/ allow 1024 for 64-bit$/;"	v
kSamplingInterval	.\tests\sampler_test.cc	/^static const size_t kSamplingInterval = 512*1024;$/;"	v	file:
kSigmas	.\tests\sampler_test.cc	/^static const double kSigmas = 4;$/;"	v	file:
kSigned	.\internal_logging.h	/^    kSigned,$/;"	e	enum:tcmalloc::LogItem::Tag
kSizeBits	.\tests\tcmalloc_unittest.cc	/^static const int kSizeBits = 8 * sizeof(size_t);$/;"	m	namespace:testing	file:
kSleepInterval	.\tests\profile-handler_unittest.cc	/^int kSleepInterval = 200000000;$/;"	m	namespace:__anon37	file:
kSpinLockFree	.\base\spinlock.h	/^  enum { kSpinLockFree = 0 };$/;"	e	enum:SpinLock::__anon12
kSpinLockHeld	.\base\spinlock.h	/^  enum { kSpinLockHeld = 1 };$/;"	e	enum:SpinLock::__anon13
kSpinLockSleeper	.\base\spinlock.h	/^  enum { kSpinLockSleeper = 2 };$/;"	e	enum:SpinLock::__anon14
kStatsBufferSize	.\internal_logging.cc	/^static const int kStatsBufferSize = 16 << 10;$/;"	v	file:
kStealAmount	.\common.h	/^static const size_t kStealAmount = 1 << 16;$/;"	v
kStr	.\internal_logging.h	/^    kStr,$/;"	e	enum:tcmalloc::LogItem::Tag
kStripFrames	.\heap-profile-table.cc	/^static const int kStripFrames = 2;$/;"	v	file:
kStripFrames	.\heap-profile-table.cc	/^static const int kStripFrames = 3;$/;"	v	file:
kStripFrames	.\memory_region_map.cc	/^static const int kStripFrames = 1;$/;"	v	file:
kStripFrames	.\memory_region_map.cc	/^static const int kStripFrames = 3;$/;"	v	file:
kSymbolSize	.\symbolize.h	/^  static const int kSymbolSize = 1024;$/;"	m	class:SymbolTable
kTbits	.\packed-cache-inl.h	/^  static const int kTbits = 8 * sizeof(T);$/;"	m	class:PackedCache
kTimerResetInterval	.\tests\profile-handler_unittest.cc	/^int kTimerResetInterval = 5000000;$/;"	m	namespace:__anon37	file:
kTooBig	.\tests\tcmalloc_unittest.cc	/^static const size_t kTooBig = kMaxSize - 100000;$/;"	m	namespace:testing	file:
kUnknownOwnership	.\gperftools\malloc_extension.h	/^    kUnknownOwnership = 0,$/;"	e	enum:MallocExtension::Ownership
kUnmapViewOfFile	.\windows\patch_functions.cc	/^    kMapViewOfFileEx, kUnmapViewOfFile, kLoadLibraryExW, kFreeLibrary,$/;"	e	enum:__anon52::WindowsInfo::__anon54	file:
kUnnamedProcSelfMapEntry	.\heap-checker.cc	/^static const char kUnnamedProcSelfMapEntry[] = "UNNAMED";$/;"	v	file:
kUnsigned	.\internal_logging.h	/^    kUnsigned,$/;"	e	enum:tcmalloc::LogItem::Tag
kUpperMask	.\packed-cache-inl.h	/^  static const T kUpperMask = N_ONES_(T, kUpperbits) << kValuebits;$/;"	m	class:PackedCache
kUpperbits	.\packed-cache-inl.h	/^  static const int kUpperbits = kUseWholeKeys ? kKeybits : kKeybits - kHashbits;$/;"	m	class:PackedCache
kUseWholeKeys	.\packed-cache-inl.h	/^  static const bool kUseWholeKeys = kKeybits + kValuebits <= 8 * sizeof(T);$/;"	m	class:PackedCache
kValueMask	.\packed-cache-inl.h	/^  static const V kValueMask = N_ONES_(V, kValuebits);$/;"	m	class:PackedCache
kValuebits	.\packed-cache-inl.h	/^  static const int kValuebits = 7;$/;"	m	class:PackedCache
kVirtualAllocEx	.\windows\patch_functions.cc	/^    kHeapAlloc, kHeapFree, kVirtualAllocEx, kVirtualFreeEx,$/;"	e	enum:__anon52::WindowsInfo::__anon54	file:
kVirtualFreeEx	.\windows\patch_functions.cc	/^    kHeapAlloc, kHeapFree, kVirtualAllocEx, kVirtualFreeEx,$/;"	e	enum:__anon52::WindowsInfo::__anon54	file:
k_CallocCrt	.\windows\patch_functions.cc	/^    k_CallocCrt,$/;"	e	enum:__anon52::LibcInfo::__anon53	file:
k_Expand	.\windows\patch_functions.cc	/^    k_Msize, k_Expand,$/;"	e	enum:__anon52::LibcInfo::__anon53	file:
k_Msize	.\windows\patch_functions.cc	/^    k_Msize, k_Expand,$/;"	e	enum:__anon52::LibcInfo::__anon53	file:
keep_profiles_	.\gperftools\heap-checker.h	/^  bool keep_profiles_;  \/\/ iff we should keep the heap profiles we've made$/;"	m	class:HeapLeakChecker
kernel_dirent	.\base\linux_syscall_support.h	/^struct kernel_dirent {$/;"	s
kernel_dirent64	.\base\linux_syscall_support.h	/^struct kernel_dirent64 {$/;"	s
kernel_old_sigaction	.\base\linux_syscall_support.h	/^struct kernel_old_sigaction {$/;"	s
kernel_old_sigaction	.\base\linux_syscall_support.h	263;"	d
kernel_rusage	.\base\linux_syscall_support.h	/^struct kernel_rusage {$/;"	s
kernel_sigaction	.\base\linux_syscall_support.h	/^struct kernel_sigaction {$/;"	s
kernel_sigset_t	.\base\linux_syscall_support.h	/^struct kernel_sigset_t {$/;"	s
kernel_stat	.\base\linux_syscall_support.h	/^struct kernel_stat {$/;"	s
kernel_stat64	.\base\linux_syscall_support.h	/^struct kernel_stat64 {$/;"	s
kernel_timespec	.\base\linux_syscall_support.h	/^struct kernel_timespec {$/;"	s
kernel_timeval	.\base\linux_syscall_support.h	/^struct kernel_timeval {$/;"	s
key	.\addressmap-inl.h	/^    Key    key;$/;"	m	struct:AddressMap::Entry
key	.\tests\heap-checker_unittest.cc	/^static pthread_key_t key[kKeys];$/;"	v	file:
key_for_destr_fn_arg	.\windows\port.cc	/^  pthread_key_t key_for_destr_fn_arg;$/;"	m	struct:DestrFnClosure	file:
key_init_has_run	.\tests\heap-checker_unittest.cc	/^static bool key_init_has_run = false;$/;"	v	file:
kint16max	.\base\basictypes.h	/^const  int16 kint16max  = (   ( int16) 0x7FFF);$/;"	v
kint16min	.\base\basictypes.h	/^const  int16 kint16min  = (   ( int16) 0x8000);$/;"	v
kint32max	.\base\basictypes.h	/^const  int32 kint32max  = (   ( int32) 0x7FFFFFFF);$/;"	v
kint32min	.\base\basictypes.h	/^const  int32 kint32min  = (   ( int32) 0x80000000);$/;"	v
kint64max	.\base\basictypes.h	/^const  int64 kint64max =  ( ((( int64) kint32max) << 32) | kuint32max );$/;"	v
kint64min	.\base\basictypes.h	/^const  int64 kint64min =  ( (((uint64) kint32min) << 32) | 0 );$/;"	v
kint8max	.\base\basictypes.h	/^const  int8  kint8max   = (   (  int8) 0x7F);$/;"	v
kint8min	.\base\basictypes.h	/^const  int8  kint8min   = (   (  int8) 0x80);$/;"	v
kuint16max	.\base\basictypes.h	/^const uint16 kuint16max = (   (uint16) 0xFFFF);$/;"	v
kuint32max	.\base\basictypes.h	/^const uint32 kuint32max = (   (uint32) 0xFFFFFFFF);$/;"	v
kuint64max	.\base\basictypes.h	/^const uint64 kuint64max = ( (((uint64) kuint32max) << 32) | kuint32max );$/;"	v
large_	.\page_heap.h	/^  SpanList large_;$/;"	m	class:tcmalloc::PageHeap
large_alloc_threshold	.\tcmalloc.cc	/^static int64_t large_alloc_threshold =$/;"	m	namespace:__anon34	file:
last_dump_alloc	.\heap-profiler.cc	/^static int64 last_dump_alloc = 0;     \/\/ alloc_size when did we last dump$/;"	v	file:
last_dump_free	.\heap-profiler.cc	/^static int64 last_dump_free = 0;      \/\/ free_size when did we last dump$/;"	v	file:
last_dump_time	.\heap-profiler.cc	/^static int64 last_dump_time = 0;      \/\/ The time of the last dump$/;"	v	file:
layout_ppc	.\stacktrace_powerpc-inl.h	/^struct layout_ppc {$/;"	s
layout_ppc	.\stacktrace_powerpc-linux-inl.h	/^struct layout_ppc {$/;"	s
left_	.\base\low_level_alloc.cc	/^    bool left_;       \/\/ whether left region$/;"	m	class:__anon8::ArenaLock	file:
left_	.\internal_logging.h	/^  int   left_;          \/\/ Space left in buffer (including space for \\0)$/;"	m	class:TCMalloc_Printer
len	.\tests\low_level_alloc_unittest.cc	/^  int len;        \/\/ number of bytes$/;"	m	struct:BlockDesc	file:
length	.\central_freelist.h	/^  int length() {$/;"	f	class:tcmalloc::CentralFreeList
length	.\gperftools\malloc_extension.h	/^  size_t length;        \/\/ Byte length of range$/;"	m	struct:base::MallocRange
length	.\raw_printer.h	/^  int length() const { return (ptr_ - base_); }$/;"	f	class:base::RawPrinter
length	.\span.h	/^  Length        length;         \/\/ Number of pages in span$/;"	m	struct:tcmalloc::Span
length	.\thread_cache.h	/^    size_t length() const {$/;"	f	class:tcmalloc::ThreadCache::FreeList
length_	.\thread_cache.h	/^    uint16_t length_;$/;"	m	class:tcmalloc::ThreadCache::FreeList
length_	.\thread_cache.h	/^    uint32_t length_;      \/\/ Current length.$/;"	m	class:tcmalloc::ThreadCache::FreeList
length_overages	.\thread_cache.h	/^    size_t length_overages() const {$/;"	f	class:tcmalloc::ThreadCache::FreeList
length_overages_	.\thread_cache.h	/^    uint16_t length_overages_;$/;"	m	class:tcmalloc::ThreadCache::FreeList
length_overages_	.\thread_cache.h	/^    uint32_t length_overages_;$/;"	m	class:tcmalloc::ThreadCache::FreeList
levels	.\base\low_level_alloc.cc	/^    int levels;           \/\/ levels in skiplist used$/;"	m	struct:low_level_alloc_internal::AllocList	file:
libc1	.\windows\patch_functions.cc	/^static LibcInfoWithPatchFunctions<1> libc1;$/;"	m	namespace:__anon52	file:
libc2	.\windows\patch_functions.cc	/^static LibcInfoWithPatchFunctions<2> libc2;$/;"	m	namespace:__anon52	file:
libc3	.\windows\patch_functions.cc	/^static LibcInfoWithPatchFunctions<3> libc3;$/;"	m	namespace:__anon52	file:
libc4	.\windows\patch_functions.cc	/^static LibcInfoWithPatchFunctions<4> libc4;$/;"	m	namespace:__anon52	file:
libc5	.\windows\patch_functions.cc	/^static LibcInfoWithPatchFunctions<5> libc5;$/;"	m	namespace:__anon52	file:
libc6	.\windows\patch_functions.cc	/^static LibcInfoWithPatchFunctions<6> libc6;$/;"	m	namespace:__anon52	file:
libc7	.\windows\patch_functions.cc	/^static LibcInfoWithPatchFunctions<7> libc7;$/;"	m	namespace:__anon52	file:
libc8	.\windows\patch_functions.cc	/^static LibcInfoWithPatchFunctions<8> libc8;$/;"	m	namespace:__anon52	file:
libgcc_backtrace_data	.\stacktrace_libgcc-inl.h	/^struct libgcc_backtrace_data {$/;"	s
libgcc_backtrace_helper	.\stacktrace_libgcc-inl.h	/^static _Unwind_Reason_Code libgcc_backtrace_helper(struct _Unwind_Context *ctx,$/;"	f
libpthread_initialized	.\memory_region_map.cc	/^static bool libpthread_initialized = false;$/;"	v	file:
library_live_objects	.\heap-checker.cc	/^static LibraryLiveObjectsStacks* library_live_objects = NULL;$/;"	v	file:
limit	.\stacktrace_libgcc-inl.h	/^  int limit;$/;"	m	struct:libgcc_backtrace_data
limit_	.\raw_printer.h	/^  char* limit_;         \/\/ One past last non-\\0 char we can write$/;"	m	class:base::RawPrinter
link_base_	.\base\elf_mem_image.h	/^  ElfW(Addr) link_base_;     \/\/ Link-time base (p_vaddr of first PT_LOAD).$/;"	m	class:base::ElfMemImage
linux_per_thread_timers_mode_	.\tests\profile-handler_unittest.cc	/^static bool linux_per_thread_timers_mode_ = false;$/;"	m	namespace:__anon37	file:
list	.\tests\malloc_hook_test.cc	/^static TestHookList list = INIT_HOOK_LIST(69);$/;"	m	namespace:__anon35	file:
list_	.\thread_cache.h	/^    void*    list_;       \/\/ Linked list of nodes$/;"	m	class:tcmalloc::ThreadCache::FreeList
list_	.\thread_cache.h	/^  FreeList      list_[kNumClasses];     \/\/ Array indexed by size-class$/;"	m	class:tcmalloc::ThreadCache
live	.\heap-profile-table.h	/^    bool live() const { return bucket_rep & kLive; }$/;"	f	struct:HeapProfileTable::AllocValue
live	.\heap-profile-table.h	/^    bool live;$/;"	m	struct:HeapProfileTable::AllocInfo
live_bytes_total	.\heap-checker.cc	/^static int64 live_bytes_total;$/;"	v	file:
live_objects	.\heap-checker.cc	/^static LiveObjectsStack* live_objects = NULL;$/;"	v	file:
live_objects	.\tests\heap-checker_unittest.cc	/^static list<void*>* live_objects = new list<void*>;$/;"	v	file:
live_objects_total	.\heap-checker.cc	/^static int64 live_objects_total;$/;"	v	file:
lo	.\base\elfcore.h	/^    unsigned long lo;$/;"	m	struct:mips_regs
local_atoi	.\base\linuxthreads.cc	/^static int local_atoi(const char *s) {$/;"	f	file:
local_clone	.\base\linuxthreads.cc	/^static int local_clone (int (*fn)(void *), void *arg, ...) {$/;"	f	file:
local_itoa	.\base\linuxthreads.cc	/^static char *local_itoa(char *buf, int i) {$/;"	f	file:
location	.\span.h	/^  unsigned int  location : 2;   \/\/ Is the span on a freelist, and if so, which?$/;"	m	struct:tcmalloc::Span
lock	.\base\linuxthreads.cc	/^  sem_t       *lock;$/;"	m	struct:ListerParams	file:
lock_	.\base\spinlock.h	/^  SpinLock* lock_;$/;"	m	class:SpinLockHolder
lock_	.\central_freelist.h	/^  SpinLock lock_;$/;"	m	class:tcmalloc::CentralFreeList
lock_	.\gperftools\heap-checker.h	/^  class SpinLock* lock_;  \/\/ to make HeapLeakChecker objects thread-safe$/;"	m	class:HeapLeakChecker	typeref:class:HeapLeakChecker::SpinLock
lock_	.\memory_region_map.h	/^  static SpinLock lock_;$/;"	m	class:MemoryRegionMap
lock_	.\profiler.cc	/^  SpinLock      lock_;$/;"	m	class:CpuProfiler	file:
lock_	.\tests\tcmalloc_unittest.cc	/^  Mutex                 lock_;          \/\/ For passing in another thread's obj$/;"	m	class:testing::TesterThread	file:
lock_owner_tid_	.\memory_region_map.cc	/^pthread_t MemoryRegionMap::lock_owner_tid_;  \/\/ GUARDED_BY(owner_lock_)$/;"	m	class:MemoryRegionMap	file:
lock_owner_tid_	.\memory_region_map.h	/^  static pthread_t lock_owner_tid_;$/;"	m	class:MemoryRegionMap
locks_failed_	.\tests\tcmalloc_unittest.cc	/^  int                   locks_failed_;  \/\/ Number of failed TryLock() ops$/;"	m	class:testing::TesterThread	file:
locks_ok_	.\tests\tcmalloc_unittest.cc	/^  int                   locks_ok_;      \/\/ Number of OK TryLock() ops$/;"	m	class:testing::TesterThread	file:
lockword_	.\base\spinlock.h	/^  volatile Atomic32 lockword_;$/;"	m	class:SpinLock
log_message_writer	.\internal_logging.cc	/^void (*log_message_writer)(const char* msg, int length) = WriteMessage;$/;"	m	namespace:tcmalloc	file:
log_table_	.\sampler.cc	/^double Sampler::log_table_[1<<kFastlogNumBits];$/;"	m	class:tcmalloc::Sampler	file:
log_table_	.\sampler.h	/^  static double log_table_[1<<kFastlogNumBits];  \/\/ Constant$/;"	m	class:tcmalloc::Sampler
low_level_alloc_internal	.\base\low_level_alloc.cc	/^namespace low_level_alloc_internal {$/;"	n	file:
lowater_	.\thread_cache.h	/^    uint16_t lowater_;$/;"	m	class:tcmalloc::ThreadCache::FreeList
lowater_	.\thread_cache.h	/^    uint32_t lowater_;     \/\/ Low water mark for list length.$/;"	m	class:tcmalloc::ThreadCache::FreeList
lowwatermark	.\thread_cache.h	/^    int lowwatermark() const { return lowater_; }$/;"	f	class:tcmalloc::ThreadCache::FreeList
lr	.\base\elfcore.h	/^    unsigned long lr;$/;"	m	struct:ppc_regs
lseek	.\base\linux_syscall_support.h	/^    LSS_INLINE off_t LSS_NAME(lseek)(int f, off_t o, int w) {$/;"	f
lseek	.\windows\port.h	/^inline off_t lseek(int fd, off_t offset, int whence) {$/;"	f
m	.\windows\get_mangled_names.cc	/^static char m;   \/\/ some dummy memory so new doesn't return NULL.$/;"	v	file:
magic	.\base\low_level_alloc.cc	/^      intptr_t magic; \/\/ kMagicAllocated or kMagicUnallocated xor this$/;"	m	struct:low_level_alloc_internal::AllocList::Header	file:
magic1_	.\debugallocation.cc	/^  size_t magic1_;$/;"	m	class:MallocBlock	file:
magic2_	.\debugallocation.cc	/^  int magic2_;$/;"	m	class:MallocBlock	file:
magic2_addr	.\debugallocation.cc	/^  const int* magic2_addr() const { return (const int*)(size2_addr() + 1); }$/;"	f	class:MallocBlock	file:
magic2_addr	.\debugallocation.cc	/^  int* magic2_addr() { return (int*)(size2_addr() + 1); }$/;"	f	class:MallocBlock	file:
magic_	.\windows\preamble_patcher.h	/^    unsigned int magic_;$/;"	m	struct:sidestep::PreamblePatcher::PreamblePage
main	.\tests\addressmap_unittest.cc	/^int main(int argc, char** argv) {$/;"	f
main	.\tests\atomicops_unittest.cc	/^int main(int argc, char** argv) {$/;"	f
main	.\tests\current_allocated_bytes_test.cc	/^int main() {$/;"	f
main	.\tests\debugallocation_test.cc	/^int main(int argc, char** argv) {$/;"	f
main	.\tests\frag_unittest.cc	/^int main(int argc, char** argv) {$/;"	f
main	.\tests\getpc_test.cc	/^int main(int argc, char** argv) {$/;"	f
main	.\tests\heap-checker_unittest.cc	/^int main(int argc, char** argv) {$/;"	f
main	.\tests\heap-profiler_unittest.cc	/^int main(int argc, char** argv) {$/;"	f
main	.\tests\large_heap_fragmentation_unittest.cc	/^int main (int argc, char** argv) {$/;"	f
main	.\tests\low_level_alloc_unittest.cc	/^int main(int argc, char *argv[]) {$/;"	f
main	.\tests\malloc_extension_c_test.c	/^int main(int argc, char** argv) {$/;"	f
main	.\tests\malloc_extension_test.cc	/^int main(int argc, char** argv) {$/;"	f
main	.\tests\malloc_hook_test.cc	/^int main(int argc, char** argv) {$/;"	f
main	.\tests\markidle_unittest.cc	/^int main(int argc, char** argv) {$/;"	f
main	.\tests\memalign_unittest.cc	/^int main(int argc, char** argv) {$/;"	f
main	.\tests\packed-cache_test.cc	/^int main(int argc, char **argv) {$/;"	f
main	.\tests\page_heap_test.cc	/^int main(int argc, char **argv) {$/;"	f
main	.\tests\pagemap_unittest.cc	/^int main(int argc, char** argv) {$/;"	f
main	.\tests\profile-handler_unittest.cc	/^int main(int argc, char** argv) {$/;"	f
main	.\tests\profiledata_unittest.cc	/^int main(int argc, char** argv) {$/;"	f
main	.\tests\profiler_unittest.cc	/^int main(int argc, char** argv) {$/;"	f
main	.\tests\raw_printer_test.cc	/^int main(int argc, char **argv) {$/;"	f
main	.\tests\realloc_unittest.cc	/^int main(int argc, char** argv) {$/;"	f
main	.\tests\sampler_test.cc	/^int main(int argc, char **argv) {$/;"	f
main	.\tests\sampling_test.cc	/^int main(int argc, char** argv) {$/;"	f
main	.\tests\simple_compat_test.cc	/^int main(int argc, char** argv) {$/;"	f
main	.\tests\stack_trace_table_test.cc	/^int main(int argc, char **argv) {$/;"	f
main	.\tests\stacktrace_unittest.cc	/^int main(int argc, char ** argv) {$/;"	f
main	.\tests\system-alloc_unittest.cc	/^int main(int argc, char** argv) {$/;"	f
main	.\tests\tcmalloc_large_unittest.cc	/^int main (int argc, char** argv) {$/;"	f
main	.\tests\tcmalloc_unittest.cc	/^int main(int argc, char** argv) {$/;"	f
main	.\tests\thread_dealloc_unittest.cc	/^int main(int argc, char** argv) {$/;"	f
main	.\windows\addr2line-pdb.c	/^int main(int argc, char *argv[]) {$/;"	f
main	.\windows\nm-pdb.c	/^int main(int argc, char *argv[]) {$/;"	f
main_executable	.\windows\patch_functions.cc	/^static LibcInfoWithPatchFunctions<0> main_executable;$/;"	m	namespace:__anon52	file:
main_executable_windows	.\windows\patch_functions.cc	/^static WindowsInfo main_executable_windows;$/;"	m	namespace:__anon52	file:
main_heap_checker	.\heap-checker.cc	/^static HeapLeakChecker* main_heap_checker = NULL;$/;"	v	file:
main_thread_counter	.\heap-checker.cc	/^static int main_thread_counter;   \/\/ storage for use before main()$/;"	v	file:
main_thread_pid	.\heap-checker.cc	/^static int32 main_thread_pid = getpid();$/;"	v	file:
mallinfo	.\libc_override_redefine.h	/^  struct mallinfo mallinfo(void)                 { return tc_mallinfo();      }$/;"	f
malloc	.\libc_override_redefine.h	/^  void* malloc(size_t s)                         { return tc_malloc(s);       }$/;"	f
malloc	.\windows\override_functions.cc	91;"	d	file:
malloc_extension_c_h	.\tests\simple_compat_test.cc	/^MallocExtension_Ownership malloc_extension_c_h;$/;"	v
malloc_extension_h	.\tests\simple_compat_test.cc	/^MallocExtension::Ownership malloc_extension_h;$/;"	v
malloc_fn	.\tcmalloc.cc	/^typedef void* (*malloc_fn)(void *arg);$/;"	t	namespace:__anon34	file:
malloc_hook	.\malloc_hook.cc	/^DECLARE_ATTRIBUTE_SECTION_VARS(malloc_hook);$/;"	v
malloc_hook	.\malloc_hook.cc	/^DEFINE_ATTRIBUTE_SECTION_VARS(malloc_hook);$/;"	v
malloc_hook_c_h	.\tests\simple_compat_test.cc	/^MallocHook_NewHook* malloc_hook_c_h;$/;"	v
malloc_hook_h	.\tests\simple_compat_test.cc	/^MallocHook::NewHook* malloc_hook_h;$/;"	v
malloc_size	.\libc_override_redefine.h	/^  size_t malloc_size(void* p)                    { return tc_malloc_size(p); }$/;"	f
malloc_stats	.\libc_override_osx.h	/^  void malloc_stats(void)                { tc_malloc_stats();         }$/;"	f
malloc_stats	.\libc_override_redefine.h	/^  void malloc_stats(void)                        { tc_malloc_stats();         }$/;"	f
malloc_usable_size	.\libc_override_osx.h	/^  size_t malloc_usable_size(void* p)     { return tc_malloc_size(p); }$/;"	f
malloc_usable_size	.\libc_override_redefine.h	/^  size_t malloc_usable_size(void* p)             { return tc_malloc_size(p); }$/;"	f
mallocer_addr	.\tests\heap-checker_unittest.cc	/^static void* (* volatile mallocer_addr)(uintptr_t* addr) = &Mallocer;$/;"	v	file:
mallopt	.\libc_override_osx.h	/^  int mallopt(int cmd, int v)            { return tc_mallopt(cmd, v); }$/;"	f
mallopt	.\libc_override_redefine.h	/^  int mallopt(int cmd, int v)                    { return tc_mallopt(cmd, v); }$/;"	f
map_	.\heap-profile-table.h	/^  AllocationMap map_;$/;"	m	class:HeapProfileTable::Snapshot
map_size_	.\memory_region_map.cc	/^int64 MemoryRegionMap::map_size_ = 0;$/;"	m	class:MemoryRegionMap	file:
map_size_	.\memory_region_map.h	/^  static int64 map_size_;$/;"	m	class:MemoryRegionMap
mask_	.\windows\mini_disassembler_types.h	/^  unsigned char mask_;$/;"	m	struct:sidestep::OpcodeTable
mask_valid_	.\base\low_level_alloc.cc	/^    bool mask_valid_;$/;"	m	class:__anon8::ArenaLock	file:
masked_t_	.\gperftools\heap-checker.h	/^  uintptr_t masked_t_;$/;"	m	class:HiddenPointer
matched	.\tests\tcmalloc_unittest.cc	/^  bool matched;$/;"	m	struct:testing::__anon41::RangeCallbackState	file:
max	.\heap-checker.cc	67;"	d	file:
max_cache_size_	.\central_freelist.h	/^  int32_t max_cache_size_;$/;"	m	class:tcmalloc::CentralFreeList
max_depth	.\heap-checker.cc	/^  int       max_depth;      \/\/ the maximal stack depth to disable at$/;"	m	struct:HeapLeakChecker::RangeValue	file:
max_free_queue_size	.\tests\debugallocation_test.cc	/^DECLARE_int32(max_free_queue_size);$/;"	v
max_free_queue_size	.\tests\tcmalloc_unittest.cc	/^DECLARE_int32(max_free_queue_size);     \/\/ in debugallocation.cc$/;"	v
max_heap_address	.\heap-checker.cc	/^static uintptr_t max_heap_address = 0;$/;"	v	file:
max_heap_object_size	.\heap-checker.cc	/^static size_t max_heap_object_size = 0;$/;"	v	file:
max_length	.\thread_cache.h	/^    size_t max_length() const {$/;"	f	class:tcmalloc::ThreadCache::FreeList
max_length_	.\thread_cache.h	/^    uint16_t max_length_;$/;"	m	class:tcmalloc::ThreadCache::FreeList
max_length_	.\thread_cache.h	/^    uint32_t max_length_;  \/\/ Dynamic max list length based on usage.$/;"	m	class:tcmalloc::ThreadCache::FreeList
max_lim_	.\windows\mini_disassembler_types.h	/^  unsigned char max_lim_;$/;"	m	struct:sidestep::OpcodeTable
max_object_size	.\gperftools\malloc_extension.h	/^    size_t max_object_size;$/;"	m	struct:MallocExtension::FreeListInfo
max_size	.\base\stl_allocator.h	/^  size_type max_size() const { return size_t(-1) \/ sizeof(T); }$/;"	f	class:STL_Allocator
max_size_	.\thread_cache.h	/^  size_t        max_size_;              \/\/ size_ > max_size_ --> Scavenge()$/;"	m	class:tcmalloc::ThreadCache
max_stack_depth_	.\memory_region_map.cc	/^int MemoryRegionMap::max_stack_depth_ = 0;$/;"	m	class:MemoryRegionMap	file:
max_stack_depth_	.\memory_region_map.h	/^  static int max_stack_depth_;$/;"	m	class:MemoryRegionMap
maybe_do_cpp_memalign_slow	.\tcmalloc.cc	/^static void *maybe_do_cpp_memalign_slow(size_t align, size_t size) {$/;"	f	namespace:__anon34
memalign	.\libc_override_redefine.h	/^  void* memalign(size_t a, size_t s)             { return tc_memalign(a, s);  }$/;"	f
memalign_fraction_	.\tests\tcmalloc_unittest.cc	/^  double memalign_fraction_;$/;"	m	class:testing::AllocatorState	file:
memalign_retry_data	.\debugallocation.cc	/^struct memalign_retry_data {$/;"	s	file:
memcpy_cast	.\maybe_threads.cc	/^static T2 memcpy_cast(const T1 &input) {$/;"	f	file:
metadata_bytes	.\tcmalloc.cc	/^  uint64_t metadata_bytes;    \/\/ Bytes alloced for metadata$/;"	m	struct:TCMallocStats	file:
metadata_chunk_alloc_	.\common.cc	/^static char *metadata_chunk_alloc_;$/;"	m	namespace:tcmalloc	file:
metadata_chunk_avail_	.\common.cc	/^static size_t metadata_chunk_avail_;$/;"	m	namespace:tcmalloc	file:
metadata_system_bytes	.\common.cc	/^uint64_t metadata_system_bytes() { return metadata_system_bytes_; }$/;"	f	namespace:tcmalloc
metadata_system_bytes_	.\common.cc	/^static uint64_t metadata_system_bytes_ = 0;$/;"	m	namespace:tcmalloc	file:
mi_check	.\libc_override_osx.h	/^boolean_t mi_check(malloc_zone_t *zone) {$/;"	f	namespace:__anon22
mi_enumerator	.\libc_override_osx.h	/^kern_return_t mi_enumerator(task_t task, void *,$/;"	f	namespace:__anon22
mi_force_lock	.\libc_override_osx.h	/^void mi_force_lock(malloc_zone_t *zone) {$/;"	f	namespace:__anon22
mi_force_unlock	.\libc_override_osx.h	/^void mi_force_unlock(malloc_zone_t *zone) {$/;"	f	namespace:__anon22
mi_good_size	.\libc_override_osx.h	/^size_t mi_good_size(malloc_zone_t *zone, size_t size) {$/;"	f	namespace:__anon22
mi_log	.\libc_override_osx.h	/^void mi_log(malloc_zone_t *zone, void *address) {$/;"	f	namespace:__anon22
mi_print	.\libc_override_osx.h	/^void mi_print(malloc_zone_t *zone, boolean_t verbose) {$/;"	f	namespace:__anon22
mi_statistics	.\libc_override_osx.h	/^void mi_statistics(malloc_zone_t *zone, malloc_statistics_t *stats) {$/;"	f	namespace:__anon22
mi_zone_locked	.\libc_override_osx.h	/^boolean_t mi_zone_locked(malloc_zone_t *zone) {$/;"	f	namespace:__anon22
min	.\heap-checker.cc	68;"	d	file:
min_heap_address	.\heap-checker.cc	/^static uintptr_t min_heap_address = uintptr_t(-1LL);$/;"	v	file:
min_lim_	.\windows\mini_disassembler_types.h	/^  unsigned char min_lim_;$/;"	m	struct:sidestep::OpcodeTable
min_object_size	.\gperftools\malloc_extension.h	/^    size_t min_object_size;$/;"	m	struct:MallocExtension::FreeListInfo
min_size	.\base\low_level_alloc.cc	/^  size_t min_size;        \/\/ smallest allocation block size$/;"	m	struct:LowLevelAlloc::Arena	file:
min_size	.\tests\tcmalloc_unittest.cc	/^  size_t min_size;$/;"	m	struct:testing::__anon41::RangeCallbackState	file:
min_size_for_slow_path	.\thread_cache.h	/^    size_t min_size_for_slow_path;$/;"	m	struct:tcmalloc::ThreadCache::ThreadLocalData
mips_regs	.\base\elfcore.h	/^    struct mips_regs mips_regs;$/;"	m	struct:Frame	typeref:struct:Frame::mips_regs
mips_regs	.\base\elfcore.h	/^  typedef struct mips_regs {$/;"	s
mips_regs	.\base\elfcore.h	/^  } mips_regs;$/;"	t	typeref:struct:mips_regs
mkdir	.\windows\port.h	/^inline int mkdir(const char *pathname, int) {$/;"	f
mmap	.\malloc_hook_mmap_freebsd.h	46;"	d
mmap	.\malloc_hook_mmap_linux.h	151;"	d
mmap	.\windows\port.h	/^inline void *mmap(void *addr, size_t length, int prot, int flags,$/;"	f
mmap_calls	.\tests\malloc_hook_test.cc	/^int mmap_calls = 0;$/;"	m	namespace:__anon35	file:
mmap_hooks_	.\malloc_hook.cc	/^HookList<MallocHook::MmapHook> mmap_hooks_ = INIT_HOOK_LIST;$/;"	m	namespace:base::internal	file:
mmap_matching_calls	.\tests\malloc_hook_test.cc	/^int mmap_matching_calls = 0;$/;"	m	namespace:__anon35	file:
mmap_name	.\system-alloc.cc	/^static const char mmap_name[] = "MmapSysAllocator";$/;"	v	file:
mmap_replacement_	.\malloc_hook.cc	/^HookList<MallocHook::MmapReplacement> mmap_replacement_ = { 0 };$/;"	m	namespace:base::internal	file:
mmap_space	.\system-alloc.cc	/^} mmap_space;$/;"	v	typeref:union:__anon31	file:
mmapper_addr	.\tests\heap-checker_unittest.cc	/^static void* (*mmapper_addr)(uintptr_t* addr) = &Mmapper;$/;"	v	file:
mnemonic_	.\windows\mini_disassembler_types.h	/^  const char* mnemonic_;$/;"	m	struct:sidestep::Opcode
mnemonic_	.\windows\mini_disassembler_types.h	/^  const char* mnemonic_;$/;"	m	struct:sidestep::SpecificOpcode
modBaseAddr	.\windows\patch_functions.cc	/^  LPVOID  modBaseAddr;     \/\/ the same as hmodule$/;"	m	struct:__anon52::ModuleEntryCopy	file:
modBaseSize	.\windows\patch_functions.cc	/^  DWORD   modBaseSize;$/;"	m	struct:__anon52::ModuleEntryCopy	file:
module_	.\base\sysinfo.h	/^  MODULEENTRY32 module_;   \/\/ info about current dll (and dll iterator)$/;"	m	class:ProcMapsIterator
module_base	.\windows\nm-pdb.c	/^  ULONG64 module_base;$/;"	m	struct:__anon51	file:
module_base_address_	.\windows\patch_functions.cc	/^  const void *module_base_address_;$/;"	m	class:__anon52::LibcInfo	file:
module_base_size_	.\windows\patch_functions.cc	/^  size_t module_base_size_;$/;"	m	class:__anon52::LibcInfo	file:
module_enter_exit_hook	.\tcmalloc.cc	/^static TCMallocGuard module_enter_exit_hook;$/;"	v	file:
mq	.\base\elfcore.h	/^    unsigned long mq;$/;"	m	struct:ppc_regs
mremap	.\base\linux_syscall_support.h	/^  LSS_INLINE void *LSS_NAME(mremap)(void *old_address, size_t old_size,$/;"	f
mremap	.\malloc_hook.cc	40;"	d	file:
mremap	.\malloc_hook.cc	42;"	d	file:
mremap_hooks_	.\malloc_hook.cc	/^HookList<MallocHook::MremapHook> mremap_hooks_ = INIT_HOOK_LIST;$/;"	m	namespace:base::internal	file:
msr	.\base\elfcore.h	/^    unsigned long msr;$/;"	m	struct:ppc_regs
mu	.\base\low_level_alloc.cc	/^  SpinLock mu;            \/\/ protects freelist, allocation_count,$/;"	m	struct:LowLevelAlloc::Arena	file:
mu_	.\base\simple_mutex.h	/^  Mutex * const mu_;$/;"	m	class:MUTEX_NAMESPACE::MutexLock
mu_	.\base\simple_mutex.h	/^  Mutex * const mu_;$/;"	m	class:MUTEX_NAMESPACE::ReaderMutexLock
mu_	.\base\simple_mutex.h	/^  Mutex * const mu_;$/;"	m	class:MUTEX_NAMESPACE::WriterMutexLock
mu_	.\tests\profile-handler_unittest.cc	/^  Mutex mu_;$/;"	m	class:__anon37::BusyThread	file:
munmap	.\windows\port.h	/^inline int munmap(void *addr, size_t length) {$/;"	f
munmap_calls	.\tests\malloc_hook_test.cc	/^int munmap_calls = 0;$/;"	m	namespace:__anon35	file:
munmap_hooks_	.\malloc_hook.cc	/^HookList<MallocHook::MunmapHook> munmap_hooks_ = INIT_HOOK_LIST;$/;"	m	namespace:base::internal	file:
munmap_matching_calls	.\tests\malloc_hook_test.cc	/^int munmap_matching_calls = 0;$/;"	m	namespace:__anon35	file:
munmap_replacement_	.\malloc_hook.cc	/^HookList<MallocHook::MunmapReplacement> munmap_replacement_ = { 0 };$/;"	m	namespace:base::internal	file:
mutex_	.\base\simple_mutex.h	/^  MutexType mutex_;$/;"	m	class:MUTEX_NAMESPACE::Mutex
my_errno	.\base\linuxthreads.cc	/^    int my_errno;$/;"	m	class:__anon2::SysCalls	file:
mz_calloc	.\libc_override_osx.h	/^void* mz_calloc(malloc_zone_t* zone, size_t num_items, size_t size) {$/;"	f	namespace:__anon22
mz_destroy	.\libc_override_osx.h	/^void mz_destroy(malloc_zone_t* zone) {$/;"	f	namespace:__anon22
mz_free	.\libc_override_osx.h	/^void mz_free(malloc_zone_t* zone, void* ptr) {$/;"	f	namespace:__anon22
mz_malloc	.\libc_override_osx.h	/^void* mz_malloc(malloc_zone_t* zone, size_t size) {$/;"	f	namespace:__anon22
mz_memalign	.\libc_override_osx.h	/^void* mz_memalign(malloc_zone_t* zone, size_t align, size_t size) {$/;"	f	namespace:__anon22
mz_realloc	.\libc_override_osx.h	/^void* mz_realloc(malloc_zone_t* zone, void* ptr, size_t size) {$/;"	f	namespace:__anon22
mz_size	.\libc_override_osx.h	/^size_t mz_size(malloc_zone_t* zone, const void* ptr) {$/;"	f	namespace:__anon22
mz_valloc	.\libc_override_osx.h	/^void* mz_valloc(malloc_zone_t* zone, size_t size) {$/;"	f	namespace:__anon22
n1	.\tests\heap-checker_unittest.cc	/^  char n1[5];$/;"	m	struct:Nesting	file:
n2	.\tests\heap-checker_unittest.cc	/^  char n2[11];$/;"	m	struct:Nesting	file:
n3	.\tests\heap-checker_unittest.cc	/^  char n3[27];$/;"	m	struct:Nesting	file:
name	.\base\elf_mem_image.h	/^    const char      *name;      \/\/ E.g. "__vdso_getcpu"$/;"	m	struct:base::ElfMemImage::SymbolInfo
name	.\stacktrace.cc	/^  const char *name;$/;"	m	struct:GetStackImplementation	file:
name	.\tests\tcmalloc_unittest.cc	/^    string      name;$/;"	m	struct:testing::TestHarness::Type	file:
name	.\windows\nm-pdb.c	/^  char *name;$/;"	m	struct:__anon50	file:
name	.\windows\patch_functions.cc	/^    const char* const name;          \/\/ name of fn in a module (eg "malloc")$/;"	m	struct:__anon52::WindowsInfo::FunctionInfo	file:
name_	.\base\googleinit.h	/^  const char* const name_;$/;"	m	class:GoogleInitializer
name_	.\gperftools\heap-checker.h	/^  const char* name_;  \/\/ our remembered name (we own it)$/;"	m	class:HeapLeakChecker
names_	.\system-alloc.cc	/^  const char* names_[kMaxAllocators];$/;"	m	class:DefaultSysAllocator	file:
nanosleep	.\windows\port.h	/^inline int nanosleep(const struct timespec *req, struct timespec *rem) {$/;"	f
new_hooks_	.\malloc_hook.cc	/^HookList<MallocHook::NewHook> new_hooks_ =$/;"	m	namespace:base::internal	file:
new_type	.\debugallocation.cc	/^  int new_type;$/;"	m	struct:debug_alloc_retry_data	file:
news_handled	.\tests\tcmalloc_unittest.cc	/^static int news_handled = 0;$/;"	m	namespace:testing	file:
next	.\addressmap-inl.h	/^    Cluster* next;                      \/\/ Next cluster in hash table chain$/;"	m	struct:AddressMap::Cluster
next	.\addressmap-inl.h	/^    Entry* next;$/;"	m	struct:AddressMap::Entry
next	.\addressmap-inl.h	/^    Object* next;$/;"	m	struct:AddressMap::Object
next	.\base\low_level_alloc.cc	/^    AllocList *next[kMaxLevel];   \/\/ actually has levels elements.$/;"	m	struct:low_level_alloc_internal::AllocList	file:
next	.\heap-profile-stats.h	/^  HeapProfileBucket* next;  \/\/ Next entry in hash-table.$/;"	m	struct:HeapProfileBucket
next	.\span.h	/^  Span*         next;           \/\/ Used when in link list$/;"	m	struct:tcmalloc::Span
next	.\stack_trace_table.h	/^    Bucket* next;$/;"	m	struct:tcmalloc::StackTraceTable::Bucket
next	.\stacktrace_powerpc-inl.h	/^  struct layout_ppc *next;$/;"	m	struct:layout_ppc	typeref:struct:layout_ppc::layout_ppc
next	.\stacktrace_powerpc-linux-inl.h	/^  struct layout_ppc *next;$/;"	m	struct:layout_ppc	typeref:struct:layout_ppc::layout_ppc
next_	.\thread_cache.h	/^  ThreadCache* next_;$/;"	m	class:tcmalloc::ThreadCache
next_	.\windows\preamble_patcher.h	/^    PreamblePage* next_;$/;"	m	struct:sidestep::PreamblePatcher::PreamblePage
next_key	.\maybe_threads.cc	/^static int next_key;$/;"	v	file:
next_memory_steal_	.\thread_cache.cc	/^ThreadCache* ThreadCache::next_memory_steal_ = NULL;$/;"	m	class:tcmalloc::ThreadCache	file:
next_memory_steal_	.\thread_cache.h	/^  static ThreadCache* next_memory_steal_;$/;"	m	class:tcmalloc::ThreadCache
nexthistory	.\span.h	/^  int nexthistory;$/;"	m	struct:tcmalloc::Span
nextline_	.\base\sysinfo.h	/^  char *nextline_;    \/\/ start of next line$/;"	m	class:ProcMapsIterator
nonempty_	.\central_freelist.h	/^  Span     nonempty_;       \/\/ Dummy header for list of non-empty spans$/;"	m	class:tcmalloc::CentralFreeList
normal	.\page_heap.h	/^    Span        normal;$/;"	m	struct:tcmalloc::PageHeap::SpanList
normal_length	.\page_heap.h	/^    int64 normal_length[kMaxPages];$/;"	m	struct:tcmalloc::PageHeap::SmallSpanStats
normal_pages	.\page_heap.h	/^    int64 normal_pages;    \/\/ Combined page length of normal large spans$/;"	m	struct:tcmalloc::PageHeap::LargeSpanStats
not_implemented	.\stacktrace_win32-inl.h	/^static int not_implemented(void) {$/;"	f
nraddr	.\third_party\valgrind.h	/^      unsigned int nraddr; \/* where's the code? *\/$/;"	m	struct:__anon42
nraddr	.\third_party\valgrind.h	/^      unsigned int nraddr; \/* where's the code? *\/$/;"	m	struct:__anon44
nraddr	.\third_party\valgrind.h	/^      unsigned int nraddr; \/* where's the code? *\/$/;"	m	struct:__anon46
nraddr	.\third_party\valgrind.h	/^      unsigned long long int nraddr; \/* where's the code? *\/$/;"	m	struct:__anon43
nraddr	.\third_party\valgrind.h	/^      unsigned long long int nraddr; \/* where's the code? *\/$/;"	m	struct:__anon45
nraddr	.\third_party\valgrind.h	/^      unsigned long long int nraddr; \/* where's the code? *\/$/;"	m	struct:__anon47
num_buckets_	.\heap-profile-table.h	/^  int num_buckets_;$/;"	m	class:HeapProfileTable
num_buckets_	.\memory_region_map.cc	/^int MemoryRegionMap::num_buckets_ = 0;  \/\/ GUARDED_BY(lock_)$/;"	m	class:MemoryRegionMap	file:
num_deleter_pcs	.\debugallocation.cc	/^  int num_deleter_pcs;$/;"	m	struct:MallocBlockQueueEntry	file:
num_evicted_	.\profiledata.h	/^  int           num_evicted_;   \/\/ how many evicted entries?$/;"	m	class:ProfileData
num_objects_to_move	.\common.h	/^  inline int num_objects_to_move(size_t cl) {$/;"	f	class:tcmalloc::SizeMap
num_objects_to_move_	.\common.h	/^  int num_objects_to_move_[kNumClasses];$/;"	m	class:tcmalloc::SizeMap
num_spans_	.\central_freelist.h	/^  size_t   num_spans_;      \/\/ Number of spans in empty_ plus nonempty_$/;"	m	class:tcmalloc::CentralFreeList
num_tests_	.\tests\tcmalloc_unittest.cc	/^  int                   num_tests_;     \/\/ Num tests run so far$/;"	m	class:testing::TestHarness	file:
num_threads_remaining	.\tests\malloc_hook_test.cc	/^static volatile int num_threads_remaining;$/;"	m	namespace:__anon35	file:
obj_makers	.\tests\heap-checker_unittest.cc	/^static list<ObjMakerFunc> obj_makers;  \/\/ list of registered object makers$/;"	v	file:
object_size	.\heap-profile-table.h	/^    size_t object_size;  \/\/ size of the allocation$/;"	m	struct:HeapProfileTable::AllocInfo
objects	.\span.h	/^  void*         objects;        \/\/ Linked list of free objects$/;"	m	struct:tcmalloc::Span
off_t	.\windows\port.h	/^typedef _off_t off_t;$/;"	t
offset_	.\debugallocation.cc	/^  size_t offset_;   \/\/ normally 0 unless memaligned memory$/;"	m	class:MallocBlock	file:
old_min_size_for_slow_path	.\thread_cache.h	/^    size_t old_min_size_for_slow_path;$/;"	m	struct:tcmalloc::ThreadCache::ThreadLocalData
old_value_	.\tests\tcmalloc_unittest.cc	/^  size_t old_value_;$/;"	m	class:testing::AggressiveDecommitChanger	file:
on_process_term	.\windows\port.cc	/^static int on_process_term(void) {$/;"	f	file:
on_tls_callback	.\windows\port.cc	/^static void NTAPI on_tls_callback(HINSTANCE h, DWORD dwReason, PVOID pv) {$/;"	f	file:
once	.\malloc_hook.cc	/^pthread_once_t once = PTHREAD_ONCE_INIT;$/;"	m	namespace:__anon24	file:
once_	.\profile-handler.cc	/^  static pthread_once_t once_;$/;"	m	class:ProfileHandler	file:
once_	.\profile-handler.cc	/^pthread_once_t ProfileHandler::once_ = PTHREAD_ONCE_INIT;$/;"	m	class:ProfileHandler	file:
opcode_if_66_prefix_	.\windows\mini_disassembler_types.h	/^  SpecificOpcode opcode_if_66_prefix_;$/;"	m	struct:sidestep::Opcode
opcode_if_f2_prefix_	.\windows\mini_disassembler_types.h	/^  SpecificOpcode opcode_if_f2_prefix_;$/;"	m	struct:sidestep::Opcode
opcode_if_f3_prefix_	.\windows\mini_disassembler_types.h	/^  SpecificOpcode opcode_if_f3_prefix_;$/;"	m	struct:sidestep::Opcode
open	.\base\linux_syscall_support.h	/^    LSS_INLINE int LSS_NAME(open)(const char* p, int f, int m) {$/;"	f
open	.\windows\port.h	/^inline int open(const char *pathname, int flags, int mode = 0) {$/;"	f
operand_bytes_	.\windows\mini_disassembler.h	/^  unsigned int operand_bytes_;$/;"	m	class:sidestep::MiniDisassembler
operand_default_is_32_bits_	.\windows\mini_disassembler.h	/^  bool operand_default_is_32_bits_;$/;"	m	class:sidestep::MiniDisassembler
operand_default_support_64_bits_	.\windows\mini_disassembler.h	/^  bool operand_default_support_64_bits_;$/;"	m	class:sidestep::MiniDisassembler
operand_is_32_bits_	.\windows\mini_disassembler.h	/^  bool operand_is_32_bits_;$/;"	m	class:sidestep::MiniDisassembler
operand_is_64_bits_	.\windows\mini_disassembler.h	/^  bool operand_is_64_bits_;$/;"	m	class:sidestep::MiniDisassembler
operand_size_	.\windows\mini_disassembler_types.h	/^  OperandSize operand_size_;$/;"	m	struct:sidestep::ModrmEntry
operator !=	.\base\elf_mem_image.cc	/^bool ElfMemImage::SymbolIterator::operator!=(const SymbolIterator &rhs) const {$/;"	f	class:base::ElfMemImage::SymbolIterator
operator ()	.\memory_region_map.h	/^    bool operator()(const Region& x, const Region& y) const {$/;"	f	struct:MemoryRegionMap::RegionCmp
operator *	.\base\elf_mem_image.cc	/^const ElfMemImage::SymbolInfo& ElfMemImage::SymbolIterator::operator*() const {$/;"	f	class:base::ElfMemImage::SymbolIterator
operator ++	.\base\elf_mem_image.cc	/^ElfMemImage::SymbolIterator &ElfMemImage::SymbolIterator::operator++() {$/;"	f	class:base::ElfMemImage::SymbolIterator
operator ->	.\base\elf_mem_image.cc	/^const ElfMemImage::SymbolInfo *ElfMemImage::SymbolIterator::operator->() const {$/;"	f	class:base::ElfMemImage::SymbolIterator
operator <	.\heap-profile-table.cc	/^  bool operator<(const Entry& x) const {$/;"	f	struct:HeapProfileTable::Snapshot::Entry
operator =	.\tests\heap-checker_unittest.cc	/^  void operator=(const Array& x) {$/;"	f	struct:Array
operator ==	.\base\elf_mem_image.cc	/^bool ElfMemImage::SymbolIterator::operator==(const SymbolIterator &rhs) const {$/;"	f	class:base::ElfMemImage::SymbolIterator
operator ==	.\base\stl_allocator.h	/^  bool operator==(const STL_Allocator&) const { return true; }$/;"	f	class:STL_Allocator
operator []	.\tests\profiledata_unittest.cc	/^  T& operator[](int i) { return data_[i]; }$/;"	f	class:__anon38::scoped_array
operator []	.\tests\sampler_test.cc	/^  T& operator[](int i) { return p_[i]; }$/;"	f	class:__anon39::scoped_array
operator delete	.\libc_override_redefine.h	/^void operator delete(void* p) throw()            { tc_delete(p);              }$/;"	f
operator delete	.\libc_override_redefine.h	/^void operator delete(void* p, size_t s) throw()  { tc_delete_sized(p, s);     }$/;"	f
operator delete	.\libc_override_redefine.h	/^void operator delete(void* ptr, const std::nothrow_t& nt) throw() {$/;"	f
operator delete	.\windows\get_mangled_names.cc	/^void operator delete(void* p) throw() { }$/;"	f
operator delete	.\windows\get_mangled_names.cc	/^void operator delete(void* p, const std::nothrow_t&) throw() { }$/;"	f
operator delete[]	.\libc_override_redefine.h	/^void operator delete[](void* p) throw()          { tc_deletearray(p);         }$/;"	f
operator delete[]	.\libc_override_redefine.h	/^void operator delete[](void* p, size_t s) throw(){ tc_deletearray_sized(p);   }$/;"	f
operator delete[]	.\libc_override_redefine.h	/^void operator delete[](void* ptr, const std::nothrow_t& nt) throw() {$/;"	f
operator delete[]	.\windows\get_mangled_names.cc	/^void operator delete[](void* p) throw() { }$/;"	f
operator delete[]	.\windows\get_mangled_names.cc	/^void operator delete[](void* p, const std::nothrow_t&) throw() { }$/;"	f
operator new	.\libc_override_redefine.h	/^void* operator new(size_t size)                  { return tc_new(size);       }$/;"	f
operator new	.\libc_override_redefine.h	/^void* operator new(size_t size, const std::nothrow_t& nt) throw() {$/;"	f
operator new	.\tests\heap-checker_unittest.cc	/^void* operator new(size_t size, const Initialized&) {$/;"	f
operator new	.\windows\get_mangled_names.cc	/^void* operator new(size_t size) { return &m; }$/;"	f
operator new	.\windows\get_mangled_names.cc	/^void* operator new(size_t size, const std::nothrow_t&) throw() { return &m; }$/;"	f
operator new[]	.\libc_override_redefine.h	/^void* operator new[](size_t size)                { return tc_newarray(size);  }$/;"	f
operator new[]	.\libc_override_redefine.h	/^void* operator new[](size_t size, const std::nothrow_t& nt) throw() {$/;"	f
operator new[]	.\tests\heap-checker_unittest.cc	/^void* operator new[](size_t size, const Initialized&) {$/;"	f
operator new[]	.\windows\get_mangled_names.cc	/^void* operator new[](size_t size) { return &m; }$/;"	f
operator new[]	.\windows\get_mangled_names.cc	/^void* operator new[](size_t size, const std::nothrow_t&) throw() { return &m; }$/;"	f
orig_rax	.\base\elfcore.h	/^    uint64_t  r9,r8,rax,rcx,rdx,rsi,rdi,orig_rax;$/;"	m	struct:i386_regs
original_function	.\windows\auto_testing_hook.h	/^  T original_function() {$/;"	f	class:sidestep::AutoTestingHookImpl
original_function	.\windows\preamble_patcher_test.cc	/^IncrementingFunc original_function = NULL;$/;"	m	namespace:__anon57	file:
original_function_	.\windows\auto_testing_hook.h	/^  T original_function_;  \/\/ always valid$/;"	m	class:sidestep::AutoTestingHookImpl
origstub_fn	.\windows\patch_functions.cc	/^    GenericFnPtr origstub_fn;        \/\/ original fn contents after we patch$/;"	m	struct:__anon52::WindowsInfo::FunctionInfo	file:
origstub_fn_	.\windows\patch_functions.cc	/^  static GenericFnPtr origstub_fn_[kNumFunctions];$/;"	m	class:__anon52::LibcInfoWithPatchFunctions	file:
origstub_fn_	.\windows\patch_functions.cc	/^template<int T> GenericFnPtr LibcInfoWithPatchFunctions<T>::origstub_fn_[] = {$/;"	m	class:__anon52::LibcInfoWithPatchFunctions	file:
other	.\base\stl_allocator.h	/^    typedef STL_Allocator<T1, Alloc> other;$/;"	t	struct:STL_Allocator::rebind
out_	.\profiledata.h	/^  int           out_;           \/\/ fd for output file.$/;"	m	class:ProfileData
overall_thread_cache_size	.\thread_cache.h	/^  static size_t overall_thread_cache_size() {$/;"	f	class:tcmalloc::ThreadCache
overall_thread_cache_size_	.\thread_cache.cc	/^size_t ThreadCache::overall_thread_cache_size_ = kDefaultOverallThreadCacheSize;$/;"	m	class:tcmalloc::ThreadCache	file:
overall_thread_cache_size_	.\thread_cache.h	/^  static size_t overall_thread_cache_size_;$/;"	m	class:tcmalloc::ThreadCache
owner_lock_	.\memory_region_map.h	/^  static SpinLock owner_lock_;$/;"	m	class:MemoryRegionMap
p	.\base\basictypes.h	/^  void*  p;$/;"	m	union:MemoryAligner
p1_	.\tests\heap-checker_unittest.cc	/^  P1 p1_;$/;"	m	class:Callback1	file:
p1_	.\tests\heap-checker_unittest.cc	/^  P1 p1_;$/;"	m	class:Callback2	file:
p2_	.\tests\heap-checker_unittest.cc	/^  P2 p2_;$/;"	m	class:Callback2	file:
p_	.\internal_logging.cc	/^  char* p_;$/;"	m	class:tcmalloc::Logger	file:
p_	.\tests\sampler_test.cc	/^  T* p_;$/;"	m	class:__anon39::scoped_array	file:
p_process_term_tcmalloc	.\windows\port.cc	/^int (*p_process_term_tcmalloc)(void) = on_process_term;$/;"	v
p_thread_callback_tcmalloc	.\windows\port.cc	/^void (NTAPI *p_thread_callback_tcmalloc)($/;"	v
pad	.\base\elfcore.h	/^    unsigned long pad[6];       \/* Unused padding to match kernel structures *\/$/;"	m	struct:mips_regs
pad1	.\base\linux_syscall_support.h	/^  short              pad1;$/;"	m	struct:kernel_stat
pad2	.\base\linux_syscall_support.h	/^  short              pad2;$/;"	m	struct:kernel_stat
pad_	.\central_freelist.h	/^  char pad_[64 - kFreeListSizeMod64];$/;"	m	class:tcmalloc::CentralFreeListPaddedTo
pageheap	.\static_vars.h	/^  static PageHeap* pageheap() { return pageheap_; }$/;"	f	class:tcmalloc::Static
pageheap	.\tcmalloc.cc	/^  PageHeap::Stats pageheap;   \/\/ Stats from page heap$/;"	m	struct:TCMallocStats	file:
pageheap_	.\static_vars.cc	/^PageHeap* Static::pageheap_ = NULL;$/;"	m	class:tcmalloc::Static	file:
pageheap_	.\static_vars.h	/^  static PageHeap* pageheap_;$/;"	m	class:tcmalloc::Static
pageheap_lock	.\static_vars.h	/^  static SpinLock* pageheap_lock() { return &pageheap_lock_; }$/;"	f	class:tcmalloc::Static
pageheap_lock_	.\static_vars.h	/^  static SpinLock pageheap_lock_;$/;"	m	class:tcmalloc::Static
pagemap_	.\page_heap.h	/^  PageMap pagemap_;$/;"	m	class:tcmalloc::PageHeap
pagemap_cache_	.\page_heap.h	/^  mutable PageMapCache pagemap_cache_;$/;"	m	class:tcmalloc::PageHeap
pages	.\common.h	/^inline Length pages(size_t bytes) {$/;"	f	namespace:tcmalloc
pages_allocator_place	.\emergency_malloc.cc	/^  } pages_allocator_place;$/;"	m	namespace:tcmalloc	typeref:union:tcmalloc::__anon18	file:
pagesize	.\base\low_level_alloc.cc	/^  size_t pagesize;        \/\/ ==getpagesize()  (init under mu, then ro)$/;"	m	struct:LowLevelAlloc::Arena	file:
pagesize	.\system-alloc.cc	/^static size_t pagesize = 0;$/;"	v	file:
pagesize	.\tcmalloc.cc	/^static size_t pagesize = 0;$/;"	v	file:
pagesize_	.\windows\preamble_patcher.cc	/^long PreamblePatcher::pagesize_ = 0;$/;"	m	class:sidestep::PreamblePatcher	file:
pagesize_	.\windows\preamble_patcher.h	/^  static long pagesize_;$/;"	m	class:sidestep::PreamblePatcher
parameter	.\base\linuxthreads.cc	/^  void        *parameter;$/;"	m	struct:ListerParams	file:
parent	.\tests\heap-checker_unittest.cc	/^    Nesting* parent;$/;"	m	struct:Nesting::Inner	file:
passed_	.\tests\tcmalloc_unittest.cc	/^  vector<Object>        passed_;        \/\/ Pending objects passed from others$/;"	m	class:testing::TesterThread	file:
patched	.\windows\patch_functions.cc	/^  bool patched() const { return is_valid(); }$/;"	f	class:__anon52::LibcInfo
pc_offset	.\getpc.h	/^  int pc_offset;$/;"	m	struct:CallUnrollInfo
pclose	.\windows\port.h	/^inline int pclose(FILE *stream) {$/;"	f
per_thread_cache_size_	.\thread_cache.cc	/^volatile size_t ThreadCache::per_thread_cache_size_ = kMaxThreadCacheSize;$/;"	m	class:tcmalloc::ThreadCache	file:
per_thread_cache_size_	.\thread_cache.h	/^  static volatile size_t per_thread_cache_size_;$/;"	m	class:tcmalloc::ThreadCache
per_thread_timer_enabled_	.\profile-handler.cc	/^  bool per_thread_timer_enabled_;$/;"	m	class:ProfileHandler	file:
perftools_fn	.\windows\patch_functions.cc	/^    const GenericFnPtr perftools_fn; \/\/ fn we want to patch in$/;"	m	struct:__anon52::WindowsInfo::FunctionInfo	file:
perftools_fn_	.\windows\patch_functions.cc	/^  static const GenericFnPtr perftools_fn_[kNumFunctions];$/;"	m	class:__anon52::LibcInfoWithPatchFunctions	file:
perftools_fn_	.\windows\patch_functions.cc	/^const GenericFnPtr LibcInfoWithPatchFunctions<T>::perftools_fn_[] = {$/;"	m	class:__anon52::LibcInfoWithPatchFunctions	file:
perftools_pthread_atfork	.\maybe_threads.cc	/^void perftools_pthread_atfork(void (*before)(),$/;"	f
perftools_pthread_getspecific	.\maybe_threads.cc	/^void *perftools_pthread_getspecific(pthread_key_t key) {$/;"	f
perftools_pthread_getspecific	.\windows\port.h	/^inline void* perftools_pthread_getspecific(DWORD key) {$/;"	f
perftools_pthread_key_create	.\maybe_threads.cc	/^int perftools_pthread_key_create(pthread_key_t *key,$/;"	f
perftools_pthread_key_create	.\windows\port.h	/^inline int perftools_pthread_key_create(pthread_key_t *pkey,$/;"	f
perftools_pthread_key_delete	.\maybe_threads.cc	/^int perftools_pthread_key_delete(pthread_key_t key) {$/;"	f
perftools_pthread_once	.\maybe_threads.cc	/^int perftools_pthread_once(pthread_once_t *ctl,$/;"	f
perftools_pthread_once	.\windows\port.cc	/^extern "C" int perftools_pthread_once(pthread_once_t *once_control,$/;"	f
perftools_pthread_setspecific	.\maybe_threads.cc	/^int perftools_pthread_setspecific(pthread_key_t key, void *val) {$/;"	f
perftools_pthread_setspecific	.\windows\port.h	/^inline int perftools_pthread_setspecific(pthread_key_t key, const void *value) {$/;"	f
perftools_pthread_specific_vals	.\maybe_threads.cc	/^static void *perftools_pthread_specific_vals[MAX_PERTHREAD_VALS];$/;"	v	file:
perftools_vsnprintf	.\base\logging.h	70;"	d
perftools_vsnprintf	.\windows\port.h	/^inline int perftools_vsnprintf(char *str, size_t size, const char *format,$/;"	f
phinited	.\thread_cache.cc	/^static bool phinited = false;$/;"	m	namespace:tcmalloc	file:
pid_	.\base\sysinfo.h	/^  pid_t pid_;$/;"	m	class:ProcMapsIterator
pid_t	.\windows\port.h	/^typedef int pid_t;$/;"	t
pipe	.\base\linux_syscall_support.h	/^    LSS_INLINE int LSS_NAME(pipe)(int *p) {$/;"	f
place	.\heap-checker.cc	/^  ObjectPlacement place;  \/\/ where ptr points to$/;"	m	struct:AllocObject	file:
pointer	.\base\stl_allocator.h	/^  typedef T*         pointer;$/;"	t	class:STL_Allocator
pointer_source_alignment	.\heap-checker.cc	/^static size_t pointer_source_alignment = kPointerSourceAlignment;$/;"	v	file:
poll	.\windows\port.h	/^inline int poll(struct pollfd* fds, int nfds, int timeout) {$/;"	f
popen	.\windows\port.h	/^inline FILE *popen(const char *command, const char *type) {$/;"	f
pos	.\stacktrace_libgcc-inl.h	/^  int pos;$/;"	m	struct:libgcc_backtrace_data
posix_memalign	.\libc_override_redefine.h	/^  int posix_memalign(void** r, size_t a, size_t s)         {$/;"	f
ppc_regs	.\base\elfcore.h	/^  typedef struct ppc_regs {$/;"	s
ppc_regs	.\base\elfcore.h	/^  } ppc_regs;$/;"	t	typeref:struct:ppc_regs
preamble_pages_	.\windows\preamble_patcher.cc	/^PreamblePatcher::PreamblePage* PreamblePatcher::preamble_pages_ = NULL;$/;"	m	class:sidestep::PreamblePatcher	file:
preamble_pages_	.\windows\preamble_patcher.h	/^  static PreamblePage* preamble_pages_;$/;"	m	class:sidestep::PreamblePatcher
premmap_hooks_	.\malloc_hook.cc	/^HookList<MallocHook::PreMmapHook> premmap_hooks_ =$/;"	m	namespace:base::internal	file:
presbrk_hooks_	.\malloc_hook.cc	/^HookList<MallocHook::PreSbrkHook> presbrk_hooks_ =$/;"	m	namespace:base::internal	file:
prev	.\span.h	/^  Span*         prev;           \/\/ Used when in link list$/;"	m	struct:tcmalloc::Span
prev_	.\thread_cache.h	/^  ThreadCache* prev_;$/;"	m	class:tcmalloc::ThreadCache
printf	.\internal_logging.cc	/^void TCMalloc_Printer::printf(const char* format, ...) {$/;"	f	class:TCMalloc_Printer
priv_data	.\malloc_hook-inl.h	/^  AtomicWord priv_data[kHookListCapacity];$/;"	m	struct:base::internal::HookList
priv_end	.\malloc_hook-inl.h	/^  AtomicWord priv_end;$/;"	m	struct:base::internal::HookList
prof_handler	.\profiler.cc	/^void CpuProfiler::prof_handler(int sig, siginfo_t*, void* signal_ucontext,$/;"	f	class:CpuProfiler
prof_handler	.\tests\getpc_test.cc	/^static void prof_handler(int sig, siginfo_t*, void* signal_ucontext) {$/;"	f	file:
prof_handler_called	.\tests\getpc_test.cc	/^static volatile bool prof_handler_called = false;$/;"	v	file:
prof_handler_token_	.\profiler.cc	/^  ProfileHandlerToken* prof_handler_token_;$/;"	m	class:CpuProfiler	file:
profile_mmap_	.\heap-profile-table.h	/^  bool profile_mmap_;$/;"	m	class:HeapProfileTable
profile_name	.\gperftools\profiler.h	/^  char   profile_name[1024];  \/* Name of profile file being written, or '\\0' *\/$/;"	m	struct:ProfilerState
profile_name	.\profiledata.h	/^    char     profile_name[1024];  \/\/ Name of file being written, or '\\0'$/;"	m	struct:ProfileData::State
profile_name_prefix	.\heap-checker.cc	/^static string* profile_name_prefix = NULL;$/;"	v	file:
profile_stats	.\heap-profile-table.h	/^    Stats* profile_stats;  \/\/ stats to update (may be NULL)$/;"	m	struct:HeapProfileTable::DumpArgs
profiler_h	.\tests\simple_compat_test.cc	/^ProfilerOptions* profiler_h;$/;"	v
pthread_equal	.\windows\port.h	/^inline bool pthread_equal(pthread_t left, pthread_t right) {$/;"	f
pthread_key_t	.\windows\port.h	/^typedef DWORD pthread_key_t;$/;"	t
pthread_once_init	.\maybe_threads.cc	/^static pthread_once_t pthread_once_init = PTHREAD_ONCE_INIT;$/;"	v	file:
pthread_once_t	.\windows\port.h	/^typedef LONG pthread_once_t;$/;"	t
pthread_self	.\windows\port.h	/^inline pthread_t pthread_self(void) {$/;"	f
pthread_t	.\windows\port.h	/^typedef DWORD pthread_t;$/;"	t
ptr	.\base\low_level_alloc.cc	/^  void *ptr;$/;"	m	union:__anon9	file:
ptr	.\debugallocation.cc	/^  void *ptr;$/;"	m	union:__anon17	file:
ptr	.\emergency_malloc.cc	/^    void *ptr;$/;"	m	union:tcmalloc::__anon18	file:
ptr	.\heap-checker.cc	/^  const void* ptr;        \/\/ the object$/;"	m	struct:AllocObject	file:
ptr	.\internal_logging.h	/^    const void* ptr;$/;"	m	union:tcmalloc::LogItem::__anon21
ptr	.\memfs_malloc.cc	/^  void *ptr;$/;"	m	union:__anon25	file:
ptr	.\system-alloc.cc	/^  void *ptr;$/;"	m	union:__anon30	file:
ptr	.\system-alloc.cc	/^  void *ptr;$/;"	m	union:__anon31	file:
ptr	.\system-alloc.cc	/^  void *ptr;$/;"	m	union:__anon32	file:
ptr	.\tests\addressmap_unittest.cc	/^  char* ptr;$/;"	m	struct:PtrAndSize	file:
ptr	.\tests\heap-checker_unittest.cc	/^  T* ptr;$/;"	m	struct:Array	file:
ptr	.\tests\heap-checker_unittest.cc	/^  mutable C* ptr;$/;"	m	class:TClass	file:
ptr	.\tests\heap-checker_unittest.cc	/^  mutable char* ptr;$/;"	m	class:ClassA	file:
ptr	.\tests\low_level_alloc_unittest.cc	/^  char *ptr;      \/\/ pointer to memory$/;"	m	struct:BlockDesc	file:
ptr	.\tests\tcmalloc_unittest.cc	/^    char*       ptr;                    \/\/ Allocated pointer$/;"	m	struct:testing::TesterThread::Object	file:
ptr	.\tests\tcmalloc_unittest.cc	/^  uintptr_t ptr;$/;"	m	struct:testing::__anon41::RangeCallbackState	file:
ptr_	.\raw_printer.h	/^  char* ptr_;           \/\/ Where should we write next$/;"	m	class:base::RawPrinter
ptr_	.\tests\system-alloc_unittest.cc	/^  int ptr_;$/;"	m	class:ArraySysAllocator	file:
ptr_to_function	.\tests\testutil.cc	/^  void (*ptr_to_function)(int);$/;"	m	struct:FunctionAndId	file:
ptrace_detach	.\base\linux_syscall_support.h	/^  LSS_INLINE int LSS_NAME(ptrace_detach)(pid_t pid) {$/;"	f
ptrs	.\pagemap.h	/^    Node* ptrs[INTERIOR_LENGTH];$/;"	m	struct:TCMalloc_PageMap3::Node
pvalloc	.\libc_override_osx.h	/^  void* pvalloc(size_t s)                { return tc_pvalloc(s);      }$/;"	f
pvalloc	.\libc_override_redefine.h	/^  void* pvalloc(size_t s)                        { return tc_pvalloc(s);      }$/;"	f
pvalloc	.\tests\tcmalloc_unittest.cc	104;"	d	file:
q_	.\debugallocation.cc	/^  QueueEntry q_[kFreeQueueSize];$/;"	m	class:FreeQueue	file:
q_back_	.\debugallocation.cc	/^  int q_back_;$/;"	m	class:FreeQueue	file:
q_front_	.\debugallocation.cc	/^  int q_front_;$/;"	m	class:FreeQueue	file:
r10	.\base\elfcore.h	/^    uint64_t  r15,r14,r13,r12,rbp,rbx,r11,r10;$/;"	m	struct:i386_regs
r11	.\base\elfcore.h	/^    uint64_t  r15,r14,r13,r12,rbp,rbx,r11,r10;$/;"	m	struct:i386_regs
r12	.\base\elfcore.h	/^    uint64_t  r15,r14,r13,r12,rbp,rbx,r11,r10;$/;"	m	struct:i386_regs
r13	.\base\elfcore.h	/^    uint64_t  r15,r14,r13,r12,rbp,rbx,r11,r10;$/;"	m	struct:i386_regs
r14	.\base\elfcore.h	/^    uint64_t  r15,r14,r13,r12,rbp,rbx,r11,r10;$/;"	m	struct:i386_regs
r15	.\base\elfcore.h	/^    uint64_t  r15,r14,r13,r12,rbp,rbx,r11,r10;$/;"	m	struct:i386_regs
r2	.\third_party\valgrind.h	/^      unsigned int r2;  \/* what tocptr do we need? *\/$/;"	m	struct:__anon46
r2	.\third_party\valgrind.h	/^      unsigned long long int r2;  \/* what tocptr do we need? *\/$/;"	m	struct:__anon45
r2	.\third_party\valgrind.h	/^      unsigned long long int r2;  \/* what tocptr do we need? *\/$/;"	m	struct:__anon47
r8	.\base\elfcore.h	/^    uint64_t  r9,r8,rax,rcx,rdx,rsi,rdi,orig_rax;$/;"	m	struct:i386_regs
r9	.\base\elfcore.h	/^    uint64_t  r9,r8,rax,rcx,rdx,rsi,rdi,orig_rax;$/;"	m	struct:i386_regs
random	.\windows\port.h	/^inline long random(void) { return rand(); }$/;"	f
rax	.\base\elfcore.h	/^    uint64_t  r9,r8,rax,rcx,rdx,rsi,rdi,orig_rax;$/;"	m	struct:i386_regs
rbp	.\base\elfcore.h	/^    uint64_t  r15,r14,r13,r12,rbp,rbx,r11,r10;$/;"	m	struct:i386_regs
rbx	.\base\elfcore.h	/^    uint64_t  r15,r14,r13,r12,rbp,rbx,r11,r10;$/;"	m	struct:i386_regs
rcx	.\base\elfcore.h	/^    uint64_t  r9,r8,rax,rcx,rdx,rsi,rdi,orig_rax;$/;"	m	struct:i386_regs
rdi	.\base\elfcore.h	/^    uint64_t  r9,r8,rax,rcx,rdx,rsi,rdi,orig_rax;$/;"	m	struct:i386_regs
rdx	.\base\elfcore.h	/^    uint64_t  r9,r8,rax,rcx,rdx,rsi,rdi,orig_rax;$/;"	m	struct:i386_regs
read	.\windows\port.h	/^inline ssize_t read(int fd, void *buf, size_t count) {$/;"	f
real_malloced_size	.\debugallocation.cc	/^  static size_t real_malloced_size(size_t size) {$/;"	f	class:MallocBlock	file:
real_mmapped_size	.\debugallocation.cc	/^  static size_t real_mmapped_size(size_t size) {$/;"	f	class:MallocBlock	file:
real_size	.\debugallocation.cc	/^  size_t real_size() {$/;"	f	class:MallocBlock	file:
realloc	.\libc_override_redefine.h	/^  void* realloc(void* p, size_t s)               { return tc_realloc(p, s);   }$/;"	f
rebind	.\base\stl_allocator.h	/^  template <class T1> struct rebind {$/;"	s	class:STL_Allocator
recursion_count_	.\memory_region_map.cc	/^int MemoryRegionMap::recursion_count_ = 0;  \/\/ GUARDED_BY(owner_lock_)$/;"	m	class:MemoryRegionMap	file:
recursion_count_	.\memory_region_map.h	/^  static int recursion_count_;$/;"	m	class:MemoryRegionMap
recursive	.\stacktrace_libunwind-inl.h	/^static __thread int recursive;$/;"	v
recursive_insert	.\memory_region_map.cc	/^static bool recursive_insert = false;$/;"	v	file:
refcount	.\span.h	/^  unsigned int  refcount : 16;  \/\/ Number of non-free objects$/;"	m	struct:tcmalloc::Span
reference	.\base\stl_allocator.h	/^  typedef T&         reference;$/;"	t	class:STL_Allocator
region_set	.\memory_region_map.cc	/^  RegionSet* region_set() { return reinterpret_cast<RegionSet*>(rep); }$/;"	f	union:MemoryRegionMap::RegionSetRep
regions_	.\memory_region_map.cc	/^MemoryRegionMap::RegionSet* MemoryRegionMap::regions_ = NULL;$/;"	m	class:MemoryRegionMap	file:
regions_	.\memory_region_map.h	/^  static RegionSet* regions_;$/;"	m	class:MemoryRegionMap
regions_rep	.\memory_region_map.cc	/^static MemoryRegionMap::RegionSetRep regions_rep;$/;"	v	file:
release_index_	.\page_heap.h	/^  int release_index_;$/;"	m	class:tcmalloc::PageHeap
rep	.\memory_region_map.cc	/^  char rep[sizeof(RegionSet)];$/;"	m	union:MemoryRegionMap::RegionSetRep	file:
replacement_function_	.\windows\auto_testing_hook.h	/^  T replacement_function_;  \/\/ always valid$/;"	m	class:sidestep::AutoTestingHookImpl
resolve_delete_sized	.\libc_override_gcc_and_weak.h	/^static void *resolve_delete_sized(void) {$/;"	f
resolve_deletearray_sized	.\libc_override_gcc_and_weak.h	/^static void *resolve_deletearray_sized(void) {$/;"	f
result	.\base\linuxthreads.cc	/^  int         result, err;$/;"	m	struct:ListerParams	file:
result	.\tests\profiler_unittest.cc	/^static volatile int result = 0;$/;"	v	file:
retry_debug_allocate	.\debugallocation.cc	/^static void *retry_debug_allocate(void *arg) {$/;"	f	file:
retry_debug_memalign	.\debugallocation.cc	/^static void *retry_debug_memalign(void *arg) {$/;"	f	file:
retry_do_memalign	.\tcmalloc.cc	/^static void *retry_do_memalign(void *arg) {$/;"	f	namespace:__anon34
retry_malloc	.\tcmalloc.cc	/^static void *retry_malloc(void* size) {$/;"	f	namespace:__anon34
retry_memaligh_data	.\tcmalloc.cc	/^struct retry_memaligh_data {$/;"	s	namespace:__anon34	file:
return_addr	.\stacktrace_powerpc-inl.h	/^  void *return_addr;$/;"	m	struct:layout_ppc
return_addr	.\stacktrace_powerpc-linux-inl.h	/^  void *return_addr;$/;"	m	struct:layout_ppc
return_sp_offset	.\getpc.h	/^  int return_sp_offset;$/;"	m	struct:CallUnrollInfo
returned	.\page_heap.h	/^    Span        returned;$/;"	m	struct:tcmalloc::PageHeap::SpanList
returned_length	.\page_heap.h	/^    int64 returned_length[kMaxPages];$/;"	m	struct:tcmalloc::PageHeap::SmallSpanStats
returned_pages	.\page_heap.h	/^    int64 returned_pages;  \/\/ Combined page length of unmapped spans$/;"	m	struct:tcmalloc::PageHeap::LargeSpanStats
rgProcAddresses	.\windows\patch_functions.cc	/^  GenericFnPtr rgProcAddresses[LibcInfo::ctrgProcAddress];$/;"	m	struct:__anon52::ModuleEntryCopy	file:
rip	.\base\elfcore.h	/^    uint64_t  rip,cs,eflags;$/;"	m	struct:i386_regs
rip	.\base\elfcore.h	/^    unsigned long rip;		\/* Program counter.                          *\/$/;"	m	struct:ppc_regs
rnd	.\tests\addressmap_unittest.cc	/^static UniformRandomNumberGenerator rnd;$/;"	v	file:
rnd_	.\sampler.h	/^  uint64_t      rnd_;                   \/\/ Cheap random number generator$/;"	m	class:tcmalloc::Sampler
rnd_	.\tests\sampler_test.cc	/^  uint32_t rnd_;                   \/\/ Cheap random number generator$/;"	m	class:OldSampler	file:
rnd_	.\tests\tcmalloc_unittest.cc	/^  AllocatorState        rnd_;           \/\/ For generating random numbers$/;"	m	class:testing::TesterThread	file:
root_	.\pagemap.h	/^  Leaf* root_[ROOT_LENGTH];             \/\/ Pointers to 32 child nodes$/;"	m	class:TCMalloc_PageMap2
root_	.\pagemap.h	/^  Node* root_;                          \/\/ Root of radix tree$/;"	m	class:TCMalloc_PageMap3
roundup	.\base\low_level_alloc.cc	/^  size_t roundup;         \/\/ lowest power of 2 >= max(16,sizeof (AllocList))$/;"	m	struct:LowLevelAlloc::Arena	file:
rsi	.\base\elfcore.h	/^    uint64_t  r9,r8,rax,rcx,rdx,rsi,rdi,orig_rax;$/;"	m	struct:i386_regs
rsp	.\base\elfcore.h	/^    uint64_t  rsp,ss;$/;"	m	struct:i386_regs
ru_idrss	.\base\linux_syscall_support.h	/^  long               ru_idrss;$/;"	m	struct:kernel_rusage
ru_inblock	.\base\linux_syscall_support.h	/^  long               ru_inblock;$/;"	m	struct:kernel_rusage
ru_isrss	.\base\linux_syscall_support.h	/^  long               ru_isrss;$/;"	m	struct:kernel_rusage
ru_ixrss	.\base\linux_syscall_support.h	/^  long               ru_ixrss;$/;"	m	struct:kernel_rusage
ru_majflt	.\base\linux_syscall_support.h	/^  long               ru_majflt;$/;"	m	struct:kernel_rusage
ru_maxrss	.\base\linux_syscall_support.h	/^  long               ru_maxrss;$/;"	m	struct:kernel_rusage
ru_minflt	.\base\linux_syscall_support.h	/^  long               ru_minflt;$/;"	m	struct:kernel_rusage
ru_msgrcv	.\base\linux_syscall_support.h	/^  long               ru_msgrcv;$/;"	m	struct:kernel_rusage
ru_msgsnd	.\base\linux_syscall_support.h	/^  long               ru_msgsnd;$/;"	m	struct:kernel_rusage
ru_nivcsw	.\base\linux_syscall_support.h	/^  long               ru_nivcsw;$/;"	m	struct:kernel_rusage
ru_nsignals	.\base\linux_syscall_support.h	/^  long               ru_nsignals;$/;"	m	struct:kernel_rusage
ru_nswap	.\base\linux_syscall_support.h	/^  long               ru_nswap;$/;"	m	struct:kernel_rusage
ru_nvcsw	.\base\linux_syscall_support.h	/^  long               ru_nvcsw;$/;"	m	struct:kernel_rusage
ru_oublock	.\base\linux_syscall_support.h	/^  long               ru_oublock;$/;"	m	struct:kernel_rusage
ru_stime	.\base\linux_syscall_support.h	/^  struct kernel_timeval ru_stime;$/;"	m	struct:kernel_rusage	typeref:struct:kernel_rusage::kernel_timeval
ru_utime	.\base\linux_syscall_support.h	/^  struct kernel_timeval ru_utime;$/;"	m	struct:kernel_rusage	typeref:struct:kernel_rusage::kernel_timeval
run_check	.\tests\heap-checker_unittest.sh	/^run_check() {$/;"	f
run_check_transfer_num_obj	.\tests\tcmalloc_unittest.sh	/^run_check_transfer_num_obj() {$/;"	f
run_hidden_ptr	.\tests\heap-checker_unittest.cc	/^void (*volatile run_hidden_ptr)(Closure* c, int n);$/;"	v
run_unittest	.\tests\tcmalloc_unittest.sh	/^run_unittest() {$/;"	f
s	.\base\basictypes.h	/^  size_t s;$/;"	m	union:MemoryAligner
s_first_opcode_byte	.\windows\ia32_opcode_map.cc	/^const Opcode s_first_opcode_byte[] = {$/;"	m	namespace:sidestep	file:
s_ia16_modrm_map_	.\windows\ia32_modrm_map.cc	/^const ModrmEntry MiniDisassembler::s_ia16_modrm_map_[] = {$/;"	m	class:sidestep::MiniDisassembler	file:
s_ia16_modrm_map_	.\windows\mini_disassembler.h	/^  static const ModrmEntry s_ia16_modrm_map_[];$/;"	m	class:sidestep::MiniDisassembler
s_ia32_modrm_map_	.\windows\ia32_modrm_map.cc	/^const ModrmEntry MiniDisassembler::s_ia32_modrm_map_[] = {$/;"	m	class:sidestep::MiniDisassembler	file:
s_ia32_modrm_map_	.\windows\mini_disassembler.h	/^  static const ModrmEntry s_ia32_modrm_map_[];$/;"	m	class:sidestep::MiniDisassembler
s_ia32_opcode_map_	.\windows\ia32_opcode_map.cc	/^const OpcodeTable MiniDisassembler::s_ia32_opcode_map_[]={$/;"	m	class:sidestep::MiniDisassembler	file:
s_ia32_opcode_map_	.\windows\mini_disassembler.h	/^  static const OpcodeTable s_ia32_opcode_map_[];$/;"	m	class:sidestep::MiniDisassembler
s_opcode_byte_after_0f	.\windows\ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_0f[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_0f00	.\windows\ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_0f00[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_0f01	.\windows\ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_0f01[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_0f18	.\windows\ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_0f18[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_0f71	.\windows\ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_0f71[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_0f72	.\windows\ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_0f72[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_0f73	.\windows\ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_0f73[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_0fae	.\windows\ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_0fae[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_0fba	.\windows\ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_0fba[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_0fc7	.\windows\ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_0fc7[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_80	.\windows\ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_80[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_81	.\windows\ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_81[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_82	.\windows\ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_82[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_83	.\windows\ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_83[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_c0	.\windows\ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_c0[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_c1	.\windows\ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_c1[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_d0	.\windows\ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_d0[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_d1	.\windows\ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_d1[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_d2	.\windows\ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_d2[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_d3	.\windows\ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_d3[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_f6	.\windows\ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_f6[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_f7	.\windows\ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_f7[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_fe	.\windows\ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_fe[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_ff	.\windows\ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_ff[] = {$/;"	m	namespace:sidestep	file:
sa_flags	.\base\linux_syscall_support.h	/^  unsigned long      sa_flags;$/;"	m	struct:kernel_old_sigaction
sa_flags	.\base\linux_syscall_support.h	/^  unsigned long      sa_flags;$/;"	m	struct:kernel_sigaction
sa_handler_	.\base\linux_syscall_support.h	/^    void             (*sa_handler_)(int);$/;"	m	union:kernel_old_sigaction::__anon3
sa_handler_	.\base\linux_syscall_support.h	/^    void             (*sa_handler_)(int);$/;"	m	union:kernel_sigaction::__anon4
sa_mask	.\base\linux_syscall_support.h	/^  struct kernel_sigset_t sa_mask;$/;"	m	struct:kernel_sigaction	typeref:struct:kernel_sigaction::kernel_sigset_t
sa_mask	.\base\linux_syscall_support.h	/^  unsigned long      sa_mask;$/;"	m	struct:kernel_old_sigaction
sa_restorer	.\base\linux_syscall_support.h	/^  void               (*sa_restorer)(void);$/;"	m	struct:kernel_old_sigaction
sa_sigaction_	.\base\linux_syscall_support.h	/^    void             (*sa_sigaction_)(int, siginfo_t *, void *);$/;"	m	union:kernel_old_sigaction::__anon3
sa_sigaction_	.\base\linux_syscall_support.h	/^    void             (*sa_sigaction_)(int, siginfo_t *, void *);$/;"	m	union:kernel_sigaction::__anon4
safe_vsnprintf	.\windows\preamble_patcher_test.cc	/^int safe_vsnprintf(char *str, size_t size, const char *format, va_list ap) {$/;"	f
safeclose	.\base\sysinfo.cc	102;"	d	file:
safeclose	.\base\sysinfo.cc	104;"	d	file:
safeopen	.\base\sysinfo.cc	92;"	d	file:
safeopen	.\base\sysinfo.cc	94;"	d	file:
saferead	.\base\sysinfo.cc	97;"	d	file:
saferead	.\base\sysinfo.cc	99;"	d	file:
sample	.\span.h	/^  unsigned int  sample : 1;     \/\/ Sampled object?$/;"	m	struct:tcmalloc::Span
sample_period	.\tests\sampler_test.cc	/^  static uint64_t sample_period;$/;"	m	class:OldSampler	file:
sample_period	.\tests\sampler_test.cc	/^uint64_t OldSampler::sample_period;$/;"	m	class:OldSampler	file:
sampled_objects	.\static_vars.h	/^  static Span* sampled_objects() { return &sampled_objects_; }$/;"	f	class:tcmalloc::Static
sampled_objects_	.\static_vars.cc	/^Span Static::sampled_objects_;$/;"	m	class:tcmalloc::Static	file:
sampled_objects_	.\static_vars.h	/^  static Span sampled_objects_;$/;"	m	class:tcmalloc::Static
sampler_	.\thread_cache.h	/^  Sampler       sampler_;               \/\/ A sampler$/;"	m	class:tcmalloc::ThreadCache
samples_gathered	.\gperftools\profiler.h	/^  int    samples_gathered;    \/* Number of samples gathered so far (or 0) *\/$/;"	m	struct:ProfilerState
samples_gathered	.\profiledata.h	/^    int      samples_gathered;    \/\/ Number of samples gathered to far (or 0)$/;"	m	struct:ProfileData::State
saved_buckets_	.\memory_region_map.cc	/^HeapProfileBucket MemoryRegionMap::saved_buckets_[20];  \/\/ GUARDED_BY(lock_)$/;"	m	class:MemoryRegionMap	file:
saved_buckets_count_	.\memory_region_map.cc	/^int MemoryRegionMap::saved_buckets_count_ = 0;  \/\/ GUARDED_BY(lock_)$/;"	m	class:MemoryRegionMap	file:
saved_buckets_keys_	.\memory_region_map.cc	/^const void* MemoryRegionMap::saved_buckets_keys_[20][kMaxStackDepth];$/;"	m	class:MemoryRegionMap	file:
saved_regions	.\memory_region_map.cc	/^static MemoryRegionMap::Region saved_regions[20];$/;"	v	file:
saved_regions_count	.\memory_region_map.cc	/^static int saved_regions_count = 0;$/;"	v	file:
sbrk	.\windows\port.h	/^inline void *sbrk(intptr_t increment) {$/;"	f
sbrk_hooks_	.\malloc_hook.cc	/^HookList<MallocHook::SbrkHook> sbrk_hooks_ = INIT_HOOK_LIST;$/;"	m	namespace:base::internal	file:
sbrk_name	.\system-alloc.cc	/^static const char sbrk_name[] = "SbrkSysAllocator";$/;"	v	file:
sbrk_space	.\system-alloc.cc	/^} sbrk_space;$/;"	v	typeref:union:__anon30	file:
scavenge_counter_	.\page_heap.h	/^  int64_t scavenge_counter_;$/;"	m	class:tcmalloc::PageHeap
schar	.\base\basictypes.h	/^typedef signed char         schar;$/;"	t
sched_yield	.\windows\port.h	/^inline void sched_yield(void) {$/;"	f
scoped_array	.\tests\profiledata_unittest.cc	/^  scoped_array(T* data) : data_(data) { }$/;"	f	class:__anon38::scoped_array
scoped_array	.\tests\profiledata_unittest.cc	/^template<typename T> class scoped_array {$/;"	c	namespace:__anon38	file:
scoped_array	.\tests\sampler_test.cc	/^  scoped_array(T* p) : p_(p) { }$/;"	f	class:__anon39::scoped_array
scoped_array	.\tests\sampler_test.cc	/^template<typename T> class scoped_array {$/;"	c	namespace:__anon39	file:
seed_	.\tests\tcmalloc_unittest.cc	/^    int32 seed_;$/;"	m	class:testing::TesterThread::ACMRandom	file:
self_thread_pid	.\heap-checker.cc	/^static pid_t self_thread_pid = 0;$/;"	v	file:
self_thread_stack_top	.\heap-checker.cc	/^static const void* self_thread_stack_top;$/;"	v	file:
set	.\pagemap.h	/^  void set(Number k, void* v) {$/;"	f	class:TCMalloc_PageMap1
set	.\pagemap.h	/^  void set(Number k, void* v) {$/;"	f	class:TCMalloc_PageMap2
set	.\pagemap.h	/^  void set(Number k, void* v) {$/;"	f	class:TCMalloc_PageMap3
set_bucket	.\heap-profile-table.h	/^    void set_bucket(Bucket* b) { bucket_rep = reinterpret_cast<uintptr_t>(b); }$/;"	f	struct:HeapProfileTable::AllocValue
set_call_stack_depth	.\memory_region_map.h	/^    void set_call_stack_depth(int depth) {$/;"	f	struct:MemoryRegionMap::Region
set_data	.\tests\heap-checker_unittest.cc	/^static int set_data[] = { 1, 2, 3, 4, 5, 6, 7, 21, 22, 23, 24, 25, 26, 27 };$/;"	v	file:
set_end_addr	.\memory_region_map.h	/^    void set_end_addr(uintptr_t addr) {$/;"	f	struct:MemoryRegionMap::Region
set_frequency	.\profiledata.h	/^    void set_frequency(int frequency) {$/;"	f	class:ProfileData::Options
set_growth_stacks	.\static_vars.h	/^  static void set_growth_stacks(StackTrace* s) { growth_stacks_ = s; }$/;"	f	class:tcmalloc::Static
set_ignore	.\heap-profile-table.h	/^    void set_ignore(bool r) {$/;"	f	struct:HeapProfileTable::AllocValue
set_is_stack	.\memory_region_map.h	/^    void set_is_stack() { is_stack = true; }$/;"	f	struct:MemoryRegionMap::Region
set_is_valid	.\windows\patch_functions.cc	/^  void set_is_valid(bool b) { is_valid_ = b; }$/;"	f	class:__anon52::LibcInfo
set_length_overages	.\thread_cache.h	/^    void set_length_overages(size_t new_count) {$/;"	f	class:tcmalloc::ThreadCache::FreeList
set_live	.\heap-profile-table.h	/^    void set_live(bool l) {$/;"	f	struct:HeapProfileTable::AllocValue
set_max_length	.\thread_cache.h	/^    void set_max_length(size_t new_max) {$/;"	f	class:tcmalloc::ThreadCache::FreeList
set_offset	.\debugallocation.cc	/^  void set_offset(int offset) { this->offset_ = offset; }$/;"	f	class:MallocBlock
set_overall_thread_cache_size	.\thread_cache.cc	/^void ThreadCache::set_overall_thread_cache_size(size_t new_size) {$/;"	f	class:tcmalloc::ThreadCache
set_start_addr	.\memory_region_map.h	/^    void set_start_addr(uintptr_t addr) {$/;"	f	struct:MemoryRegionMap::Region
set_stop_work	.\tests\profile-handler_unittest.cc	/^  void set_stop_work(bool stop_work) {$/;"	f	class:__anon37::BusyThread
set_thread_disable_counter	.\heap-checker.cc	/^inline void set_thread_disable_counter(int value) {$/;"	f
shift_	.\windows\mini_disassembler_types.h	/^  unsigned char shift_;$/;"	m	struct:sidestep::OpcodeTable
should_decode_modrm_	.\windows\mini_disassembler.h	/^  bool should_decode_modrm_;$/;"	m	class:sidestep::MiniDisassembler
should_report_large	.\tcmalloc.cc	/^inline bool should_report_large(Length num_pages) {$/;"	f	namespace:__anon34
sidestep	.\windows\auto_testing_hook.h	/^namespace sidestep {$/;"	n
sidestep	.\windows\ia32_modrm_map.cc	/^namespace sidestep {$/;"	n	file:
sidestep	.\windows\ia32_opcode_map.cc	/^namespace sidestep {$/;"	n	file:
sidestep	.\windows\mini_disassembler.cc	/^namespace sidestep {$/;"	n	file:
sidestep	.\windows\mini_disassembler.h	/^namespace sidestep {$/;"	n
sidestep	.\windows\mini_disassembler_types.h	/^namespace sidestep {$/;"	n
sidestep	.\windows\preamble_patcher.cc	/^namespace sidestep {$/;"	n	file:
sidestep	.\windows\preamble_patcher.h	/^namespace sidestep {$/;"	n
sidestep	.\windows\preamble_patcher_test.cc	/^namespace sidestep {$/;"	n	file:
sidestep	.\windows\preamble_patcher_with_stub.cc	/^namespace sidestep {$/;"	n	file:
sig	.\base\linux_syscall_support.h	/^  unsigned long sig[(KERNEL_NSIG + 8*sizeof(unsigned long) - 1)\/$/;"	m	struct:kernel_sigset_t
sig_handler	.\heap-checker.cc	/^void sig_handler(int signo){$/;"	f
sig_marker	.\base\linuxthreads.cc	/^static volatile int *sig_pids, sig_num_threads, sig_proc, sig_marker;$/;"	v	file:
sig_num_threads	.\base\linuxthreads.cc	/^static volatile int *sig_pids, sig_num_threads, sig_proc, sig_marker;$/;"	v	file:
sig_pids	.\base\linuxthreads.cc	/^static volatile int *sig_pids, sig_num_threads, sig_proc, sig_marker;$/;"	v	file:
sig_proc	.\base\linuxthreads.cc	/^static volatile int *sig_pids, sig_num_threads, sig_proc, sig_marker;$/;"	v	file:
sig_set_	.\profile-handler.cc	/^  sigset_t sig_set_;$/;"	m	class:ScopedSignalBlocker	file:
sigaction	.\base\linux_syscall_support.h	/^    LSS_INLINE int LSS_NAME(sigaction)(int signum,$/;"	f
sigaddset	.\base\linux_syscall_support.h	/^  LSS_INLINE int LSS_NAME(sigaddset)(struct kernel_sigset_t *set,$/;"	f
sigdelset	.\base\linux_syscall_support.h	/^  LSS_INLINE int LSS_NAME(sigdelset)(struct kernel_sigset_t *set,$/;"	f
sigemptyset	.\base\linux_syscall_support.h	/^  LSS_INLINE int LSS_NAME(sigemptyset)(struct kernel_sigset_t *set) {$/;"	f
sigfillset	.\base\linux_syscall_support.h	/^  LSS_INLINE int LSS_NAME(sigfillset)(struct kernel_sigset_t *set) {$/;"	f
signal_lock_	.\profile-handler.cc	/^  SpinLock signal_lock_;$/;"	m	class:ProfileHandler	file:
signal_number_	.\profile-handler.cc	/^  int signal_number_;$/;"	m	class:ProfileHandler	file:
sigprocmask	.\base\linux_syscall_support.h	/^    LSS_INLINE int LSS_NAME(sigprocmask)(int how,$/;"	f
size	.\base\low_level_alloc.cc	/^      intptr_t size;  \/\/ size of entire region, including this field. Must be$/;"	m	struct:low_level_alloc_internal::AllocList::Header	file:
size	.\common.h	/^  uintptr_t size;          \/\/ Size of object$/;"	m	struct:tcmalloc::StackTrace
size	.\debugallocation.cc	/^  size_t size() const {$/;"	f	class:FreeQueue
size	.\debugallocation.cc	/^  size_t size;$/;"	m	struct:MallocBlockQueueEntry	file:
size	.\debugallocation.cc	/^  size_t size;$/;"	m	struct:debug_alloc_retry_data	file:
size	.\debugallocation.cc	/^  size_t size;$/;"	m	struct:memalign_retry_data	file:
size	.\heap-checker.cc	/^  uintptr_t size;         \/\/ its size$/;"	m	struct:AllocObject	file:
size	.\tcmalloc.cc	/^  size_t size;$/;"	m	struct:__anon34::retry_memaligh_data	file:
size	.\tests\addressmap_unittest.cc	/^  size_t size;$/;"	m	struct:PtrAndSize	file:
size	.\tests\heap-checker_unittest.cc	/^  size_t size;$/;"	m	struct:Array	file:
size	.\tests\tcmalloc_unittest.cc	/^    int         size;                   \/\/ Allocated size$/;"	m	struct:testing::TesterThread::Object	file:
size1_	.\debugallocation.cc	/^  size_t size1_;$/;"	m	class:MallocBlock	file:
size2_	.\debugallocation.cc	/^  size_t size2_;$/;"	m	class:MallocBlock	file:
size2_addr	.\debugallocation.cc	/^  const size_t* size2_addr() const {$/;"	f	class:MallocBlock	file:
size2_addr	.\debugallocation.cc	/^  size_t* size2_addr() { return (size_t*)((char*)&size2_ + size1_); }$/;"	f	class:MallocBlock	file:
size_	.\thread_cache.h	/^  size_t        size_;                  \/\/ Combined size of data$/;"	m	class:tcmalloc::ThreadCache
size_class_	.\central_freelist.h	/^  size_t   size_class_;     \/\/ My size class$/;"	m	class:tcmalloc::CentralFreeList
size_type	.\base\stl_allocator.h	/^  typedef size_t     size_type;$/;"	t	class:STL_Allocator
sizeclass	.\span.h	/^  unsigned int  sizeclass : 8;  \/\/ Size-class for small objects (or 0)$/;"	m	struct:tcmalloc::Span
sized_delete_enabled	.\libc_override_gcc_and_weak.h	/^static bool sized_delete_enabled(void) {$/;"	f
sizemap	.\static_vars.h	/^  static SizeMap* sizemap() { return &sizemap_; }$/;"	f	class:tcmalloc::Static
sizemap_	.\static_vars.cc	/^SizeMap Static::sizemap_;$/;"	m	class:tcmalloc::Static	file:
sizemap_	.\static_vars.h	/^  static SizeMap sizemap_;$/;"	m	class:tcmalloc::Static
sizeof	.\base\atomicops-internals-windows.h	/^COMPILE_ASSERT(sizeof(Atomic64) == sizeof(PVOID), atomic_word_is_atomic);$/;"	m	namespace:base::subtle
skip	.\stacktrace_libgcc-inl.h	/^  int skip;$/;"	m	struct:libgcc_backtrace_data
sleep	.\windows\port.h	/^inline unsigned int sleep(unsigned int seconds) {$/;"	f
small	.\tcmalloc.cc	150;"	d	file:
snapshot_	.\base\sysinfo.h	/^  HANDLE snapshot_;   \/\/ filehandle on dll info$/;"	m	class:ProcMapsIterator
snprintf	.\windows\port.h	/^inline int snprintf(char *str, size_t size, const char *format, ...) {$/;"	f
snum	.\internal_logging.h	/^    int64_t snum;$/;"	m	union:tcmalloc::LogItem::__anon21
socket	.\base\linux_syscall_support.h	/^    LSS_INLINE int LSS_NAME(socket)(int domain, int type, int protocol) {$/;"	f
some_ints	.\tests\heap-checker_unittest.cc	/^static int some_ints[] = { 1, 2, 3, 21, 22, 23, 24, 25 };$/;"	v	file:
space_left	.\raw_printer.h	/^  int space_left() const { return (limit_ - ptr_); }$/;"	f	class:base::RawPrinter
span_allocator	.\static_vars.h	/^  static PageHeapAllocator<Span>* span_allocator() { return &span_allocator_; }$/;"	f	class:tcmalloc::Static
span_allocator_	.\static_vars.cc	/^PageHeapAllocator<Span> Static::span_allocator_;$/;"	m	class:tcmalloc::Static	file:
span_allocator_	.\static_vars.h	/^  static PageHeapAllocator<Span> span_allocator_;$/;"	m	class:tcmalloc::Static
spans	.\page_heap.h	/^    int64 spans;           \/\/ Number of such spans$/;"	m	struct:tcmalloc::PageHeap::LargeSpanStats
srandom	.\windows\port.h	/^inline void srandom(unsigned int seed) { srand(seed); }$/;"	f
ss	.\base\elfcore.h	/^    uint64_t  rsp,ss;$/;"	m	struct:i386_regs
ssize_t	.\windows\port.h	/^typedef intptr_t ssize_t;$/;"	t
st_atim	.\base\linux_syscall_support.h	/^  kernel_timespec    st_atim;$/;"	m	struct:kernel_stat
st_atim	.\base\linux_syscall_support.h	/^  kernel_timespec    st_atim;$/;"	m	struct:kernel_stat64
st_atime_	.\base\linux_syscall_support.h	/^  long               st_atime_;$/;"	m	struct:kernel_stat
st_atime_	.\base\linux_syscall_support.h	/^  uint64_t           st_atime_;$/;"	m	struct:kernel_stat
st_atime_	.\base\linux_syscall_support.h	/^  unsigned           st_atime_;$/;"	m	struct:kernel_stat
st_atime_	.\base\linux_syscall_support.h	/^  unsigned           st_atime_;$/;"	m	struct:kernel_stat64
st_atime_	.\base\linux_syscall_support.h	/^  unsigned long      st_atime_;$/;"	m	struct:kernel_stat
st_atime_nsec_	.\base\linux_syscall_support.h	/^  long               st_atime_nsec_;$/;"	m	struct:kernel_stat
st_atime_nsec_	.\base\linux_syscall_support.h	/^  uint64_t           st_atime_nsec_;$/;"	m	struct:kernel_stat
st_atime_nsec_	.\base\linux_syscall_support.h	/^  unsigned           st_atime_nsec_;$/;"	m	struct:kernel_stat
st_atime_nsec_	.\base\linux_syscall_support.h	/^  unsigned           st_atime_nsec_;$/;"	m	struct:kernel_stat64
st_atime_nsec_	.\base\linux_syscall_support.h	/^  unsigned long      st_atime_nsec_;$/;"	m	struct:kernel_stat
st_blksize	.\base\linux_syscall_support.h	/^  int                st_blksize;$/;"	m	struct:kernel_stat
st_blksize	.\base\linux_syscall_support.h	/^  int64_t            st_blksize;$/;"	m	struct:kernel_stat
st_blksize	.\base\linux_syscall_support.h	/^  long long          st_blksize;$/;"	m	struct:kernel_stat64
st_blksize	.\base\linux_syscall_support.h	/^  unsigned           st_blksize;$/;"	m	struct:kernel_stat
st_blksize	.\base\linux_syscall_support.h	/^  unsigned           st_blksize;$/;"	m	struct:kernel_stat64
st_blksize	.\base\linux_syscall_support.h	/^  unsigned long      st_blksize;$/;"	m	struct:kernel_stat
st_blocks	.\base\linux_syscall_support.h	/^  int                st_blocks;$/;"	m	struct:kernel_stat
st_blocks	.\base\linux_syscall_support.h	/^  int64_t            st_blocks;$/;"	m	struct:kernel_stat
st_blocks	.\base\linux_syscall_support.h	/^  long               st_blocks;$/;"	m	struct:kernel_stat
st_blocks	.\base\linux_syscall_support.h	/^  long long          st_blocks;$/;"	m	struct:kernel_stat64
st_blocks	.\base\linux_syscall_support.h	/^  unsigned           st_blocks;$/;"	m	struct:kernel_stat
st_blocks	.\base\linux_syscall_support.h	/^  unsigned long      st_blocks;$/;"	m	struct:kernel_stat
st_blocks	.\base\linux_syscall_support.h	/^  unsigned long long st_blocks;$/;"	m	struct:kernel_stat
st_blocks	.\base\linux_syscall_support.h	/^  unsigned long long st_blocks;$/;"	m	struct:kernel_stat64
st_ctim	.\base\linux_syscall_support.h	/^  kernel_timespec    st_ctim;$/;"	m	struct:kernel_stat
st_ctim	.\base\linux_syscall_support.h	/^  kernel_timespec    st_ctim;$/;"	m	struct:kernel_stat64
st_ctime_	.\base\linux_syscall_support.h	/^  long               st_ctime_;$/;"	m	struct:kernel_stat
st_ctime_	.\base\linux_syscall_support.h	/^  uint64_t           st_ctime_;$/;"	m	struct:kernel_stat
st_ctime_	.\base\linux_syscall_support.h	/^  unsigned           st_ctime_;$/;"	m	struct:kernel_stat
st_ctime_	.\base\linux_syscall_support.h	/^  unsigned           st_ctime_;$/;"	m	struct:kernel_stat64
st_ctime_	.\base\linux_syscall_support.h	/^  unsigned long      st_ctime_;$/;"	m	struct:kernel_stat
st_ctime_nsec_	.\base\linux_syscall_support.h	/^  long               st_ctime_nsec_;$/;"	m	struct:kernel_stat
st_ctime_nsec_	.\base\linux_syscall_support.h	/^  uint64_t           st_ctime_nsec_;$/;"	m	struct:kernel_stat
st_ctime_nsec_	.\base\linux_syscall_support.h	/^  unsigned           st_ctime_nsec_;$/;"	m	struct:kernel_stat
st_ctime_nsec_	.\base\linux_syscall_support.h	/^  unsigned           st_ctime_nsec_;$/;"	m	struct:kernel_stat64
st_ctime_nsec_	.\base\linux_syscall_support.h	/^  unsigned long      st_ctime_nsec_;$/;"	m	struct:kernel_stat
st_dev	.\base\linux_syscall_support.h	/^  uint64_t           st_dev;$/;"	m	struct:kernel_stat
st_dev	.\base\linux_syscall_support.h	/^  unsigned           st_dev;$/;"	m	struct:kernel_stat
st_dev	.\base\linux_syscall_support.h	/^  unsigned long      st_dev;$/;"	m	struct:kernel_stat
st_dev	.\base\linux_syscall_support.h	/^  unsigned long long st_dev;$/;"	m	struct:kernel_stat
st_dev	.\base\linux_syscall_support.h	/^  unsigned long long st_dev;$/;"	m	struct:kernel_stat64
st_dev	.\base\linux_syscall_support.h	/^  unsigned short     st_dev;$/;"	m	struct:kernel_stat
st_gid	.\base\linux_syscall_support.h	/^  unsigned           st_gid;$/;"	m	struct:kernel_stat
st_gid	.\base\linux_syscall_support.h	/^  unsigned           st_gid;$/;"	m	struct:kernel_stat64
st_gid	.\base\linux_syscall_support.h	/^  unsigned int       st_gid;$/;"	m	struct:kernel_stat
st_gid	.\base\linux_syscall_support.h	/^  unsigned short     st_gid;$/;"	m	struct:kernel_stat
st_ino	.\base\linux_syscall_support.h	/^  uint64_t           st_ino;$/;"	m	struct:kernel_stat
st_ino	.\base\linux_syscall_support.h	/^  unsigned           st_ino;$/;"	m	struct:kernel_stat
st_ino	.\base\linux_syscall_support.h	/^  unsigned long      st_ino;$/;"	m	struct:kernel_stat
st_ino	.\base\linux_syscall_support.h	/^  unsigned long long st_ino;$/;"	m	struct:kernel_stat
st_ino	.\base\linux_syscall_support.h	/^  unsigned long long st_ino;$/;"	m	struct:kernel_stat64
st_mode	.\base\linux_syscall_support.h	/^  unsigned           st_mode;$/;"	m	struct:kernel_stat
st_mode	.\base\linux_syscall_support.h	/^  unsigned           st_mode;$/;"	m	struct:kernel_stat64
st_mode	.\base\linux_syscall_support.h	/^  unsigned int       st_mode;$/;"	m	struct:kernel_stat
st_mode	.\base\linux_syscall_support.h	/^  unsigned long      st_mode;$/;"	m	struct:kernel_stat
st_mode	.\base\linux_syscall_support.h	/^  unsigned short     st_mode;$/;"	m	struct:kernel_stat
st_mtim	.\base\linux_syscall_support.h	/^  kernel_timespec    st_mtim;$/;"	m	struct:kernel_stat
st_mtim	.\base\linux_syscall_support.h	/^  kernel_timespec    st_mtim;$/;"	m	struct:kernel_stat64
st_mtime_	.\base\linux_syscall_support.h	/^  long               st_mtime_;$/;"	m	struct:kernel_stat
st_mtime_	.\base\linux_syscall_support.h	/^  uint64_t           st_mtime_;$/;"	m	struct:kernel_stat
st_mtime_	.\base\linux_syscall_support.h	/^  unsigned           st_mtime_;$/;"	m	struct:kernel_stat
st_mtime_	.\base\linux_syscall_support.h	/^  unsigned           st_mtime_;$/;"	m	struct:kernel_stat64
st_mtime_	.\base\linux_syscall_support.h	/^  unsigned long      st_mtime_;$/;"	m	struct:kernel_stat
st_mtime_nsec_	.\base\linux_syscall_support.h	/^  long               st_mtime_nsec_;$/;"	m	struct:kernel_stat
st_mtime_nsec_	.\base\linux_syscall_support.h	/^  uint64_t           st_mtime_nsec_;$/;"	m	struct:kernel_stat
st_mtime_nsec_	.\base\linux_syscall_support.h	/^  unsigned           st_mtime_nsec_;$/;"	m	struct:kernel_stat
st_mtime_nsec_	.\base\linux_syscall_support.h	/^  unsigned           st_mtime_nsec_;$/;"	m	struct:kernel_stat64
st_mtime_nsec_	.\base\linux_syscall_support.h	/^  unsigned long      st_mtime_nsec_;$/;"	m	struct:kernel_stat
st_nlink	.\base\linux_syscall_support.h	/^  uint64_t           st_nlink;$/;"	m	struct:kernel_stat
st_nlink	.\base\linux_syscall_support.h	/^  unsigned           st_nlink;$/;"	m	struct:kernel_stat
st_nlink	.\base\linux_syscall_support.h	/^  unsigned           st_nlink;$/;"	m	struct:kernel_stat64
st_nlink	.\base\linux_syscall_support.h	/^  unsigned int       st_nlink;$/;"	m	struct:kernel_stat
st_nlink	.\base\linux_syscall_support.h	/^  unsigned long      st_nlink;$/;"	m	struct:kernel_stat
st_nlink	.\base\linux_syscall_support.h	/^  unsigned short     st_nlink;$/;"	m	struct:kernel_stat
st_pad1	.\base\linux_syscall_support.h	/^  int                st_pad1[3];$/;"	m	struct:kernel_stat
st_pad2	.\base\linux_syscall_support.h	/^  int                st_pad2[2];$/;"	m	struct:kernel_stat
st_pad3	.\base\linux_syscall_support.h	/^  int                st_pad3;$/;"	m	struct:kernel_stat
st_pad4	.\base\linux_syscall_support.h	/^  int                st_pad4[14];$/;"	m	struct:kernel_stat
st_rdev	.\base\linux_syscall_support.h	/^  uint64_t           st_rdev;$/;"	m	struct:kernel_stat
st_rdev	.\base\linux_syscall_support.h	/^  unsigned           st_rdev;$/;"	m	struct:kernel_stat
st_rdev	.\base\linux_syscall_support.h	/^  unsigned long      st_rdev;$/;"	m	struct:kernel_stat
st_rdev	.\base\linux_syscall_support.h	/^  unsigned long long st_rdev;$/;"	m	struct:kernel_stat
st_rdev	.\base\linux_syscall_support.h	/^  unsigned long long st_rdev;$/;"	m	struct:kernel_stat64
st_rdev	.\base\linux_syscall_support.h	/^  unsigned short     st_rdev;$/;"	m	struct:kernel_stat
st_size	.\base\linux_syscall_support.h	/^  int64_t            st_size;$/;"	m	struct:kernel_stat
st_size	.\base\linux_syscall_support.h	/^  long               st_size;$/;"	m	struct:kernel_stat
st_size	.\base\linux_syscall_support.h	/^  long long          st_size;$/;"	m	struct:kernel_stat
st_size	.\base\linux_syscall_support.h	/^  long long          st_size;$/;"	m	struct:kernel_stat64
st_size	.\base\linux_syscall_support.h	/^  unsigned           st_size;$/;"	m	struct:kernel_stat
st_size	.\base\linux_syscall_support.h	/^  unsigned long      st_size;$/;"	m	struct:kernel_stat
st_uid	.\base\linux_syscall_support.h	/^  unsigned           st_uid;$/;"	m	struct:kernel_stat
st_uid	.\base\linux_syscall_support.h	/^  unsigned           st_uid;$/;"	m	struct:kernel_stat64
st_uid	.\base\linux_syscall_support.h	/^  unsigned int       st_uid;$/;"	m	struct:kernel_stat
st_uid	.\base\linux_syscall_support.h	/^  unsigned short     st_uid;$/;"	m	struct:kernel_stat
stack	.\common.h	/^  void*     stack[kMaxStackDepth];$/;"	m	struct:tcmalloc::StackTrace
stack	.\heap-profile-stats.h	/^  const void** stack;       \/\/ Stack trace.$/;"	m	struct:HeapProfileBucket
stack	.\profiledata.h	/^    Slot stack[kMaxStackDepth];  \/\/ Stack contents$/;"	m	struct:ProfileData::Entry
stack_depth	.\heap-profile-table.h	/^    int stack_depth;                \/\/ Depth of stack trace$/;"	m	struct:HeapProfileTable::AllocContextInfo
stack_depth	.\heap-profile-table.h	/^    int stack_depth;  \/\/ depth of call_stack$/;"	m	struct:HeapProfileTable::AllocInfo
stack_depth	.\stacktrace_instrument-inl.h	/^  int   stack_depth;$/;"	m	struct:__anon28
stack_direction	.\heap-checker.cc	/^static StackDirection stack_direction = UNKNOWN_DIRECTION;$/;"	v	file:
stack_tops	.\heap-checker.cc	/^static StackTopSet* stack_tops = NULL;$/;"	v	file:
stacktrace_allocator	.\static_vars.h	/^  static PageHeapAllocator<StackTrace>* stacktrace_allocator() {$/;"	f	class:tcmalloc::Static
stacktrace_allocator_	.\static_vars.cc	/^PageHeapAllocator<StackTrace> Static::stacktrace_allocator_;$/;"	m	class:tcmalloc::Static	file:
stacktrace_allocator_	.\static_vars.h	/^  static PageHeapAllocator<StackTrace> stacktrace_allocator_;$/;"	m	class:tcmalloc::Static
stacktrace_allowed	.\stacktrace.cc	/^    bool stacktrace_allowed;$/;"	m	class:__anon27::StacktraceScope	file:
stacktrace_h	.\tests\simple_compat_test.cc	/^int (*stacktrace_h)(void**, int, int) = &GetStackTrace;$/;"	v
start	.\span.h	/^  PageID        start;          \/\/ Starting page number$/;"	m	struct:tcmalloc::Span
start	.\tests\stacktrace_unittest.cc	/^  const void *start, *end;$/;"	m	struct:__anon40::AddressRange	file:
start_addr	.\memory_region_map.h	/^    uintptr_t start_addr;  \/\/ region start address$/;"	m	struct:MemoryRegionMap::Region
start_address	.\heap-checker.cc	/^  uintptr_t start_address;  \/\/ the start of the range$/;"	m	struct:HeapLeakChecker::RangeValue	file:
start_snapshot_	.\gperftools\heap-checker.h	/^  void* start_snapshot_;$/;"	m	class:HeapLeakChecker
start_time	.\gperftools\profiler.h	/^  time_t start_time;          \/* If enabled, when was profiling started? *\/$/;"	m	struct:ProfilerState
start_time	.\profiledata.h	/^    time_t   start_time;          \/\/ If enabled, when was profiling started?$/;"	m	struct:ProfileData::State
start_time_	.\profiledata.h	/^  time_t        start_time_;    \/\/ Start time, or 0$/;"	m	class:ProfileData
stat	.\base\linux_syscall_support.h	/^    LSS_INLINE int LSS_NAME(stat)(const char* p, struct kernel_stat* b) {$/;"	f
static_fn	.\windows\patch_functions.cc	/^  static GenericFnPtr static_fn(int ifunction) {$/;"	f	class:__anon52::LibcInfo
static_fn_	.\windows\patch_functions.cc	/^  static const GenericFnPtr static_fn_[kNumFunctions];$/;"	m	class:__anon52::LibcInfo	file:
static_fn_	.\windows\patch_functions.cc	/^const GenericFnPtr LibcInfo::static_fn_[] = {$/;"	m	class:__anon52::LibcInfo	file:
stats	.\page_heap.h	/^  inline Stats stats() const { return stats_; }$/;"	f	class:tcmalloc::PageHeap
stats_	.\page_heap.h	/^  Stats stats_;$/;"	m	class:tcmalloc::PageHeap
stats_blocks_	.\debugallocation.cc	/^  static int stats_blocks_;$/;"	m	class:MallocBlock	file:
stats_blocks_	.\debugallocation.cc	/^int MallocBlock::stats_blocks_;$/;"	m	class:MallocBlock	file:
stats_buffer	.\internal_logging.cc	/^static char stats_buffer[kStatsBufferSize] = { 0 };$/;"	v	file:
stats_histogram_	.\debugallocation.cc	/^  static int* stats_histogram_;$/;"	m	class:MallocBlock	file:
stats_histogram_	.\debugallocation.cc	/^int* MallocBlock::stats_histogram_;$/;"	m	class:MallocBlock	file:
stats_total_	.\debugallocation.cc	/^  static size_t stats_total_;$/;"	m	class:MallocBlock	file:
stats_total_	.\debugallocation.cc	/^size_t MallocBlock::stats_total_;$/;"	m	class:MallocBlock	file:
std	.\windows\gperftools\tcmalloc.h	/^namespace std {$/;"	n
stext_	.\base\sysinfo.h	/^  char *stext_;       \/\/ start of text$/;"	m	class:ProcMapsIterator
stop_work	.\tests\profile-handler_unittest.cc	/^  bool stop_work() {$/;"	f	class:__anon37::BusyThread
stop_work_	.\tests\profile-handler_unittest.cc	/^  bool stop_work_;$/;"	m	class:__anon37::BusyThread	file:
str	.\internal_logging.h	/^    const char* str;$/;"	m	union:tcmalloc::LogItem::__anon21
strsize_	.\base\elf_mem_image.h	/^  size_t strsize_;$/;"	m	class:base::ElfMemImage
strtoll	.\windows\port.h	/^inline long long int strtoll(const char *nptr, char **endptr, int base) {$/;"	f
strtoq	.\windows\port.h	/^inline long long int strtoq(const char *nptr, char **endptr, int base) {$/;"	f
strtoull	.\windows\port.h	/^inline unsigned long long int strtoull(const char *nptr, char **endptr,$/;"	f
strtouq	.\windows\port.h	/^inline unsigned long long int strtouq(const char *nptr, char **endptr,$/;"	f
subtle	.\base\atomicops-internals-arm-generic.h	/^namespace subtle {$/;"	n	namespace:base
subtle	.\base\atomicops-internals-arm-v6plus.h	/^namespace subtle {$/;"	n	namespace:base
subtle	.\base\atomicops-internals-gcc.h	/^namespace subtle {$/;"	n	namespace:base
subtle	.\base\atomicops-internals-linuxppc.h	/^namespace subtle {$/;"	n	namespace:base
subtle	.\base\atomicops-internals-macosx.h	/^namespace subtle {$/;"	n	namespace:base
subtle	.\base\atomicops-internals-mips.h	/^namespace subtle {$/;"	n	namespace:base
subtle	.\base\atomicops-internals-windows.h	/^namespace subtle {$/;"	n	namespace:base
subtle	.\base\atomicops-internals-x86.h	/^namespace subtle {$/;"	n	namespace:base
subtle	.\base\atomicops.h	/^namespace subtle {$/;"	n	namespace:base
sym_cmp	.\windows\nm-pdb.c	/^static int sym_cmp(const void *_s1, const void *_s2) {$/;"	f	file:
symbol	.\base\elf_mem_image.h	/^    const ElfW(Sym) *symbol;    \/\/ Symbol in the dynamic symbol table.$/;"	m	struct:base::ElfMemImage::SymbolInfo
symbol_buffer_	.\symbolize.h	/^  char *symbol_buffer_;$/;"	m	class:SymbolTable
symbolization_table_	.\symbolize.h	/^  SymbolMap symbolization_table_;$/;"	m	class:SymbolTable
syms	.\windows\nm-pdb.c	/^  SYM *syms;$/;"	m	struct:__anon51	file:
syms_cap	.\windows\nm-pdb.c	/^  DWORD syms_cap;$/;"	m	struct:__anon51	file:
syms_len	.\windows\nm-pdb.c	/^  DWORD syms_len;$/;"	m	struct:__anon51	file:
sync_signals	.\base\linuxthreads.cc	/^static const int sync_signals[]  = { SIGABRT, SIGILL, SIGFPE, SIGSEGV, SIGBUS,$/;"	v	file:
sys0_sigprocmask	.\base\linuxthreads.cc	609;"	d	file:
sys0_waitpid	.\base\linuxthreads.cc	610;"	d	file:
sys_alloc	.\system-alloc.cc	/^SysAllocator* sys_alloc = NULL;$/;"	v
sys_alloc	.\windows\system-alloc.cc	/^SysAllocator* sys_alloc = NULL;$/;"	v
sys_ptrace	.\heap-checker.cc	1067;"	d	file:
system_alloc_inited	.\system-alloc.cc	/^static bool system_alloc_inited = false;$/;"	v	file:
system_alloc_inited	.\windows\system-alloc.cc	/^static bool system_alloc_inited = false;$/;"	v	file:
system_bytes	.\page_heap.h	/^    uint64_t system_bytes;    \/\/ Total bytes allocated from system$/;"	m	struct:tcmalloc::PageHeap::Stats
table_	.\stack_trace_table.h	/^  Bucket** table_;$/;"	m	class:tcmalloc::StackTraceTable
table_	.\windows\mini_disassembler_types.h	/^  const Opcode* table_;$/;"	m	struct:sidestep::OpcodeTable
table_index_	.\windows\mini_disassembler_types.h	/^  int table_index_;$/;"	m	struct:sidestep::Opcode
table_index_	.\windows\mini_disassembler_types.h	/^  int table_index_;$/;"	m	struct:sidestep::SpecificOpcode
table_offset	.\base\elf_mem_image.cc	/^                         ElfW(Off) table_offset,$/;"	m	namespace:base::__anon1	file:
tag_	.\internal_logging.h	/^  Tag tag_;$/;"	m	class:tcmalloc::LogItem
tail	.\central_freelist.h	/^    void *tail;  \/\/ Tail of chain of objects.$/;"	m	struct:tcmalloc::CentralFreeList::TCEntry
target_function_	.\windows\auto_testing_hook.h	/^  T target_function_;  \/\/ always valid$/;"	m	class:sidestep::AutoTestingHookImpl
tc_calloc	.\libc_override_glibc.h	/^  void* __libc_calloc(size_t n, size_t size)      ALIAS(tc_calloc);$/;"	v
tc_cfree	.\libc_override_glibc.h	/^  void __libc_cfree(void* ptr)                    ALIAS(tc_cfree);$/;"	v
tc_delete	.\libc_override_gcc_and_weak.h	/^    ALIAS(tc_delete);$/;"	v
tc_delete	.\libc_override_gcc_and_weak.h	/^  ALIAS(tc_delete);$/;"	v
tc_delete_nothrow	.\libc_override_gcc_and_weak.h	/^    ALIAS(tc_delete_nothrow);$/;"	v
tc_delete_sized	.\debugallocation.cc	/^extern "C" PERFTOOLS_DLL_DECL void tc_delete_sized(void* p, size_t size) throw() {$/;"	f
tc_delete_sized	.\libc_override_gcc_and_weak.h	/^    ALIAS(tc_delete_sized);$/;"	v
tc_delete_sized	.\tcmalloc.cc	/^extern "C" PERFTOOLS_DLL_DECL void tc_delete_sized(void *p, size_t size) throw() {$/;"	f
tc_deletearray	.\libc_override_gcc_and_weak.h	/^    ALIAS(tc_deletearray);$/;"	v
tc_deletearray	.\libc_override_gcc_and_weak.h	/^  ALIAS(tc_deletearray);$/;"	v
tc_deletearray_nothrow	.\libc_override_gcc_and_weak.h	/^    ALIAS(tc_deletearray_nothrow);$/;"	v
tc_deletearray_sized	.\debugallocation.cc	/^extern "C" PERFTOOLS_DLL_DECL void tc_deletearray_sized(void* p, size_t size) throw() {$/;"	f
tc_deletearray_sized	.\libc_override_gcc_and_weak.h	/^    ALIAS(tc_deletearray_sized);$/;"	v
tc_deletearray_sized	.\tcmalloc.cc	/^extern "C" PERFTOOLS_DLL_DECL void tc_deletearray_sized(void *p, size_t size) throw() {$/;"	f
tc_free	.\libc_override_glibc.h	/^  void __libc_free(void* ptr)                     ALIAS(tc_free);$/;"	v
tc_free_sized	.\tcmalloc.cc	/^  TC_ALIAS(tc_free_sized);$/;"	v
tc_get_sysalloc_default	.\windows\system-alloc.cc	/^extern "C" SysAllocator* tc_get_sysalloc_default(SysAllocator *def)$/;"	f
tc_get_sysalloc_override	.\system-alloc.cc	/^SysAllocator *tc_get_sysalloc_override(SysAllocator *def)$/;"	f
tc_get_sysalloc_override	.\windows\system-alloc.cc	/^SysAllocator* tc_get_sysalloc_override(SysAllocator *def)$/;"	f
tc_length	.\central_freelist.cc	/^int CentralFreeList::tc_length() {$/;"	f	class:tcmalloc::CentralFreeList
tc_malloc	.\libc_override_glibc.h	/^  void* __libc_malloc(size_t size)                ALIAS(tc_malloc);$/;"	v
tc_memalign	.\libc_override_glibc.h	/^  void* __libc_memalign(size_t align, size_t s)   ALIAS(tc_memalign);$/;"	v
tc_new	.\debugallocation.cc	/^extern "C" PERFTOOLS_DLL_DECL void* tc_new(size_t size) {$/;"	f
tc_new	.\libc_override_gcc_and_weak.h	/^    ALIAS(tc_new);$/;"	v
tc_new	.\tcmalloc.cc	/^TC_ALIAS(tc_new);$/;"	v
tc_new	.\tcmalloc.cc	/^extern "C" PERFTOOLS_DLL_DECL void* tc_new(size_t size) {$/;"	f
tc_new_mode	.\tcmalloc.cc	/^static int tc_new_mode = 0;  \/\/ See tc_set_new_mode().$/;"	v	file:
tc_new_nothrow	.\libc_override_gcc_and_weak.h	/^    ALIAS(tc_new_nothrow);$/;"	v
tc_newarray	.\debugallocation.cc	/^extern "C" PERFTOOLS_DLL_DECL void* tc_newarray(size_t size) {$/;"	f
tc_newarray	.\libc_override_gcc_and_weak.h	/^    ALIAS(tc_newarray);$/;"	v
tc_newarray_nothrow	.\libc_override_gcc_and_weak.h	/^    ALIAS(tc_newarray_nothrow);$/;"	v
tc_posix_memalign	.\libc_override_glibc.h	/^  int __posix_memalign(void** r, size_t a, size_t s)  ALIAS(tc_posix_memalign);$/;"	v
tc_pvalloc	.\libc_override_glibc.h	/^  void* __libc_pvalloc(size_t size)               ALIAS(tc_pvalloc);$/;"	v
tc_realloc	.\libc_override_glibc.h	/^  void* __libc_realloc(void* ptr, size_t size)    ALIAS(tc_realloc);$/;"	v
tc_slots_	.\central_freelist.h	/^  TCEntry tc_slots_[kMaxNumTransferEntries];$/;"	m	class:tcmalloc::CentralFreeList
tc_valloc	.\libc_override_glibc.h	/^  void* __libc_valloc(size_t size)                ALIAS(tc_valloc);$/;"	v
tcmalloc	.\base\commandlineflags.h	/^namespace tcmalloc {$/;"	n
tcmalloc	.\base\sysinfo.cc	/^namespace tcmalloc {$/;"	n	file:
tcmalloc	.\base\sysinfo.h	/^namespace tcmalloc {$/;"	n
tcmalloc	.\central_freelist.cc	/^namespace tcmalloc {$/;"	n	file:
tcmalloc	.\central_freelist.h	/^namespace tcmalloc {$/;"	n
tcmalloc	.\common.cc	/^namespace tcmalloc {$/;"	n	file:
tcmalloc	.\common.h	/^namespace tcmalloc {$/;"	n
tcmalloc	.\emergency_malloc.cc	/^namespace tcmalloc {$/;"	n	file:
tcmalloc	.\emergency_malloc.h	/^namespace tcmalloc {$/;"	n
tcmalloc	.\emergency_malloc_for_stacktrace.cc	/^namespace tcmalloc {$/;"	n	file:
tcmalloc	.\fake_stacktrace_scope.cc	/^namespace tcmalloc {$/;"	n	file:
tcmalloc	.\internal_logging.cc	/^namespace tcmalloc {$/;"	n	file:
tcmalloc	.\internal_logging.h	/^namespace tcmalloc {$/;"	n
tcmalloc	.\libc_override_osx.h	/^namespace tcmalloc {$/;"	n
tcmalloc	.\linked_list.h	/^namespace tcmalloc {$/;"	n
tcmalloc	.\maybe_emergency_malloc.h	/^namespace tcmalloc {$/;"	n
tcmalloc	.\page_heap.cc	/^namespace tcmalloc {$/;"	n	file:
tcmalloc	.\page_heap.h	/^namespace tcmalloc {$/;"	n
tcmalloc	.\page_heap_allocator.h	/^namespace tcmalloc {$/;"	n
tcmalloc	.\sampler.cc	/^namespace tcmalloc {$/;"	n	file:
tcmalloc	.\sampler.h	/^namespace tcmalloc {$/;"	n
tcmalloc	.\span.cc	/^namespace tcmalloc {$/;"	n	file:
tcmalloc	.\span.h	/^namespace tcmalloc {$/;"	n
tcmalloc	.\stack_trace_table.cc	/^namespace tcmalloc {$/;"	n	file:
tcmalloc	.\stack_trace_table.h	/^namespace tcmalloc {$/;"	n
tcmalloc	.\stacktrace.cc	/^namespace tcmalloc {$/;"	n	file:
tcmalloc	.\static_vars.cc	/^namespace tcmalloc {$/;"	n	file:
tcmalloc	.\static_vars.h	/^namespace tcmalloc {$/;"	n
tcmalloc	.\thread_cache.cc	/^namespace tcmalloc {$/;"	n	file:
tcmalloc	.\thread_cache.h	/^namespace tcmalloc {$/;"	n
tcmalloc_h	.\tests\simple_compat_test.cc	/^void* (*tcmalloc_h)(size_t) = &tc_new;$/;"	v
tcmalloc_heap_limit_mb	.\tests\page_heap_test.cc	/^DECLARE_int64(tcmalloc_heap_limit_mb);$/;"	v
tcmalloc_initializer	.\heap-profiler.cc	/^static const TCMallocGuard tcmalloc_initializer;$/;"	v	file:
tcmalloc_sample_parameter	.\tests\sampler_test.cc	/^DECLARE_int64(tcmalloc_sample_parameter);$/;"	v
tcmalloc_sample_parameter	.\tests\tcmalloc_unittest.cc	/^DECLARE_int64(tcmalloc_sample_parameter);$/;"	v
tcmalloc_sample_parameter	.\thread_cache.h	/^DECLARE_int64(tcmalloc_sample_parameter);$/;"	v
tcmallocguard_refcount	.\tcmalloc.cc	/^static int tcmallocguard_refcount = 0;  \/\/ no lock needed: runs before main()$/;"	v	file:
temp_	.\central_freelist.cc	/^  SpinLock *held_, *temp_;$/;"	m	class:tcmalloc::__anon16::LockInverter	file:
test_arithmetic	.\tests\sampler_test.cc	/^void test_arithmetic(uint64_t rnd) {$/;"	f
test_counter	.\tests\debugallocation_test.cc	/^static int test_counter = 0;    \/\/ incremented every time the macro is called$/;"	v	file:
test_main_thread	.\tests\profiler_unittest.cc	/^static void test_main_thread() {$/;"	f	file:
test_other_thread	.\tests\profiler_unittest.cc	/^static void test_other_thread() {$/;"	f	file:
test_to_run	.\tests\debugallocation_test.cc	/^static int test_to_run = 0;     \/\/ set in main() based on argv$/;"	v	file:
testing	.\tests\tcmalloc_unittest.cc	/^namespace testing {$/;"	n	file:
thread_	.\tests\profile-handler_unittest.cc	/^  pthread_t thread_;$/;"	m	class:__anon37::Thread	file:
thread_back_trace	.\stacktrace_instrument-inl.h	/^static BACK_TRACE thread_back_trace[MAX_THREAD];$/;"	v
thread_bytes	.\tcmalloc.cc	/^  uint64_t thread_bytes;      \/\/ Bytes in thread caches$/;"	m	struct:TCMallocStats	file:
thread_disable_counter	.\heap-checker.cc	/^static __thread int thread_disable_counter$/;"	v	file:
thread_disable_counter_key	.\heap-checker.cc	/^static pthread_key_t thread_disable_counter_key;$/;"	v	file:
thread_heap_count_	.\thread_cache.cc	/^int ThreadCache::thread_heap_count_ = 0;$/;"	m	class:tcmalloc::ThreadCache	file:
thread_heap_count_	.\thread_cache.h	/^  static int thread_heap_count_;$/;"	m	class:tcmalloc::ThreadCache
thread_heaps_	.\thread_cache.cc	/^ThreadCache* ThreadCache::thread_heaps_ = NULL;$/;"	m	class:tcmalloc::ThreadCache	file:
thread_heaps_	.\thread_cache.h	/^  static ThreadCache* thread_heaps_;$/;"	m	class:tcmalloc::ThreadCache
thread_listing_status	.\heap-checker.cc	/^} thread_listing_status = CALLBACK_NOT_STARTED;$/;"	v	typeref:enum:__anon20	file:
thread_timer_key	.\profile-handler.cc	/^  pthread_key_t thread_timer_key;$/;"	m	class:ProfileHandler	file:
threadcache_allocator	.\thread_cache.cc	/^PageHeapAllocator<ThreadCache> threadcache_allocator;$/;"	m	namespace:tcmalloc	file:
threadcount_lock	.\tests\malloc_hook_test.cc	/^static Mutex threadcount_lock;$/;"	m	namespace:__anon35	file:
threads	.\tests\tcmalloc_unittest.cc	/^static TesterThread** threads;$/;"	m	namespace:testing	file:
tid	.\base\elfcore.h	/^    pid_t            tid;$/;"	m	struct:Frame
tid	.\base\elfcore.h	/^    pid_t           tid;$/;"	m	struct:Frame
tid	.\base\elfcore.h	/^    pid_t tid;$/;"	m	struct:Frame
tid_	.\thread_cache.h	/^  pthread_t     tid_;                   \/\/ Which thread owns it$/;"	m	class:tcmalloc::ThreadCache
timer_id_holder	.\profile-handler.cc	/^  timer_id_holder(timer_t _timerid) : timerid(_timerid) {}$/;"	f	struct:timer_id_holder
timer_id_holder	.\profile-handler.cc	/^struct timer_id_holder {$/;"	s	file:
timer_running_	.\profile-handler.cc	/^  bool timer_running_;$/;"	m	class:ProfileHandler	file:
timer_type_	.\profile-handler.cc	/^  int timer_type_;$/;"	m	class:ProfileHandler	file:
timer_type_	.\tests\profile-handler_unittest.cc	/^static int timer_type_ = ITIMER_PROF;$/;"	m	namespace:__anon37	file:
timerid	.\profile-handler.cc	/^  timer_t timerid;$/;"	m	struct:timer_id_holder	file:
timespec	.\windows\port.h	/^struct timespec {$/;"	s
total	.\heap-profile-table.h	/^  const Stats& total() const { return total_; }$/;"	f	class:HeapProfileTable
total	.\heap-profile-table.h	/^  const Stats& total() const { return total_; }$/;"	f	class:HeapProfileTable::Snapshot
total_	.\heap-profile-table.h	/^  Bucket total_;$/;"	m	class:HeapProfileTable
total_	.\heap-profile-table.h	/^  Bucket total_;$/;"	m	class:HeapProfileTable::Snapshot
total_bytes_	.\profiledata.h	/^  size_t        total_bytes_;   \/\/ How much output$/;"	m	class:ProfileData
total_bytes_free	.\gperftools\malloc_extension.h	/^    size_t total_bytes_free;$/;"	m	struct:MallocExtension::FreeListInfo
total_weight_	.\tests\tcmalloc_unittest.cc	/^  int                   total_weight_;  \/\/ Total weight of all types$/;"	m	class:testing::TestHarness	file:
trace	.\stack_trace_table.h	/^    StackTrace trace;$/;"	m	struct:tcmalloc::StackTraceTable::Bucket
transfer_bytes	.\tcmalloc.cc	/^  uint64_t transfer_bytes;    \/\/ Bytes in central transfer cache$/;"	m	struct:TCMallocStats	file:
tsd_inited_	.\thread_cache.cc	/^bool ThreadCache::tsd_inited_ = false;$/;"	m	class:tcmalloc::ThreadCache	file:
tsd_inited_	.\thread_cache.h	/^  static bool tsd_inited_;$/;"	m	class:tcmalloc::ThreadCache
tv_nsec	.\base\linux_syscall_support.h	/^  long               tv_nsec;$/;"	m	struct:kernel_timespec
tv_nsec	.\windows\port.h	/^  int tv_nsec;$/;"	m	struct:timespec
tv_sec	.\base\linux_syscall_support.h	/^  long               tv_sec;$/;"	m	struct:kernel_timespec
tv_sec	.\base\linux_syscall_support.h	/^  long               tv_sec;$/;"	m	struct:kernel_timeval
tv_sec	.\windows\port.h	/^  int tv_sec;$/;"	m	struct:timespec
tv_usec	.\base\linux_syscall_support.h	/^  long               tv_usec;$/;"	m	struct:kernel_timeval
type	.\gperftools\malloc_extension.h	/^    const char* type;$/;"	m	struct:MallocExtension::FreeListInfo
type	.\gperftools\malloc_extension.h	/^  Type type;            \/\/ Type of this range$/;"	m	struct:base::MallocRange
type	.\tests\tcmalloc_unittest.cc	/^    int         type;$/;"	m	struct:testing::TestHarness::Type	file:
type_	.\windows\mini_disassembler_types.h	/^  InstructionType type_;$/;"	m	struct:sidestep::Opcode
type_	.\windows\mini_disassembler_types.h	/^  InstructionType type_;$/;"	m	struct:sidestep::SpecificOpcode
types_	.\tests\tcmalloc_unittest.cc	/^  vector<Type>*         types_;         \/\/ Registered types$/;"	m	class:testing::TestHarness	file:
u_	.\internal_logging.h	/^  } u_;$/;"	m	class:tcmalloc::LogItem	typeref:union:tcmalloc::LogItem::__anon21
ucontext_t	.\getpc.h	/^typedef int ucontext_t;$/;"	t
ucontext_t	.\getpc.h	/^typedef ucontext ucontext_t;$/;"	t
ucontext_t	.\profiler.cc	/^typedef int ucontext_t;   \/\/ just to quiet the compiler, mostly$/;"	t	file:
ucontext_t	.\profiler.cc	/^typedef ucontext ucontext_t;$/;"	t	file:
ucontext_t	.\stacktrace_powerpc-linux-inl.h	/^typedef ucontext ucontext_t;$/;"	t
ucontext_t	.\stacktrace_x86-inl.h	/^typedef ucontext ucontext_t;$/;"	t
uint16	.\base\basictypes.h	/^typedef uint16_t           uint16;$/;"	t
uint16_t	.\windows\port.h	/^typedef unsigned __int16 uint16_t;$/;"	t
uint32	.\base\basictypes.h	/^typedef uint32_t           uint32;$/;"	t
uint32_t	.\windows\port.h	/^typedef unsigned __int32 uint32_t;$/;"	t
uint64	.\base\basictypes.h	/^typedef uint64_t           uint64;$/;"	t
uint64_t	.\windows\port.h	/^typedef unsigned __int64 uint64_t;$/;"	t
uint8	.\base\basictypes.h	/^typedef uint8_t            uint8;$/;"	t
uint8_t	.\windows\port.h	/^typedef unsigned __int8 uint8_t;$/;"	t
unclaimed_cache_space_	.\thread_cache.cc	/^ssize_t ThreadCache::unclaimed_cache_space_ = kDefaultOverallThreadCacheSize;$/;"	m	class:tcmalloc::ThreadCache	file:
unclaimed_cache_space_	.\thread_cache.h	/^  static ssize_t unclaimed_cache_space_;$/;"	m	class:tcmalloc::ThreadCache
unhooked_arena	.\base\low_level_alloc.cc	/^static struct LowLevelAlloc::Arena unhooked_arena;$/;"	v	typeref:struct:Arena	file:
unhooked_async_sig_safe_arena	.\base\low_level_alloc.cc	/^static struct LowLevelAlloc::Arena unhooked_async_sig_safe_arena;$/;"	v	typeref:struct:Arena	file:
unmap_size_	.\memory_region_map.cc	/^int64 MemoryRegionMap::unmap_size_ = 0;$/;"	m	class:MemoryRegionMap	file:
unmap_size_	.\memory_region_map.h	/^  static int64 unmap_size_;$/;"	m	class:MemoryRegionMap
unmapped_bytes	.\page_heap.h	/^    uint64_t unmapped_bytes;  \/\/ Total bytes on returned freelists$/;"	m	struct:tcmalloc::PageHeap::Stats
unum	.\internal_logging.h	/^    uint64_t unum;$/;"	m	union:tcmalloc::LogItem::__anon21
unused	.\base\elfcore.h	/^    unsigned long unused;$/;"	m	struct:mips_regs
uregs	.\base\elfcore.h	/^    long uregs[18];$/;"	m	struct:arm_regs
uregs	.\base\elfcore.h	/^    struct i386_regs uregs;$/;"	m	struct:Frame	typeref:struct:Frame::i386_regs
uregs	.\base\elfcore.h	/^    unsigned long uregs[32];	\/* General Purpose Registers - r0-r31.       *\/$/;"	m	struct:ppc_regs
uregs	.\base\elfcore.h	/^    unsigned long uregs[32];    \/* General purpose registers.                *\/$/;"	m	struct:mips_regs
usage	.\windows\addr2line-pdb.c	/^void usage() {$/;"	f
usage	.\windows\nm-pdb.c	/^void usage() {$/;"	f
use_emergency_malloc	.\thread_cache.h	/^    bool use_emergency_malloc;$/;"	m	struct:tcmalloc::ThreadCache::ThreadLocalData
use_main_thread_counter	.\heap-checker.cc	/^static bool use_main_thread_counter = true;$/;"	v	file:
use_sib_byte_	.\windows\mini_disassembler_types.h	/^  bool use_sib_byte_;$/;"	m	struct:sidestep::ModrmEntry
used_slots_	.\central_freelist.h	/^  int32_t used_slots_;$/;"	m	class:tcmalloc::CentralFreeList
using_low_level_alloc	.\tests\low_level_alloc_unittest.cc	/^static bool using_low_level_alloc = false;$/;"	v	file:
using_maps_backing_	.\base\sysinfo.h	/^  bool using_maps_backing_; \/\/ true if we are looking at maps_backing instead of maps.$/;"	m	class:ProcMapsIterator
val	.\tests\heap-checker_unittest.cc	/^  mutable C val;$/;"	m	class:TClass	file:
valloc	.\libc_override_redefine.h	/^  void* valloc(size_t s)                         { return tc_valloc(s);       }$/;"	f
valloc	.\tests\tcmalloc_unittest.cc	103;"	d	file:
value	.\addressmap-inl.h	/^    Value  value;$/;"	m	struct:AddressMap::Entry
value	.\span.h	/^  int value[64];$/;"	m	struct:tcmalloc::Span
value_type	.\base\stl_allocator.h	/^  typedef T          value_type;$/;"	t	class:STL_Allocator
values	.\pagemap.h	/^    void* values[LEAF_LENGTH];$/;"	m	struct:TCMalloc_PageMap2::Leaf
values	.\pagemap.h	/^    void* values[LEAF_LENGTH];$/;"	m	struct:TCMalloc_PageMap3::Leaf
vdso_base_	.\base\vdso_support.cc	/^const void *VDSOSupport::vdso_base_ = ElfMemImage::kInvalidBase;$/;"	m	class:base::VDSOSupport	file:
vdso_base_	.\base\vdso_support.h	/^  static const void *vdso_base_;$/;"	m	class:base::VDSOSupport
vdso_init_helper	.\base\vdso_support.cc	/^} vdso_init_helper;$/;"	m	namespace:base	typeref:class:base::VDSOInitHelper	file:
verbose	.\base\logging.h	/^DECLARE_int32(verbose);$/;"	v
verdef_	.\base\elf_mem_image.h	/^  const ElfW(Verdef) *verdef_;$/;"	m	class:base::ElfMemImage
verdefnum_	.\base\elf_mem_image.h	/^  size_t verdefnum_;$/;"	m	class:base::ElfMemImage
version	.\base\elf_mem_image.h	/^    const char      *version;   \/\/ E.g. "LINUX_2.6", could be ""$/;"	m	struct:base::ElfMemImage::SymbolInfo
versym_	.\base\elf_mem_image.h	/^  const ElfW(Versym) *versym_;$/;"	m	class:base::ElfMemImage
virtual_space	.\windows\system-alloc.cc	/^static char virtual_space[sizeof(VirtualSysAllocator)];$/;"	v	file:
void_function	.\gperftools\heap-checker.h	/^  typedef void (*void_function)(void);$/;"	t	class:HeapCleaner
waitpid	.\base\linux_syscall_support.h	/^    LSS_INLINE pid_t LSS_NAME(waitpid)(pid_t pid, int *status, int options){$/;"	f
weight	.\tests\tcmalloc_unittest.cc	/^    int         weight;$/;"	m	struct:testing::TestHarness::Type	file:
windows_fn	.\windows\patch_functions.cc	/^    GenericFnPtr windows_fn;         \/\/ the fn whose name we call (&malloc)$/;"	m	struct:__anon52::WindowsInfo::FunctionInfo	file:
windows_fn	.\windows\patch_functions.cc	/^  GenericFnPtr windows_fn(int ifunction) const {$/;"	f	class:__anon52::LibcInfo
windows_fn_	.\windows\patch_functions.cc	/^  GenericFnPtr windows_fn_[kNumFunctions];$/;"	m	class:__anon52::LibcInfo	file:
wipe_stack_ptr	.\tests\heap-checker_unittest.cc	/^void (*volatile wipe_stack_ptr)(int n);$/;"	v
write	.\windows\port.h	/^inline ssize_t write(int fd, const void *buf, size_t count) {$/;"	f
write_file	.\heap-checker.cc	/^void write_file(string file, string str){$/;"	f
write_file	.\heap-checker.cc	/^void write_file(string file, string str, int pid){$/;"	f
write_log	.\profiler.cc	/^void write_log(string file, string str){$/;"	f
write_log	.\profiler.cc	/^void write_log(string file, string str, int pid){$/;"	f
xeq	.\base\elfcore.h	/^    unsigned long xeq;$/;"	m	struct:ppc_regs
~AddressMap	.\addressmap-inl.h	/^AddressMap<Value>::~AddressMap() {$/;"	f	class:AddressMap
~AggressiveDecommitChanger	.\tests\tcmalloc_unittest.cc	/^  ~AggressiveDecommitChanger() {$/;"	f	class:testing::AggressiveDecommitChanger
~AllocatorState	.\tests\tcmalloc_unittest.cc	/^  virtual ~AllocatorState() {}$/;"	f	class:testing::AllocatorState
~ArenaLock	.\base\low_level_alloc.cc	/^    ~ArenaLock() { RAW_CHECK(this->left_, "haven't left Arena region"); }$/;"	f	class:__anon8::ArenaLock
~Array	.\tests\heap-checker_unittest.cc	/^  ~Array() { delete [] ptr; }$/;"	f	struct:Array
~AutoTestingHookBase	.\windows\auto_testing_hook.h	/^  virtual ~AutoTestingHookBase() {}$/;"	f	class:sidestep::AutoTestingHookBase
~AutoTestingHookHolder	.\windows\auto_testing_hook.h	/^  ~AutoTestingHookHolder() { delete hook_; }$/;"	f	class:sidestep::AutoTestingHookHolder
~AutoTestingHookImpl	.\windows\auto_testing_hook.h	/^  ~AutoTestingHookImpl() {$/;"	f	class:sidestep::AutoTestingHookImpl
~ClassB	.\tests\heap-checker_unittest.cc	/^  virtual ~ClassB() { }$/;"	f	class:ClassB
~ClassB2	.\tests\heap-checker_unittest.cc	/^  virtual ~ClassB2() { }$/;"	f	class:ClassB2
~Closure	.\tests\heap-checker_unittest.cc	/^  virtual ~Closure() { }$/;"	f	class:Closure
~CpuProfiler	.\profiler.cc	/^CpuProfiler::~CpuProfiler() {$/;"	f	class:CpuProfiler
~DefaultPagesAllocator	.\base\low_level_alloc.cc	/^    virtual ~DefaultPagesAllocator() {};$/;"	f	class:__anon7::DefaultPagesAllocator
~DeleteUnsignedCharArray	.\windows\preamble_patcher.cc	/^  ~DeleteUnsignedCharArray() {$/;"	f	class:sidestep::DeleteUnsignedCharArray
~Disabler	.\heap-checker.cc	/^HeapLeakChecker::Disabler::~Disabler() {$/;"	f	class:HeapLeakChecker::Disabler
~EmergencyArenaPagesAllocator	.\emergency_malloc.cc	/^    ~EmergencyArenaPagesAllocator() {}$/;"	f	class:tcmalloc::EmergencyArenaPagesAllocator	file:
~FileDescriptor	.\tests\profiledata_unittest.cc	/^  ~FileDescriptor() {$/;"	f	struct:__anon38::FileDescriptor
~GoogleInitializer	.\base\googleinit.h	/^  ~GoogleInitializer() {$/;"	f	class:GoogleInitializer
~HeapLeakChecker	.\heap-checker.cc	/^HeapLeakChecker::~HeapLeakChecker() {$/;"	f	class:HeapLeakChecker
~HeapLeakCheckerGlobalPrePost	.\heap-checker-bcad.cc	/^  ~HeapLeakCheckerGlobalPrePost() {$/;"	f	class:HeapLeakCheckerGlobalPrePost
~HeapProfileEndWriter	.\heap-profiler.cc	/^  ~HeapProfileEndWriter() {$/;"	f	struct:HeapProfileEndWriter
~HeapProfileTable	.\heap-profile-table.cc	/^HeapProfileTable::~HeapProfileTable() {$/;"	f	class:HeapProfileTable
~InterfaceA	.\tests\heap-checker_unittest.cc	/^  virtual ~InterfaceA() { }$/;"	f	class:InterfaceA
~InterfaceB	.\tests\heap-checker_unittest.cc	/^  virtual ~InterfaceB() { }$/;"	f	class:InterfaceB
~InterfaceC	.\tests\heap-checker_unittest.cc	/^  virtual ~InterfaceC() { }$/;"	f	class:InterfaceC
~LockHolder	.\memory_region_map.h	/^    ~LockHolder() { Unlock(); }$/;"	f	class:MemoryRegionMap::LockHolder
~LockInverter	.\central_freelist.cc	/^  inline ~LockInverter() { temp_->Unlock(); held_->Lock();  }$/;"	f	class:tcmalloc::__anon16::LockInverter
~MallocExtension	.\malloc_extension.cc	/^MallocExtension::~MallocExtension() { }$/;"	f	class:MallocExtension
~Mutex	.\base\simple_mutex.h	/^Mutex::~Mutex()            { assert(mutex_ == 0); }$/;"	f	class:MUTEX_NAMESPACE::Mutex
~Mutex	.\base\simple_mutex.h	/^Mutex::~Mutex()            { if (destroy_) DeleteCriticalSection(&mutex_); }$/;"	f	class:MUTEX_NAMESPACE::Mutex
~Mutex	.\base\simple_mutex.h	/^Mutex::~Mutex()       { if (destroy_) SAFE_PTHREAD(pthread_mutex_destroy); }$/;"	f	class:MUTEX_NAMESPACE::Mutex
~Mutex	.\base\simple_mutex.h	/^Mutex::~Mutex()       { if (destroy_) SAFE_PTHREAD(pthread_rwlock_destroy); }$/;"	f	class:MUTEX_NAMESPACE::Mutex
~MutexLock	.\base\simple_mutex.h	/^  ~MutexLock() { mu_->Unlock(); }$/;"	f	class:MUTEX_NAMESPACE::MutexLock
~PagesAllocator	.\base\low_level_alloc.cc	/^LowLevelAlloc::PagesAllocator::~PagesAllocator() {$/;"	f	class:LowLevelAlloc::PagesAllocator
~ProcMapsIterator	.\base\sysinfo.cc	/^ProcMapsIterator::~ProcMapsIterator() {$/;"	f	class:ProcMapsIterator
~ProfileData	.\profiledata.cc	/^ProfileData::~ProfileData() {$/;"	f	class:ProfileData
~ProfileHandler	.\profile-handler.cc	/^ProfileHandler::~ProfileHandler() {$/;"	f	class:ProfileHandler
~ReaderMutexLock	.\base\simple_mutex.h	/^  ~ReaderMutexLock() { mu_->ReaderUnlock(); }$/;"	f	class:MUTEX_NAMESPACE::ReaderMutexLock
~STL_Allocator	.\base\stl_allocator.h	/^  ~STL_Allocator() { }$/;"	f	class:STL_Allocator
~ScopedSignalBlocker	.\profile-handler.cc	/^  ~ScopedSignalBlocker() {$/;"	f	class:ScopedSignalBlocker
~SpinLockHolder	.\base\spinlock.h	/^  inline ~SpinLockHolder() \/*UNLOCK_FUNCTION()*\/ { lock_->Unlock(); }$/;"	f	class:SpinLockHolder
~StackTraceTable	.\stack_trace_table.cc	/^StackTraceTable::~StackTraceTable() {$/;"	f	class:tcmalloc::StackTraceTable
~StacktraceScope	.\stacktrace.cc	/^    ~StacktraceScope() {$/;"	f	class:__anon27::StacktraceScope
~SymbolTable	.\symbolize.h	/^  ~SymbolTable() {$/;"	f	class:SymbolTable
~SysAllocator	.\malloc_extension.cc	/^SysAllocator::~SysAllocator() {}$/;"	f	class:SysAllocator
~TCMallocGuard	.\tcmalloc.cc	/^TCMallocGuard::~TCMallocGuard() {$/;"	f	class:TCMallocGuard
~TestHarness	.\tests\tcmalloc_unittest.cc	/^  ~TestHarness() {$/;"	f	class:testing::TestHarness
~TesterThread	.\tests\tcmalloc_unittest.cc	/^  virtual ~TesterThread() {$/;"	f	class:testing::TesterThread
~Thread	.\tests\profile-handler_unittest.cc	/^  virtual ~Thread() { }$/;"	f	class:__anon37::Thread
~WriterMutexLock	.\base\simple_mutex.h	/^  ~WriterMutexLock() { mu_->WriterUnlock(); }$/;"	f	class:MUTEX_NAMESPACE::WriterMutexLock
~scoped_array	.\tests\profiledata_unittest.cc	/^  ~scoped_array() { delete[] data_; }$/;"	f	class:__anon38::scoped_array
~scoped_array	.\tests\sampler_test.cc	/^  ~scoped_array() { delete[] p_; }$/;"	f	class:__anon39::scoped_array
