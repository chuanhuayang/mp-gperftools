ALLOC_COUNT	addressmap-inl.h	/^  static const int ALLOC_COUNT = 64;$/;"	m	class:AddressMap
AddressMap	addressmap-inl.h	/^AddressMap<Value>::AddressMap(Allocator alloc, DeAllocator dealloc)$/;"	f	class:AddressMap
AddressMap	addressmap-inl.h	/^class AddressMap {$/;"	c
Allocator	addressmap-inl.h	/^  typedef void* (*Allocator)(size_t size);$/;"	t	class:AddressMap
BASE_ADDRESSMAP_INL_H_	addressmap-inl.h	82;"	d
BlockID	addressmap-inl.h	/^  static int BlockID(Number address) {$/;"	f	class:AddressMap
Cluster	addressmap-inl.h	/^  struct Cluster {$/;"	s	class:AddressMap
DeAllocator	addressmap-inl.h	/^  typedef void  (*DeAllocator)(void* ptr);$/;"	t	class:AddressMap
Entry	addressmap-inl.h	/^  struct Entry {$/;"	s	class:AddressMap
Find	addressmap-inl.h	/^inline const Value* AddressMap<Value>::Find(Key key) const {$/;"	f	class:AddressMap
FindAndRemove	addressmap-inl.h	/^bool AddressMap<Value>::FindAndRemove(Key key, Value* removed_value) {$/;"	f	class:AddressMap
FindCluster	addressmap-inl.h	/^  Cluster* FindCluster(Number address, bool create) {$/;"	f	class:AddressMap
FindInside	addressmap-inl.h	/^const Value* AddressMap<Value>::FindInside(ValueSizeFunc size_func,$/;"	f	class:AddressMap
FindMutable	addressmap-inl.h	/^inline Value* AddressMap<Value>::FindMutable(Key key) {$/;"	f	class:AddressMap
HashInt	addressmap-inl.h	/^  static int HashInt(Number x) {$/;"	f	class:AddressMap
Insert	addressmap-inl.h	/^void AddressMap<Value>::Insert(Key key, Value value) {$/;"	f	class:AddressMap
Iterate	addressmap-inl.h	/^inline void AddressMap<Value>::Iterate(void (*callback)(Key, Value*, Type),$/;"	f	class:AddressMap
Key	addressmap-inl.h	/^  typedef const void* Key;$/;"	t	class:AddressMap
New	addressmap-inl.h	/^  template <class T> T* New(int num) {$/;"	f	class:AddressMap
Number	addressmap-inl.h	/^  typedef uintptr_t Number;$/;"	t	class:AddressMap
Object	addressmap-inl.h	/^  struct Object {$/;"	s	class:AddressMap
ValueSizeFunc	addressmap-inl.h	/^  typedef size_t (*ValueSizeFunc)(const Value& v);$/;"	t	class:AddressMap
alloc_	addressmap-inl.h	/^  Allocator     alloc_;                 \/\/ The allocator$/;"	m	class:AddressMap
allocated_	addressmap-inl.h	/^  Object*       allocated_;             \/\/ List of allocated objects$/;"	m	class:AddressMap
blocks	addressmap-inl.h	/^    Entry*   blocks[kClusterBlocks];    \/\/ Per-block linked-lists$/;"	m	struct:AddressMap::Cluster
dealloc_	addressmap-inl.h	/^  DeAllocator   dealloc_;               \/\/ The deallocator$/;"	m	class:AddressMap
free_	addressmap-inl.h	/^  Entry*        free_;                   \/\/ Free list of unused Entry objects$/;"	m	class:AddressMap
hashtable_	addressmap-inl.h	/^  Cluster**     hashtable_;              \/\/ The hash-table$/;"	m	class:AddressMap
id	addressmap-inl.h	/^    Number   id;                        \/\/ Cluster ID$/;"	m	struct:AddressMap::Cluster
kBlockBits	addressmap-inl.h	/^  static const int kBlockBits = 7;$/;"	m	class:AddressMap
kBlockSize	addressmap-inl.h	/^  static const int kBlockSize = 1 << kBlockBits;$/;"	m	class:AddressMap
kClusterBits	addressmap-inl.h	/^  static const int kClusterBits = 13;$/;"	m	class:AddressMap
kClusterBlocks	addressmap-inl.h	/^  static const int kClusterBlocks = 1 << kClusterBits;$/;"	m	class:AddressMap
kClusterSize	addressmap-inl.h	/^  static const Number kClusterSize = 1 << (kBlockBits + kClusterBits);$/;"	m	class:AddressMap
kHashBits	addressmap-inl.h	/^  static const int kHashBits = 12;$/;"	m	class:AddressMap
kHashMultiplier	addressmap-inl.h	/^  static const uint32_t kHashMultiplier = 2654435769u;$/;"	m	class:AddressMap
kHashSize	addressmap-inl.h	/^  static const int kHashSize = 1 << 12;$/;"	m	class:AddressMap
key	addressmap-inl.h	/^    Key    key;$/;"	m	struct:AddressMap::Entry
next	addressmap-inl.h	/^    Cluster* next;                      \/\/ Next cluster in hash table chain$/;"	m	struct:AddressMap::Cluster
next	addressmap-inl.h	/^    Entry* next;$/;"	m	struct:AddressMap::Entry
next	addressmap-inl.h	/^    Object* next;$/;"	m	struct:AddressMap::Object
value	addressmap-inl.h	/^    Value  value;$/;"	m	struct:AddressMap::Entry
~AddressMap	addressmap-inl.h	/^AddressMap<Value>::~AddressMap() {$/;"	f	class:AddressMap
ARMV2	base\arm_instruction_set_select.h	81;"	d
ARMV3	base\arm_instruction_set_select.h	76;"	d
ARMV4	base\arm_instruction_set_select.h	70;"	d
ARMV5	base\arm_instruction_set_select.h	64;"	d
ARMV6	base\arm_instruction_set_select.h	56;"	d
ARMV7	base\arm_instruction_set_select.h	46;"	d
ARMV8	base\arm_instruction_set_select.h	39;"	d
ARM_INSTRUCTION_SET_SELECT_H_	base\arm_instruction_set_select.h	36;"	d
ATTRIBUTE_WEAK	base\atomicops-internals-arm-generic.h	/^LinuxKernelCmpxchgFunc pLinuxKernelCmpxchg ATTRIBUTE_WEAK =$/;"	m	namespace:base::subtle
ATTRIBUTE_WEAK	base\atomicops-internals-arm-generic.h	/^LinuxKernelMemoryBarrierFunc pLinuxKernelMemoryBarrier ATTRIBUTE_WEAK =$/;"	m	namespace:base::subtle
Acquire_AtomicExchange	base\atomicops-internals-arm-generic.h	/^inline Atomic32 Acquire_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
Acquire_AtomicExchange	base\atomicops-internals-arm-generic.h	/^inline Atomic64 Acquire_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
Acquire_CompareAndSwap	base\atomicops-internals-arm-generic.h	/^inline Atomic32 Acquire_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
Acquire_CompareAndSwap	base\atomicops-internals-arm-generic.h	/^inline Atomic64 Acquire_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
Acquire_Load	base\atomicops-internals-arm-generic.h	/^inline Atomic32 Acquire_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle
Acquire_Load	base\atomicops-internals-arm-generic.h	/^inline Atomic64 Acquire_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle
Acquire_Store	base\atomicops-internals-arm-generic.h	/^inline void Acquire_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle
Acquire_Store	base\atomicops-internals-arm-generic.h	/^inline void Acquire_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle
Atomic32	base\atomicops-internals-arm-generic.h	/^typedef int32_t Atomic32;$/;"	t
Atomic64	base\atomicops-internals-arm-generic.h	/^typedef int64_t Atomic64;$/;"	t	namespace:base::subtle
BASE_ATOMICOPS_INTERNALS_ARM_GENERIC_H_	base\atomicops-internals-arm-generic.h	39;"	d
LinuxKernelCmpxchgFunc	base\atomicops-internals-arm-generic.h	/^typedef Atomic32 (*LinuxKernelCmpxchgFunc)(Atomic32 old_value,$/;"	t	namespace:base::subtle
LinuxKernelMemoryBarrierFunc	base\atomicops-internals-arm-generic.h	/^typedef void (*LinuxKernelMemoryBarrierFunc)(void);$/;"	t	namespace:base::subtle
MemoryBarrier	base\atomicops-internals-arm-generic.h	/^inline void MemoryBarrier() {$/;"	f	namespace:base::subtle
NoBarrier_AtomicExchange	base\atomicops-internals-arm-generic.h	/^inline Atomic32 NoBarrier_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
NoBarrier_AtomicExchange	base\atomicops-internals-arm-generic.h	/^inline Atomic64 NoBarrier_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
NoBarrier_CompareAndSwap	base\atomicops-internals-arm-generic.h	/^inline Atomic32 NoBarrier_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
NoBarrier_CompareAndSwap	base\atomicops-internals-arm-generic.h	/^inline Atomic64 NoBarrier_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
NoBarrier_Load	base\atomicops-internals-arm-generic.h	/^inline Atomic32 NoBarrier_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle
NoBarrier_Load	base\atomicops-internals-arm-generic.h	/^inline Atomic64 NoBarrier_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle
NoBarrier_Store	base\atomicops-internals-arm-generic.h	/^inline void NoBarrier_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle
NoBarrier_Store	base\atomicops-internals-arm-generic.h	/^inline void NoBarrier_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle
NotImplementedFatalError	base\atomicops-internals-arm-generic.h	/^inline void NotImplementedFatalError(const char *function_name) {$/;"	f	namespace:base::subtle
Release_AtomicExchange	base\atomicops-internals-arm-generic.h	/^inline Atomic32 Release_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
Release_AtomicExchange	base\atomicops-internals-arm-generic.h	/^inline Atomic64 Release_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
Release_CompareAndSwap	base\atomicops-internals-arm-generic.h	/^inline Atomic32 Release_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
Release_CompareAndSwap	base\atomicops-internals-arm-generic.h	/^inline Atomic64 Release_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
Release_Load	base\atomicops-internals-arm-generic.h	/^inline Atomic32 Release_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle
Release_Load	base\atomicops-internals-arm-generic.h	/^inline Atomic64 Release_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle
Release_Store	base\atomicops-internals-arm-generic.h	/^inline void Release_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle
Release_Store	base\atomicops-internals-arm-generic.h	/^inline void Release_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle
base	base\atomicops-internals-arm-generic.h	/^namespace base {$/;"	n
subtle	base\atomicops-internals-arm-generic.h	/^namespace subtle {$/;"	n	namespace:base
Acquire_AtomicExchange	base\atomicops-internals-arm-v6plus.h	/^inline Atomic32 Acquire_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
Acquire_AtomicExchange	base\atomicops-internals-arm-v6plus.h	/^inline Atomic64 Acquire_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
Acquire_CompareAndSwap	base\atomicops-internals-arm-v6plus.h	/^inline Atomic32 Acquire_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
Acquire_CompareAndSwap	base\atomicops-internals-arm-v6plus.h	/^inline Atomic64 Acquire_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
Acquire_Load	base\atomicops-internals-arm-v6plus.h	/^inline Atomic32 Acquire_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle
Acquire_Load	base\atomicops-internals-arm-v6plus.h	/^inline Atomic64 Acquire_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle
Acquire_Store	base\atomicops-internals-arm-v6plus.h	/^inline void Acquire_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle
Acquire_Store	base\atomicops-internals-arm-v6plus.h	/^inline void Acquire_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle
Atomic32	base\atomicops-internals-arm-v6plus.h	/^typedef int32_t Atomic32;$/;"	t
Atomic64	base\atomicops-internals-arm-v6plus.h	/^typedef int64_t Atomic64;$/;"	t	namespace:base::subtle
BASE_ATOMICOPS_HAS_LDREXD_AND_STREXD	base\atomicops-internals-arm-v6plus.h	50;"	d
BASE_ATOMICOPS_INTERNALS_ARM_V6PLUS_H_	base\atomicops-internals-arm-v6plus.h	40;"	d
BASE_HAS_ATOMIC64	base\atomicops-internals-arm-v6plus.h	168;"	d
MemoryBarrier	base\atomicops-internals-arm-v6plus.h	/^inline void MemoryBarrier() {$/;"	f	namespace:base::subtle
NoBarrier_AtomicExchange	base\atomicops-internals-arm-v6plus.h	/^inline Atomic32 NoBarrier_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
NoBarrier_AtomicExchange	base\atomicops-internals-arm-v6plus.h	/^inline Atomic64 NoBarrier_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
NoBarrier_CompareAndSwap	base\atomicops-internals-arm-v6plus.h	/^inline Atomic32 NoBarrier_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
NoBarrier_CompareAndSwap	base\atomicops-internals-arm-v6plus.h	/^inline Atomic64 NoBarrier_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
NoBarrier_Load	base\atomicops-internals-arm-v6plus.h	/^inline Atomic32 NoBarrier_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle
NoBarrier_Load	base\atomicops-internals-arm-v6plus.h	/^inline Atomic64 NoBarrier_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle
NoBarrier_Store	base\atomicops-internals-arm-v6plus.h	/^inline void NoBarrier_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle
NoBarrier_Store	base\atomicops-internals-arm-v6plus.h	/^inline void NoBarrier_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle
NotImplementedFatalError	base\atomicops-internals-arm-v6plus.h	/^inline void NotImplementedFatalError(const char *function_name) {$/;"	f	namespace:base::subtle
Release_AtomicExchange	base\atomicops-internals-arm-v6plus.h	/^inline Atomic32 Release_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
Release_AtomicExchange	base\atomicops-internals-arm-v6plus.h	/^inline Atomic64 Release_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
Release_CompareAndSwap	base\atomicops-internals-arm-v6plus.h	/^inline Atomic32 Release_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
Release_CompareAndSwap	base\atomicops-internals-arm-v6plus.h	/^inline Atomic64 Release_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
Release_Load	base\atomicops-internals-arm-v6plus.h	/^inline Atomic32 Release_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle
Release_Load	base\atomicops-internals-arm-v6plus.h	/^inline Atomic64 Release_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle
Release_Store	base\atomicops-internals-arm-v6plus.h	/^inline void Release_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle
Release_Store	base\atomicops-internals-arm-v6plus.h	/^inline void Release_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle
base	base\atomicops-internals-arm-v6plus.h	/^namespace base {$/;"	n
subtle	base\atomicops-internals-arm-v6plus.h	/^namespace subtle {$/;"	n	namespace:base
Acquire_AtomicExchange	base\atomicops-internals-gcc.h	/^inline Atomic32 Acquire_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
Acquire_AtomicExchange	base\atomicops-internals-gcc.h	/^inline Atomic64 Acquire_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
Acquire_CompareAndSwap	base\atomicops-internals-gcc.h	/^inline Atomic32 Acquire_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
Acquire_CompareAndSwap	base\atomicops-internals-gcc.h	/^inline Atomic64 Acquire_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
Acquire_Load	base\atomicops-internals-gcc.h	/^inline Atomic32 Acquire_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle
Acquire_Load	base\atomicops-internals-gcc.h	/^inline Atomic64 Acquire_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle
Acquire_Store	base\atomicops-internals-gcc.h	/^inline void Acquire_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle
Acquire_Store	base\atomicops-internals-gcc.h	/^inline void Acquire_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle
Atomic32	base\atomicops-internals-gcc.h	/^typedef int32_t Atomic32;$/;"	t
Atomic64	base\atomicops-internals-gcc.h	/^typedef int64_t Atomic64;$/;"	t	namespace:base::subtle
BASE_ATOMICOPS_INTERNALS_GCC_GENERIC_H_	base\atomicops-internals-gcc.h	39;"	d
MemoryBarrier	base\atomicops-internals-gcc.h	/^inline void MemoryBarrier() {$/;"	f	namespace:base::subtle
NoBarrier_AtomicExchange	base\atomicops-internals-gcc.h	/^inline Atomic32 NoBarrier_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
NoBarrier_AtomicExchange	base\atomicops-internals-gcc.h	/^inline Atomic64 NoBarrier_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
NoBarrier_CompareAndSwap	base\atomicops-internals-gcc.h	/^inline Atomic32 NoBarrier_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
NoBarrier_CompareAndSwap	base\atomicops-internals-gcc.h	/^inline Atomic64 NoBarrier_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
NoBarrier_Load	base\atomicops-internals-gcc.h	/^inline Atomic32 NoBarrier_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle
NoBarrier_Load	base\atomicops-internals-gcc.h	/^inline Atomic64 NoBarrier_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle
NoBarrier_Store	base\atomicops-internals-gcc.h	/^inline void NoBarrier_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle
NoBarrier_Store	base\atomicops-internals-gcc.h	/^inline void NoBarrier_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle
Release_AtomicExchange	base\atomicops-internals-gcc.h	/^inline Atomic32 Release_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
Release_AtomicExchange	base\atomicops-internals-gcc.h	/^inline Atomic64 Release_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
Release_CompareAndSwap	base\atomicops-internals-gcc.h	/^inline Atomic32 Release_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
Release_CompareAndSwap	base\atomicops-internals-gcc.h	/^inline Atomic64 Release_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
Release_Load	base\atomicops-internals-gcc.h	/^inline Atomic32 Release_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle
Release_Load	base\atomicops-internals-gcc.h	/^inline Atomic64 Release_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle
Release_Store	base\atomicops-internals-gcc.h	/^inline void Release_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle
Release_Store	base\atomicops-internals-gcc.h	/^inline void Release_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle
base	base\atomicops-internals-gcc.h	/^namespace base {$/;"	n
subtle	base\atomicops-internals-gcc.h	/^namespace subtle {$/;"	n	namespace:base
Acquire_AtomicExchange	base\atomicops-internals-linuxppc.h	/^inline Atomic32 Acquire_AtomicExchange(volatile Atomic32 *ptr,$/;"	f	namespace:base::subtle
Acquire_AtomicExchange	base\atomicops-internals-linuxppc.h	/^inline Atomic64 Acquire_AtomicExchange(volatile Atomic64 *ptr,$/;"	f	namespace:base::subtle
Acquire_CompareAndSwap	base\atomicops-internals-linuxppc.h	/^inline Atomic32 Acquire_CompareAndSwap(volatile Atomic32 *ptr,$/;"	f	namespace:base::subtle
Acquire_CompareAndSwap	base\atomicops-internals-linuxppc.h	/^inline Atomic64 Acquire_CompareAndSwap(volatile Atomic64 *ptr,$/;"	f	namespace:base::subtle
Acquire_Load	base\atomicops-internals-linuxppc.h	/^inline Atomic32 Acquire_Load(volatile const Atomic32 *ptr) {$/;"	f	namespace:base::subtle
Acquire_Load	base\atomicops-internals-linuxppc.h	/^inline Atomic64 Acquire_Load(volatile const Atomic64 *ptr) {$/;"	f	namespace:base::subtle
Acquire_Store	base\atomicops-internals-linuxppc.h	/^inline void Acquire_Store(volatile Atomic32 *ptr, Atomic32 value) {$/;"	f	namespace:base::subtle
Acquire_Store	base\atomicops-internals-linuxppc.h	/^inline void Acquire_Store(volatile Atomic64 *ptr, Atomic64 value) {$/;"	f	namespace:base::subtle
Atomic32	base\atomicops-internals-linuxppc.h	/^typedef int32_t Atomic32;$/;"	t
Atomic64	base\atomicops-internals-linuxppc.h	/^typedef int64_t Atomic64;$/;"	t	namespace:base::subtle
BASE_ATOMICOPS_INTERNALS_LINUXPPC_H_	base\atomicops-internals-linuxppc.h	39;"	d
BASE_HAS_ATOMIC64	base\atomicops-internals-linuxppc.h	44;"	d
MemoryBarrier	base\atomicops-internals-linuxppc.h	/^inline void MemoryBarrier() {$/;"	f	namespace:base::subtle
NoBarrier_AtomicExchange	base\atomicops-internals-linuxppc.h	/^inline Atomic32 NoBarrier_AtomicExchange(volatile Atomic32 *ptr,$/;"	f	namespace:base::subtle
NoBarrier_AtomicExchange	base\atomicops-internals-linuxppc.h	/^inline Atomic64 NoBarrier_AtomicExchange(volatile Atomic64 *ptr,$/;"	f	namespace:base::subtle
NoBarrier_CompareAndSwap	base\atomicops-internals-linuxppc.h	/^inline Atomic32 NoBarrier_CompareAndSwap(volatile Atomic32 *ptr,$/;"	f	namespace:base::subtle
NoBarrier_CompareAndSwap	base\atomicops-internals-linuxppc.h	/^inline Atomic64 NoBarrier_CompareAndSwap(volatile Atomic64 *ptr,$/;"	f	namespace:base::subtle
NoBarrier_Load	base\atomicops-internals-linuxppc.h	/^inline Atomic32 NoBarrier_Load(volatile const Atomic32 *ptr) {$/;"	f	namespace:base::subtle
NoBarrier_Load	base\atomicops-internals-linuxppc.h	/^inline Atomic64 NoBarrier_Load(volatile const Atomic64 *ptr) {$/;"	f	namespace:base::subtle
NoBarrier_Store	base\atomicops-internals-linuxppc.h	/^inline void NoBarrier_Store(volatile Atomic32 *ptr, Atomic32 value) {$/;"	f	namespace:base::subtle
NoBarrier_Store	base\atomicops-internals-linuxppc.h	/^inline void NoBarrier_Store(volatile Atomic64 *ptr, Atomic64 value) {$/;"	f	namespace:base::subtle
OSAtomicAdd32	base\atomicops-internals-linuxppc.h	/^static inline Atomic32 OSAtomicAdd32(Atomic32 amount, Atomic32 *value) {$/;"	f	namespace:base::subtle
OSAtomicAdd32Barrier	base\atomicops-internals-linuxppc.h	/^static inline Atomic32 OSAtomicAdd32Barrier(Atomic32 amount, Atomic32 *value) {$/;"	f	namespace:base::subtle
OSAtomicAdd64	base\atomicops-internals-linuxppc.h	/^static inline Atomic64 OSAtomicAdd64(Atomic64 amount, Atomic64 *value) {$/;"	f	namespace:base::subtle
OSAtomicAdd64Barrier	base\atomicops-internals-linuxppc.h	/^static inline Atomic64 OSAtomicAdd64Barrier(Atomic64 amount, Atomic64 *value) {$/;"	f	namespace:base::subtle
OSAtomicCompareAndSwap32	base\atomicops-internals-linuxppc.h	/^static inline bool OSAtomicCompareAndSwap32(Atomic32 old_value,$/;"	f	namespace:base::subtle
OSAtomicCompareAndSwap32Acquire	base\atomicops-internals-linuxppc.h	/^static inline Atomic32 OSAtomicCompareAndSwap32Acquire(Atomic32 old_value,$/;"	f	namespace:base::subtle
OSAtomicCompareAndSwap32Release	base\atomicops-internals-linuxppc.h	/^static inline Atomic32 OSAtomicCompareAndSwap32Release(Atomic32 old_value,$/;"	f	namespace:base::subtle
OSAtomicCompareAndSwap64	base\atomicops-internals-linuxppc.h	/^static inline bool OSAtomicCompareAndSwap64(Atomic64 old_value,$/;"	f	namespace:base::subtle
OSAtomicCompareAndSwap64Acquire	base\atomicops-internals-linuxppc.h	/^static inline Atomic64 OSAtomicCompareAndSwap64Acquire(Atomic64 old_value,$/;"	f	namespace:base::subtle
OSAtomicCompareAndSwap64Release	base\atomicops-internals-linuxppc.h	/^static inline Atomic64 OSAtomicCompareAndSwap64Release(Atomic64 old_value,$/;"	f	namespace:base::subtle
Release_AtomicExchange	base\atomicops-internals-linuxppc.h	/^inline Atomic32 Release_AtomicExchange(volatile Atomic32 *ptr,$/;"	f	namespace:base::subtle
Release_AtomicExchange	base\atomicops-internals-linuxppc.h	/^inline Atomic64 Release_AtomicExchange(volatile Atomic64 *ptr,$/;"	f	namespace:base::subtle
Release_CompareAndSwap	base\atomicops-internals-linuxppc.h	/^inline Atomic32 Release_CompareAndSwap(volatile Atomic32 *ptr,$/;"	f	namespace:base::subtle
Release_CompareAndSwap	base\atomicops-internals-linuxppc.h	/^inline Atomic64 Release_CompareAndSwap(volatile Atomic64 *ptr,$/;"	f	namespace:base::subtle
Release_Load	base\atomicops-internals-linuxppc.h	/^inline Atomic32 Release_Load(volatile const Atomic32 *ptr) {$/;"	f	namespace:base::subtle
Release_Load	base\atomicops-internals-linuxppc.h	/^inline Atomic64 Release_Load(volatile const Atomic64 *ptr) {$/;"	f	namespace:base::subtle
Release_Store	base\atomicops-internals-linuxppc.h	/^inline void Release_Store(volatile Atomic32 *ptr, Atomic32 value) {$/;"	f	namespace:base::subtle
Release_Store	base\atomicops-internals-linuxppc.h	/^inline void Release_Store(volatile Atomic64 *ptr, Atomic64 value) {$/;"	f	namespace:base::subtle
_isync	base\atomicops-internals-linuxppc.h	/^static inline void _isync(void) {$/;"	f	namespace:base::subtle
_lwsync	base\atomicops-internals-linuxppc.h	/^static inline void _lwsync(void) {$/;"	f	namespace:base::subtle
_sync	base\atomicops-internals-linuxppc.h	/^static inline void _sync(void) {$/;"	f	namespace:base::subtle
base	base\atomicops-internals-linuxppc.h	/^namespace base {$/;"	n
subtle	base\atomicops-internals-linuxppc.h	/^namespace subtle {$/;"	n	namespace:base
Acquire_AtomicExchange	base\atomicops-internals-macosx.h	/^inline Atomic32 Acquire_AtomicExchange(volatile Atomic32 *ptr,$/;"	f	namespace:base::subtle
Acquire_AtomicExchange	base\atomicops-internals-macosx.h	/^inline Atomic64 Acquire_AtomicExchange(volatile Atomic64 *ptr,$/;"	f	namespace:base::subtle
Acquire_CompareAndSwap	base\atomicops-internals-macosx.h	/^inline Atomic32 Acquire_CompareAndSwap(volatile Atomic32 *ptr,$/;"	f	namespace:base::subtle
Acquire_CompareAndSwap	base\atomicops-internals-macosx.h	/^inline Atomic64 Acquire_CompareAndSwap(volatile Atomic64 *ptr,$/;"	f	namespace:base::subtle
Acquire_Load	base\atomicops-internals-macosx.h	/^inline Atomic32 Acquire_Load(volatile const Atomic32 *ptr) {$/;"	f	namespace:base::subtle
Acquire_Load	base\atomicops-internals-macosx.h	/^inline Atomic64 Acquire_Load(volatile const Atomic64 *ptr) {$/;"	f	namespace:base::subtle
Acquire_Store	base\atomicops-internals-macosx.h	/^inline void Acquire_Store(volatile Atomic32 *ptr, Atomic32 value) {$/;"	f	namespace:base::subtle
Acquire_Store	base\atomicops-internals-macosx.h	/^inline void Acquire_Store(volatile Atomic64 *ptr, Atomic64 value) {$/;"	f	namespace:base::subtle
Atomic32	base\atomicops-internals-macosx.h	/^typedef int32_t Atomic32;$/;"	t
Atomic64	base\atomicops-internals-macosx.h	/^typedef int64_t Atomic64;$/;"	t	namespace:base::subtle
AtomicWordCastType	base\atomicops-internals-macosx.h	46;"	d
AtomicWordCastType	base\atomicops-internals-macosx.h	48;"	d
BASE_ATOMICOPS_INTERNALS_MACOSX_H_	base\atomicops-internals-macosx.h	37;"	d
BASE_HAS_ATOMIC64	base\atomicops-internals-macosx.h	52;"	d
MemoryBarrier	base\atomicops-internals-macosx.h	/^inline void MemoryBarrier() {$/;"	f	namespace:base::subtle
NoBarrier_AtomicExchange	base\atomicops-internals-macosx.h	/^inline Atomic32 NoBarrier_AtomicExchange(volatile Atomic32 *ptr,$/;"	f	namespace:base::subtle
NoBarrier_AtomicExchange	base\atomicops-internals-macosx.h	/^inline Atomic64 NoBarrier_AtomicExchange(volatile Atomic64 *ptr,$/;"	f	namespace:base::subtle
NoBarrier_CompareAndSwap	base\atomicops-internals-macosx.h	/^inline Atomic32 NoBarrier_CompareAndSwap(volatile Atomic32 *ptr,$/;"	f	namespace:base::subtle
NoBarrier_CompareAndSwap	base\atomicops-internals-macosx.h	/^inline Atomic64 NoBarrier_CompareAndSwap(volatile Atomic64 *ptr,$/;"	f	namespace:base::subtle
NoBarrier_Load	base\atomicops-internals-macosx.h	/^inline Atomic32 NoBarrier_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle
NoBarrier_Load	base\atomicops-internals-macosx.h	/^inline Atomic64 NoBarrier_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle
NoBarrier_Store	base\atomicops-internals-macosx.h	/^inline void NoBarrier_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle
NoBarrier_Store	base\atomicops-internals-macosx.h	/^inline void NoBarrier_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle
OSAtomicAdd64	base\atomicops-internals-macosx.h	/^inline int64_t OSAtomicAdd64(int64_t theAmount, int64_t *theValue) {$/;"	f	namespace:base::subtle
OSAtomicAdd64Barrier	base\atomicops-internals-macosx.h	/^inline int64_t OSAtomicAdd64Barrier($/;"	f	namespace:base::subtle
OSAtomicCompareAndSwap64	base\atomicops-internals-macosx.h	/^inline int64_t OSAtomicCompareAndSwap64($/;"	f	namespace:base::subtle
OSAtomicCompareAndSwap64Barrier	base\atomicops-internals-macosx.h	/^inline int64_t OSAtomicCompareAndSwap64Barrier($/;"	f	namespace:base::subtle
Release_AtomicExchange	base\atomicops-internals-macosx.h	/^inline Atomic32 Release_AtomicExchange(volatile Atomic32 *ptr,$/;"	f	namespace:base::subtle
Release_AtomicExchange	base\atomicops-internals-macosx.h	/^inline Atomic64 Release_AtomicExchange(volatile Atomic64 *ptr,$/;"	f	namespace:base::subtle
Release_CompareAndSwap	base\atomicops-internals-macosx.h	/^inline Atomic32 Release_CompareAndSwap(volatile Atomic32 *ptr,$/;"	f	namespace:base::subtle
Release_CompareAndSwap	base\atomicops-internals-macosx.h	/^inline Atomic64 Release_CompareAndSwap(volatile Atomic64 *ptr,$/;"	f	namespace:base::subtle
Release_Load	base\atomicops-internals-macosx.h	/^inline Atomic32 Release_Load(volatile const Atomic32 *ptr) {$/;"	f	namespace:base::subtle
Release_Load	base\atomicops-internals-macosx.h	/^inline Atomic64 Release_Load(volatile const Atomic64 *ptr) {$/;"	f	namespace:base::subtle
Release_Store	base\atomicops-internals-macosx.h	/^inline void Release_Store(volatile Atomic32 *ptr, Atomic32 value) {$/;"	f	namespace:base::subtle
Release_Store	base\atomicops-internals-macosx.h	/^inline void Release_Store(volatile Atomic64 *ptr, Atomic64 value) {$/;"	f	namespace:base::subtle
base	base\atomicops-internals-macosx.h	/^namespace base {$/;"	n
subtle	base\atomicops-internals-macosx.h	/^namespace subtle {$/;"	n	namespace:base
Acquire_AtomicExchange	base\atomicops-internals-mips.h	/^inline Atomic32 Acquire_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
Acquire_AtomicExchange	base\atomicops-internals-mips.h	/^inline Atomic64 Acquire_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
Acquire_CompareAndSwap	base\atomicops-internals-mips.h	/^inline Atomic32 Acquire_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
Acquire_CompareAndSwap	base\atomicops-internals-mips.h	/^inline Atomic64 Acquire_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
Acquire_Load	base\atomicops-internals-mips.h	/^inline Atomic32 Acquire_Load(volatile const Atomic32* ptr)$/;"	f	namespace:base::subtle
Acquire_Load	base\atomicops-internals-mips.h	/^inline Atomic64 Acquire_Load(volatile const Atomic64* ptr)$/;"	f	namespace:base::subtle
Acquire_Store	base\atomicops-internals-mips.h	/^inline void Acquire_Store(volatile Atomic32* ptr, Atomic32 value)$/;"	f	namespace:base::subtle
Acquire_Store	base\atomicops-internals-mips.h	/^inline void Acquire_Store(volatile Atomic64* ptr, Atomic64 value)$/;"	f	namespace:base::subtle
Atomic32	base\atomicops-internals-mips.h	/^typedef int32_t Atomic32;$/;"	t
Atomic64	base\atomicops-internals-mips.h	/^typedef int64_t Atomic64;$/;"	t	namespace:base::subtle
BASE_ATOMICOPS_INTERNALS_MIPS_H_	base\atomicops-internals-mips.h	40;"	d
BASE_HAS_ATOMIC64	base\atomicops-internals-mips.h	43;"	d
MemoryBarrier	base\atomicops-internals-mips.h	/^inline void MemoryBarrier()$/;"	f	namespace:base::subtle
NoBarrier_AtomicExchange	base\atomicops-internals-mips.h	/^inline Atomic32 NoBarrier_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
NoBarrier_AtomicExchange	base\atomicops-internals-mips.h	/^inline Atomic64 NoBarrier_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
NoBarrier_CompareAndSwap	base\atomicops-internals-mips.h	/^inline Atomic32 NoBarrier_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
NoBarrier_CompareAndSwap	base\atomicops-internals-mips.h	/^inline Atomic64 NoBarrier_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
NoBarrier_Load	base\atomicops-internals-mips.h	/^inline Atomic32 NoBarrier_Load(volatile const Atomic32* ptr)$/;"	f	namespace:base::subtle
NoBarrier_Load	base\atomicops-internals-mips.h	/^inline Atomic64 NoBarrier_Load(volatile const Atomic64* ptr)$/;"	f	namespace:base::subtle
NoBarrier_Store	base\atomicops-internals-mips.h	/^inline void NoBarrier_Store(volatile Atomic32* ptr, Atomic32 value)$/;"	f	namespace:base::subtle
NoBarrier_Store	base\atomicops-internals-mips.h	/^inline void NoBarrier_Store(volatile Atomic64* ptr, Atomic64 value)$/;"	f	namespace:base::subtle
Release_AtomicExchange	base\atomicops-internals-mips.h	/^inline Atomic32 Release_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
Release_AtomicExchange	base\atomicops-internals-mips.h	/^inline Atomic64 Release_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
Release_CompareAndSwap	base\atomicops-internals-mips.h	/^inline Atomic32 Release_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
Release_CompareAndSwap	base\atomicops-internals-mips.h	/^inline Atomic64 Release_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
Release_Load	base\atomicops-internals-mips.h	/^inline Atomic32 Release_Load(volatile const Atomic32* ptr)$/;"	f	namespace:base::subtle
Release_Load	base\atomicops-internals-mips.h	/^inline Atomic64 Release_Load(volatile const Atomic64* ptr)$/;"	f	namespace:base::subtle
Release_Store	base\atomicops-internals-mips.h	/^inline void Release_Store(volatile Atomic32* ptr, Atomic32 value)$/;"	f	namespace:base::subtle
Release_Store	base\atomicops-internals-mips.h	/^inline void Release_Store(volatile Atomic64* ptr, Atomic64 value)$/;"	f	namespace:base::subtle
base	base\atomicops-internals-mips.h	/^namespace base {$/;"	n
subtle	base\atomicops-internals-mips.h	/^namespace subtle {$/;"	n	namespace:base
Acquire_AtomicExchange	base\atomicops-internals-windows.h	/^inline Atomic32 Acquire_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
Acquire_AtomicExchange	base\atomicops-internals-windows.h	/^inline Atomic64 Acquire_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
Acquire_CompareAndSwap	base\atomicops-internals-windows.h	/^inline Atomic32 Acquire_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
Acquire_CompareAndSwap	base\atomicops-internals-windows.h	/^inline Atomic64 Acquire_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
Acquire_Load	base\atomicops-internals-windows.h	/^inline Atomic32 Acquire_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle
Acquire_Load	base\atomicops-internals-windows.h	/^inline Atomic64 Acquire_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle
Acquire_Store	base\atomicops-internals-windows.h	/^inline void Acquire_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle
Acquire_Store	base\atomicops-internals-windows.h	/^inline void Acquire_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle
Atomic32	base\atomicops-internals-windows.h	/^typedef int32 Atomic32;$/;"	t
Atomic64	base\atomicops-internals-windows.h	/^typedef int64 Atomic64;$/;"	t	namespace:base::subtle
BASE_ATOMICOPS_INTERNALS_WINDOWS_H_	base\atomicops-internals-windows.h	40;"	d
BASE_HAS_ATOMIC64	base\atomicops-internals-windows.h	49;"	d
FastInterlockedCompareExchange	base\atomicops-internals-windows.h	/^inline LONG FastInterlockedCompareExchange(volatile LONG* ptr,$/;"	f
FastInterlockedCompareExchangePointer	base\atomicops-internals-windows.h	/^inline PVOID FastInterlockedCompareExchangePointer(volatile PVOID* ptr,$/;"	f
FastInterlockedExchange	base\atomicops-internals-windows.h	/^inline LONG FastInterlockedExchange(volatile LONG* ptr, LONG newval) {$/;"	f
FastInterlockedExchangeAdd	base\atomicops-internals-windows.h	/^inline LONG FastInterlockedExchangeAdd(volatile LONG* ptr, LONG increment) {$/;"	f
FastInterlockedExchangeAdd64	base\atomicops-internals-windows.h	/^inline LONGLONG FastInterlockedExchangeAdd64(volatile LONGLONG* ptr,$/;"	f
FastInterlockedExchangePointer	base\atomicops-internals-windows.h	/^inline PVOID FastInterlockedExchangePointer(volatile PVOID* ptr, PVOID newval) {$/;"	f
MemoryBarrier	base\atomicops-internals-windows.h	/^inline void MemoryBarrier() {$/;"	f	namespace:base::subtle
MemoryBarrier	base\atomicops-internals-windows.h	/^inline void MemoryBarrier() {$/;"	f
NoBarrier_AtomicExchange	base\atomicops-internals-windows.h	/^inline Atomic32 NoBarrier_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
NoBarrier_AtomicExchange	base\atomicops-internals-windows.h	/^inline Atomic64 NoBarrier_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
NoBarrier_CompareAndSwap	base\atomicops-internals-windows.h	/^inline Atomic32 NoBarrier_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
NoBarrier_CompareAndSwap	base\atomicops-internals-windows.h	/^inline Atomic64 NoBarrier_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
NoBarrier_Load	base\atomicops-internals-windows.h	/^inline Atomic32 NoBarrier_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle
NoBarrier_Load	base\atomicops-internals-windows.h	/^inline Atomic64 NoBarrier_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle
NoBarrier_Load	base\atomicops-internals-windows.h	/^inline Atomic64 NoBarrier_Load(volatile const Atomic64* ptrValue)$/;"	f	namespace:base::subtle
NoBarrier_Store	base\atomicops-internals-windows.h	/^inline void NoBarrier_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle
NoBarrier_Store	base\atomicops-internals-windows.h	/^inline void NoBarrier_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle
NoBarrier_Store	base\atomicops-internals-windows.h	/^inline void NoBarrier_Store(volatile Atomic64* ptrValue, Atomic64 value)$/;"	f	namespace:base::subtle
NotImplementedFatalError	base\atomicops-internals-windows.h	/^inline void NotImplementedFatalError(const char *function_name) {$/;"	f	namespace:base::subtle
Release_AtomicExchange	base\atomicops-internals-windows.h	/^inline Atomic32 Release_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
Release_AtomicExchange	base\atomicops-internals-windows.h	/^inline Atomic64 Release_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
Release_CompareAndSwap	base\atomicops-internals-windows.h	/^inline Atomic32 Release_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
Release_CompareAndSwap	base\atomicops-internals-windows.h	/^inline Atomic64 Release_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
Release_Load	base\atomicops-internals-windows.h	/^inline Atomic32 Release_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle
Release_Load	base\atomicops-internals-windows.h	/^inline Atomic64 Release_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle
Release_Store	base\atomicops-internals-windows.h	/^inline void Release_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle
Release_Store	base\atomicops-internals-windows.h	/^inline void Release_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle
atomic_word_is_atomic	base\atomicops-internals-windows.h	/^COMPILE_ASSERT(sizeof(Atomic64) == sizeof(PVOID), atomic_word_is_atomic);$/;"	m	namespace:base::subtle
base	base\atomicops-internals-windows.h	/^namespace base {$/;"	n
sizeof	base\atomicops-internals-windows.h	/^COMPILE_ASSERT(sizeof(Atomic64) == sizeof(PVOID), atomic_word_is_atomic);$/;"	m	namespace:base::subtle
subtle	base\atomicops-internals-windows.h	/^namespace subtle {$/;"	n	namespace:base
AtomicOps_Internalx86CPUFeatures	base\atomicops-internals-x86.cc	/^struct AtomicOps_x86CPUFeatureStruct AtomicOps_Internalx86CPUFeatures = {$/;"	v	typeref:struct:AtomicOps_x86CPUFeatureStruct
AtomicOps_Internalx86CPUFeaturesInit	base\atomicops-internals-x86.cc	/^static void AtomicOps_Internalx86CPUFeaturesInit() {$/;"	f	file:
cpuid	base\atomicops-internals-x86.cc	52;"	d	file:
cpuid	base\atomicops-internals-x86.cc	58;"	d	file:
ATOMICOPS_COMPILER_BARRIER	base\atomicops-internals-x86.h	389;"	d
ATOMICOPS_COMPILER_BARRIER	base\atomicops-internals-x86.h	64;"	d
Acquire_AtomicExchange	base\atomicops-internals-x86.h	/^inline Atomic32 Acquire_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
Acquire_AtomicExchange	base\atomicops-internals-x86.h	/^inline Atomic64 Acquire_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
Acquire_CompareAndSwap	base\atomicops-internals-x86.h	/^inline Atomic32 Acquire_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
Acquire_CompareAndSwap	base\atomicops-internals-x86.h	/^inline Atomic64 Acquire_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
Acquire_Load	base\atomicops-internals-x86.h	/^inline Atomic32 Acquire_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle
Acquire_Load	base\atomicops-internals-x86.h	/^inline Atomic64 Acquire_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle
Acquire_Store	base\atomicops-internals-x86.h	/^inline void Acquire_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle
Acquire_Store	base\atomicops-internals-x86.h	/^inline void Acquire_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle
Atomic32	base\atomicops-internals-x86.h	/^typedef int32_t Atomic32;$/;"	t
Atomic64	base\atomicops-internals-x86.h	/^typedef int64_t Atomic64;$/;"	t	namespace:base::subtle
AtomicOps_x86CPUFeatureStruct	base\atomicops-internals-x86.h	/^struct AtomicOps_x86CPUFeatureStruct {$/;"	s
BASE_ATOMICOPS_INTERNALS_X86_H_	base\atomicops-internals-x86.h	40;"	d
BASE_HAS_ATOMIC64	base\atomicops-internals-x86.h	44;"	d
MemoryBarrier	base\atomicops-internals-x86.h	/^inline void MemoryBarrier() {$/;"	f	namespace:base::subtle
NoBarrier_AtomicExchange	base\atomicops-internals-x86.h	/^inline Atomic32 NoBarrier_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
NoBarrier_AtomicExchange	base\atomicops-internals-x86.h	/^inline Atomic64 NoBarrier_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
NoBarrier_CompareAndSwap	base\atomicops-internals-x86.h	/^inline Atomic32 NoBarrier_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
NoBarrier_CompareAndSwap	base\atomicops-internals-x86.h	/^inline Atomic64 NoBarrier_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
NoBarrier_Load	base\atomicops-internals-x86.h	/^inline Atomic32 NoBarrier_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle
NoBarrier_Load	base\atomicops-internals-x86.h	/^inline Atomic64 NoBarrier_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle
NoBarrier_Store	base\atomicops-internals-x86.h	/^inline void NoBarrier_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle
NoBarrier_Store	base\atomicops-internals-x86.h	/^inline void NoBarrier_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle
Release_AtomicExchange	base\atomicops-internals-x86.h	/^inline Atomic32 Release_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
Release_AtomicExchange	base\atomicops-internals-x86.h	/^inline Atomic64 Release_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
Release_CompareAndSwap	base\atomicops-internals-x86.h	/^inline Atomic32 Release_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle
Release_CompareAndSwap	base\atomicops-internals-x86.h	/^inline Atomic64 Release_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
Release_Load	base\atomicops-internals-x86.h	/^inline Atomic32 Release_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle
Release_Load	base\atomicops-internals-x86.h	/^inline Atomic64 Release_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle
Release_Store	base\atomicops-internals-x86.h	/^inline void Release_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle
Release_Store	base\atomicops-internals-x86.h	/^inline void Release_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle
__sync_val_compare_and_swap	base\atomicops-internals-x86.h	/^inline Atomic64 __sync_val_compare_and_swap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle
base	base\atomicops-internals-x86.h	/^namespace base {$/;"	n
has_cmpxchg16b	base\atomicops-internals-x86.h	/^  bool has_cmpxchg16b;      \/\/ Processor supports cmpxchg16b instruction.$/;"	m	struct:AtomicOps_x86CPUFeatureStruct
has_sse2	base\atomicops-internals-x86.h	/^  bool has_sse2;            \/\/ Processor has SSE2.$/;"	m	struct:AtomicOps_x86CPUFeatureStruct
subtle	base\atomicops-internals-x86.h	/^namespace subtle {$/;"	n	namespace:base
Acquire_AtomicExchange	base\atomicops.h	/^inline AtomicWord Acquire_AtomicExchange(volatile AtomicWord* ptr,$/;"	f	namespace:base::subtle
Acquire_CompareAndSwap	base\atomicops.h	/^inline Atomic32 Acquire_CompareAndSwap(volatile Atomic32* ptr,$/;"	f
Acquire_CompareAndSwap	base\atomicops.h	/^inline AtomicWord Acquire_CompareAndSwap(volatile AtomicWord* ptr,$/;"	f	namespace:base::subtle
Acquire_CompareAndSwap	base\atomicops.h	/^inline AtomicWord Acquire_CompareAndSwap(volatile AtomicWord* ptr,$/;"	f
Acquire_CompareAndSwap	base\atomicops.h	/^inline base::subtle::Atomic64 Acquire_CompareAndSwap($/;"	f
Acquire_Load	base\atomicops.h	/^inline Atomic32 Acquire_Load(volatile const Atomic32* ptr) {$/;"	f
Acquire_Load	base\atomicops.h	/^inline AtomicWord Acquire_Load(volatile const AtomicWord* ptr) {$/;"	f	namespace:base::subtle
Acquire_Load	base\atomicops.h	/^inline AtomicWord Acquire_Load(volatile const AtomicWord* ptr) {$/;"	f
Acquire_Load	base\atomicops.h	/^inline base::subtle::Atomic64 Acquire_Load($/;"	f
Acquire_Store	base\atomicops.h	/^inline void Acquire_Store($/;"	f
Acquire_Store	base\atomicops.h	/^inline void Acquire_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f
Acquire_Store	base\atomicops.h	/^inline void Acquire_Store(volatile AtomicWord* ptr, AtomicWord value) {$/;"	f	namespace:base::subtle
Acquire_Store	base\atomicops.h	/^inline void Acquire_Store(volatile AtomicWord* ptr, AtomicWord value) {$/;"	f
AtomicWord	base\atomicops.h	/^typedef intptr_t AtomicWord;$/;"	t
GCC_VERSION	base\atomicops.h	101;"	d
NoBarrier_AtomicExchange	base\atomicops.h	/^inline AtomicWord NoBarrier_AtomicExchange(volatile AtomicWord* ptr,$/;"	f	namespace:base::subtle
NoBarrier_CompareAndSwap	base\atomicops.h	/^inline AtomicWord NoBarrier_CompareAndSwap(volatile AtomicWord* ptr,$/;"	f	namespace:base::subtle
NoBarrier_Load	base\atomicops.h	/^inline AtomicWord NoBarrier_Load(volatile const AtomicWord *ptr) {$/;"	f	namespace:base::subtle
NoBarrier_Store	base\atomicops.h	/^inline void NoBarrier_Store(volatile AtomicWord *ptr, AtomicWord value) {$/;"	f	namespace:base::subtle
Release_AtomicExchange	base\atomicops.h	/^inline AtomicWord Release_AtomicExchange(volatile AtomicWord* ptr,$/;"	f	namespace:base::subtle
Release_CompareAndSwap	base\atomicops.h	/^inline Atomic32 Release_CompareAndSwap(volatile Atomic32* ptr,$/;"	f
Release_CompareAndSwap	base\atomicops.h	/^inline AtomicWord Release_CompareAndSwap(volatile AtomicWord* ptr,$/;"	f	namespace:base::subtle
Release_CompareAndSwap	base\atomicops.h	/^inline AtomicWord Release_CompareAndSwap(volatile AtomicWord* ptr,$/;"	f
Release_CompareAndSwap	base\atomicops.h	/^inline base::subtle::Atomic64 Release_CompareAndSwap($/;"	f
Release_Load	base\atomicops.h	/^inline Atomic32 Release_Load(volatile const Atomic32* ptr) {$/;"	f
Release_Load	base\atomicops.h	/^inline AtomicWord Release_Load(volatile const AtomicWord* ptr) {$/;"	f	namespace:base::subtle
Release_Load	base\atomicops.h	/^inline AtomicWord Release_Load(volatile const AtomicWord* ptr) {$/;"	f
Release_Load	base\atomicops.h	/^inline base::subtle::Atomic64 Release_Load($/;"	f
Release_Store	base\atomicops.h	/^inline void Release_Store($/;"	f
Release_Store	base\atomicops.h	/^inline void Release_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f
Release_Store	base\atomicops.h	/^inline void Release_Store(volatile AtomicWord* ptr, AtomicWord value) {$/;"	f	namespace:base::subtle
Release_Store	base\atomicops.h	/^inline void Release_Store(volatile AtomicWord* ptr, AtomicWord value) {$/;"	f
THREAD_ATOMICOPS_H_	base\atomicops.h	78;"	d
base	base\atomicops.h	/^namespace base {$/;"	n
subtle	base\atomicops.h	/^namespace subtle {$/;"	n	namespace:base
ATTRIBUTE_NOINLINE	base\basictypes.h	228;"	d
ATTRIBUTE_NOINLINE	base\basictypes.h	231;"	d
ATTRIBUTE_SECTION	base\basictypes.h	260;"	d
ATTRIBUTE_SECTION	base\basictypes.h	279;"	d
ATTRIBUTE_SECTION	base\basictypes.h	338;"	d
ATTRIBUTE_SECTION_START	base\basictypes.h	274;"	d
ATTRIBUTE_SECTION_START	base\basictypes.h	333;"	d
ATTRIBUTE_SECTION_START	base\basictypes.h	342;"	d
ATTRIBUTE_SECTION_STOP	base\basictypes.h	275;"	d
ATTRIBUTE_SECTION_STOP	base\basictypes.h	334;"	d
ATTRIBUTE_SECTION_STOP	base\basictypes.h	343;"	d
ATTRIBUTE_UNUSED	base\basictypes.h	190;"	d
ATTRIBUTE_UNUSED	base\basictypes.h	192;"	d
ATTRIBUTE_VISIBILITY_HIDDEN	base\basictypes.h	235;"	d
ATTRIBUTE_VISIBILITY_HIDDEN	base\basictypes.h	237;"	d
ATTRIBUTE_WEAK	base\basictypes.h	227;"	d
ATTRIBUTE_WEAK	base\basictypes.h	230;"	d
AssignAttributeStartEnd	base\basictypes.h	/^  AssignAttributeStartEnd(const char* name, char** pstart, char** pend) {$/;"	f	class:AssignAttributeStartEnd
AssignAttributeStartEnd	base\basictypes.h	/^class AssignAttributeStartEnd {$/;"	c
CACHELINE_ALIGNED	base\basictypes.h	/^} CACHELINE_ALIGNED;$/;"	v	typeref:union:MemoryAligner
CACHELINE_ALIGNED	base\basictypes.h	349;"	d
CACHELINE_ALIGNED	base\basictypes.h	351;"	d
CACHELINE_ALIGNED	base\basictypes.h	353;"	d
CACHELINE_ALIGNED	base\basictypes.h	356;"	d
CACHELINE_ALIGNED	base\basictypes.h	358;"	d
CACHELINE_ALIGNED	base\basictypes.h	361;"	d
CACHELINE_ALIGNED	base\basictypes.h	366;"	d
COMPILE_ASSERT	base\basictypes.h	195;"	d
CompileAssert	base\basictypes.h	/^struct CompileAssert {$/;"	s
DECLARE_ATTRIBUTE_SECTION_VARS	base\basictypes.h	265;"	d
DECLARE_ATTRIBUTE_SECTION_VARS	base\basictypes.h	320;"	d
DECLARE_ATTRIBUTE_SECTION_VARS	base\basictypes.h	339;"	d
DEFINE_ATTRIBUTE_SECTION_VARS	base\basictypes.h	269;"	d
DEFINE_ATTRIBUTE_SECTION_VARS	base\basictypes.h	329;"	d
DEFINE_ATTRIBUTE_SECTION_VARS	base\basictypes.h	341;"	d
DISALLOW_COPY_AND_ASSIGN	base\basictypes.h	127;"	d
DISALLOW_EVIL_CONSTRUCTORS	base\basictypes.h	122;"	d
GPRIuPTHREAD	base\basictypes.h	112;"	d
GPRIxPTHREAD	base\basictypes.h	113;"	d
HAVE_ATTRIBUTE_SECTION_START	base\basictypes.h	276;"	d
HAVE_ATTRIBUTE_SECTION_START	base\basictypes.h	335;"	d
INIT_ATTRIBUTE_SECTION_VARS	base\basictypes.h	268;"	d
INIT_ATTRIBUTE_SECTION_VARS	base\basictypes.h	324;"	d
INIT_ATTRIBUTE_SECTION_VARS	base\basictypes.h	340;"	d
LINKER_INITIALIZED	base\basictypes.h	/^enum LinkerInitialized { LINKER_INITIALIZED };$/;"	e	enum:base::LinkerInitialized
LinkerInitialized	base\basictypes.h	/^enum LinkerInitialized { LINKER_INITIALIZED };$/;"	g	namespace:base
MemoryAligner	base\basictypes.h	/^union MemoryAligner {$/;"	u
OFFSETOF_MEMBER	base\basictypes.h	200;"	d
PRINTABLE_PTHREAD	base\basictypes.h	115;"	d
PRINTABLE_PTHREAD	base\basictypes.h	117;"	d
PRId64	base\basictypes.h	99;"	d
PRIu64	base\basictypes.h	105;"	d
PRIx64	base\basictypes.h	93;"	d
PRIxPTR	base\basictypes.h	108;"	d
SCNd64	base\basictypes.h	102;"	d
SCNx64	base\basictypes.h	96;"	d
_BASICTYPES_H_	base\basictypes.h	32;"	d
arraysize	base\basictypes.h	198;"	d
base	base\basictypes.h	/^namespace base {$/;"	n
bit_cast	base\basictypes.h	/^inline Dest bit_cast(const Source& source) {$/;"	f
d	base\basictypes.h	/^  double d;$/;"	m	union:MemoryAligner
int16	base\basictypes.h	/^typedef int16_t             int16;$/;"	t
int32	base\basictypes.h	/^typedef int32_t             int32;$/;"	t
int64	base\basictypes.h	/^typedef int64_t             int64;$/;"	t
int8	base\basictypes.h	/^typedef int8_t              int8;$/;"	t
kint16max	base\basictypes.h	/^const  int16 kint16max  = (   ( int16) 0x7FFF);$/;"	v
kint16min	base\basictypes.h	/^const  int16 kint16min  = (   ( int16) 0x8000);$/;"	v
kint32max	base\basictypes.h	/^const  int32 kint32max  = (   ( int32) 0x7FFFFFFF);$/;"	v
kint32min	base\basictypes.h	/^const  int32 kint32min  = (   ( int32) 0x80000000);$/;"	v
kint64max	base\basictypes.h	/^const  int64 kint64max =  ( ((( int64) kint32max) << 32) | kuint32max );$/;"	v
kint64min	base\basictypes.h	/^const  int64 kint64min =  ( (((uint64) kint32min) << 32) | 0 );$/;"	v
kint8max	base\basictypes.h	/^const  int8  kint8max   = (   (  int8) 0x7F);$/;"	v
kint8min	base\basictypes.h	/^const  int8  kint8min   = (   (  int8) 0x80);$/;"	v
kuint16max	base\basictypes.h	/^const uint16 kuint16max = (   (uint16) 0xFFFF);$/;"	v
kuint32max	base\basictypes.h	/^const uint32 kuint32max = (   (uint32) 0xFFFFFFFF);$/;"	v
kuint64max	base\basictypes.h	/^const uint64 kuint64max = ( (((uint64) kuint32max) << 32) | kuint32max );$/;"	v
p	base\basictypes.h	/^  void*  p;$/;"	m	union:MemoryAligner
s	base\basictypes.h	/^  size_t s;$/;"	m	union:MemoryAligner
schar	base\basictypes.h	/^typedef signed char         schar;$/;"	t
uint16	base\basictypes.h	/^typedef uint16_t           uint16;$/;"	t
uint32	base\basictypes.h	/^typedef uint32_t           uint32;$/;"	t
uint64	base\basictypes.h	/^typedef uint64_t           uint64;$/;"	t
uint8	base\basictypes.h	/^typedef uint8_t            uint8;$/;"	t
BASE_COMMANDLINEFLAGS_H_	base\commandlineflags.h	50;"	d
DECLARE_VARIABLE	base\commandlineflags.h	58;"	d
DECLARE_bool	base\commandlineflags.h	72;"	d
DECLARE_double	base\commandlineflags.h	95;"	d
DECLARE_int32	base\commandlineflags.h	78;"	d
DECLARE_int64	base\commandlineflags.h	84;"	d
DECLARE_string	base\commandlineflags.h	102;"	d
DECLARE_uint64	base\commandlineflags.h	89;"	d
DEFINE_VARIABLE	base\commandlineflags.h	64;"	d
DEFINE_bool	base\commandlineflags.h	74;"	d
DEFINE_double	base\commandlineflags.h	97;"	d
DEFINE_int32	base\commandlineflags.h	80;"	d
DEFINE_int64	base\commandlineflags.h	86;"	d
DEFINE_string	base\commandlineflags.h	107;"	d
DEFINE_uint64	base\commandlineflags.h	91;"	d
EnvToBool	base\commandlineflags.h	154;"	d
EnvToDouble	base\commandlineflags.h	163;"	d
EnvToInt	base\commandlineflags.h	157;"	d
EnvToInt64	base\commandlineflags.h	160;"	d
EnvToString	base\commandlineflags.h	151;"	d
StringToBool	base\commandlineflags.h	/^    inline bool StringToBool(const char *value, bool def) {$/;"	f	namespace:tcmalloc::commandlineflags
StringToDouble	base\commandlineflags.h	/^    inline double StringToDouble(const char *value, double def) {$/;"	f	namespace:tcmalloc::commandlineflags
StringToInt	base\commandlineflags.h	/^    inline int StringToInt(const char *value, int def) {$/;"	f	namespace:tcmalloc::commandlineflags
StringToLongLong	base\commandlineflags.h	/^    inline long long StringToLongLong(const char *value, long long def) {$/;"	f	namespace:tcmalloc::commandlineflags
commandlineflags	base\commandlineflags.h	/^  namespace commandlineflags {$/;"	n	namespace:tcmalloc
tcmalloc	base\commandlineflags.h	/^namespace tcmalloc {$/;"	n
AnnotateBarrierDestroy	base\dynamic_annotations.c	/^void AnnotateBarrierDestroy(const char *file, int line,$/;"	f
AnnotateBarrierInit	base\dynamic_annotations.c	/^void AnnotateBarrierInit(const char *file, int line,$/;"	f
AnnotateBarrierWaitAfter	base\dynamic_annotations.c	/^void AnnotateBarrierWaitAfter(const char *file, int line,$/;"	f
AnnotateBarrierWaitBefore	base\dynamic_annotations.c	/^void AnnotateBarrierWaitBefore(const char *file, int line,$/;"	f
AnnotateBenignRace	base\dynamic_annotations.c	/^void AnnotateBenignRace(const char *file, int line,$/;"	f
AnnotateBenignRaceSized	base\dynamic_annotations.c	/^void AnnotateBenignRaceSized(const char *file, int line,$/;"	f
AnnotateCondVarSignal	base\dynamic_annotations.c	/^void AnnotateCondVarSignal(const char *file, int line,$/;"	f
AnnotateCondVarSignalAll	base\dynamic_annotations.c	/^void AnnotateCondVarSignalAll(const char *file, int line,$/;"	f
AnnotateCondVarWait	base\dynamic_annotations.c	/^void AnnotateCondVarWait(const char *file, int line,$/;"	f
AnnotateEnableRaceDetection	base\dynamic_annotations.c	/^void AnnotateEnableRaceDetection(const char *file, int line, int enable){}$/;"	f
AnnotateExpectRace	base\dynamic_annotations.c	/^void AnnotateExpectRace(const char *file, int line,$/;"	f
AnnotateFlushState	base\dynamic_annotations.c	/^void AnnotateFlushState(const char *file, int line){}$/;"	f
AnnotateIgnoreReadsBegin	base\dynamic_annotations.c	/^void AnnotateIgnoreReadsBegin(const char *file, int line){}$/;"	f
AnnotateIgnoreReadsEnd	base\dynamic_annotations.c	/^void AnnotateIgnoreReadsEnd(const char *file, int line){}$/;"	f
AnnotateIgnoreWritesBegin	base\dynamic_annotations.c	/^void AnnotateIgnoreWritesBegin(const char *file, int line){}$/;"	f
AnnotateIgnoreWritesEnd	base\dynamic_annotations.c	/^void AnnotateIgnoreWritesEnd(const char *file, int line){}$/;"	f
AnnotateMutexIsUsedAsCondVar	base\dynamic_annotations.c	/^void AnnotateMutexIsUsedAsCondVar(const char *file, int line,$/;"	f
AnnotateNewMemory	base\dynamic_annotations.c	/^void AnnotateNewMemory(const char *file, int line,$/;"	f
AnnotateNoOp	base\dynamic_annotations.c	/^void AnnotateNoOp(const char *file, int line,$/;"	f
AnnotatePCQCreate	base\dynamic_annotations.c	/^void AnnotatePCQCreate(const char *file, int line,$/;"	f
AnnotatePCQDestroy	base\dynamic_annotations.c	/^void AnnotatePCQDestroy(const char *file, int line,$/;"	f
AnnotatePCQGet	base\dynamic_annotations.c	/^void AnnotatePCQGet(const char *file, int line,$/;"	f
AnnotatePCQPut	base\dynamic_annotations.c	/^void AnnotatePCQPut(const char *file, int line,$/;"	f
AnnotatePublishMemoryRange	base\dynamic_annotations.c	/^void AnnotatePublishMemoryRange(const char *file, int line,$/;"	f
AnnotateRWLockAcquired	base\dynamic_annotations.c	/^void AnnotateRWLockAcquired(const char *file, int line,$/;"	f
AnnotateRWLockCreate	base\dynamic_annotations.c	/^void AnnotateRWLockCreate(const char *file, int line,$/;"	f
AnnotateRWLockDestroy	base\dynamic_annotations.c	/^void AnnotateRWLockDestroy(const char *file, int line,$/;"	f
AnnotateRWLockReleased	base\dynamic_annotations.c	/^void AnnotateRWLockReleased(const char *file, int line,$/;"	f
AnnotateThreadName	base\dynamic_annotations.c	/^void AnnotateThreadName(const char *file, int line,$/;"	f
AnnotateTraceMemory	base\dynamic_annotations.c	/^void AnnotateTraceMemory(const char *file, int line,$/;"	f
AnnotateUnpublishMemoryRange	base\dynamic_annotations.c	/^void AnnotateUnpublishMemoryRange(const char *file, int line,$/;"	f
DYNAMIC_ANNOTATIONS_EXTERNAL_IMPL	base\dynamic_annotations.c	59;"	d	file:
GetRunningOnValgrind	base\dynamic_annotations.c	/^static int GetRunningOnValgrind(void) {$/;"	f	file:
RunningOnValgrind	base\dynamic_annotations.c	/^int RunningOnValgrind(void) {$/;"	f
ValgrindSlowdown	base\dynamic_annotations.c	/^double ValgrindSlowdown(void) {$/;"	f
ANNOTALYSIS_IGNORE_READS_BEGIN	base\dynamic_annotations.h	381;"	d
ANNOTALYSIS_IGNORE_READS_BEGIN	base\dynamic_annotations.h	400;"	d
ANNOTALYSIS_IGNORE_READS_BEGIN	base\dynamic_annotations.h	401;"	d
ANNOTALYSIS_IGNORE_READS_END	base\dynamic_annotations.h	382;"	d
ANNOTALYSIS_IGNORE_READS_END	base\dynamic_annotations.h	402;"	d
ANNOTALYSIS_IGNORE_READS_END	base\dynamic_annotations.h	403;"	d
ANNOTALYSIS_IGNORE_WRITES_BEGIN	base\dynamic_annotations.h	383;"	d
ANNOTALYSIS_IGNORE_WRITES_BEGIN	base\dynamic_annotations.h	404;"	d
ANNOTALYSIS_IGNORE_WRITES_BEGIN	base\dynamic_annotations.h	405;"	d
ANNOTALYSIS_IGNORE_WRITES_END	base\dynamic_annotations.h	384;"	d
ANNOTALYSIS_IGNORE_WRITES_END	base\dynamic_annotations.h	406;"	d
ANNOTALYSIS_IGNORE_WRITES_END	base\dynamic_annotations.h	407;"	d
ANNOTALYSIS_ONLY	base\dynamic_annotations.h	391;"	d
ANNOTALYSIS_ONLY	base\dynamic_annotations.h	576;"	d
ANNOTALYSIS_SEMICOLON_OR_EMPTY_BODY	base\dynamic_annotations.h	380;"	d
ANNOTALYSIS_SEMICOLON_OR_EMPTY_BODY	base\dynamic_annotations.h	394;"	d
ANNOTALYSIS_SEMICOLON_OR_EMPTY_BODY	base\dynamic_annotations.h	395;"	d
ANNOTALYSIS_SEMICOLON_OR_EMPTY_BODY	base\dynamic_annotations.h	625;"	d
ANNOTALYSIS_STATIC_INLINE	base\dynamic_annotations.h	379;"	d
ANNOTALYSIS_STATIC_INLINE	base\dynamic_annotations.h	392;"	d
ANNOTALYSIS_STATIC_INLINE	base\dynamic_annotations.h	393;"	d
ANNOTALYSIS_STATIC_INLINE	base\dynamic_annotations.h	624;"	d
ANNOTALYSIS_UNPROTECTED_READ	base\dynamic_annotations.h	385;"	d
ANNOTALYSIS_UNPROTECTED_READ	base\dynamic_annotations.h	408;"	d
ANNOTALYSIS_UNPROTECTED_READ	base\dynamic_annotations.h	409;"	d
ANNOTATE_BARRIER_DESTROY	base\dynamic_annotations.h	309;"	d
ANNOTATE_BARRIER_DESTROY	base\dynamic_annotations.h	339;"	d
ANNOTATE_BARRIER_INIT	base\dynamic_annotations.h	296;"	d
ANNOTATE_BARRIER_INIT	base\dynamic_annotations.h	336;"	d
ANNOTATE_BARRIER_WAIT_AFTER	base\dynamic_annotations.h	305;"	d
ANNOTATE_BARRIER_WAIT_AFTER	base\dynamic_annotations.h	338;"	d
ANNOTATE_BARRIER_WAIT_BEFORE	base\dynamic_annotations.h	301;"	d
ANNOTATE_BARRIER_WAIT_BEFORE	base\dynamic_annotations.h	337;"	d
ANNOTATE_BENIGN_RACE	base\dynamic_annotations.h	206;"	d
ANNOTATE_BENIGN_RACE	base\dynamic_annotations.h	355;"	d
ANNOTATE_BENIGN_RACE_SIZED	base\dynamic_annotations.h	212;"	d
ANNOTATE_BENIGN_RACE_SIZED	base\dynamic_annotations.h	356;"	d
ANNOTATE_BENIGN_RACE_STATIC	base\dynamic_annotations.h	545;"	d
ANNOTATE_BENIGN_RACE_STATIC	base\dynamic_annotations.h	560;"	d
ANNOTATE_CONDVAR_LOCK_WAIT	base\dynamic_annotations.h	106;"	d
ANNOTATE_CONDVAR_LOCK_WAIT	base\dynamic_annotations.h	340;"	d
ANNOTATE_CONDVAR_SIGNAL	base\dynamic_annotations.h	116;"	d
ANNOTATE_CONDVAR_SIGNAL	base\dynamic_annotations.h	342;"	d
ANNOTATE_CONDVAR_SIGNAL_ALL	base\dynamic_annotations.h	120;"	d
ANNOTATE_CONDVAR_SIGNAL_ALL	base\dynamic_annotations.h	343;"	d
ANNOTATE_CONDVAR_WAIT	base\dynamic_annotations.h	111;"	d
ANNOTATE_CONDVAR_WAIT	base\dynamic_annotations.h	341;"	d
ANNOTATE_ENABLE_RACE_DETECTION	base\dynamic_annotations.h	252;"	d
ANNOTATE_ENABLE_RACE_DETECTION	base\dynamic_annotations.h	367;"	d
ANNOTATE_EXPECT_RACE	base\dynamic_annotations.h	317;"	d
ANNOTATE_EXPECT_RACE	base\dynamic_annotations.h	354;"	d
ANNOTATE_FLUSH_STATE	base\dynamic_annotations.h	326;"	d
ANNOTATE_FLUSH_STATE	base\dynamic_annotations.h	369;"	d
ANNOTATE_HAPPENS_AFTER	base\dynamic_annotations.h	125;"	d
ANNOTATE_HAPPENS_AFTER	base\dynamic_annotations.h	345;"	d
ANNOTATE_HAPPENS_BEFORE	base\dynamic_annotations.h	124;"	d
ANNOTATE_HAPPENS_BEFORE	base\dynamic_annotations.h	344;"	d
ANNOTATE_IGNORE_READS_AND_WRITES_BEGIN	base\dynamic_annotations.h	236;"	d
ANNOTATE_IGNORE_READS_AND_WRITES_BEGIN	base\dynamic_annotations.h	365;"	d
ANNOTATE_IGNORE_READS_AND_WRITES_BEGIN	base\dynamic_annotations.h	595;"	d
ANNOTATE_IGNORE_READS_AND_WRITES_BEGIN	base\dynamic_annotations.h	596;"	d
ANNOTATE_IGNORE_READS_AND_WRITES_END	base\dynamic_annotations.h	243;"	d
ANNOTATE_IGNORE_READS_AND_WRITES_END	base\dynamic_annotations.h	366;"	d
ANNOTATE_IGNORE_READS_AND_WRITES_END	base\dynamic_annotations.h	602;"	d
ANNOTATE_IGNORE_READS_AND_WRITES_END	base\dynamic_annotations.h	603;"	d
ANNOTATE_IGNORE_READS_BEGIN	base\dynamic_annotations.h	220;"	d
ANNOTATE_IGNORE_READS_BEGIN	base\dynamic_annotations.h	361;"	d
ANNOTATE_IGNORE_READS_BEGIN	base\dynamic_annotations.h	579;"	d
ANNOTATE_IGNORE_READS_BEGIN	base\dynamic_annotations.h	580;"	d
ANNOTATE_IGNORE_READS_END	base\dynamic_annotations.h	224;"	d
ANNOTATE_IGNORE_READS_END	base\dynamic_annotations.h	362;"	d
ANNOTATE_IGNORE_READS_END	base\dynamic_annotations.h	583;"	d
ANNOTATE_IGNORE_READS_END	base\dynamic_annotations.h	584;"	d
ANNOTATE_IGNORE_WRITES_BEGIN	base\dynamic_annotations.h	228;"	d
ANNOTATE_IGNORE_WRITES_BEGIN	base\dynamic_annotations.h	363;"	d
ANNOTATE_IGNORE_WRITES_BEGIN	base\dynamic_annotations.h	587;"	d
ANNOTATE_IGNORE_WRITES_BEGIN	base\dynamic_annotations.h	588;"	d
ANNOTATE_IGNORE_WRITES_END	base\dynamic_annotations.h	232;"	d
ANNOTATE_IGNORE_WRITES_END	base\dynamic_annotations.h	364;"	d
ANNOTATE_IGNORE_WRITES_END	base\dynamic_annotations.h	591;"	d
ANNOTATE_IGNORE_WRITES_END	base\dynamic_annotations.h	592;"	d
ANNOTATE_MUTEX_IS_USED_AS_CONDVAR	base\dynamic_annotations.h	159;"	d
ANNOTATE_MUTEX_IS_USED_AS_CONDVAR	base\dynamic_annotations.h	358;"	d
ANNOTATE_NEW_MEMORY	base\dynamic_annotations.h	170;"	d
ANNOTATE_NEW_MEMORY	base\dynamic_annotations.h	353;"	d
ANNOTATE_NO_OP	base\dynamic_annotations.h	321;"	d
ANNOTATE_NO_OP	base\dynamic_annotations.h	368;"	d
ANNOTATE_PCQ_CREATE	base\dynamic_annotations.h	181;"	d
ANNOTATE_PCQ_CREATE	base\dynamic_annotations.h	349;"	d
ANNOTATE_PCQ_DESTROY	base\dynamic_annotations.h	185;"	d
ANNOTATE_PCQ_DESTROY	base\dynamic_annotations.h	350;"	d
ANNOTATE_PCQ_GET	base\dynamic_annotations.h	194;"	d
ANNOTATE_PCQ_GET	base\dynamic_annotations.h	352;"	d
ANNOTATE_PCQ_PUT	base\dynamic_annotations.h	190;"	d
ANNOTATE_PCQ_PUT	base\dynamic_annotations.h	351;"	d
ANNOTATE_PUBLISH_MEMORY_RANGE	base\dynamic_annotations.h	134;"	d
ANNOTATE_PUBLISH_MEMORY_RANGE	base\dynamic_annotations.h	346;"	d
ANNOTATE_PURE_HAPPENS_BEFORE_MUTEX	base\dynamic_annotations.h	155;"	d
ANNOTATE_PURE_HAPPENS_BEFORE_MUTEX	base\dynamic_annotations.h	357;"	d
ANNOTATE_RWLOCK_ACQUIRED	base\dynamic_annotations.h	281;"	d
ANNOTATE_RWLOCK_ACQUIRED	base\dynamic_annotations.h	334;"	d
ANNOTATE_RWLOCK_CREATE	base\dynamic_annotations.h	272;"	d
ANNOTATE_RWLOCK_CREATE	base\dynamic_annotations.h	332;"	d
ANNOTATE_RWLOCK_DESTROY	base\dynamic_annotations.h	276;"	d
ANNOTATE_RWLOCK_DESTROY	base\dynamic_annotations.h	333;"	d
ANNOTATE_RWLOCK_RELEASED	base\dynamic_annotations.h	285;"	d
ANNOTATE_RWLOCK_RELEASED	base\dynamic_annotations.h	335;"	d
ANNOTATE_SWAP_MEMORY_RANGE	base\dynamic_annotations.h	142;"	d
ANNOTATE_SWAP_MEMORY_RANGE	base\dynamic_annotations.h	348;"	d
ANNOTATE_THREAD_NAME	base\dynamic_annotations.h	263;"	d
ANNOTATE_THREAD_NAME	base\dynamic_annotations.h	360;"	d
ANNOTATE_TRACE_MEMORY	base\dynamic_annotations.h	259;"	d
ANNOTATE_TRACE_MEMORY	base\dynamic_annotations.h	359;"	d
ANNOTATE_UNPROTECTED_READ	base\dynamic_annotations.h	559;"	d
ANNOTATE_UNPROTECTED_READ	base\dynamic_annotations.h	610;"	d
ANNOTATE_UNPUBLISH_MEMORY_RANGE	base\dynamic_annotations.h	138;"	d
ANNOTATE_UNPUBLISH_MEMORY_RANGE	base\dynamic_annotations.h	347;"	d
BASE_DYNAMIC_ANNOTATIONS_H_	base\dynamic_annotations.h	58;"	d
DYNAMIC_ANNOTATIONS_ENABLED	base\dynamic_annotations.h	61;"	d
CurrentElfClass	base\elf_mem_image.cc	/^typedef ElfClass<__WORDSIZE> CurrentElfClass;$/;"	t	namespace:base::__anon1	file:
ElfClass	base\elf_mem_image.cc	/^template <> class ElfClass<32> {$/;"	c	namespace:base::__anon1	file:
ElfClass	base\elf_mem_image.cc	/^template <> class ElfClass<64> {$/;"	c	namespace:base::__anon1	file:
ElfClass	base\elf_mem_image.cc	/^template <int N> class ElfClass {$/;"	c	namespace:base::__anon1	file:
ElfMemImage	base\elf_mem_image.cc	/^ElfMemImage::ElfMemImage(const void *base) {$/;"	f	class:base::ElfMemImage
ElfW	base\elf_mem_image.cc	/^  static int ElfBind(const ElfW(Sym) *) {$/;"	f	class:base::__anon1::ElfClass
ElfW	base\elf_mem_image.cc	/^  static int ElfType(const ElfW(Sym) *) {$/;"	f	class:base::__anon1::ElfClass
GetDynsym	base\elf_mem_image.cc	/^const ElfW(Sym) *ElfMemImage::GetDynsym(int index) const {$/;"	f	class:base::ElfMemImage
GetNumSymbols	base\elf_mem_image.cc	/^int ElfMemImage::GetNumSymbols() const {$/;"	f	class:base::ElfMemImage
GetPhdr	base\elf_mem_image.cc	/^const ElfW(Phdr) *ElfMemImage::GetPhdr(int index) const {$/;"	f	class:base::ElfMemImage
GetVerdef	base\elf_mem_image.cc	/^const ElfW(Verdef) *ElfMemImage::GetVerdef(int index) const {$/;"	f	class:base::ElfMemImage
GetVersym	base\elf_mem_image.cc	/^const ElfW(Versym) *ElfMemImage::GetVersym(int index) const {$/;"	f	class:base::ElfMemImage
Init	base\elf_mem_image.cc	/^void ElfMemImage::Init(const void *base) {$/;"	f	class:base::ElfMemImage
LookupSymbol	base\elf_mem_image.cc	/^bool ElfMemImage::LookupSymbol(const char *name,$/;"	f	class:base::ElfMemImage
LookupSymbolByAddress	base\elf_mem_image.cc	/^bool ElfMemImage::LookupSymbolByAddress(const void *address,$/;"	f	class:base::ElfMemImage
SymbolIterator	base\elf_mem_image.cc	/^ElfMemImage::SymbolIterator::SymbolIterator(const void *const image, int index)$/;"	f	class:base::ElfMemImage::SymbolIterator
Update	base\elf_mem_image.cc	/^void ElfMemImage::SymbolIterator::Update(int increment) {$/;"	f	class:base::ElfMemImage::SymbolIterator
VERSYM_VERSION	base\elf_mem_image.cc	55;"	d	file:
base	base\elf_mem_image.cc	/^namespace base {$/;"	n	file:
begin	base\elf_mem_image.cc	/^ElfMemImage::SymbolIterator ElfMemImage::begin() const {$/;"	f	class:base::ElfMemImage
ehdr	base\elf_mem_image.cc	/^const T* GetTableElement(const ElfW(Ehdr) *ehdr,$/;"	m	namespace:base::__anon1	file:
element_size	base\elf_mem_image.cc	/^                         ElfW(Word) element_size,$/;"	m	namespace:base::__anon1	file:
end	base\elf_mem_image.cc	/^ElfMemImage::SymbolIterator ElfMemImage::end() const {$/;"	f	class:base::ElfMemImage
kElfClass	base\elf_mem_image.cc	/^  static const int kElfClass = -1;$/;"	m	class:base::__anon1::ElfClass	file:
kElfClass	base\elf_mem_image.cc	/^  static const int kElfClass = ELFCLASS32;$/;"	m	class:base::__anon1::ElfClass	file:
kElfClass	base\elf_mem_image.cc	/^  static const int kElfClass = ELFCLASS64;$/;"	m	class:base::__anon1::ElfClass	file:
kInvalidBase	base\elf_mem_image.cc	/^const void *const ElfMemImage::kInvalidBase =$/;"	m	class:base::ElfMemImage	file:
operator !=	base\elf_mem_image.cc	/^bool ElfMemImage::SymbolIterator::operator!=(const SymbolIterator &rhs) const {$/;"	f	class:base::ElfMemImage::SymbolIterator
operator *	base\elf_mem_image.cc	/^const ElfMemImage::SymbolInfo& ElfMemImage::SymbolIterator::operator*() const {$/;"	f	class:base::ElfMemImage::SymbolIterator
operator ++	base\elf_mem_image.cc	/^ElfMemImage::SymbolIterator &ElfMemImage::SymbolIterator::operator++() {$/;"	f	class:base::ElfMemImage::SymbolIterator
operator ->	base\elf_mem_image.cc	/^const ElfMemImage::SymbolInfo *ElfMemImage::SymbolIterator::operator->() const {$/;"	f	class:base::ElfMemImage::SymbolIterator
operator ==	base\elf_mem_image.cc	/^bool ElfMemImage::SymbolIterator::operator==(const SymbolIterator &rhs) const {$/;"	f	class:base::ElfMemImage::SymbolIterator
table_offset	base\elf_mem_image.cc	/^                         ElfW(Off) table_offset,$/;"	m	namespace:base::__anon1	file:
BASE_ELF_MEM_IMAGE_H_	base\elf_mem_image.h	37;"	d
ElfMemImage	base\elf_mem_image.h	/^class ElfMemImage {$/;"	c	namespace:base
HAVE_ELF_MEM_IMAGE	base\elf_mem_image.h	48;"	d
IsPresent	base\elf_mem_image.h	/^  bool                 IsPresent() const { return ehdr_ != NULL; }$/;"	f	class:base::ElfMemImage
SymbolInfo	base\elf_mem_image.h	/^  struct SymbolInfo {$/;"	s	class:base::ElfMemImage
SymbolIterator	base\elf_mem_image.h	/^  class SymbolIterator {$/;"	c	class:base::ElfMemImage
address	base\elf_mem_image.h	/^    const void      *address;   \/\/ Relocated symbol address.$/;"	m	struct:base::ElfMemImage::SymbolInfo
base	base\elf_mem_image.h	/^namespace base {$/;"	n
dynstr_	base\elf_mem_image.h	/^  const char *dynstr_;$/;"	m	class:base::ElfMemImage
dynsym_	base\elf_mem_image.h	/^  const ElfW(Sym) *dynsym_;$/;"	m	class:base::ElfMemImage
ehdr_	base\elf_mem_image.h	/^  const ElfW(Ehdr) *ehdr_;$/;"	m	class:base::ElfMemImage
hash_	base\elf_mem_image.h	/^  const ElfW(Word) *hash_;$/;"	m	class:base::ElfMemImage
image_	base\elf_mem_image.h	/^    const void *const image_;$/;"	m	class:base::ElfMemImage::SymbolIterator
index_	base\elf_mem_image.h	/^    int index_;$/;"	m	class:base::ElfMemImage::SymbolIterator
info_	base\elf_mem_image.h	/^    SymbolInfo info_;$/;"	m	class:base::ElfMemImage::SymbolIterator
kInvalidBase	base\elf_mem_image.h	/^  static const void *const kInvalidBase;$/;"	m	class:base::ElfMemImage
link_base_	base\elf_mem_image.h	/^  ElfW(Addr) link_base_;     \/\/ Link-time base (p_vaddr of first PT_LOAD).$/;"	m	class:base::ElfMemImage
name	base\elf_mem_image.h	/^    const char      *name;      \/\/ E.g. "__vdso_getcpu"$/;"	m	struct:base::ElfMemImage::SymbolInfo
strsize_	base\elf_mem_image.h	/^  size_t strsize_;$/;"	m	class:base::ElfMemImage
symbol	base\elf_mem_image.h	/^    const ElfW(Sym) *symbol;    \/\/ Symbol in the dynamic symbol table.$/;"	m	struct:base::ElfMemImage::SymbolInfo
verdef_	base\elf_mem_image.h	/^  const ElfW(Verdef) *verdef_;$/;"	m	class:base::ElfMemImage
verdefnum_	base\elf_mem_image.h	/^  size_t verdefnum_;$/;"	m	class:base::ElfMemImage
version	base\elf_mem_image.h	/^    const char      *version;   \/\/ E.g. "LINUX_2.6", could be ""$/;"	m	struct:base::ElfMemImage::SymbolInfo
versym_	base\elf_mem_image.h	/^  const ElfW(Versym) *versym_;$/;"	m	class:base::ElfMemImage
BP	base\elfcore.h	70;"	d
BP	base\elfcore.h	94;"	d
DUMPER	base\elfcore.h	56;"	d
FRAME	base\elfcore.h	139;"	d
FRAME	base\elfcore.h	192;"	d
FRAME	base\elfcore.h	257;"	d
FRAME	base\elfcore.h	289;"	d
FRAME	base\elfcore.h	351;"	d
Frame	base\elfcore.h	/^  typedef struct Frame {$/;"	s
Frame	base\elfcore.h	/^  } Frame;$/;"	t	typeref:struct:Frame
IP	base\elfcore.h	115;"	d
IP	base\elfcore.h	72;"	d
IP	base\elfcore.h	96;"	d
LR	base\elfcore.h	116;"	d
LR	base\elfcore.h	97;"	d
MIPSREG	base\elfcore.h	288;"	d
SET_FRAME	base\elfcore.h	180;"	d
SET_FRAME	base\elfcore.h	241;"	d
SET_FRAME	base\elfcore.h	271;"	d
SET_FRAME	base\elfcore.h	334;"	d
SET_FRAME	base\elfcore.h	352;"	d
SP	base\elfcore.h	114;"	d
SP	base\elfcore.h	71;"	d
SP	base\elfcore.h	95;"	d
_ELFCORE_H	base\elfcore.h	36;"	d
arm	base\elfcore.h	/^    struct arm_regs arm;$/;"	m	struct:Frame	typeref:struct:Frame::arm_regs
arm_regs	base\elfcore.h	/^  typedef struct arm_regs {     \/* General purpose registers                 *\/$/;"	s
arm_regs	base\elfcore.h	/^  } arm_regs;$/;"	t	typeref:struct:arm_regs
ccr	base\elfcore.h	/^    unsigned long ccr;$/;"	m	struct:ppc_regs
cp0_badvaddr	base\elfcore.h	/^    unsigned long cp0_badvaddr;$/;"	m	struct:mips_regs
cp0_cause	base\elfcore.h	/^    unsigned long cp0_cause;$/;"	m	struct:mips_regs
cp0_epc	base\elfcore.h	/^    unsigned long cp0_epc;      \/* Program counter.                          *\/$/;"	m	struct:mips_regs
cp0_status	base\elfcore.h	/^    unsigned long cp0_status;$/;"	m	struct:mips_regs
cs	base\elfcore.h	/^    uint64_t  rip,cs,eflags;$/;"	m	struct:i386_regs
ctr	base\elfcore.h	/^    unsigned long ctr;$/;"	m	struct:ppc_regs
ds	base\elfcore.h	/^    uint64_t  ds,es,fs,gs;$/;"	m	struct:i386_regs
eflags	base\elfcore.h	/^    uint64_t  rip,cs,eflags;$/;"	m	struct:i386_regs
errno_	base\elfcore.h	/^    int              errno_;$/;"	m	struct:Frame
errno_	base\elfcore.h	/^    int             errno_;$/;"	m	struct:Frame
es	base\elfcore.h	/^    uint64_t  ds,es,fs,gs;$/;"	m	struct:i386_regs
fpr	base\elfcore.h	/^    double        fpr[32];	\/* Floating-Point Registers - f0-f31.        *\/$/;"	m	struct:ppc_regs
fs	base\elfcore.h	/^    uint64_t  ds,es,fs,gs;$/;"	m	struct:i386_regs
fs_base	base\elfcore.h	/^    uint64_t  fs_base, gs_base;$/;"	m	struct:i386_regs
gs	base\elfcore.h	/^    uint64_t  ds,es,fs,gs;$/;"	m	struct:i386_regs
gs_base	base\elfcore.h	/^    uint64_t  fs_base, gs_base;$/;"	m	struct:i386_regs
hi	base\elfcore.h	/^    unsigned long hi;           \/* Used for multiplication and division.     *\/$/;"	m	struct:mips_regs
i386_regs	base\elfcore.h	/^  typedef struct i386_regs {    \/* Normal (non-FPU) CPU registers            *\/$/;"	s
i386_regs	base\elfcore.h	/^  } i386_regs;$/;"	t	typeref:struct:i386_regs
lo	base\elfcore.h	/^    unsigned long lo;$/;"	m	struct:mips_regs
lr	base\elfcore.h	/^    unsigned long lr;$/;"	m	struct:ppc_regs
mips_regs	base\elfcore.h	/^    struct mips_regs mips_regs;$/;"	m	struct:Frame	typeref:struct:Frame::mips_regs
mips_regs	base\elfcore.h	/^  typedef struct mips_regs {$/;"	s
mips_regs	base\elfcore.h	/^  } mips_regs;$/;"	t	typeref:struct:mips_regs
mq	base\elfcore.h	/^    unsigned long mq;$/;"	m	struct:ppc_regs
msr	base\elfcore.h	/^    unsigned long msr;$/;"	m	struct:ppc_regs
orig_rax	base\elfcore.h	/^    uint64_t  r9,r8,rax,rcx,rdx,rsi,rdi,orig_rax;$/;"	m	struct:i386_regs
pad	base\elfcore.h	/^    unsigned long pad[6];       \/* Unused padding to match kernel structures *\/$/;"	m	struct:mips_regs
ppc_regs	base\elfcore.h	/^  typedef struct ppc_regs {$/;"	s
ppc_regs	base\elfcore.h	/^  } ppc_regs;$/;"	t	typeref:struct:ppc_regs
r10	base\elfcore.h	/^    uint64_t  r15,r14,r13,r12,rbp,rbx,r11,r10;$/;"	m	struct:i386_regs
r11	base\elfcore.h	/^    uint64_t  r15,r14,r13,r12,rbp,rbx,r11,r10;$/;"	m	struct:i386_regs
r12	base\elfcore.h	/^    uint64_t  r15,r14,r13,r12,rbp,rbx,r11,r10;$/;"	m	struct:i386_regs
r13	base\elfcore.h	/^    uint64_t  r15,r14,r13,r12,rbp,rbx,r11,r10;$/;"	m	struct:i386_regs
r14	base\elfcore.h	/^    uint64_t  r15,r14,r13,r12,rbp,rbx,r11,r10;$/;"	m	struct:i386_regs
r15	base\elfcore.h	/^    uint64_t  r15,r14,r13,r12,rbp,rbx,r11,r10;$/;"	m	struct:i386_regs
r8	base\elfcore.h	/^    uint64_t  r9,r8,rax,rcx,rdx,rsi,rdi,orig_rax;$/;"	m	struct:i386_regs
r9	base\elfcore.h	/^    uint64_t  r9,r8,rax,rcx,rdx,rsi,rdi,orig_rax;$/;"	m	struct:i386_regs
rax	base\elfcore.h	/^    uint64_t  r9,r8,rax,rcx,rdx,rsi,rdi,orig_rax;$/;"	m	struct:i386_regs
rbp	base\elfcore.h	/^    uint64_t  r15,r14,r13,r12,rbp,rbx,r11,r10;$/;"	m	struct:i386_regs
rbx	base\elfcore.h	/^    uint64_t  r15,r14,r13,r12,rbp,rbx,r11,r10;$/;"	m	struct:i386_regs
rcx	base\elfcore.h	/^    uint64_t  r9,r8,rax,rcx,rdx,rsi,rdi,orig_rax;$/;"	m	struct:i386_regs
rdi	base\elfcore.h	/^    uint64_t  r9,r8,rax,rcx,rdx,rsi,rdi,orig_rax;$/;"	m	struct:i386_regs
rdx	base\elfcore.h	/^    uint64_t  r9,r8,rax,rcx,rdx,rsi,rdi,orig_rax;$/;"	m	struct:i386_regs
rip	base\elfcore.h	/^    uint64_t  rip,cs,eflags;$/;"	m	struct:i386_regs
rip	base\elfcore.h	/^    unsigned long rip;		\/* Program counter.                          *\/$/;"	m	struct:ppc_regs
rsi	base\elfcore.h	/^    uint64_t  r9,r8,rax,rcx,rdx,rsi,rdi,orig_rax;$/;"	m	struct:i386_regs
rsp	base\elfcore.h	/^    uint64_t  rsp,ss;$/;"	m	struct:i386_regs
ss	base\elfcore.h	/^    uint64_t  rsp,ss;$/;"	m	struct:i386_regs
tid	base\elfcore.h	/^    pid_t            tid;$/;"	m	struct:Frame
tid	base\elfcore.h	/^    pid_t           tid;$/;"	m	struct:Frame
tid	base\elfcore.h	/^    pid_t tid;$/;"	m	struct:Frame
unused	base\elfcore.h	/^    unsigned long unused;$/;"	m	struct:mips_regs
uregs	base\elfcore.h	/^    long uregs[18];$/;"	m	struct:arm_regs
uregs	base\elfcore.h	/^    struct i386_regs uregs;$/;"	m	struct:Frame	typeref:struct:Frame::i386_regs
uregs	base\elfcore.h	/^    unsigned long uregs[32];	\/* General Purpose Registers - r0-r31.       *\/$/;"	m	struct:ppc_regs
uregs	base\elfcore.h	/^    unsigned long uregs[32];    \/* General purpose registers.                *\/$/;"	m	struct:mips_regs
xeq	base\elfcore.h	/^    unsigned long xeq;$/;"	m	struct:ppc_regs
GoogleInitializer	base\googleinit.h	/^  GoogleInitializer(const char* name, VoidFunction ctor, VoidFunction dtor)$/;"	f	class:GoogleInitializer
GoogleInitializer	base\googleinit.h	/^class GoogleInitializer {$/;"	c
REGISTER_MODULE_DESTRUCTOR	base\googleinit.h	66;"	d
REGISTER_MODULE_INITIALIZER	base\googleinit.h	59;"	d
VoidFunction	base\googleinit.h	/^  typedef void (*VoidFunction)(void);$/;"	t	class:GoogleInitializer
_GOOGLEINIT_H	base\googleinit.h	35;"	d
destructor_	base\googleinit.h	/^  const VoidFunction destructor_;$/;"	m	class:GoogleInitializer
name_	base\googleinit.h	/^  const char* const name_;$/;"	m	class:GoogleInitializer
~GoogleInitializer	base\googleinit.h	/^  ~GoogleInitializer() {$/;"	f	class:GoogleInitializer
AT_FDCWD	base\linux_syscall_support.h	535;"	d
AT_REMOVEDIR	base\linux_syscall_support.h	541;"	d
AT_SYMLINK_NOFOLLOW	base\linux_syscall_support.h	538;"	d
CFI_ADJUST_CFA_OFFSET	base\linux_syscall_support.h	963;"	d
CFI_ADJUST_CFA_OFFSET	base\linux_syscall_support.h	966;"	d
FRAME_MIN_SIZE	base\linux_syscall_support.h	1968;"	d
FRAME_TOC_SAVE	base\linux_syscall_support.h	1969;"	d
GETDENTS	base\linux_syscall_support.h	2368;"	d
KERNEL_DIRENT	base\linux_syscall_support.h	2367;"	d
KERNEL_NSIG	base\linux_syscall_support.h	278;"	d
KERNEL_NSIG	base\linux_syscall_support.h	280;"	d
LSS_ASMINPUT_0	base\linux_syscall_support.h	1877;"	d
LSS_ASMINPUT_0	base\linux_syscall_support.h	1878;"	d
LSS_ASMINPUT_1	base\linux_syscall_support.h	1879;"	d
LSS_ASMINPUT_1	base\linux_syscall_support.h	1880;"	d
LSS_ASMINPUT_2	base\linux_syscall_support.h	1881;"	d
LSS_ASMINPUT_2	base\linux_syscall_support.h	1882;"	d
LSS_ASMINPUT_3	base\linux_syscall_support.h	1883;"	d
LSS_ASMINPUT_3	base\linux_syscall_support.h	1884;"	d
LSS_ASMINPUT_4	base\linux_syscall_support.h	1885;"	d
LSS_ASMINPUT_4	base\linux_syscall_support.h	1886;"	d
LSS_ASMINPUT_5	base\linux_syscall_support.h	1887;"	d
LSS_ASMINPUT_5	base\linux_syscall_support.h	1888;"	d
LSS_ASMINPUT_6	base\linux_syscall_support.h	1889;"	d
LSS_ASMINPUT_6	base\linux_syscall_support.h	1890;"	d
LSS_BODY	base\linux_syscall_support.h	1231;"	d
LSS_BODY	base\linux_syscall_support.h	1232;"	d
LSS_BODY	base\linux_syscall_support.h	1448;"	d
LSS_BODY	base\linux_syscall_support.h	1449;"	d
LSS_BODY	base\linux_syscall_support.h	1636;"	d
LSS_BODY	base\linux_syscall_support.h	1637;"	d
LSS_BODY	base\linux_syscall_support.h	1891;"	d
LSS_BODY	base\linux_syscall_support.h	1892;"	d
LSS_BODY	base\linux_syscall_support.h	2120;"	d
LSS_BODY	base\linux_syscall_support.h	2121;"	d
LSS_BODY	base\linux_syscall_support.h	2242;"	d
LSS_BODY	base\linux_syscall_support.h	2243;"	d
LSS_BODY	base\linux_syscall_support.h	977;"	d
LSS_BODY	base\linux_syscall_support.h	978;"	d
LSS_BODY_ARG0	base\linux_syscall_support.h	1265;"	d
LSS_BODY_ARG0	base\linux_syscall_support.h	1272;"	d
LSS_BODY_ARG1	base\linux_syscall_support.h	1266;"	d
LSS_BODY_ARG1	base\linux_syscall_support.h	1273;"	d
LSS_BODY_ARG2	base\linux_syscall_support.h	1267;"	d
LSS_BODY_ARG2	base\linux_syscall_support.h	1275;"	d
LSS_BODY_ARG3	base\linux_syscall_support.h	1268;"	d
LSS_BODY_ARG3	base\linux_syscall_support.h	1277;"	d
LSS_BODY_ARG4	base\linux_syscall_support.h	1269;"	d
LSS_BODY_ARG4	base\linux_syscall_support.h	1279;"	d
LSS_BODY_ARG5	base\linux_syscall_support.h	1270;"	d
LSS_BODY_ARG5	base\linux_syscall_support.h	1281;"	d
LSS_BODY_ARG6	base\linux_syscall_support.h	1271;"	d
LSS_BODY_ARG6	base\linux_syscall_support.h	1283;"	d
LSS_BODY_ASM0	base\linux_syscall_support.h	1235;"	d
LSS_BODY_ASM0	base\linux_syscall_support.h	1242;"	d
LSS_BODY_ASM1	base\linux_syscall_support.h	1236;"	d
LSS_BODY_ASM1	base\linux_syscall_support.h	1243;"	d
LSS_BODY_ASM2	base\linux_syscall_support.h	1237;"	d
LSS_BODY_ASM2	base\linux_syscall_support.h	1244;"	d
LSS_BODY_ASM3	base\linux_syscall_support.h	1238;"	d
LSS_BODY_ASM3	base\linux_syscall_support.h	1245;"	d
LSS_BODY_ASM4	base\linux_syscall_support.h	1239;"	d
LSS_BODY_ASM4	base\linux_syscall_support.h	1246;"	d
LSS_BODY_ASM5	base\linux_syscall_support.h	1240;"	d
LSS_BODY_ASM5	base\linux_syscall_support.h	1247;"	d
LSS_BODY_ASM6	base\linux_syscall_support.h	1241;"	d
LSS_BODY_ASM6	base\linux_syscall_support.h	1248;"	d
LSS_BODY_CLOBBER0	base\linux_syscall_support.h	1250;"	d
LSS_BODY_CLOBBER0	base\linux_syscall_support.h	1257;"	d
LSS_BODY_CLOBBER1	base\linux_syscall_support.h	1251;"	d
LSS_BODY_CLOBBER1	base\linux_syscall_support.h	1258;"	d
LSS_BODY_CLOBBER2	base\linux_syscall_support.h	1252;"	d
LSS_BODY_CLOBBER2	base\linux_syscall_support.h	1259;"	d
LSS_BODY_CLOBBER3	base\linux_syscall_support.h	1253;"	d
LSS_BODY_CLOBBER3	base\linux_syscall_support.h	1260;"	d
LSS_BODY_CLOBBER4	base\linux_syscall_support.h	1254;"	d
LSS_BODY_CLOBBER4	base\linux_syscall_support.h	1261;"	d
LSS_BODY_CLOBBER5	base\linux_syscall_support.h	1255;"	d
LSS_BODY_CLOBBER5	base\linux_syscall_support.h	1262;"	d
LSS_BODY_CLOBBER6	base\linux_syscall_support.h	1256;"	d
LSS_BODY_CLOBBER6	base\linux_syscall_support.h	1263;"	d
LSS_ENTRYPOINT	base\linux_syscall_support.h	1200;"	d
LSS_ENTRYPOINT	base\linux_syscall_support.h	1201;"	d
LSS_ERRNO	base\linux_syscall_support.h	873;"	d
LSS_ERRNO	base\linux_syscall_support.h	878;"	d
LSS_ERRNO	base\linux_syscall_support.h	880;"	d
LSS_INLINE	base\linux_syscall_support.h	883;"	d
LSS_INLINE	base\linux_syscall_support.h	885;"	d
LSS_INLINE	base\linux_syscall_support.h	887;"	d
LSS_LOADARGS_0	base\linux_syscall_support.h	1850;"	d
LSS_LOADARGS_0	base\linux_syscall_support.h	1851;"	d
LSS_LOADARGS_1	base\linux_syscall_support.h	1853;"	d
LSS_LOADARGS_1	base\linux_syscall_support.h	1854;"	d
LSS_LOADARGS_2	base\linux_syscall_support.h	1857;"	d
LSS_LOADARGS_2	base\linux_syscall_support.h	1858;"	d
LSS_LOADARGS_3	base\linux_syscall_support.h	1861;"	d
LSS_LOADARGS_3	base\linux_syscall_support.h	1862;"	d
LSS_LOADARGS_4	base\linux_syscall_support.h	1865;"	d
LSS_LOADARGS_4	base\linux_syscall_support.h	1866;"	d
LSS_LOADARGS_5	base\linux_syscall_support.h	1869;"	d
LSS_LOADARGS_5	base\linux_syscall_support.h	1870;"	d
LSS_LOADARGS_6	base\linux_syscall_support.h	1873;"	d
LSS_LOADARGS_6	base\linux_syscall_support.h	1874;"	d
LSS_LOAD_ARG	base\linux_syscall_support.h	1445;"	d
LSS_LOAD_ARG	base\linux_syscall_support.h	1446;"	d
LSS_NAME	base\linux_syscall_support.h	/^    LSS_INLINE void (*LSS_NAME(restore)(void))(void) {$/;"	f
LSS_NAME	base\linux_syscall_support.h	/^    LSS_INLINE void (*LSS_NAME(restore_rt)(void))(void) {$/;"	f
LSS_NAME	base\linux_syscall_support.h	893;"	d
LSS_NAME	base\linux_syscall_support.h	895;"	d
LSS_NAME	base\linux_syscall_support.h	897;"	d
LSS_NAME	base\linux_syscall_support.h	899;"	d
LSS_NAME	base\linux_syscall_support.h	901;"	d
LSS_NAME	base\linux_syscall_support.h	903;"	d
LSS_NAME	base\linux_syscall_support.h	905;"	d
LSS_NAME	base\linux_syscall_support.h	907;"	d
LSS_NAME	base\linux_syscall_support.h	909;"	d
LSS_NAME	base\linux_syscall_support.h	911;"	d
LSS_NAME	base\linux_syscall_support.h	913;"	d
LSS_NAME	base\linux_syscall_support.h	915;"	d
LSS_NAME	base\linux_syscall_support.h	917;"	d
LSS_REG	base\linux_syscall_support.h	1435;"	d
LSS_REG	base\linux_syscall_support.h	1436;"	d
LSS_REG	base\linux_syscall_support.h	1622;"	d
LSS_REG	base\linux_syscall_support.h	1623;"	d
LSS_REG	base\linux_syscall_support.h	2118;"	d
LSS_REG	base\linux_syscall_support.h	2119;"	d
LSS_REG	base\linux_syscall_support.h	2240;"	d
LSS_REG	base\linux_syscall_support.h	2241;"	d
LSS_RETURN	base\linux_syscall_support.h	1220;"	d
LSS_RETURN	base\linux_syscall_support.h	1221;"	d
LSS_RETURN	base\linux_syscall_support.h	920;"	d
LSS_RETURN	base\linux_syscall_support.h	926;"	d
LSS_RETURN	base\linux_syscall_support.h	938;"	d
LSS_RETURN	base\linux_syscall_support.h	950;"	d
LSS_SAVE_ARG	base\linux_syscall_support.h	1443;"	d
LSS_SAVE_ARG	base\linux_syscall_support.h	1444;"	d
LSS_SYSCALL_ARG	base\linux_syscall_support.h	1209;"	d
LSS_SYSCALL_ARG	base\linux_syscall_support.h	1210;"	d
MIPS_SYSCALL_CLOBBERS	base\linux_syscall_support.h	1629;"	d
MIPS_SYSCALL_CLOBBERS	base\linux_syscall_support.h	1632;"	d
MREMAP_FIXED	base\linux_syscall_support.h	544;"	d
O_DIRECTORY	base\linux_syscall_support.h	523;"	d
O_DIRECTORY	base\linux_syscall_support.h	525;"	d
PR_GET_DUMPABLE	base\linux_syscall_support.h	529;"	d
PR_SET_DUMPABLE	base\linux_syscall_support.h	532;"	d
SA_RESTORER	base\linux_syscall_support.h	547;"	d
SYS_LINUX_SYSCALL_SUPPORT_H	base\linux_syscall_support.h	131;"	d
_LSS_BODY	base\linux_syscall_support.h	1223;"	d
_LSS_BODY	base\linux_syscall_support.h	1224;"	d
_LSS_RETURN	base\linux_syscall_support.h	1211;"	d
_LSS_RETURN	base\linux_syscall_support.h	1212;"	d
__NR__exit	base\linux_syscall_support.h	2350;"	d
__NR__gettid	base\linux_syscall_support.h	2351;"	d
__NR__mremap	base\linux_syscall_support.h	2352;"	d
__NR__sigaction	base\linux_syscall_support.h	2548;"	d
__NR__sigprocmask	base\linux_syscall_support.h	2549;"	d
__NR_clock_getres	base\linux_syscall_support.h	826;"	d
__NR_clock_gettime	base\linux_syscall_support.h	823;"	d
__NR_fadvise64	base\linux_syscall_support.h	820;"	d
__NR_fallocate	base\linux_syscall_support.h	856;"	d
__NR_fstat64	base\linux_syscall_support.h	559;"	d
__NR_fstat64	base\linux_syscall_support.h	603;"	d
__NR_fstat64	base\linux_syscall_support.h	639;"	d
__NR_fstat64	base\linux_syscall_support.h	705;"	d
__NR_fstatat	base\linux_syscall_support.h	654;"	d
__NR_fstatat	base\linux_syscall_support.h	671;"	d
__NR_fstatat	base\linux_syscall_support.h	688;"	d
__NR_fstatat	base\linux_syscall_support.h	728;"	d
__NR_fstatfs64	base\linux_syscall_support.h	832;"	d
__NR_futex	base\linux_syscall_support.h	568;"	d
__NR_futex	base\linux_syscall_support.h	612;"	d
__NR_futex	base\linux_syscall_support.h	620;"	d
__NR_futex	base\linux_syscall_support.h	648;"	d
__NR_futex	base\linux_syscall_support.h	665;"	d
__NR_futex	base\linux_syscall_support.h	682;"	d
__NR_futex	base\linux_syscall_support.h	717;"	d
__NR_futex	base\linux_syscall_support.h	808;"	d
__NR_getcpu	base\linux_syscall_support.h	574;"	d
__NR_getcpu	base\linux_syscall_support.h	657;"	d
__NR_getcpu	base\linux_syscall_support.h	674;"	d
__NR_getcpu	base\linux_syscall_support.h	691;"	d
__NR_getcpu	base\linux_syscall_support.h	723;"	d
__NR_getcpu	base\linux_syscall_support.h	853;"	d
__NR_getdents64	base\linux_syscall_support.h	562;"	d
__NR_getdents64	base\linux_syscall_support.h	606;"	d
__NR_getdents64	base\linux_syscall_support.h	623;"	d
__NR_getdents64	base\linux_syscall_support.h	642;"	d
__NR_getdents64	base\linux_syscall_support.h	711;"	d
__NR_getdents64	base\linux_syscall_support.h	778;"	d
__NR_getresgid	base\linux_syscall_support.h	769;"	d
__NR_getresuid	base\linux_syscall_support.h	763;"	d
__NR_getrlimit	base\linux_syscall_support.h	757;"	d
__NR_gettid	base\linux_syscall_support.h	565;"	d
__NR_gettid	base\linux_syscall_support.h	609;"	d
__NR_gettid	base\linux_syscall_support.h	617;"	d
__NR_gettid	base\linux_syscall_support.h	645;"	d
__NR_gettid	base\linux_syscall_support.h	662;"	d
__NR_gettid	base\linux_syscall_support.h	679;"	d
__NR_gettid	base\linux_syscall_support.h	714;"	d
__NR_gettid	base\linux_syscall_support.h	802;"	d
__NR_getxattr	base\linux_syscall_support.h	790;"	d
__NR_ioprio_get	base\linux_syscall_support.h	838;"	d
__NR_ioprio_set	base\linux_syscall_support.h	835;"	d
__NR_lgetxattr	base\linux_syscall_support.h	793;"	d
__NR_listxattr	base\linux_syscall_support.h	796;"	d
__NR_llistxattr	base\linux_syscall_support.h	799;"	d
__NR_lsetxattr	base\linux_syscall_support.h	787;"	d
__NR_move_pages	base\linux_syscall_support.h	850;"	d
__NR_newfstatat	base\linux_syscall_support.h	844;"	d
__NR_openat	base\linux_syscall_support.h	571;"	d
__NR_openat	base\linux_syscall_support.h	626;"	d
__NR_openat	base\linux_syscall_support.h	651;"	d
__NR_openat	base\linux_syscall_support.h	668;"	d
__NR_openat	base\linux_syscall_support.h	685;"	d
__NR_openat	base\linux_syscall_support.h	720;"	d
__NR_openat	base\linux_syscall_support.h	841;"	d
__NR_pread64	base\linux_syscall_support.h	751;"	d
__NR_pwrite64	base\linux_syscall_support.h	754;"	d
__NR_quotactl	base\linux_syscall_support.h	733;"	d
__NR_readahead	base\linux_syscall_support.h	781;"	d
__NR_rt_sigaction	base\linux_syscall_support.h	552;"	d
__NR_rt_sigaction	base\linux_syscall_support.h	596;"	d
__NR_rt_sigaction	base\linux_syscall_support.h	632;"	d
__NR_rt_sigaction	base\linux_syscall_support.h	698;"	d
__NR_rt_sigaction	base\linux_syscall_support.h	739;"	d
__NR_rt_sigpending	base\linux_syscall_support.h	745;"	d
__NR_rt_sigprocmask	base\linux_syscall_support.h	553;"	d
__NR_rt_sigprocmask	base\linux_syscall_support.h	597;"	d
__NR_rt_sigprocmask	base\linux_syscall_support.h	633;"	d
__NR_rt_sigprocmask	base\linux_syscall_support.h	699;"	d
__NR_rt_sigprocmask	base\linux_syscall_support.h	742;"	d
__NR_rt_sigreturn	base\linux_syscall_support.h	736;"	d
__NR_rt_sigsuspend	base\linux_syscall_support.h	748;"	d
__NR_sched_getaffinity	base\linux_syscall_support.h	814;"	d
__NR_sched_setaffinity	base\linux_syscall_support.h	811;"	d
__NR_set_tid_address	base\linux_syscall_support.h	817;"	d
__NR_setfsgid	base\linux_syscall_support.h	775;"	d
__NR_setfsuid	base\linux_syscall_support.h	772;"	d
__NR_setresgid	base\linux_syscall_support.h	766;"	d
__NR_setresuid	base\linux_syscall_support.h	760;"	d
__NR_setxattr	base\linux_syscall_support.h	784;"	d
__NR_socket	base\linux_syscall_support.h	708;"	d
__NR_stat64	base\linux_syscall_support.h	556;"	d
__NR_stat64	base\linux_syscall_support.h	600;"	d
__NR_stat64	base\linux_syscall_support.h	636;"	d
__NR_stat64	base\linux_syscall_support.h	702;"	d
__NR_statfs64	base\linux_syscall_support.h	829;"	d
__NR_tkill	base\linux_syscall_support.h	805;"	d
__NR_unlinkat	base\linux_syscall_support.h	847;"	d
__SYS_REG	base\linux_syscall_support.h	580;"	d
__SYS_REG	base\linux_syscall_support.h	589;"	d
__SYS_REG_LIST	base\linux_syscall_support.h	581;"	d
__SYS_REG_LIST	base\linux_syscall_support.h	590;"	d
__pad0	base\linux_syscall_support.h	/^  unsigned           __pad0;$/;"	m	struct:kernel_stat
__pad0	base\linux_syscall_support.h	/^  unsigned           __pad0[3];$/;"	m	struct:kernel_stat
__pad0	base\linux_syscall_support.h	/^  unsigned char      __pad0[4];$/;"	m	struct:kernel_stat64
__pad1	base\linux_syscall_support.h	/^  unsigned           __pad1[3];$/;"	m	struct:kernel_stat
__pad1	base\linux_syscall_support.h	/^  unsigned int       __pad1;$/;"	m	struct:kernel_stat
__pad1	base\linux_syscall_support.h	/^  unsigned long      __pad1;$/;"	m	struct:kernel_stat
__pad2	base\linux_syscall_support.h	/^  int                __pad2;$/;"	m	struct:kernel_stat
__pad2	base\linux_syscall_support.h	/^  int                __pad2;$/;"	m	struct:kernel_stat64
__pad2	base\linux_syscall_support.h	/^  unsigned           __pad2;$/;"	m	struct:kernel_stat
__pad3	base\linux_syscall_support.h	/^  unsigned char      __pad3[4];$/;"	m	struct:kernel_stat64
__st_ino	base\linux_syscall_support.h	/^  unsigned           __st_ino;$/;"	m	struct:kernel_stat64
__syscall	base\linux_syscall_support.h	582;"	d
__syscall	base\linux_syscall_support.h	591;"	d
__syscall_safe	base\linux_syscall_support.h	583;"	d
__syscall_safe	base\linux_syscall_support.h	592;"	d
__unused	base\linux_syscall_support.h	/^  int64_t            __unused[3];$/;"	m	struct:kernel_stat
__unused	base\linux_syscall_support.h	/^  unsigned long      __unused[3];$/;"	m	struct:kernel_stat
__unused4	base\linux_syscall_support.h	/^  unsigned           __unused4;$/;"	m	struct:kernel_stat
__unused4	base\linux_syscall_support.h	/^  unsigned int       __unused4;$/;"	m	struct:kernel_stat
__unused4	base\linux_syscall_support.h	/^  unsigned long      __unused4;$/;"	m	struct:kernel_stat
__unused4	base\linux_syscall_support.h	/^  unsigned long      __unused4;$/;"	m	struct:kernel_stat64
__unused5	base\linux_syscall_support.h	/^  unsigned           __unused5;$/;"	m	struct:kernel_stat
__unused5	base\linux_syscall_support.h	/^  unsigned int       __unused5;$/;"	m	struct:kernel_stat
__unused5	base\linux_syscall_support.h	/^  unsigned long      __unused5;$/;"	m	struct:kernel_stat
__unused5	base\linux_syscall_support.h	/^  unsigned long      __unused5;$/;"	m	struct:kernel_stat64
__unused6	base\linux_syscall_support.h	/^  unsigned long      __unused6;$/;"	m	struct:kernel_stat
__unused6	base\linux_syscall_support.h	/^  unsigned long      __unused6;$/;"	m	struct:kernel_stat64
_syscall0	base\linux_syscall_support.h	1286;"	d
_syscall0	base\linux_syscall_support.h	1287;"	d
_syscall0	base\linux_syscall_support.h	1459;"	d
_syscall0	base\linux_syscall_support.h	1460;"	d
_syscall0	base\linux_syscall_support.h	1644;"	d
_syscall0	base\linux_syscall_support.h	1645;"	d
_syscall0	base\linux_syscall_support.h	1918;"	d
_syscall0	base\linux_syscall_support.h	1919;"	d
_syscall0	base\linux_syscall_support.h	2131;"	d
_syscall0	base\linux_syscall_support.h	2132;"	d
_syscall0	base\linux_syscall_support.h	2254;"	d
_syscall0	base\linux_syscall_support.h	2255;"	d
_syscall0	base\linux_syscall_support.h	989;"	d
_syscall0	base\linux_syscall_support.h	990;"	d
_syscall1	base\linux_syscall_support.h	1000;"	d
_syscall1	base\linux_syscall_support.h	1291;"	d
_syscall1	base\linux_syscall_support.h	1292;"	d
_syscall1	base\linux_syscall_support.h	1464;"	d
_syscall1	base\linux_syscall_support.h	1465;"	d
_syscall1	base\linux_syscall_support.h	1650;"	d
_syscall1	base\linux_syscall_support.h	1651;"	d
_syscall1	base\linux_syscall_support.h	1923;"	d
_syscall1	base\linux_syscall_support.h	1924;"	d
_syscall1	base\linux_syscall_support.h	2136;"	d
_syscall1	base\linux_syscall_support.h	2137;"	d
_syscall1	base\linux_syscall_support.h	2259;"	d
_syscall1	base\linux_syscall_support.h	2260;"	d
_syscall1	base\linux_syscall_support.h	999;"	d
_syscall2	base\linux_syscall_support.h	1006;"	d
_syscall2	base\linux_syscall_support.h	1007;"	d
_syscall2	base\linux_syscall_support.h	1296;"	d
_syscall2	base\linux_syscall_support.h	1297;"	d
_syscall2	base\linux_syscall_support.h	1471;"	d
_syscall2	base\linux_syscall_support.h	1472;"	d
_syscall2	base\linux_syscall_support.h	1656;"	d
_syscall2	base\linux_syscall_support.h	1657;"	d
_syscall2	base\linux_syscall_support.h	1928;"	d
_syscall2	base\linux_syscall_support.h	1929;"	d
_syscall2	base\linux_syscall_support.h	2141;"	d
_syscall2	base\linux_syscall_support.h	2142;"	d
_syscall2	base\linux_syscall_support.h	2265;"	d
_syscall2	base\linux_syscall_support.h	2266;"	d
_syscall3	base\linux_syscall_support.h	1013;"	d
_syscall3	base\linux_syscall_support.h	1014;"	d
_syscall3	base\linux_syscall_support.h	1301;"	d
_syscall3	base\linux_syscall_support.h	1302;"	d
_syscall3	base\linux_syscall_support.h	1480;"	d
_syscall3	base\linux_syscall_support.h	1481;"	d
_syscall3	base\linux_syscall_support.h	1663;"	d
_syscall3	base\linux_syscall_support.h	1664;"	d
_syscall3	base\linux_syscall_support.h	1933;"	d
_syscall3	base\linux_syscall_support.h	1934;"	d
_syscall3	base\linux_syscall_support.h	2147;"	d
_syscall3	base\linux_syscall_support.h	2148;"	d
_syscall3	base\linux_syscall_support.h	2271;"	d
_syscall3	base\linux_syscall_support.h	2272;"	d
_syscall4	base\linux_syscall_support.h	1021;"	d
_syscall4	base\linux_syscall_support.h	1022;"	d
_syscall4	base\linux_syscall_support.h	1307;"	d
_syscall4	base\linux_syscall_support.h	1308;"	d
_syscall4	base\linux_syscall_support.h	1491;"	d
_syscall4	base\linux_syscall_support.h	1492;"	d
_syscall4	base\linux_syscall_support.h	1670;"	d
_syscall4	base\linux_syscall_support.h	1671;"	d
_syscall4	base\linux_syscall_support.h	1938;"	d
_syscall4	base\linux_syscall_support.h	1939;"	d
_syscall4	base\linux_syscall_support.h	2153;"	d
_syscall4	base\linux_syscall_support.h	2154;"	d
_syscall4	base\linux_syscall_support.h	2277;"	d
_syscall4	base\linux_syscall_support.h	2278;"	d
_syscall5	base\linux_syscall_support.h	1029;"	d
_syscall5	base\linux_syscall_support.h	1030;"	d
_syscall5	base\linux_syscall_support.h	1313;"	d
_syscall5	base\linux_syscall_support.h	1314;"	d
_syscall5	base\linux_syscall_support.h	1505;"	d
_syscall5	base\linux_syscall_support.h	1506;"	d
_syscall5	base\linux_syscall_support.h	1677;"	d
_syscall5	base\linux_syscall_support.h	1682;"	d
_syscall5	base\linux_syscall_support.h	1704;"	d
_syscall5	base\linux_syscall_support.h	1944;"	d
_syscall5	base\linux_syscall_support.h	1945;"	d
_syscall5	base\linux_syscall_support.h	2160;"	d
_syscall5	base\linux_syscall_support.h	2161;"	d
_syscall5	base\linux_syscall_support.h	2287;"	d
_syscall5	base\linux_syscall_support.h	2288;"	d
_syscall6	base\linux_syscall_support.h	1047;"	d
_syscall6	base\linux_syscall_support.h	1048;"	d
_syscall6	base\linux_syscall_support.h	1322;"	d
_syscall6	base\linux_syscall_support.h	1323;"	d
_syscall6	base\linux_syscall_support.h	1522;"	d
_syscall6	base\linux_syscall_support.h	1523;"	d
_syscall6	base\linux_syscall_support.h	1714;"	d
_syscall6	base\linux_syscall_support.h	1719;"	d
_syscall6	base\linux_syscall_support.h	1744;"	d
_syscall6	base\linux_syscall_support.h	1951;"	d
_syscall6	base\linux_syscall_support.h	1952;"	d
_syscall6	base\linux_syscall_support.h	2170;"	d
_syscall6	base\linux_syscall_support.h	2171;"	d
_syscall6	base\linux_syscall_support.h	2297;"	d
_syscall6	base\linux_syscall_support.h	2298;"	d
clone	base\linux_syscall_support.h	/^    LSS_INLINE int LSS_NAME(clone)(int (*fn)(void *), void *child_stack,$/;"	f
d_ino	base\linux_syscall_support.h	/^  long               d_ino;$/;"	m	struct:kernel_dirent
d_ino	base\linux_syscall_support.h	/^  unsigned long long d_ino;$/;"	m	struct:kernel_dirent64
d_name	base\linux_syscall_support.h	/^  char               d_name[256];$/;"	m	struct:kernel_dirent
d_name	base\linux_syscall_support.h	/^  char               d_name[256];$/;"	m	struct:kernel_dirent64
d_off	base\linux_syscall_support.h	/^  long               d_off;$/;"	m	struct:kernel_dirent
d_off	base\linux_syscall_support.h	/^  long long          d_off;$/;"	m	struct:kernel_dirent64
d_reclen	base\linux_syscall_support.h	/^  unsigned short     d_reclen;$/;"	m	struct:kernel_dirent
d_reclen	base\linux_syscall_support.h	/^  unsigned short     d_reclen;$/;"	m	struct:kernel_dirent64
d_type	base\linux_syscall_support.h	/^  unsigned char      d_type;$/;"	m	struct:kernel_dirent64
gettid	base\linux_syscall_support.h	/^  LSS_INLINE pid_t LSS_NAME(gettid)() {$/;"	f
kernel_dirent	base\linux_syscall_support.h	/^struct kernel_dirent {$/;"	s
kernel_dirent64	base\linux_syscall_support.h	/^struct kernel_dirent64 {$/;"	s
kernel_old_sigaction	base\linux_syscall_support.h	/^struct kernel_old_sigaction {$/;"	s
kernel_old_sigaction	base\linux_syscall_support.h	263;"	d
kernel_rusage	base\linux_syscall_support.h	/^struct kernel_rusage {$/;"	s
kernel_sigaction	base\linux_syscall_support.h	/^struct kernel_sigaction {$/;"	s
kernel_sigset_t	base\linux_syscall_support.h	/^struct kernel_sigset_t {$/;"	s
kernel_stat	base\linux_syscall_support.h	/^struct kernel_stat {$/;"	s
kernel_stat64	base\linux_syscall_support.h	/^struct kernel_stat64 {$/;"	s
kernel_timespec	base\linux_syscall_support.h	/^struct kernel_timespec {$/;"	s
kernel_timeval	base\linux_syscall_support.h	/^struct kernel_timeval {$/;"	s
lseek	base\linux_syscall_support.h	/^    LSS_INLINE off_t LSS_NAME(lseek)(int f, off_t o, int w) {$/;"	f
mremap	base\linux_syscall_support.h	/^  LSS_INLINE void *LSS_NAME(mremap)(void *old_address, size_t old_size,$/;"	f
open	base\linux_syscall_support.h	/^    LSS_INLINE int LSS_NAME(open)(const char* p, int f, int m) {$/;"	f
pad1	base\linux_syscall_support.h	/^  short              pad1;$/;"	m	struct:kernel_stat
pad2	base\linux_syscall_support.h	/^  short              pad2;$/;"	m	struct:kernel_stat
pipe	base\linux_syscall_support.h	/^    LSS_INLINE int LSS_NAME(pipe)(int *p) {$/;"	f
ptrace_detach	base\linux_syscall_support.h	/^  LSS_INLINE int LSS_NAME(ptrace_detach)(pid_t pid) {$/;"	f
ru_idrss	base\linux_syscall_support.h	/^  long               ru_idrss;$/;"	m	struct:kernel_rusage
ru_inblock	base\linux_syscall_support.h	/^  long               ru_inblock;$/;"	m	struct:kernel_rusage
ru_isrss	base\linux_syscall_support.h	/^  long               ru_isrss;$/;"	m	struct:kernel_rusage
ru_ixrss	base\linux_syscall_support.h	/^  long               ru_ixrss;$/;"	m	struct:kernel_rusage
ru_majflt	base\linux_syscall_support.h	/^  long               ru_majflt;$/;"	m	struct:kernel_rusage
ru_maxrss	base\linux_syscall_support.h	/^  long               ru_maxrss;$/;"	m	struct:kernel_rusage
ru_minflt	base\linux_syscall_support.h	/^  long               ru_minflt;$/;"	m	struct:kernel_rusage
ru_msgrcv	base\linux_syscall_support.h	/^  long               ru_msgrcv;$/;"	m	struct:kernel_rusage
ru_msgsnd	base\linux_syscall_support.h	/^  long               ru_msgsnd;$/;"	m	struct:kernel_rusage
ru_nivcsw	base\linux_syscall_support.h	/^  long               ru_nivcsw;$/;"	m	struct:kernel_rusage
ru_nsignals	base\linux_syscall_support.h	/^  long               ru_nsignals;$/;"	m	struct:kernel_rusage
ru_nswap	base\linux_syscall_support.h	/^  long               ru_nswap;$/;"	m	struct:kernel_rusage
ru_nvcsw	base\linux_syscall_support.h	/^  long               ru_nvcsw;$/;"	m	struct:kernel_rusage
ru_oublock	base\linux_syscall_support.h	/^  long               ru_oublock;$/;"	m	struct:kernel_rusage
ru_stime	base\linux_syscall_support.h	/^  struct kernel_timeval ru_stime;$/;"	m	struct:kernel_rusage	typeref:struct:kernel_rusage::kernel_timeval
ru_utime	base\linux_syscall_support.h	/^  struct kernel_timeval ru_utime;$/;"	m	struct:kernel_rusage	typeref:struct:kernel_rusage::kernel_timeval
sa_flags	base\linux_syscall_support.h	/^  unsigned long      sa_flags;$/;"	m	struct:kernel_old_sigaction
sa_flags	base\linux_syscall_support.h	/^  unsigned long      sa_flags;$/;"	m	struct:kernel_sigaction
sa_handler_	base\linux_syscall_support.h	/^    void             (*sa_handler_)(int);$/;"	m	union:kernel_old_sigaction::__anon3
sa_handler_	base\linux_syscall_support.h	/^    void             (*sa_handler_)(int);$/;"	m	union:kernel_sigaction::__anon4
sa_mask	base\linux_syscall_support.h	/^  struct kernel_sigset_t sa_mask;$/;"	m	struct:kernel_sigaction	typeref:struct:kernel_sigaction::kernel_sigset_t
sa_mask	base\linux_syscall_support.h	/^  unsigned long      sa_mask;$/;"	m	struct:kernel_old_sigaction
sa_restorer	base\linux_syscall_support.h	/^  void               (*sa_restorer)(void);$/;"	m	struct:kernel_old_sigaction
sa_sigaction_	base\linux_syscall_support.h	/^    void             (*sa_sigaction_)(int, siginfo_t *, void *);$/;"	m	union:kernel_old_sigaction::__anon3
sa_sigaction_	base\linux_syscall_support.h	/^    void             (*sa_sigaction_)(int, siginfo_t *, void *);$/;"	m	union:kernel_sigaction::__anon4
sig	base\linux_syscall_support.h	/^  unsigned long sig[(KERNEL_NSIG + 8*sizeof(unsigned long) - 1)\/$/;"	m	struct:kernel_sigset_t
sigaction	base\linux_syscall_support.h	/^    LSS_INLINE int LSS_NAME(sigaction)(int signum,$/;"	f
sigaddset	base\linux_syscall_support.h	/^  LSS_INLINE int LSS_NAME(sigaddset)(struct kernel_sigset_t *set,$/;"	f
sigdelset	base\linux_syscall_support.h	/^  LSS_INLINE int LSS_NAME(sigdelset)(struct kernel_sigset_t *set,$/;"	f
sigemptyset	base\linux_syscall_support.h	/^  LSS_INLINE int LSS_NAME(sigemptyset)(struct kernel_sigset_t *set) {$/;"	f
sigfillset	base\linux_syscall_support.h	/^  LSS_INLINE int LSS_NAME(sigfillset)(struct kernel_sigset_t *set) {$/;"	f
sigprocmask	base\linux_syscall_support.h	/^    LSS_INLINE int LSS_NAME(sigprocmask)(int how,$/;"	f
socket	base\linux_syscall_support.h	/^    LSS_INLINE int LSS_NAME(socket)(int domain, int type, int protocol) {$/;"	f
st_atim	base\linux_syscall_support.h	/^  kernel_timespec    st_atim;$/;"	m	struct:kernel_stat
st_atim	base\linux_syscall_support.h	/^  kernel_timespec    st_atim;$/;"	m	struct:kernel_stat64
st_atime_	base\linux_syscall_support.h	/^  long               st_atime_;$/;"	m	struct:kernel_stat
st_atime_	base\linux_syscall_support.h	/^  uint64_t           st_atime_;$/;"	m	struct:kernel_stat
st_atime_	base\linux_syscall_support.h	/^  unsigned           st_atime_;$/;"	m	struct:kernel_stat
st_atime_	base\linux_syscall_support.h	/^  unsigned           st_atime_;$/;"	m	struct:kernel_stat64
st_atime_	base\linux_syscall_support.h	/^  unsigned long      st_atime_;$/;"	m	struct:kernel_stat
st_atime_nsec_	base\linux_syscall_support.h	/^  long               st_atime_nsec_;$/;"	m	struct:kernel_stat
st_atime_nsec_	base\linux_syscall_support.h	/^  uint64_t           st_atime_nsec_;$/;"	m	struct:kernel_stat
st_atime_nsec_	base\linux_syscall_support.h	/^  unsigned           st_atime_nsec_;$/;"	m	struct:kernel_stat
st_atime_nsec_	base\linux_syscall_support.h	/^  unsigned           st_atime_nsec_;$/;"	m	struct:kernel_stat64
st_atime_nsec_	base\linux_syscall_support.h	/^  unsigned long      st_atime_nsec_;$/;"	m	struct:kernel_stat
st_blksize	base\linux_syscall_support.h	/^  int                st_blksize;$/;"	m	struct:kernel_stat
st_blksize	base\linux_syscall_support.h	/^  int64_t            st_blksize;$/;"	m	struct:kernel_stat
st_blksize	base\linux_syscall_support.h	/^  long long          st_blksize;$/;"	m	struct:kernel_stat64
st_blksize	base\linux_syscall_support.h	/^  unsigned           st_blksize;$/;"	m	struct:kernel_stat
st_blksize	base\linux_syscall_support.h	/^  unsigned           st_blksize;$/;"	m	struct:kernel_stat64
st_blksize	base\linux_syscall_support.h	/^  unsigned long      st_blksize;$/;"	m	struct:kernel_stat
st_blocks	base\linux_syscall_support.h	/^  int                st_blocks;$/;"	m	struct:kernel_stat
st_blocks	base\linux_syscall_support.h	/^  int64_t            st_blocks;$/;"	m	struct:kernel_stat
st_blocks	base\linux_syscall_support.h	/^  long               st_blocks;$/;"	m	struct:kernel_stat
st_blocks	base\linux_syscall_support.h	/^  long long          st_blocks;$/;"	m	struct:kernel_stat64
st_blocks	base\linux_syscall_support.h	/^  unsigned           st_blocks;$/;"	m	struct:kernel_stat
st_blocks	base\linux_syscall_support.h	/^  unsigned long      st_blocks;$/;"	m	struct:kernel_stat
st_blocks	base\linux_syscall_support.h	/^  unsigned long long st_blocks;$/;"	m	struct:kernel_stat
st_blocks	base\linux_syscall_support.h	/^  unsigned long long st_blocks;$/;"	m	struct:kernel_stat64
st_ctim	base\linux_syscall_support.h	/^  kernel_timespec    st_ctim;$/;"	m	struct:kernel_stat
st_ctim	base\linux_syscall_support.h	/^  kernel_timespec    st_ctim;$/;"	m	struct:kernel_stat64
st_ctime_	base\linux_syscall_support.h	/^  long               st_ctime_;$/;"	m	struct:kernel_stat
st_ctime_	base\linux_syscall_support.h	/^  uint64_t           st_ctime_;$/;"	m	struct:kernel_stat
st_ctime_	base\linux_syscall_support.h	/^  unsigned           st_ctime_;$/;"	m	struct:kernel_stat
st_ctime_	base\linux_syscall_support.h	/^  unsigned           st_ctime_;$/;"	m	struct:kernel_stat64
st_ctime_	base\linux_syscall_support.h	/^  unsigned long      st_ctime_;$/;"	m	struct:kernel_stat
st_ctime_nsec_	base\linux_syscall_support.h	/^  long               st_ctime_nsec_;$/;"	m	struct:kernel_stat
st_ctime_nsec_	base\linux_syscall_support.h	/^  uint64_t           st_ctime_nsec_;$/;"	m	struct:kernel_stat
st_ctime_nsec_	base\linux_syscall_support.h	/^  unsigned           st_ctime_nsec_;$/;"	m	struct:kernel_stat
st_ctime_nsec_	base\linux_syscall_support.h	/^  unsigned           st_ctime_nsec_;$/;"	m	struct:kernel_stat64
st_ctime_nsec_	base\linux_syscall_support.h	/^  unsigned long      st_ctime_nsec_;$/;"	m	struct:kernel_stat
st_dev	base\linux_syscall_support.h	/^  uint64_t           st_dev;$/;"	m	struct:kernel_stat
st_dev	base\linux_syscall_support.h	/^  unsigned           st_dev;$/;"	m	struct:kernel_stat
st_dev	base\linux_syscall_support.h	/^  unsigned long      st_dev;$/;"	m	struct:kernel_stat
st_dev	base\linux_syscall_support.h	/^  unsigned long long st_dev;$/;"	m	struct:kernel_stat
st_dev	base\linux_syscall_support.h	/^  unsigned long long st_dev;$/;"	m	struct:kernel_stat64
st_dev	base\linux_syscall_support.h	/^  unsigned short     st_dev;$/;"	m	struct:kernel_stat
st_gid	base\linux_syscall_support.h	/^  unsigned           st_gid;$/;"	m	struct:kernel_stat
st_gid	base\linux_syscall_support.h	/^  unsigned           st_gid;$/;"	m	struct:kernel_stat64
st_gid	base\linux_syscall_support.h	/^  unsigned int       st_gid;$/;"	m	struct:kernel_stat
st_gid	base\linux_syscall_support.h	/^  unsigned short     st_gid;$/;"	m	struct:kernel_stat
st_ino	base\linux_syscall_support.h	/^  uint64_t           st_ino;$/;"	m	struct:kernel_stat
st_ino	base\linux_syscall_support.h	/^  unsigned           st_ino;$/;"	m	struct:kernel_stat
st_ino	base\linux_syscall_support.h	/^  unsigned long      st_ino;$/;"	m	struct:kernel_stat
st_ino	base\linux_syscall_support.h	/^  unsigned long long st_ino;$/;"	m	struct:kernel_stat
st_ino	base\linux_syscall_support.h	/^  unsigned long long st_ino;$/;"	m	struct:kernel_stat64
st_mode	base\linux_syscall_support.h	/^  unsigned           st_mode;$/;"	m	struct:kernel_stat
st_mode	base\linux_syscall_support.h	/^  unsigned           st_mode;$/;"	m	struct:kernel_stat64
st_mode	base\linux_syscall_support.h	/^  unsigned int       st_mode;$/;"	m	struct:kernel_stat
st_mode	base\linux_syscall_support.h	/^  unsigned long      st_mode;$/;"	m	struct:kernel_stat
st_mode	base\linux_syscall_support.h	/^  unsigned short     st_mode;$/;"	m	struct:kernel_stat
st_mtim	base\linux_syscall_support.h	/^  kernel_timespec    st_mtim;$/;"	m	struct:kernel_stat
st_mtim	base\linux_syscall_support.h	/^  kernel_timespec    st_mtim;$/;"	m	struct:kernel_stat64
st_mtime_	base\linux_syscall_support.h	/^  long               st_mtime_;$/;"	m	struct:kernel_stat
st_mtime_	base\linux_syscall_support.h	/^  uint64_t           st_mtime_;$/;"	m	struct:kernel_stat
st_mtime_	base\linux_syscall_support.h	/^  unsigned           st_mtime_;$/;"	m	struct:kernel_stat
st_mtime_	base\linux_syscall_support.h	/^  unsigned           st_mtime_;$/;"	m	struct:kernel_stat64
st_mtime_	base\linux_syscall_support.h	/^  unsigned long      st_mtime_;$/;"	m	struct:kernel_stat
st_mtime_nsec_	base\linux_syscall_support.h	/^  long               st_mtime_nsec_;$/;"	m	struct:kernel_stat
st_mtime_nsec_	base\linux_syscall_support.h	/^  uint64_t           st_mtime_nsec_;$/;"	m	struct:kernel_stat
st_mtime_nsec_	base\linux_syscall_support.h	/^  unsigned           st_mtime_nsec_;$/;"	m	struct:kernel_stat
st_mtime_nsec_	base\linux_syscall_support.h	/^  unsigned           st_mtime_nsec_;$/;"	m	struct:kernel_stat64
st_mtime_nsec_	base\linux_syscall_support.h	/^  unsigned long      st_mtime_nsec_;$/;"	m	struct:kernel_stat
st_nlink	base\linux_syscall_support.h	/^  uint64_t           st_nlink;$/;"	m	struct:kernel_stat
st_nlink	base\linux_syscall_support.h	/^  unsigned           st_nlink;$/;"	m	struct:kernel_stat
st_nlink	base\linux_syscall_support.h	/^  unsigned           st_nlink;$/;"	m	struct:kernel_stat64
st_nlink	base\linux_syscall_support.h	/^  unsigned int       st_nlink;$/;"	m	struct:kernel_stat
st_nlink	base\linux_syscall_support.h	/^  unsigned long      st_nlink;$/;"	m	struct:kernel_stat
st_nlink	base\linux_syscall_support.h	/^  unsigned short     st_nlink;$/;"	m	struct:kernel_stat
st_pad1	base\linux_syscall_support.h	/^  int                st_pad1[3];$/;"	m	struct:kernel_stat
st_pad2	base\linux_syscall_support.h	/^  int                st_pad2[2];$/;"	m	struct:kernel_stat
st_pad3	base\linux_syscall_support.h	/^  int                st_pad3;$/;"	m	struct:kernel_stat
st_pad4	base\linux_syscall_support.h	/^  int                st_pad4[14];$/;"	m	struct:kernel_stat
st_rdev	base\linux_syscall_support.h	/^  uint64_t           st_rdev;$/;"	m	struct:kernel_stat
st_rdev	base\linux_syscall_support.h	/^  unsigned           st_rdev;$/;"	m	struct:kernel_stat
st_rdev	base\linux_syscall_support.h	/^  unsigned long      st_rdev;$/;"	m	struct:kernel_stat
st_rdev	base\linux_syscall_support.h	/^  unsigned long long st_rdev;$/;"	m	struct:kernel_stat
st_rdev	base\linux_syscall_support.h	/^  unsigned long long st_rdev;$/;"	m	struct:kernel_stat64
st_rdev	base\linux_syscall_support.h	/^  unsigned short     st_rdev;$/;"	m	struct:kernel_stat
st_size	base\linux_syscall_support.h	/^  int64_t            st_size;$/;"	m	struct:kernel_stat
st_size	base\linux_syscall_support.h	/^  long               st_size;$/;"	m	struct:kernel_stat
st_size	base\linux_syscall_support.h	/^  long long          st_size;$/;"	m	struct:kernel_stat
st_size	base\linux_syscall_support.h	/^  long long          st_size;$/;"	m	struct:kernel_stat64
st_size	base\linux_syscall_support.h	/^  unsigned           st_size;$/;"	m	struct:kernel_stat
st_size	base\linux_syscall_support.h	/^  unsigned long      st_size;$/;"	m	struct:kernel_stat
st_uid	base\linux_syscall_support.h	/^  unsigned           st_uid;$/;"	m	struct:kernel_stat
st_uid	base\linux_syscall_support.h	/^  unsigned           st_uid;$/;"	m	struct:kernel_stat64
st_uid	base\linux_syscall_support.h	/^  unsigned int       st_uid;$/;"	m	struct:kernel_stat
st_uid	base\linux_syscall_support.h	/^  unsigned short     st_uid;$/;"	m	struct:kernel_stat
stat	base\linux_syscall_support.h	/^    LSS_INLINE int LSS_NAME(stat)(const char* p, struct kernel_stat* b) {$/;"	f
tv_nsec	base\linux_syscall_support.h	/^  long               tv_nsec;$/;"	m	struct:kernel_timespec
tv_sec	base\linux_syscall_support.h	/^  long               tv_sec;$/;"	m	struct:kernel_timespec
tv_sec	base\linux_syscall_support.h	/^  long               tv_sec;$/;"	m	struct:kernel_timeval
tv_usec	base\linux_syscall_support.h	/^  long               tv_usec;$/;"	m	struct:kernel_timeval
waitpid	base\linux_syscall_support.h	/^    LSS_INLINE pid_t LSS_NAME(waitpid)(pid_t pid, int *status, int options){$/;"	f
ALT_STACKSIZE	base\linuxthreads.cc	246;"	d	file:
CLONE_STACK_SIZE	base\linuxthreads.cc	103;"	d	file:
CLONE_STACK_SIZE	base\linuxthreads.cc	105;"	d	file:
CLONE_UNTRACED	base\linuxthreads.cc	56;"	d	file:
DirtyStack	base\linuxthreads.cc	/^static void DirtyStack(size_t amount) {$/;"	f	file:
ERRNO	base\linuxthreads.cc	167;"	d	file:
ListerParams	base\linuxthreads.cc	/^struct ListerParams {$/;"	s	file:
ListerThread	base\linuxthreads.cc	/^static void ListerThread(struct ListerParams *args) {$/;"	f	file:
NO_INTR	base\linuxthreads.cc	145;"	d	file:
SYS_CPLUSPLUS	base\linuxthreads.cc	157;"	d	file:
SYS_ERRNO	base\linuxthreads.cc	158;"	d	file:
SYS_INLINE	base\linuxthreads.cc	159;"	d	file:
SYS_LINUX_SYSCALL_SUPPORT_H	base\linuxthreads.cc	161;"	d	file:
SYS_PREFIX	base\linuxthreads.cc	160;"	d	file:
SignalHandler	base\linuxthreads.cc	/^static void SignalHandler(int signum, siginfo_t *si, void *data) {$/;"	f	file:
SysCalls	base\linuxthreads.cc	/^    SysCalls() : my_errno(0) { }$/;"	f	class:__anon2::SysCalls
SysCalls	base\linuxthreads.cc	/^  class SysCalls {$/;"	c	namespace:__anon2	file:
TCMalloc_ListAllProcessThreads	base\linuxthreads.cc	/^int TCMalloc_ListAllProcessThreads(void *parameter,$/;"	f
TCMalloc_ResumeAllProcessThreads	base\linuxthreads.cc	/^int TCMalloc_ResumeAllProcessThreads(int num_threads, pid_t *thread_pids) {$/;"	f
altstack_mem	base\linuxthreads.cc	/^  char        *altstack_mem;$/;"	m	struct:ListerParams	file:
ap	base\linuxthreads.cc	/^  va_list     ap;$/;"	m	struct:ListerParams	file:
c_open	base\linuxthreads.cc	/^static int c_open(const char *fname, int flags, int mode) {$/;"	f	file:
callback	base\linuxthreads.cc	/^  ListAllProcessThreadsCallBack callback;$/;"	m	struct:ListerParams	file:
err	base\linuxthreads.cc	/^  int         result, err;$/;"	m	struct:ListerParams	file:
local_atoi	base\linuxthreads.cc	/^static int local_atoi(const char *s) {$/;"	f	file:
local_clone	base\linuxthreads.cc	/^static int local_clone (int (*fn)(void *), void *arg, ...) {$/;"	f	file:
local_itoa	base\linuxthreads.cc	/^static char *local_itoa(char *buf, int i) {$/;"	f	file:
lock	base\linuxthreads.cc	/^  sem_t       *lock;$/;"	m	struct:ListerParams	file:
my_errno	base\linuxthreads.cc	/^    int my_errno;$/;"	m	class:__anon2::SysCalls	file:
parameter	base\linuxthreads.cc	/^  void        *parameter;$/;"	m	struct:ListerParams	file:
result	base\linuxthreads.cc	/^  int         result, err;$/;"	m	struct:ListerParams	file:
sig_marker	base\linuxthreads.cc	/^static volatile int *sig_pids, sig_num_threads, sig_proc, sig_marker;$/;"	v	file:
sig_num_threads	base\linuxthreads.cc	/^static volatile int *sig_pids, sig_num_threads, sig_proc, sig_marker;$/;"	v	file:
sig_pids	base\linuxthreads.cc	/^static volatile int *sig_pids, sig_num_threads, sig_proc, sig_marker;$/;"	v	file:
sig_proc	base\linuxthreads.cc	/^static volatile int *sig_pids, sig_num_threads, sig_proc, sig_marker;$/;"	v	file:
sync_signals	base\linuxthreads.cc	/^static const int sync_signals[]  = { SIGABRT, SIGILL, SIGFPE, SIGSEGV, SIGBUS,$/;"	v	file:
sys0_sigprocmask	base\linuxthreads.cc	609;"	d	file:
sys0_waitpid	base\linuxthreads.cc	610;"	d	file:
THREADS	base\linuxthreads.h	50;"	d
_LINUXTHREADS_H	base\linuxthreads.h	35;"	d
NO_INTR	base\logging.cc	88;"	d	file:
RawClose	base\logging.cc	/^void RawClose(RawFD fd) {$/;"	f
RawClose	base\logging.cc	/^void RawClose(RawFD handle) {$/;"	f
RawOpenForWriting	base\logging.cc	/^RawFD RawOpenForWriting(const char* filename) {$/;"	f
RawWrite	base\logging.cc	/^void RawWrite(RawFD fd, const char* buf, size_t len) {$/;"	f
RawWrite	base\logging.cc	/^void RawWrite(RawFD handle, const char* buf, size_t len) {$/;"	f
ASSERT_EQ	base\logging.h	157;"	d
ASSERT_FALSE	base\logging.h	168;"	d
ASSERT_GE	base\logging.h	161;"	d
ASSERT_GT	base\logging.h	162;"	d
ASSERT_LE	base\logging.h	159;"	d
ASSERT_LT	base\logging.h	160;"	d
ASSERT_NE	base\logging.h	158;"	d
ASSERT_STREQ	base\logging.h	169;"	d
ASSERT_TRUE	base\logging.h	167;"	d
CHECK	base\logging.h	84;"	d
CHECK_EQ	base\logging.h	143;"	d
CHECK_ERR	base\logging.h	172;"	d
CHECK_GE	base\logging.h	147;"	d
CHECK_GT	base\logging.h	148;"	d
CHECK_LE	base\logging.h	145;"	d
CHECK_LT	base\logging.h	146;"	d
CHECK_NE	base\logging.h	144;"	d
CHECK_OP	base\logging.h	135;"	d
DCHECK_EQ	base\logging.h	176;"	d
DCHECK_EQ	base\logging.h	183;"	d
DCHECK_GE	base\logging.h	180;"	d
DCHECK_GE	base\logging.h	187;"	d
DCHECK_GT	base\logging.h	181;"	d
DCHECK_GT	base\logging.h	188;"	d
DCHECK_LE	base\logging.h	178;"	d
DCHECK_LE	base\logging.h	185;"	d
DCHECK_LT	base\logging.h	179;"	d
DCHECK_LT	base\logging.h	186;"	d
DCHECK_NE	base\logging.h	177;"	d
DCHECK_NE	base\logging.h	184;"	d
DEBUG_MODE	base\logging.h	/^enum { DEBUG_MODE = 0 };$/;"	e	enum:__anon5
DEBUG_MODE	base\logging.h	/^enum { DEBUG_MODE = 1 };$/;"	e	enum:__anon6
ERROR	base\logging.h	/^enum LogSeverity {INFO = -1, WARNING = -2, ERROR = -3, FATAL = -4};$/;"	e	enum:LogSeverity
ERROR	base\logging.h	193;"	d
EXPECT_EQ	base\logging.h	151;"	d
EXPECT_FALSE	base\logging.h	165;"	d
EXPECT_GE	base\logging.h	155;"	d
EXPECT_GT	base\logging.h	156;"	d
EXPECT_LE	base\logging.h	153;"	d
EXPECT_LT	base\logging.h	154;"	d
EXPECT_NE	base\logging.h	152;"	d
EXPECT_STREQ	base\logging.h	166;"	d
EXPECT_TRUE	base\logging.h	164;"	d
FATAL	base\logging.h	/^enum LogSeverity {INFO = -1, WARNING = -2, ERROR = -3, FATAL = -4};$/;"	e	enum:LogSeverity
INFO	base\logging.h	/^enum LogSeverity {INFO = -1, WARNING = -2, ERROR = -3, FATAL = -4};$/;"	e	enum:LogSeverity
LOG	base\logging.h	/^inline void LOG(int lvl, const char* pat, ...)      { LOG_PRINTF(lvl, pat); }$/;"	f
LOG_IF	base\logging.h	/^inline void LOG_IF(int lvl, bool cond, const char* pat, ...) {$/;"	f
LOG_PRINTF	base\logging.h	218;"	d
LogPrintf	base\logging.h	/^inline void LogPrintf(int severity, const char* pat, va_list ap) {$/;"	f
LogSeverity	base\logging.h	/^enum LogSeverity {INFO = -1, WARNING = -2, ERROR = -3, FATAL = -4};$/;"	g
NOMINMAX	base\logging.h	245;"	d
PCHECK	base\logging.h	114;"	d
RAW_CHECK	base\logging.h	94;"	d
RAW_DCHECK	base\logging.h	106;"	d
RAW_DCHECK	base\logging.h	109;"	d
RAW_LOG	base\logging.h	/^inline void RAW_LOG(int lvl, const char* pat, ...)  { LOG_PRINTF(lvl, pat); }$/;"	f
RAW_VLOG	base\logging.h	/^inline void RAW_VLOG(int lvl, const char* pat, ...) { LOG_PRINTF(lvl, pat); }$/;"	f
RawFD	base\logging.h	/^typedef HANDLE RawFD;$/;"	t
RawFD	base\logging.h	/^typedef int RawFD;$/;"	t
VLOG	base\logging.h	/^inline void VLOG(int lvl, const char* pat, ...)     { LOG_PRINTF(lvl, pat); }$/;"	f
VLOG_IS_ON	base\logging.h	215;"	d
WARNING	base\logging.h	/^enum LogSeverity {INFO = -1, WARNING = -2, ERROR = -3, FATAL = -4};$/;"	e	enum:LogSeverity
WRITE_TO_STDERR	base\logging.h	58;"	d
WRITE_TO_STDERR	base\logging.h	61;"	d
WRITE_TO_STDERR	base\logging.h	63;"	d
_LOGGING_H_	base\logging.h	37;"	d
kIllegalRawFD	base\logging.h	/^const RawFD kIllegalRawFD = -1;   \/\/ what open returns if it fails$/;"	v
kIllegalRawFD	base\logging.h	/^const RawFD kIllegalRawFD = INVALID_HANDLE_VALUE;$/;"	v
perftools_vsnprintf	base\logging.h	70;"	d
verbose	base\logging.h	/^DECLARE_int32(verbose);$/;"	v
AddToFreelist	base\low_level_alloc.cc	/^static void AddToFreelist(void *v, LowLevelAlloc::Arena *arena) {$/;"	f	file:
Alloc	base\low_level_alloc.cc	/^void *LowLevelAlloc::Alloc(size_t request) {$/;"	f	class:LowLevelAlloc
AllocList	base\low_level_alloc.cc	/^  struct AllocList {$/;"	s	namespace:low_level_alloc_internal	file:
AllocWithArena	base\low_level_alloc.cc	/^void *LowLevelAlloc::AllocWithArena(size_t request, Arena *arena) {$/;"	f	class:LowLevelAlloc
Arena	base\low_level_alloc.cc	/^  Arena() : mu(SpinLock::LINKER_INITIALIZED) {} \/\/ does nothing; for static init$/;"	f	struct:LowLevelAlloc::Arena
Arena	base\low_level_alloc.cc	/^  explicit Arena(int) : pagesize(0) {}  \/\/ set pagesize to zero explicitly$/;"	f	struct:LowLevelAlloc::Arena
Arena	base\low_level_alloc.cc	/^struct LowLevelAlloc::Arena {$/;"	s	class:LowLevelAlloc	file:
ArenaInit	base\low_level_alloc.cc	/^static void ArenaInit(LowLevelAlloc::Arena *arena) {$/;"	f	file:
ArenaLock	base\low_level_alloc.cc	/^  class SCOPED_LOCKABLE ArenaLock {$/;"	c	namespace:__anon8	file:
Coalesce	base\low_level_alloc.cc	/^static void Coalesce(AllocList *a) {$/;"	f	file:
DefaultArena	base\low_level_alloc.cc	/^LowLevelAlloc::Arena *LowLevelAlloc::DefaultArena() {$/;"	f	class:LowLevelAlloc
DefaultPagesAllocator	base\low_level_alloc.cc	/^  class DefaultPagesAllocator : public LowLevelAlloc::PagesAllocator {$/;"	c	namespace:__anon7	file:
DeleteArena	base\low_level_alloc.cc	/^bool LowLevelAlloc::DeleteArena(Arena *arena) {$/;"	f	class:LowLevelAlloc
DoAllocWithArena	base\low_level_alloc.cc	/^static void *DoAllocWithArena(size_t request, LowLevelAlloc::Arena *arena) {$/;"	f	file:
Free	base\low_level_alloc.cc	/^void LowLevelAlloc::Free(void *v) {$/;"	f	class:LowLevelAlloc
GetDefaultPagesAllocator	base\low_level_alloc.cc	/^LowLevelAlloc::PagesAllocator *LowLevelAlloc::GetDefaultPagesAllocator(void) {$/;"	f	class:LowLevelAlloc
Header	base\low_level_alloc.cc	/^    struct Header {$/;"	s	struct:low_level_alloc_internal::AllocList	file:
IntLog2	base\low_level_alloc.cc	/^static int IntLog2(size_t size, size_t base) {$/;"	f	file:
LLA_SkiplistDelete	base\low_level_alloc.cc	/^static void LLA_SkiplistDelete(AllocList *head, AllocList *e,$/;"	f	file:
LLA_SkiplistInsert	base\low_level_alloc.cc	/^static void LLA_SkiplistInsert(AllocList *head, AllocList *e,$/;"	f	file:
LLA_SkiplistLevels	base\low_level_alloc.cc	/^static int LLA_SkiplistLevels(size_t size, size_t base, bool random) {$/;"	f	file:
LLA_SkiplistSearch	base\low_level_alloc.cc	/^static AllocList *LLA_SkiplistSearch(AllocList *head,$/;"	f	file:
Leave	base\low_level_alloc.cc	/^    void Leave() \/*UNLOCK_FUNCTION()*\/ {$/;"	f	class:__anon8::ArenaLock
MAP_ANONYMOUS	base\low_level_alloc.cc	55;"	d	file:
Magic	base\low_level_alloc.cc	/^inline static intptr_t Magic(intptr_t magic, AllocList::Header *ptr) {$/;"	f	file:
MapPages	base\low_level_alloc.cc	/^void *DefaultPagesAllocator::MapPages(int32 flags, size_t size) {$/;"	f	class:DefaultPagesAllocator
NewArena	base\low_level_alloc.cc	/^LowLevelAlloc::Arena *LowLevelAlloc::NewArena(int32 flags,$/;"	f	class:LowLevelAlloc
NewArenaWithCustomAlloc	base\low_level_alloc.cc	/^LowLevelAlloc::Arena *LowLevelAlloc::NewArenaWithCustomAlloc(int32 flags,$/;"	f	class:LowLevelAlloc
Next	base\low_level_alloc.cc	/^static AllocList *Next(int i, AllocList *prev, LowLevelAlloc::Arena *arena) {$/;"	f	file:
Random	base\low_level_alloc.cc	/^static int Random() {$/;"	f	file:
RoundUp	base\low_level_alloc.cc	/^static intptr_t RoundUp(intptr_t addr, intptr_t align) {$/;"	f	file:
UnMapPages	base\low_level_alloc.cc	/^void DefaultPagesAllocator::UnMapPages(int32 flags, void *region, size_t size) {$/;"	f	class:DefaultPagesAllocator
allocation_count	base\low_level_alloc.cc	/^  int32 allocation_count; \/\/ count of allocated blocks (under mu)$/;"	m	struct:LowLevelAlloc::Arena	file:
allocator	base\low_level_alloc.cc	/^  PagesAllocator *allocator;$/;"	m	struct:LowLevelAlloc::Arena	file:
arena	base\low_level_alloc.cc	/^      LowLevelAlloc::Arena *arena; \/\/ pointer to parent arena$/;"	m	struct:low_level_alloc_internal::AllocList::Header	file:
arena_	base\low_level_alloc.cc	/^        : left_(false), mask_valid_(false), arena_(arena) {$/;"	f	class:__anon8::ArenaLock
arena_	base\low_level_alloc.cc	/^    LowLevelAlloc::Arena *arena_;$/;"	m	class:__anon8::ArenaLock	file:
chars	base\low_level_alloc.cc	/^  char chars[sizeof(DefaultPagesAllocator)];$/;"	m	union:__anon9	file:
debug_pages_allocator_space	base\low_level_alloc.cc	/^} debug_pages_allocator_space;$/;"	v	typeref:union:__anon9	file:
default_arena	base\low_level_alloc.cc	/^static struct LowLevelAlloc::Arena default_arena;$/;"	v	typeref:struct:Arena	file:
default_pages_allocator	base\low_level_alloc.cc	/^static DefaultPagesAllocator *default_pages_allocator;$/;"	v	file:
dummy_for_alignment	base\low_level_alloc.cc	/^      void *dummy_for_alignment;   \/\/ aligns regions to 0 mod 2*sizeof(void*)$/;"	m	struct:low_level_alloc_internal::AllocList::Header	file:
flags	base\low_level_alloc.cc	/^  int32 flags;            \/\/ flags passed to NewArena (ro after init)$/;"	m	struct:LowLevelAlloc::Arena	file:
freelist	base\low_level_alloc.cc	/^  AllocList freelist;     \/\/ head of free list; sorted by addr (under mu)$/;"	m	struct:LowLevelAlloc::Arena	file:
header	base\low_level_alloc.cc	/^    } header;$/;"	m	struct:low_level_alloc_internal::AllocList	typeref:struct:low_level_alloc_internal::AllocList::Header	file:
kMagicAllocated	base\low_level_alloc.cc	/^static const intptr_t kMagicAllocated = 0x4c833e95;$/;"	v	file:
kMagicUnallocated	base\low_level_alloc.cc	/^static const intptr_t kMagicUnallocated = ~kMagicAllocated;$/;"	v	file:
kMaxLevel	base\low_level_alloc.cc	/^static const int kMaxLevel = 30;$/;"	v	file:
left_	base\low_level_alloc.cc	/^    bool left_;       \/\/ whether left region$/;"	m	class:__anon8::ArenaLock	file:
levels	base\low_level_alloc.cc	/^    int levels;           \/\/ levels in skiplist used$/;"	m	struct:low_level_alloc_internal::AllocList	file:
low_level_alloc_internal	base\low_level_alloc.cc	/^namespace low_level_alloc_internal {$/;"	n	file:
magic	base\low_level_alloc.cc	/^      intptr_t magic; \/\/ kMagicAllocated or kMagicUnallocated xor this$/;"	m	struct:low_level_alloc_internal::AllocList::Header	file:
mask_valid_	base\low_level_alloc.cc	/^    bool mask_valid_;$/;"	m	class:__anon8::ArenaLock	file:
min_size	base\low_level_alloc.cc	/^  size_t min_size;        \/\/ smallest allocation block size$/;"	m	struct:LowLevelAlloc::Arena	file:
mu	base\low_level_alloc.cc	/^  SpinLock mu;            \/\/ protects freelist, allocation_count,$/;"	m	struct:LowLevelAlloc::Arena	file:
next	base\low_level_alloc.cc	/^    AllocList *next[kMaxLevel];   \/\/ actually has levels elements.$/;"	m	struct:low_level_alloc_internal::AllocList	file:
pagesize	base\low_level_alloc.cc	/^  size_t pagesize;        \/\/ ==getpagesize()  (init under mu, then ro)$/;"	m	struct:LowLevelAlloc::Arena	file:
ptr	base\low_level_alloc.cc	/^  void *ptr;$/;"	m	union:__anon9	file:
roundup	base\low_level_alloc.cc	/^  size_t roundup;         \/\/ lowest power of 2 >= max(16,sizeof (AllocList))$/;"	m	struct:LowLevelAlloc::Arena	file:
size	base\low_level_alloc.cc	/^      intptr_t size;  \/\/ size of entire region, including this field. Must be$/;"	m	struct:low_level_alloc_internal::AllocList::Header	file:
unhooked_arena	base\low_level_alloc.cc	/^static struct LowLevelAlloc::Arena unhooked_arena;$/;"	v	typeref:struct:Arena	file:
unhooked_async_sig_safe_arena	base\low_level_alloc.cc	/^static struct LowLevelAlloc::Arena unhooked_async_sig_safe_arena;$/;"	v	typeref:struct:Arena	file:
~ArenaLock	base\low_level_alloc.cc	/^    ~ArenaLock() { RAW_CHECK(this->left_, "haven't left Arena region"); }$/;"	f	class:__anon8::ArenaLock
~DefaultPagesAllocator	base\low_level_alloc.cc	/^    virtual ~DefaultPagesAllocator() {};$/;"	f	class:__anon7::DefaultPagesAllocator
~PagesAllocator	base\low_level_alloc.cc	/^LowLevelAlloc::PagesAllocator::~PagesAllocator() {$/;"	f	class:LowLevelAlloc::PagesAllocator
LowLevelAlloc	base\low_level_alloc.h	/^class LowLevelAlloc {$/;"	c
PagesAllocator	base\low_level_alloc.h	/^  class PagesAllocator {$/;"	c	class:LowLevelAlloc
_BASE_LOW_LEVEL_ALLOC_H_	base\low_level_alloc.h	33;"	d
kAsyncSignalSafe	base\low_level_alloc.h	/^    kAsyncSignalSafe = 0x0002,$/;"	e	enum:LowLevelAlloc::__anon10
kCallMallocHook	base\low_level_alloc.h	/^    kCallMallocHook = 0x0001,$/;"	e	enum:LowLevelAlloc::__anon10
GOOGLE_MUTEX_H_	base\simple_mutex.h	106;"	d
LINKER_INITIALIZED	base\simple_mutex.h	/^  enum LinkerInitialized { LINKER_INITIALIZED };$/;"	e	enum:MUTEX_NAMESPACE::Mutex::LinkerInitialized
LinkerInitialized	base\simple_mutex.h	/^  enum LinkerInitialized { LINKER_INITIALIZED };$/;"	g	class:MUTEX_NAMESPACE::Mutex
Lock	base\simple_mutex.h	/^void Mutex::Lock()         { SAFE_PTHREAD(pthread_mutex_lock); }$/;"	f	class:MUTEX_NAMESPACE::Mutex
Lock	base\simple_mutex.h	/^void Mutex::Lock()         { SAFE_PTHREAD(pthread_rwlock_wrlock); }$/;"	f	class:MUTEX_NAMESPACE::Mutex
Lock	base\simple_mutex.h	/^void Mutex::Lock()         { assert(--mutex_ == -1); }$/;"	f	class:MUTEX_NAMESPACE::Mutex
Lock	base\simple_mutex.h	/^void Mutex::Lock()         { if (is_safe_) EnterCriticalSection(&mutex_); }$/;"	f	class:MUTEX_NAMESPACE::Mutex
MUTEX_NAMESPACE	base\simple_mutex.h	/^namespace MUTEX_NAMESPACE {$/;"	n
MUTEX_NAMESPACE	base\simple_mutex.h	144;"	d
MUTEX_NAMESPACE	base\simple_mutex.h	330;"	d
Mutex	base\simple_mutex.h	/^  Mutex(Mutex* \/*ignored*\/) {}$/;"	f	class:MUTEX_NAMESPACE::Mutex
Mutex	base\simple_mutex.h	/^Mutex::Mutex() : destroy_(true) {$/;"	f	class:MUTEX_NAMESPACE::Mutex
Mutex	base\simple_mutex.h	/^Mutex::Mutex() : mutex_(0) { }$/;"	f	class:MUTEX_NAMESPACE::Mutex
Mutex	base\simple_mutex.h	/^Mutex::Mutex(LinkerInitialized) : destroy_(false) {$/;"	f	class:MUTEX_NAMESPACE::Mutex
Mutex	base\simple_mutex.h	/^Mutex::Mutex(Mutex::LinkerInitialized) : destroy_(false) {$/;"	f	class:MUTEX_NAMESPACE::Mutex
Mutex	base\simple_mutex.h	/^Mutex::Mutex(Mutex::LinkerInitialized) : mutex_(0) { }$/;"	f	class:MUTEX_NAMESPACE::Mutex
Mutex	base\simple_mutex.h	/^class Mutex {$/;"	c	namespace:MUTEX_NAMESPACE
MutexLock	base\simple_mutex.h	/^  explicit MutexLock(Mutex *mu) : mu_(mu) { mu_->Lock(); }$/;"	f	class:MUTEX_NAMESPACE::MutexLock
MutexLock	base\simple_mutex.h	/^class MutexLock {$/;"	c	namespace:MUTEX_NAMESPACE
MutexLock	base\simple_mutex.h	322;"	d
MutexType	base\simple_mutex.h	/^  typedef CRITICAL_SECTION MutexType;$/;"	t
MutexType	base\simple_mutex.h	/^  typedef int MutexType;      \/\/ to keep a lock-count$/;"	t
MutexType	base\simple_mutex.h	/^  typedef pthread_mutex_t MutexType;$/;"	t
MutexType	base\simple_mutex.h	/^  typedef pthread_rwlock_t MutexType;$/;"	t
ReaderLock	base\simple_mutex.h	/^void Mutex::ReaderLock()   { Lock(); }      \/\/ we don't have read-write locks$/;"	f	class:MUTEX_NAMESPACE::Mutex
ReaderLock	base\simple_mutex.h	/^void Mutex::ReaderLock()   { Lock(); }$/;"	f	class:MUTEX_NAMESPACE::Mutex
ReaderLock	base\simple_mutex.h	/^void Mutex::ReaderLock()   { SAFE_PTHREAD(pthread_rwlock_rdlock); }$/;"	f	class:MUTEX_NAMESPACE::Mutex
ReaderLock	base\simple_mutex.h	/^void Mutex::ReaderLock()   { assert(++mutex_ > 0); }$/;"	f	class:MUTEX_NAMESPACE::Mutex
ReaderMutexLock	base\simple_mutex.h	/^  explicit ReaderMutexLock(Mutex *mu) : mu_(mu) { mu_->ReaderLock(); }$/;"	f	class:MUTEX_NAMESPACE::ReaderMutexLock
ReaderMutexLock	base\simple_mutex.h	/^class ReaderMutexLock {$/;"	c	namespace:MUTEX_NAMESPACE
ReaderMutexLock	base\simple_mutex.h	323;"	d
ReaderUnlock	base\simple_mutex.h	/^void Mutex::ReaderUnlock() { SAFE_PTHREAD(pthread_rwlock_unlock); }$/;"	f	class:MUTEX_NAMESPACE::Mutex
ReaderUnlock	base\simple_mutex.h	/^void Mutex::ReaderUnlock() { Unlock(); }$/;"	f	class:MUTEX_NAMESPACE::Mutex
ReaderUnlock	base\simple_mutex.h	/^void Mutex::ReaderUnlock() { assert(mutex_-- > 0); }$/;"	f	class:MUTEX_NAMESPACE::Mutex
SAFE_PTHREAD	base\simple_mutex.h	237;"	d
SAFE_PTHREAD	base\simple_mutex.h	256;"	d
SAFE_PTHREAD	base\simple_mutex.h	260;"	d
SAFE_PTHREAD	base\simple_mutex.h	279;"	d
SetIsSafe	base\simple_mutex.h	/^  inline void SetIsSafe() { is_safe_ = true; }$/;"	f	class:MUTEX_NAMESPACE::Mutex
TryLock	base\simple_mutex.h	/^bool Mutex::TryLock()      { if (mutex_) return false; Lock(); return true; }$/;"	f	class:MUTEX_NAMESPACE::Mutex
TryLock	base\simple_mutex.h	/^bool Mutex::TryLock()      { return is_safe_ ?$/;"	f	class:MUTEX_NAMESPACE::Mutex
Unlock	base\simple_mutex.h	/^void Mutex::Unlock()       { SAFE_PTHREAD(pthread_mutex_unlock); }$/;"	f	class:MUTEX_NAMESPACE::Mutex
Unlock	base\simple_mutex.h	/^void Mutex::Unlock()       { SAFE_PTHREAD(pthread_rwlock_unlock); }$/;"	f	class:MUTEX_NAMESPACE::Mutex
Unlock	base\simple_mutex.h	/^void Mutex::Unlock()       { assert(mutex_++ == -1); }$/;"	f	class:MUTEX_NAMESPACE::Mutex
Unlock	base\simple_mutex.h	/^void Mutex::Unlock()       { if (is_safe_) LeaveCriticalSection(&mutex_); }$/;"	f	class:MUTEX_NAMESPACE::Mutex
WIN32_LEAN_AND_MEAN	base\simple_mutex.h	114;"	d
WriterLock	base\simple_mutex.h	/^  inline void WriterLock() { Lock(); }     \/\/ Acquire an exclusive lock$/;"	f	class:MUTEX_NAMESPACE::Mutex
WriterMutexLock	base\simple_mutex.h	/^  explicit WriterMutexLock(Mutex *mu) : mu_(mu) { mu_->WriterLock(); }$/;"	f	class:MUTEX_NAMESPACE::WriterMutexLock
WriterMutexLock	base\simple_mutex.h	/^class WriterMutexLock {$/;"	c	namespace:MUTEX_NAMESPACE
WriterMutexLock	base\simple_mutex.h	324;"	d
WriterUnlock	base\simple_mutex.h	/^  inline void WriterUnlock() { Unlock(); } \/\/ Release a lock from WriterLock()$/;"	f	class:MUTEX_NAMESPACE::Mutex
_WIN32_WINNT	base\simple_mutex.h	120;"	d
_XOPEN_SOURCE	base\simple_mutex.h	130;"	d
destroy_	base\simple_mutex.h	/^  bool destroy_;$/;"	m	class:MUTEX_NAMESPACE::Mutex
is_safe_	base\simple_mutex.h	/^  volatile bool is_safe_;$/;"	m	class:MUTEX_NAMESPACE::Mutex
mu_	base\simple_mutex.h	/^  Mutex * const mu_;$/;"	m	class:MUTEX_NAMESPACE::MutexLock
mu_	base\simple_mutex.h	/^  Mutex * const mu_;$/;"	m	class:MUTEX_NAMESPACE::ReaderMutexLock
mu_	base\simple_mutex.h	/^  Mutex * const mu_;$/;"	m	class:MUTEX_NAMESPACE::WriterMutexLock
mutex_	base\simple_mutex.h	/^  MutexType mutex_;$/;"	m	class:MUTEX_NAMESPACE::Mutex
~Mutex	base\simple_mutex.h	/^Mutex::~Mutex()            { assert(mutex_ == 0); }$/;"	f	class:MUTEX_NAMESPACE::Mutex
~Mutex	base\simple_mutex.h	/^Mutex::~Mutex()            { if (destroy_) DeleteCriticalSection(&mutex_); }$/;"	f	class:MUTEX_NAMESPACE::Mutex
~Mutex	base\simple_mutex.h	/^Mutex::~Mutex()       { if (destroy_) SAFE_PTHREAD(pthread_mutex_destroy); }$/;"	f	class:MUTEX_NAMESPACE::Mutex
~Mutex	base\simple_mutex.h	/^Mutex::~Mutex()       { if (destroy_) SAFE_PTHREAD(pthread_rwlock_destroy); }$/;"	f	class:MUTEX_NAMESPACE::Mutex
~MutexLock	base\simple_mutex.h	/^  ~MutexLock() { mu_->Unlock(); }$/;"	f	class:MUTEX_NAMESPACE::MutexLock
~ReaderMutexLock	base\simple_mutex.h	/^  ~ReaderMutexLock() { mu_->ReaderUnlock(); }$/;"	f	class:MUTEX_NAMESPACE::ReaderMutexLock
~WriterMutexLock	base\simple_mutex.h	/^  ~WriterMutexLock() { mu_->WriterUnlock(); }$/;"	f	class:MUTEX_NAMESPACE::WriterMutexLock
LINKER_INITIALIZED	base\spinlock.cc	/^const base::LinkerInitialized SpinLock::LINKER_INITIALIZED =$/;"	m	class:SpinLock	file:
SlowLock	base\spinlock.cc	/^void SpinLock::SlowLock() {$/;"	f	class:SpinLock
SlowUnlock	base\spinlock.cc	/^void SpinLock::SlowUnlock() {$/;"	f	class:SpinLock
SpinLock_InitHelper	base\spinlock.cc	/^  SpinLock_InitHelper() {$/;"	f	struct:__anon11::SpinLock_InitHelper
SpinLock_InitHelper	base\spinlock.cc	/^struct SpinLock_InitHelper {$/;"	s	namespace:__anon11	file:
SpinLoop	base\spinlock.cc	/^Atomic32 SpinLock::SpinLoop() {$/;"	f	class:SpinLock
SpinlockPause	base\spinlock.cc	/^inline void SpinlockPause(void) {$/;"	f	namespace:__anon11
adaptive_spin_count	base\spinlock.cc	/^static int adaptive_spin_count = 0;$/;"	v	file:
init_helper	base\spinlock.cc	/^static SpinLock_InitHelper init_helper;$/;"	m	namespace:__anon11	file:
BASE_SPINLOCK_H_	base\spinlock.h	40;"	d
EXCLUSIVE_LOCK_FUNCTION	base\spinlock.h	/^  inline explicit SpinLockHolder(SpinLock* l) EXCLUSIVE_LOCK_FUNCTION(l)$/;"	f	class:SpinLockHolder
EXCLUSIVE_TRYLOCK_FUNCTION	base\spinlock.h	/^  inline bool TryLock() EXCLUSIVE_TRYLOCK_FUNCTION(true) {$/;"	f	class:SpinLock
IsHeld	base\spinlock.h	/^  inline bool IsHeld() const {$/;"	f	class:SpinLock
LINKER_INITIALIZED	base\spinlock.h	/^  static const base::LinkerInitialized LINKER_INITIALIZED;  \/\/ backwards compat$/;"	m	class:SpinLock
Lock	base\spinlock.h	/^  inline void Lock() \/*EXCLUSIVE_LOCK_FUNCTION()*\/ {$/;"	f	class:SpinLock
SpinLock	base\spinlock.h	/^  SpinLock() : lockword_(kSpinLockFree) { }$/;"	f	class:SpinLock
SpinLock	base\spinlock.h	/^  explicit SpinLock(base::LinkerInitialized \/*x*\/) {$/;"	f	class:SpinLock
SpinLock	base\spinlock.h	/^class LOCKABLE SpinLock {$/;"	c
SpinLockHolder	base\spinlock.h	/^class SCOPED_LOCKABLE SpinLockHolder {$/;"	c
SpinLockHolder	base\spinlock.h	140;"	d
Unlock	base\spinlock.h	/^  inline void Unlock() \/*UNLOCK_FUNCTION()*\/ {$/;"	f	class:SpinLock
kSpinLockFree	base\spinlock.h	/^  enum { kSpinLockFree = 0 };$/;"	e	enum:SpinLock::__anon12
kSpinLockHeld	base\spinlock.h	/^  enum { kSpinLockHeld = 1 };$/;"	e	enum:SpinLock::__anon13
kSpinLockSleeper	base\spinlock.h	/^  enum { kSpinLockSleeper = 2 };$/;"	e	enum:SpinLock::__anon14
lock_	base\spinlock.h	/^  SpinLock* lock_;$/;"	m	class:SpinLockHolder
lockword_	base\spinlock.h	/^  volatile Atomic32 lockword_;$/;"	m	class:SpinLock
~SpinLockHolder	base\spinlock.h	/^  inline ~SpinLockHolder() \/*UNLOCK_FUNCTION()*\/ { lock_->Unlock(); }$/;"	f	class:SpinLockHolder
SuggestedDelayNS	base\spinlock_internal.cc	/^static int SuggestedDelayNS(int loop) {$/;"	f	namespace:base::internal
base	base\spinlock_internal.cc	/^namespace base { namespace internal { static int SuggestedDelayNS(int loop); }}$/;"	n	file:
base	base\spinlock_internal.cc	/^namespace base {$/;"	n	file:
internal	base\spinlock_internal.cc	/^namespace base { namespace internal { static int SuggestedDelayNS(int loop); }}$/;"	n	namespace:base	file:
internal	base\spinlock_internal.cc	/^namespace internal {$/;"	n	namespace:base	file:
BASE_SPINLOCK_INTERNAL_H_	base\spinlock_internal.h	37;"	d
base	base\spinlock_internal.h	/^namespace base {$/;"	n
internal	base\spinlock_internal.h	/^namespace internal {$/;"	n	namespace:base
FUTEX_PRIVATE_FLAG	base\spinlock_linux-inl.h	43;"	d
FUTEX_WAIT	base\spinlock_linux-inl.h	41;"	d
FUTEX_WAKE	base\spinlock_linux-inl.h	42;"	d
InitModule	base\spinlock_linux-inl.h	/^  InitModule() {$/;"	f	struct:__anon15::InitModule
InitModule	base\spinlock_linux-inl.h	/^static struct InitModule {$/;"	s	namespace:__anon15
SpinLockDelay	base\spinlock_linux-inl.h	/^void SpinLockDelay(volatile Atomic32 *w, int32 value, int loop) {$/;"	f	namespace:base::internal
SpinLockWake	base\spinlock_linux-inl.h	/^void SpinLockWake(volatile Atomic32 *w, bool all) {$/;"	f	namespace:base::internal
base	base\spinlock_linux-inl.h	/^namespace base {$/;"	n
futex_private_flag	base\spinlock_linux-inl.h	/^static int futex_private_flag = FUTEX_PRIVATE_FLAG;$/;"	v
have_futex	base\spinlock_linux-inl.h	/^static bool have_futex;$/;"	v
init_module	base\spinlock_linux-inl.h	/^} init_module;$/;"	m	namespace:__anon15	typeref:struct:__anon15::InitModule
internal	base\spinlock_linux-inl.h	/^namespace internal {$/;"	n	namespace:base
SpinLockDelay	base\spinlock_posix-inl.h	/^void SpinLockDelay(volatile Atomic32 *w, int32 value, int loop) {$/;"	f	namespace:base::internal
SpinLockWake	base\spinlock_posix-inl.h	/^void SpinLockWake(volatile Atomic32 *w, bool all) {$/;"	f	namespace:base::internal
base	base\spinlock_posix-inl.h	/^namespace base {$/;"	n
internal	base\spinlock_posix-inl.h	/^namespace internal {$/;"	n	namespace:base
SpinLockDelay	base\spinlock_win32-inl.h	/^void SpinLockDelay(volatile Atomic32 *w, int32 value, int loop) {$/;"	f	namespace:base::internal
SpinLockWake	base\spinlock_win32-inl.h	/^void SpinLockWake(volatile Atomic32 *w, bool all) {$/;"	f	namespace:base::internal
base	base\spinlock_win32-inl.h	/^namespace base {$/;"	n
internal	base\spinlock_win32-inl.h	/^namespace internal {$/;"	n	namespace:base
BASE_STL_ALLOCATOR_H_	base\stl_allocator.h	37;"	d
STL_Allocator	base\stl_allocator.h	/^  STL_Allocator() { }$/;"	f	class:STL_Allocator
STL_Allocator	base\stl_allocator.h	/^  STL_Allocator(const STL_Allocator&) { }$/;"	f	class:STL_Allocator
STL_Allocator	base\stl_allocator.h	/^  template <class T1> STL_Allocator(const STL_Allocator<T1, Alloc>&) { }$/;"	f	class:STL_Allocator
STL_Allocator	base\stl_allocator.h	/^class STL_Allocator {$/;"	c
address	base\stl_allocator.h	/^  const_pointer address(const_reference x) const { return &x; }$/;"	f	class:STL_Allocator
address	base\stl_allocator.h	/^  pointer address(reference x) const { return &x; }$/;"	f	class:STL_Allocator
allocate	base\stl_allocator.h	/^  pointer allocate(size_type n, const void* = 0) {$/;"	f	class:STL_Allocator
const_pointer	base\stl_allocator.h	/^  typedef const T*   const_pointer;$/;"	t	class:STL_Allocator
const_reference	base\stl_allocator.h	/^  typedef const T&   const_reference;$/;"	t	class:STL_Allocator
construct	base\stl_allocator.h	/^  void construct(pointer p) { ::new(p) T(); }$/;"	f	class:STL_Allocator
construct	base\stl_allocator.h	/^  void construct(pointer p, const T& val) { ::new(p) T(val); }$/;"	f	class:STL_Allocator
deallocate	base\stl_allocator.h	/^  void deallocate(pointer p, size_type n) { Alloc::Free(p, n * sizeof(T)); }$/;"	f	class:STL_Allocator
destroy	base\stl_allocator.h	/^  void destroy(pointer p) { p->~T(); }$/;"	f	class:STL_Allocator
difference_type	base\stl_allocator.h	/^  typedef ptrdiff_t  difference_type;$/;"	t	class:STL_Allocator
max_size	base\stl_allocator.h	/^  size_type max_size() const { return size_t(-1) \/ sizeof(T); }$/;"	f	class:STL_Allocator
operator ==	base\stl_allocator.h	/^  bool operator==(const STL_Allocator&) const { return true; }$/;"	f	class:STL_Allocator
other	base\stl_allocator.h	/^    typedef STL_Allocator<T1, Alloc> other;$/;"	t	struct:STL_Allocator::rebind
pointer	base\stl_allocator.h	/^  typedef T*         pointer;$/;"	t	class:STL_Allocator
rebind	base\stl_allocator.h	/^  template <class T1> struct rebind {$/;"	s	class:STL_Allocator
reference	base\stl_allocator.h	/^  typedef T&         reference;$/;"	t	class:STL_Allocator
size_type	base\stl_allocator.h	/^  typedef size_t     size_type;$/;"	t	class:STL_Allocator
value_type	base\stl_allocator.h	/^  typedef T          value_type;$/;"	t	class:STL_Allocator
~STL_Allocator	base\stl_allocator.h	/^  ~STL_Allocator() { }$/;"	f	class:STL_Allocator
ConstructFilename	base\sysinfo.cc	/^static void ConstructFilename(const char* spec, pid_t pid,$/;"	f	file:
CopyStringUntilChar	base\sysinfo.cc	/^static char *CopyStringUntilChar($/;"	f	file:
DumpProcSelfMaps	base\sysinfo.cc	/^void DumpProcSelfMaps(RawFD fd) {$/;"	f	namespace:tcmalloc
ExtractUntilChar	base\sysinfo.cc	/^static bool ExtractUntilChar(char *text, int c, char **endptr) {$/;"	f	file:
FillProcSelfMaps	base\sysinfo.cc	/^int FillProcSelfMaps(char buf[], int size, bool* wrote_all) {$/;"	f	namespace:tcmalloc
FormatLine	base\sysinfo.cc	/^int ProcMapsIterator::FormatLine(char* buffer, int bufsize,$/;"	f	class:ProcMapsIterator
GetEnvAppendPid	base\sysinfo.cc	/^bool GetEnvAppendPid(const char* env_name, char* path) {$/;"	f
GetSystemCPUsCount	base\sysinfo.cc	/^int GetSystemCPUsCount()$/;"	f
GetUniquePathFromEnv	base\sysinfo.cc	/^bool GetUniquePathFromEnv(const char* env_name, char* path) {$/;"	f
GetenvBeforeMain	base\sysinfo.cc	/^const char* GetenvBeforeMain(const char* name) {$/;"	f
Init	base\sysinfo.cc	/^void ProcMapsIterator::Init(pid_t pid, Buffer *buffer,$/;"	f	class:ProcMapsIterator
LPMODULEENTRY32	base\sysinfo.cc	75;"	d	file:
MODULEENTRY32	base\sysinfo.cc	71;"	d	file:
Module32First	base\sysinfo.cc	72;"	d	file:
Module32Next	base\sysinfo.cc	73;"	d	file:
NO_INTR	base\sysinfo.cc	84;"	d	file:
Next	base\sysinfo.cc	/^bool ProcMapsIterator::Next(uint64 *start, uint64 *end, char **flags,$/;"	f	class:ProcMapsIterator
NextExt	base\sysinfo.cc	/^bool ProcMapsIterator::NextExt(uint64 *start, uint64 *end, char **flags,$/;"	f	class:ProcMapsIterator
NextExtMachHelper	base\sysinfo.cc	/^static bool NextExtMachHelper(const mach_header* hdr,$/;"	f	file:
PLATFORM_WINDOWS	base\sysinfo.cc	33;"	d	file:
PMODULEENTRY32	base\sysinfo.cc	74;"	d	file:
ParseProcMapsLine	base\sysinfo.cc	/^static bool ParseProcMapsLine(char *text, uint64 *start, uint64 *end,$/;"	f	file:
ProcMapsIterator	base\sysinfo.cc	/^ProcMapsIterator::ProcMapsIterator(pid_t pid) {$/;"	f	class:ProcMapsIterator
ProcMapsIterator	base\sysinfo.cc	/^ProcMapsIterator::ProcMapsIterator(pid_t pid, Buffer *buffer) {$/;"	f	class:ProcMapsIterator
ProcMapsIterator	base\sysinfo.cc	/^ProcMapsIterator::ProcMapsIterator(pid_t pid, Buffer *buffer,$/;"	f	class:ProcMapsIterator
SkipWhileWhitespace	base\sysinfo.cc	/^static void SkipWhileWhitespace(char **text_pointer, int c) {$/;"	f	file:
SleepForMilliseconds	base\sysinfo.cc	/^void SleepForMilliseconds(int milliseconds) {$/;"	f
StringToInteger	base\sysinfo.cc	/^int StringToInteger<int>(char *text, char **endptr, int base) {$/;"	f
StringToInteger	base\sysinfo.cc	/^int64 StringToInteger<int64>(char *text, char **endptr, int base) {$/;"	f
StringToInteger	base\sysinfo.cc	/^static T StringToInteger(char *text, char **endptr, int base) {$/;"	f	file:
StringToInteger	base\sysinfo.cc	/^uint64 StringToInteger<uint64>(char *text, char **endptr, int base) {$/;"	f
StringToIntegerUntilChar	base\sysinfo.cc	/^static T StringToIntegerUntilChar($/;"	f	file:
StringToIntegerUntilCharWithCheck	base\sysinfo.cc	/^static bool StringToIntegerUntilCharWithCheck($/;"	f	file:
TCMallocGetenvSafe	base\sysinfo.cc	/^  const char* TCMallocGetenvSafe(const char* name) {$/;"	f
TH32CS_SNAPMODULE32	base\sysinfo.cc	79;"	d	file:
Valid	base\sysinfo.cc	/^bool ProcMapsIterator::Valid() const {$/;"	f	class:ProcMapsIterator
safeclose	base\sysinfo.cc	102;"	d	file:
safeclose	base\sysinfo.cc	104;"	d	file:
safeopen	base\sysinfo.cc	92;"	d	file:
safeopen	base\sysinfo.cc	94;"	d	file:
saferead	base\sysinfo.cc	97;"	d	file:
saferead	base\sysinfo.cc	99;"	d	file:
tcmalloc	base\sysinfo.cc	/^namespace tcmalloc {$/;"	n	file:
~ProcMapsIterator	base\sysinfo.cc	/^ProcMapsIterator::~ProcMapsIterator() {$/;"	f	class:ProcMapsIterator
Buffer	base\sysinfo.h	/^  struct Buffer {$/;"	s	class:ProcMapsIterator
CurrentLine	base\sysinfo.h	/^  const char *CurrentLine() const { return stext_; }$/;"	f	class:ProcMapsIterator
MODULEENTRY32	base\sysinfo.h	202;"	d
MODULEENTRY32	base\sysinfo.h	204;"	d
ProcMapsIterator	base\sysinfo.h	/^class ProcMapsIterator {$/;"	c
_SYSINFO_H_	base\sysinfo.h	35;"	d
buf_	base\sysinfo.h	/^    char buf_[kBufSize];$/;"	m	struct:ProcMapsIterator::Buffer
current_filename_	base\sysinfo.h	/^  char current_filename_[PATH_MAX];$/;"	m	class:ProcMapsIterator
current_image_	base\sysinfo.h	/^  int current_image_; \/\/ dll's are called "images" in macos parlance$/;"	m	class:ProcMapsIterator
current_load_cmd_	base\sysinfo.h	/^  int current_load_cmd_;   \/\/ the segment of this dll we're examining$/;"	m	class:ProcMapsIterator
dynamic_buffer_	base\sysinfo.h	/^  Buffer* dynamic_buffer_;  \/\/ dynamically-allocated Buffer$/;"	m	class:ProcMapsIterator
ebuf_	base\sysinfo.h	/^  char *ebuf_;        \/\/ end of buffer (1 char for a nul)$/;"	m	class:ProcMapsIterator
etext_	base\sysinfo.h	/^  char *etext_;       \/\/ end of text$/;"	m	class:ProcMapsIterator
fd_	base\sysinfo.h	/^  int fd_;            \/\/ filehandle on \/proc\/*\/maps$/;"	m	class:ProcMapsIterator
fd_	base\sysinfo.h	/^  int fd_;$/;"	m	class:ProcMapsIterator
flags_	base\sysinfo.h	/^  char flags_[10];$/;"	m	class:ProcMapsIterator
ibuf_	base\sysinfo.h	/^  char *ibuf_;        \/\/ input buffer$/;"	m	class:ProcMapsIterator
kBufSize	base\sysinfo.h	/^    static const size_t kBufSize = 102400;$/;"	m	struct:ProcMapsIterator::Buffer
module_	base\sysinfo.h	/^  MODULEENTRY32 module_;   \/\/ info about current dll (and dll iterator)$/;"	m	class:ProcMapsIterator
nextline_	base\sysinfo.h	/^  char *nextline_;    \/\/ start of next line$/;"	m	class:ProcMapsIterator
pid_	base\sysinfo.h	/^  pid_t pid_;$/;"	m	class:ProcMapsIterator
snapshot_	base\sysinfo.h	/^  HANDLE snapshot_;   \/\/ filehandle on dll info$/;"	m	class:ProcMapsIterator
stext_	base\sysinfo.h	/^  char *stext_;       \/\/ start of text$/;"	m	class:ProcMapsIterator
tcmalloc	base\sysinfo.h	/^namespace tcmalloc {$/;"	n
using_maps_backing_	base\sysinfo.h	/^  bool using_maps_backing_; \/\/ true if we are looking at maps_backing instead of maps.$/;"	m	class:ProcMapsIterator
ACQUIRED_AFTER	base\thread_annotations.h	84;"	d
ACQUIRED_BEFORE	base\thread_annotations.h	86;"	d
BASE_THREAD_ANNOTATIONS_H_	base\thread_annotations.h	46;"	d
EXCLUSIVE_LOCKS_REQUIRED	base\thread_annotations.h	93;"	d
EXCLUSIVE_LOCK_FUNCTION	base\thread_annotations.h	115;"	d
EXCLUSIVE_TRYLOCK_FUNCTION	base\thread_annotations.h	121;"	d
GUARDED_BY	base\thread_annotations.h	63;"	d
GUARDED_VAR	base\thread_annotations.h	64;"	d
LOCKABLE	base\thread_annotations.h	109;"	d
LOCKS_EXCLUDED	base\thread_annotations.h	102;"	d
LOCK_RETURNED	base\thread_annotations.h	106;"	d
NO_THREAD_SAFETY_ANALYSIS	base\thread_annotations.h	131;"	d
PT_GUARDED_BY	base\thread_annotations.h	74;"	d
PT_GUARDED_VAR	base\thread_annotations.h	76;"	d
SCOPED_LOCKABLE	base\thread_annotations.h	112;"	d
SHARED_LOCKS_REQUIRED	base\thread_annotations.h	96;"	d
SHARED_LOCK_FUNCTION	base\thread_annotations.h	118;"	d
SHARED_TRYLOCK_FUNCTION	base\thread_annotations.h	124;"	d
THREAD_ANNOTATION_ATTRIBUTE__	base\thread_annotations.h	52;"	d
THREAD_ANNOTATION_ATTRIBUTE__	base\thread_annotations.h	54;"	d
UNLOCK_FUNCTION	base\thread_annotations.h	127;"	d
TCMalloc_ListAllProcessThreads	base\thread_lister.c	/^int TCMalloc_ListAllProcessThreads(void *parameter,$/;"	f
TCMalloc_ResumeAllProcessThreads	base\thread_lister.c	/^int TCMalloc_ResumeAllProcessThreads(int num_threads, pid_t *thread_pids) {$/;"	f
ListAllProcessThreadsCallBack	base\thread_lister.h	/^typedef int (*ListAllProcessThreadsCallBack)(void *parameter,$/;"	t
_THREAD_LISTER_H	base\thread_lister.h	36;"	d
AT_SYSINFO_EHDR	base\vdso_support.cc	54;"	d	file:
Init	base\vdso_support.cc	/^const void *VDSOSupport::Init() {$/;"	f	class:base::VDSOSupport
LookupSymbol	base\vdso_support.cc	/^bool VDSOSupport::LookupSymbol(const char *name,$/;"	f	class:base::VDSOSupport
LookupSymbolByAddress	base\vdso_support.cc	/^bool VDSOSupport::LookupSymbolByAddress(const void *address,$/;"	f	class:base::VDSOSupport
SetBase	base\vdso_support.cc	/^const void *VDSOSupport::SetBase(const void *base) {$/;"	f	class:base::VDSOSupport
VDSOInitHelper	base\vdso_support.cc	/^  VDSOInitHelper() { VDSOSupport::Init(); }$/;"	f	class:base::VDSOInitHelper
VDSOInitHelper	base\vdso_support.cc	/^static class VDSOInitHelper {$/;"	c	namespace:base	file:
VDSOSupport	base\vdso_support.cc	/^VDSOSupport::VDSOSupport()$/;"	f	class:base::VDSOSupport
base	base\vdso_support.cc	/^namespace base {$/;"	n	file:
vdso_base_	base\vdso_support.cc	/^const void *VDSOSupport::vdso_base_ = ElfMemImage::kInvalidBase;$/;"	m	class:base::VDSOSupport	file:
vdso_init_helper	base\vdso_support.cc	/^} vdso_init_helper;$/;"	m	namespace:base	typeref:class:base::VDSOInitHelper	file:
BASE_VDSO_SUPPORT_H_	base\vdso_support.h	56;"	d
HAVE_VDSO_SUPPORT	base\vdso_support.h	64;"	d
IsPresent	base\vdso_support.h	/^  bool IsPresent() const { return image_.IsPresent(); }$/;"	f	class:base::VDSOSupport
SymbolInfo	base\vdso_support.h	/^  typedef ElfMemImage::SymbolInfo SymbolInfo;$/;"	t	class:base::VDSOSupport
SymbolIterator	base\vdso_support.h	/^  typedef ElfMemImage::SymbolIterator SymbolIterator;$/;"	t	class:base::VDSOSupport
VDSOSupport	base\vdso_support.h	/^class VDSOSupport {$/;"	c	namespace:base
base	base\vdso_support.h	/^namespace base {$/;"	n
begin	base\vdso_support.h	/^  SymbolIterator begin() const { return image_.begin(); }$/;"	f	class:base::VDSOSupport
end	base\vdso_support.h	/^  SymbolIterator end() const { return image_.end(); }$/;"	f	class:base::VDSOSupport
image_	base\vdso_support.h	/^  ElfMemImage image_;$/;"	m	class:base::VDSOSupport
vdso_base_	base\vdso_support.h	/^  static const void *vdso_base_;$/;"	m	class:base::VDSOSupport
EvictRandomSizeClass	central_freelist.cc	/^bool CentralFreeList::EvictRandomSizeClass($/;"	f	class:tcmalloc::CentralFreeList
FetchFromOneSpans	central_freelist.cc	/^int CentralFreeList::FetchFromOneSpans(int N, void **start, void **end) {$/;"	f	class:tcmalloc::CentralFreeList
FetchFromOneSpansSafe	central_freelist.cc	/^int CentralFreeList::FetchFromOneSpansSafe(int N, void **start, void **end) {$/;"	f	class:tcmalloc::CentralFreeList
Init	central_freelist.cc	/^void CentralFreeList::Init(size_t cl) {$/;"	f	class:tcmalloc::CentralFreeList
InsertRange	central_freelist.cc	/^void CentralFreeList::InsertRange(void *start, void *end, int N) {$/;"	f	class:tcmalloc::CentralFreeList
LockInverter	central_freelist.cc	/^  inline explicit LockInverter(SpinLock* held, SpinLock *temp)$/;"	f	class:tcmalloc::__anon16::LockInverter
LockInverter	central_freelist.cc	/^class LockInverter {$/;"	c	namespace:tcmalloc::__anon16	file:
MakeCacheSpace	central_freelist.cc	/^bool CentralFreeList::MakeCacheSpace() {$/;"	f	class:tcmalloc::CentralFreeList
MapObjectToSpan	central_freelist.cc	/^Span* MapObjectToSpan(void* object) {$/;"	f	namespace:tcmalloc
OverheadBytes	central_freelist.cc	/^size_t CentralFreeList::OverheadBytes() {$/;"	f	class:tcmalloc::CentralFreeList
Populate	central_freelist.cc	/^void CentralFreeList::Populate() {$/;"	f	class:tcmalloc::CentralFreeList
ReleaseListToSpans	central_freelist.cc	/^void CentralFreeList::ReleaseListToSpans(void* start) {$/;"	f	class:tcmalloc::CentralFreeList
ReleaseToSpans	central_freelist.cc	/^void CentralFreeList::ReleaseToSpans(void* object) {$/;"	f	class:tcmalloc::CentralFreeList
RemoveRange	central_freelist.cc	/^int CentralFreeList::RemoveRange(void **start, void **end, int N) {$/;"	f	class:tcmalloc::CentralFreeList
held_	central_freelist.cc	/^  SpinLock *held_, *temp_;$/;"	m	class:tcmalloc::__anon16::LockInverter	file:
tc_length	central_freelist.cc	/^int CentralFreeList::tc_length() {$/;"	f	class:tcmalloc::CentralFreeList
tcmalloc	central_freelist.cc	/^namespace tcmalloc {$/;"	n	file:
temp_	central_freelist.cc	/^  SpinLock *held_, *temp_;$/;"	m	class:tcmalloc::__anon16::LockInverter	file:
~LockInverter	central_freelist.cc	/^  inline ~LockInverter() { temp_->Unlock(); held_->Lock();  }$/;"	f	class:tcmalloc::__anon16::LockInverter
CentralFreeList	central_freelist.h	/^  CentralFreeList() : lock_(base::LINKER_INITIALIZED) { }$/;"	f	class:tcmalloc::CentralFreeList
CentralFreeList	central_freelist.h	/^class CentralFreeList {$/;"	c	namespace:tcmalloc
CentralFreeListPadded	central_freelist.h	/^class CentralFreeListPadded : public CentralFreeListPaddedTo<$/;"	c	namespace:tcmalloc
CentralFreeListPaddedTo	central_freelist.h	/^class CentralFreeListPaddedTo : public CentralFreeList {$/;"	c	namespace:tcmalloc
CentralFreeListPaddedTo	central_freelist.h	/^class CentralFreeListPaddedTo<0> : public CentralFreeList {$/;"	c	namespace:tcmalloc
Lock	central_freelist.h	/^  void Lock() {$/;"	f	class:tcmalloc::CentralFreeList
TCEntry	central_freelist.h	/^  struct TCEntry {$/;"	s	class:tcmalloc::CentralFreeList
TCMALLOC_CENTRAL_FREELIST_H_	central_freelist.h	35;"	d
Unlock	central_freelist.h	/^  void Unlock() {$/;"	f	class:tcmalloc::CentralFreeList
cache_size_	central_freelist.h	/^  int32_t cache_size_;$/;"	m	class:tcmalloc::CentralFreeList
counter_	central_freelist.h	/^  size_t   counter_;        \/\/ Number of free objects in cache entry$/;"	m	class:tcmalloc::CentralFreeList
empty_	central_freelist.h	/^  Span     empty_;          \/\/ Dummy header for list of empty spans$/;"	m	class:tcmalloc::CentralFreeList
head	central_freelist.h	/^    void *head;  \/\/ Head of chain of objects.$/;"	m	struct:tcmalloc::CentralFreeList::TCEntry
kMaxNumTransferEntries	central_freelist.h	/^  static const int kMaxNumTransferEntries = 0;$/;"	m	class:tcmalloc::CentralFreeList
kMaxNumTransferEntries	central_freelist.h	/^  static const int kMaxNumTransferEntries = 64;$/;"	m	class:tcmalloc::CentralFreeList
length	central_freelist.h	/^  int length() {$/;"	f	class:tcmalloc::CentralFreeList
lock_	central_freelist.h	/^  SpinLock lock_;$/;"	m	class:tcmalloc::CentralFreeList
max_cache_size_	central_freelist.h	/^  int32_t max_cache_size_;$/;"	m	class:tcmalloc::CentralFreeList
nonempty_	central_freelist.h	/^  Span     nonempty_;       \/\/ Dummy header for list of non-empty spans$/;"	m	class:tcmalloc::CentralFreeList
num_spans_	central_freelist.h	/^  size_t   num_spans_;      \/\/ Number of spans in empty_ plus nonempty_$/;"	m	class:tcmalloc::CentralFreeList
pad_	central_freelist.h	/^  char pad_[64 - kFreeListSizeMod64];$/;"	m	class:tcmalloc::CentralFreeListPaddedTo
size_class_	central_freelist.h	/^  size_t   size_class_;     \/\/ My size class$/;"	m	class:tcmalloc::CentralFreeList
tail	central_freelist.h	/^    void *tail;  \/\/ Tail of chain of objects.$/;"	m	struct:tcmalloc::CentralFreeList::TCEntry
tc_slots_	central_freelist.h	/^  TCEntry tc_slots_[kMaxNumTransferEntries];$/;"	m	class:tcmalloc::CentralFreeList
tcmalloc	central_freelist.h	/^namespace tcmalloc {$/;"	n
used_slots_	central_freelist.h	/^  int32_t used_slots_;$/;"	m	class:tcmalloc::CentralFreeList
AlignmentForSize	common.cc	/^int AlignmentForSize(size_t size) {$/;"	f	namespace:tcmalloc
FLAGS_tcmalloc_transfer_num_objects	common.cc	/^static int32 FLAGS_tcmalloc_transfer_num_objects;$/;"	m	namespace:tcmalloc	file:
Init	common.cc	/^void SizeMap::Init() {$/;"	f	class:tcmalloc::SizeMap
InitTCMallocTransferNumObjects	common.cc	/^static inline void InitTCMallocTransferNumObjects()$/;"	f	namespace:tcmalloc
LgFloor	common.cc	/^static inline int LgFloor(size_t n) {$/;"	f	namespace:tcmalloc
MetaDataAlloc	common.cc	/^void* MetaDataAlloc(size_t bytes) {$/;"	f	namespace:tcmalloc
NumMoveSize	common.cc	/^int SizeMap::NumMoveSize(size_t size) {$/;"	f	class:tcmalloc::SizeMap
kDefaultTransferNumObjecs	common.cc	/^static const int32 kDefaultTransferNumObjecs = 512;$/;"	m	namespace:tcmalloc	file:
kMetadataAllignment	common.cc	/^static const size_t kMetadataAllignment = sizeof(MemoryAligner);$/;"	m	namespace:tcmalloc	file:
kMetadataAllocChunkSize	common.cc	/^static const size_t kMetadataAllocChunkSize = 8*1024*1024;$/;"	m	namespace:tcmalloc	file:
metadata_chunk_alloc_	common.cc	/^static char *metadata_chunk_alloc_;$/;"	m	namespace:tcmalloc	file:
metadata_chunk_avail_	common.cc	/^static size_t metadata_chunk_avail_;$/;"	m	namespace:tcmalloc	file:
metadata_system_bytes	common.cc	/^uint64_t metadata_system_bytes() { return metadata_system_bytes_; }$/;"	f	namespace:tcmalloc
metadata_system_bytes_	common.cc	/^static uint64_t metadata_system_bytes_ = 0;$/;"	m	namespace:tcmalloc	file:
tcmalloc	common.cc	/^namespace tcmalloc {$/;"	n	file:
ByteSizeForClass	common.h	/^  inline size_t ByteSizeForClass(size_t cl) {$/;"	f	class:tcmalloc::SizeMap
ClassIndex	common.h	/^  static inline size_t ClassIndex(size_t s) {$/;"	f	class:tcmalloc::SizeMap
LIKELY	common.h	48;"	d
LIKELY	common.h	51;"	d
LargeSizeClass	common.h	/^  static inline size_t LargeSizeClass(size_t s) {$/;"	f	class:tcmalloc::SizeMap
Length	common.h	/^typedef uintptr_t Length;$/;"	t
MaybeSizeClass	common.h	/^  inline bool MaybeSizeClass(size_t size, size_t *size_class) {$/;"	f	class:tcmalloc::SizeMap
PageID	common.h	/^typedef uintptr_t PageID;$/;"	t
SizeClass	common.h	/^  inline int SizeClass(size_t size) {$/;"	f	class:tcmalloc::SizeMap
SizeMap	common.h	/^  SizeMap() { }$/;"	f	class:tcmalloc::SizeMap
SizeMap	common.h	/^class SizeMap {$/;"	c	namespace:tcmalloc
SmallSizeClass	common.h	/^  static inline size_t SmallSizeClass(size_t s) {$/;"	f	class:tcmalloc::SizeMap
StackTrace	common.h	/^struct StackTrace {$/;"	s	namespace:tcmalloc
TCMALLOC_COMMON_H_	common.h	37;"	d
UNLIKELY	common.h	49;"	d
UNLIKELY	common.h	52;"	d
class_array_	common.h	/^  unsigned char class_array_[kClassArraySize];$/;"	m	class:tcmalloc::SizeMap
class_to_pages	common.h	/^  inline size_t class_to_pages(size_t cl) {$/;"	f	class:tcmalloc::SizeMap
class_to_pages_	common.h	/^  size_t class_to_pages_[kNumClasses];$/;"	m	class:tcmalloc::SizeMap
class_to_size	common.h	/^  inline size_t class_to_size(size_t cl) {$/;"	f	class:tcmalloc::SizeMap
class_to_size_	common.h	/^  size_t class_to_size_[kNumClasses];$/;"	m	class:tcmalloc::SizeMap
depth	common.h	/^  uintptr_t depth;         \/\/ Number of PC values stored in array below$/;"	m	struct:tcmalloc::StackTrace
kAddressBits	common.h	/^static const int kAddressBits = (sizeof(void*) < 8 ? (8 * sizeof(void*)) : 48);$/;"	v
kAddressBits	common.h	/^static const int kAddressBits = 8 * sizeof(void*);$/;"	v
kAlignment	common.h	/^static const size_t kAlignment  = 8;$/;"	v
kBaseClasses	common.h	/^static const size_t kBaseClasses = 16;$/;"	v
kBaseClasses	common.h	/^static const size_t kBaseClasses = 9;$/;"	v
kClassArraySize	common.h	/^  static const size_t kClassArraySize =$/;"	m	class:tcmalloc::SizeMap
kDefaultOverallThreadCacheSize	common.h	/^static const size_t kDefaultOverallThreadCacheSize = 8u * kMaxThreadCacheSize;$/;"	v
kDefaultOverallThreadCacheSize	common.h	/^static const size_t kDefaultOverallThreadCacheSize = kMaxThreadCacheSize;$/;"	v
kLargeSizeClass	common.h	/^static const size_t kLargeSizeClass = 0;$/;"	v
kMaxDynamicFreeListLength	common.h	/^static const int kMaxDynamicFreeListLength = 8192;$/;"	v
kMaxOverages	common.h	/^static const int kMaxOverages = 3;$/;"	v
kMaxPages	common.h	/^static const size_t kMaxPages = 1 << (20 - kPageShift);$/;"	v
kMaxSize	common.h	/^static const size_t kMaxSize    = 256 * 1024;$/;"	v
kMaxSmallSize	common.h	/^  static const int kMaxSmallSize = 1024;$/;"	m	class:tcmalloc::SizeMap
kMaxStackDepth	common.h	/^static const int kMaxStackDepth = 31;$/;"	m	namespace:tcmalloc
kMaxThreadCacheSize	common.h	/^static const size_t kMaxThreadCacheSize = 4 << 20;$/;"	v
kMaxValidPages	common.h	/^static const Length kMaxValidPages = (~static_cast<Length>(0)) >> kPageShift;$/;"	v
kMinAlign	common.h	/^static const size_t kMinAlign   = 16;$/;"	v
kMinAlign	common.h	/^static const size_t kMinAlign   = 8;$/;"	v
kMinThreadCacheSize	common.h	/^static const size_t kMinThreadCacheSize = kMaxSize * 2;$/;"	v
kNumClasses	common.h	/^static const size_t kNumClasses = kBaseClasses + 69;$/;"	v
kNumClasses	common.h	/^static const size_t kNumClasses = kBaseClasses + 73;$/;"	v
kNumClasses	common.h	/^static const size_t kNumClasses = kBaseClasses + 79;$/;"	v
kPageShift	common.h	/^static const size_t kPageShift  = 13;$/;"	v
kPageShift	common.h	/^static const size_t kPageShift  = 15;$/;"	v
kPageShift	common.h	/^static const size_t kPageShift  = 16;$/;"	v
kPageSize	common.h	/^static const size_t kPageSize   = 1 << kPageShift;$/;"	v
kStealAmount	common.h	/^static const size_t kStealAmount = 1 << 16;$/;"	v
num_objects_to_move	common.h	/^  inline int num_objects_to_move(size_t cl) {$/;"	f	class:tcmalloc::SizeMap
num_objects_to_move_	common.h	/^  int num_objects_to_move_[kNumClasses];$/;"	m	class:tcmalloc::SizeMap
pages	common.h	/^inline Length pages(size_t bytes) {$/;"	f	namespace:tcmalloc
size	common.h	/^  uintptr_t size;          \/\/ Size of object$/;"	m	struct:tcmalloc::StackTrace
stack	common.h	/^  void*     stack[kMaxStackDepth];$/;"	m	struct:tcmalloc::StackTrace
tcmalloc	common.h	/^namespace tcmalloc {$/;"	n
PERFTOOLS_DLL_DECL	config_for_unittests.h	60;"	d
PERFTOOLS_DLL_DECL	config_for_unittests.h	62;"	d
PERFTOOLS_DLL_DECL	config_for_unittests.h	64;"	d
AllocMap	debugallocation.cc	/^  typedef AddressMap<int> AllocMap;$/;"	t	class:MallocBlock	file:
AllocName	debugallocation.cc	/^  static const char* AllocName(int type) {$/;"	f	class:MallocBlock	file:
Allocate	debugallocation.cc	/^  static MallocBlock* Allocate(size_t size, int type) {$/;"	f	class:MallocBlock
Check	debugallocation.cc	/^  void Check(int type) const {$/;"	f	class:MallocBlock
CheckAndClear	debugallocation.cc	/^  size_t CheckAndClear(int type, size_t given_size) {$/;"	f	class:MallocBlock	file:
CheckCallback	debugallocation.cc	/^  static void CheckCallback(const void* ptr, int* type, int dummy) {$/;"	f	class:MallocBlock	file:
CheckEverything	debugallocation.cc	/^  static bool CheckEverything() {$/;"	f	class:MallocBlock
CheckForCorruptedBuffer	debugallocation.cc	/^  static void CheckForCorruptedBuffer(const MallocBlockQueueEntry& queue_entry,$/;"	f	class:MallocBlock
CheckForDanglingWrites	debugallocation.cc	/^  static void CheckForDanglingWrites(const MallocBlockQueueEntry& queue_entry) {$/;"	f	class:MallocBlock
CheckLocked	debugallocation.cc	/^  void CheckLocked(int type) const {$/;"	f	class:MallocBlock	file:
DanglingWriteChecker	debugallocation.cc	/^void DanglingWriteChecker() {$/;"	f
DeallocName	debugallocation.cc	/^  static const char* DeallocName(int type) {$/;"	f	class:MallocBlock	file:
Deallocate	debugallocation.cc	/^  void Deallocate(int type, size_t given_size) {$/;"	f	class:MallocBlock
DebugAllocate	debugallocation.cc	/^static inline void* DebugAllocate(size_t size, int type) {$/;"	f	file:
DebugDeallocate	debugallocation.cc	/^static inline void DebugDeallocate(void* ptr, int type, size_t given_size) {$/;"	f	file:
DebugMallocImplementation	debugallocation.cc	/^class DebugMallocImplementation : public TCMallocImplementation {$/;"	c	file:
FreeQueue	debugallocation.cc	/^  FreeQueue() : q_front_(0), q_back_(0) {}$/;"	f	class:FreeQueue
FreeQueue	debugallocation.cc	/^class FreeQueue {$/;"	c	file:
FreeQueueSize	debugallocation.cc	/^  static size_t FreeQueueSize() {$/;"	f	class:MallocBlock
FromRawPointer	debugallocation.cc	/^  static MallocBlock* FromRawPointer(void* p) {$/;"	f	class:MallocBlock
FromRawPointer	debugallocation.cc	/^  static const MallocBlock* FromRawPointer(const void* p) {$/;"	f	class:MallocBlock
Full	debugallocation.cc	/^  bool Full() {$/;"	f	class:FreeQueue
GetAllocatedSize	debugallocation.cc	/^  virtual size_t GetAllocatedSize(const void* p) {$/;"	f	class:DebugMallocImplementation
GetEstimatedAllocatedSize	debugallocation.cc	/^  virtual size_t GetEstimatedAllocatedSize(size_t size) {$/;"	f	class:DebugMallocImplementation
GetFreeListSizes	debugallocation.cc	/^  virtual void GetFreeListSizes(vector<MallocExtension::FreeListInfo>* v) {$/;"	f	class:DebugMallocImplementation
GetNumericProperty	debugallocation.cc	/^  virtual bool GetNumericProperty(const char* name, size_t* value) {$/;"	f	class:DebugMallocImplementation
GetOwnership	debugallocation.cc	/^  virtual MallocExtension::Ownership GetOwnership(const void* p) {$/;"	f	class:DebugMallocImplementation
InitDeletedBuffer	debugallocation.cc	/^  static void InitDeletedBuffer() {$/;"	f	class:MallocBlock
Initialize	debugallocation.cc	/^  void Initialize(size_t size, int type) {$/;"	f	class:MallocBlock	file:
IsMMapped	debugallocation.cc	/^  bool IsMMapped() const { return kMagicMMap == magic1_; }$/;"	f	class:MallocBlock	file:
IsValidMagicValue	debugallocation.cc	/^  bool IsValidMagicValue(int value) const {$/;"	f	class:MallocBlock	file:
MALLOC_TRACE	debugallocation.cc	999;"	d	file:
MAP_ANONYMOUS	debugallocation.cc	97;"	d	file:
MallocBlock	debugallocation.cc	/^class MallocBlock {$/;"	c	file:
MallocBlockQueueEntry	debugallocation.cc	/^  MallocBlockQueueEntry() : block(NULL), size(0),$/;"	f	struct:MallocBlockQueueEntry
MallocBlockQueueEntry	debugallocation.cc	/^  MallocBlockQueueEntry(MallocBlock* b, size_t s) : block(b), size(s) {$/;"	f	struct:MallocBlockQueueEntry
MallocBlockQueueEntry	debugallocation.cc	/^struct MallocBlockQueueEntry {$/;"	s	file:
MallocMemoryStats	debugallocation.cc	/^  virtual bool MallocMemoryStats(int* blocks, size_t* total,$/;"	f	class:DebugMallocImplementation
MemoryStats	debugallocation.cc	/^  static bool MemoryStats(int* blocks, size_t* total,$/;"	f	class:MallocBlock
Pop	debugallocation.cc	/^  QueueEntry Pop() {$/;"	f	class:FreeQueue
ProcessFreeQueue	debugallocation.cc	/^  static void ProcessFreeQueue(MallocBlock* b, size_t size,$/;"	f	class:MallocBlock
Push	debugallocation.cc	/^  void Push(const QueueEntry& block) {$/;"	f	class:FreeQueue
RoundUp	debugallocation.cc	/^static intptr_t RoundUp(intptr_t value, intptr_t alignment) {$/;"	f	file:
StatsCallback	debugallocation.cc	/^  static void StatsCallback(const void* ptr, int* type, int dummy) {$/;"	f	class:MallocBlock	file:
TCMALLOC_USING_DEBUGALLOCATION	debugallocation.cc	84;"	d	file:
TraceFd	debugallocation.cc	/^static int TraceFd() {$/;"	f	file:
TracePrintf	debugallocation.cc	/^static void TracePrintf(int fd, const char *fmt, ...) {$/;"	f	file:
TraceStack	debugallocation.cc	/^static void TraceStack(void) {$/;"	f	file:
VerifyAllMemory	debugallocation.cc	/^  virtual bool VerifyAllMemory() {$/;"	f	class:DebugMallocImplementation
VerifyArrayNewMemory	debugallocation.cc	/^  virtual bool VerifyArrayNewMemory(const void* p) {$/;"	f	class:DebugMallocImplementation
VerifyMallocMemory	debugallocation.cc	/^  virtual bool VerifyMallocMemory(const void* p) {$/;"	f	class:DebugMallocImplementation
VerifyNewMemory	debugallocation.cc	/^  virtual bool VerifyNewMemory(const void* p) {$/;"	f	class:DebugMallocImplementation
__THROW	debugallocation.cc	91;"	d	file:
__malloctrace_write	debugallocation.cc	/^void __malloctrace_write(const char *buf, size_t size) {$/;"	f
align	debugallocation.cc	/^  size_t align;$/;"	m	struct:memalign_retry_data	file:
alloc_map_	debugallocation.cc	/^  static AllocMap* alloc_map_;$/;"	m	class:MallocBlock	file:
alloc_map_	debugallocation.cc	/^MallocBlock::AllocMap* MallocBlock::alloc_map_ = NULL;$/;"	m	class:MallocBlock	file:
alloc_map_lock_	debugallocation.cc	/^  static SpinLock alloc_map_lock_;$/;"	m	class:MallocBlock	file:
alloc_type_	debugallocation.cc	/^  size_t alloc_type_;$/;"	m	class:MallocBlock	file:
block	debugallocation.cc	/^  MallocBlock* block;$/;"	m	struct:MallocBlockQueueEntry	file:
chars	debugallocation.cc	/^  char chars[sizeof(DebugMallocImplementation)];$/;"	m	union:__anon17	file:
data_addr	debugallocation.cc	/^  const void* data_addr() const { return (const void*)&size2_; }$/;"	f	class:MallocBlock
data_addr	debugallocation.cc	/^  void* data_addr() { return (void*)&size2_; }$/;"	f	class:MallocBlock
data_offset	debugallocation.cc	/^  static size_t data_offset() { return OFFSETOF_MEMBER(MallocBlock, size2_); }$/;"	f	class:MallocBlock
data_size	debugallocation.cc	/^  size_t data_size() const { return size1_; }$/;"	f	class:MallocBlock
debug_alloc_retry_data	debugallocation.cc	/^struct debug_alloc_retry_data {$/;"	s	file:
debug_cpp_alloc	debugallocation.cc	/^inline void* debug_cpp_alloc(size_t size, int new_type, bool nothrow) {$/;"	f
debug_malloc_implementation_space	debugallocation.cc	/^} debug_malloc_implementation_space;$/;"	v	typeref:union:__anon17	file:
deleted_buffer_initialized_	debugallocation.cc	/^  static pthread_once_t deleted_buffer_initialized_;$/;"	m	class:MallocBlock	file:
deleted_buffer_initialized_	debugallocation.cc	/^pthread_once_t MallocBlock::deleted_buffer_initialized_ = PTHREAD_ONCE_INIT;$/;"	m	class:MallocBlock	file:
deleted_buffer_initialized_no_pthreads_	debugallocation.cc	/^  static bool deleted_buffer_initialized_no_pthreads_;$/;"	m	class:MallocBlock	file:
deleted_buffer_initialized_no_pthreads_	debugallocation.cc	/^bool MallocBlock::deleted_buffer_initialized_no_pthreads_ = false;$/;"	m	class:MallocBlock	file:
deleter_pcs	debugallocation.cc	/^  void* deleter_pcs[16];$/;"	m	struct:MallocBlockQueueEntry	file:
deleter_threadid	debugallocation.cc	/^  pthread_t deleter_threadid;$/;"	m	struct:MallocBlockQueueEntry	file:
do_debug_malloc_or_debug_cpp_alloc	debugallocation.cc	/^inline void* do_debug_malloc_or_debug_cpp_alloc(size_t size) {$/;"	f
do_debug_memalign	debugallocation.cc	/^static void *do_debug_memalign(size_t alignment, size_t size) {$/;"	f	file:
do_debug_memalign_or_debug_cpp_memalign	debugallocation.cc	/^inline void* do_debug_memalign_or_debug_cpp_memalign(size_t align,$/;"	f
free_queue_	debugallocation.cc	/^  static FreeQueue<MallocBlockQueueEntry>* free_queue_;$/;"	m	class:MallocBlock	file:
free_queue_	debugallocation.cc	/^FreeQueue<MallocBlockQueueEntry>* MallocBlock::free_queue_ = NULL;$/;"	m	class:MallocBlock	file:
free_queue_lock_	debugallocation.cc	/^  static SpinLock free_queue_lock_;$/;"	m	class:MallocBlock	file:
free_queue_size_	debugallocation.cc	/^  static size_t free_queue_size_;  \/\/ total size of blocks in free_queue_$/;"	m	class:MallocBlock	file:
free_queue_size_	debugallocation.cc	/^size_t MallocBlock::free_queue_size_ = 0;$/;"	m	class:MallocBlock	file:
kAllocName	debugallocation.cc	/^  static const char* const kAllocName[];$/;"	m	class:MallocBlock	file:
kAllocName	debugallocation.cc	/^const char* const MallocBlock::kAllocName[] = {$/;"	m	class:MallocBlock	file:
kAllocTypeMask	debugallocation.cc	/^  static const int kAllocTypeMask = 0x3;$/;"	m	class:MallocBlock	file:
kArrayNewType	debugallocation.cc	/^  static const int kArrayNewType = 0xBCEADF72;$/;"	m	class:MallocBlock	file:
kDeallocName	debugallocation.cc	/^  static const char* const kDeallocName[];$/;"	m	class:MallocBlock	file:
kDeallocName	debugallocation.cc	/^const char* const MallocBlock::kDeallocName[] = {$/;"	m	class:MallocBlock	file:
kDeallocatedTypeBit	debugallocation.cc	/^  static const int kDeallocatedTypeBit = 0x4;$/;"	m	class:MallocBlock	file:
kFreeQueueSize	debugallocation.cc	/^  static const int kFreeQueueSize = 1024;$/;"	m	class:FreeQueue	file:
kMagicDeletedBuffer	debugallocation.cc	/^  static unsigned char kMagicDeletedBuffer[1024];$/;"	m	class:MallocBlock	file:
kMagicDeletedBuffer	debugallocation.cc	/^unsigned char MallocBlock::kMagicDeletedBuffer[1024];$/;"	m	class:MallocBlock	file:
kMagicDeletedByte	debugallocation.cc	/^  static const int kMagicDeletedByte = 0xCD;$/;"	m	class:MallocBlock	file:
kMagicDeletedSizeT	debugallocation.cc	/^  static const size_t kMagicDeletedSizeT =$/;"	m	class:MallocBlock	file:
kMagicMMap	debugallocation.cc	/^  static const int kMagicMMap = 0xABCDEFAB;$/;"	m	class:MallocBlock	file:
kMagicMMap	debugallocation.cc	/^const int MallocBlock::kMagicMMap;$/;"	m	class:MallocBlock	file:
kMagicMalloc	debugallocation.cc	/^  static const int kMagicMalloc = 0xDEADBEEF;$/;"	m	class:MallocBlock	file:
kMagicMalloc	debugallocation.cc	/^const int MallocBlock::kMagicMalloc;$/;"	m	class:MallocBlock	file:
kMagicUninitializedByte	debugallocation.cc	/^  static const int kMagicUninitializedByte = 0xAB;$/;"	m	class:MallocBlock	file:
kMallocType	debugallocation.cc	/^  static const int kMallocType = 0xEFCDAB90;$/;"	m	class:MallocBlock	file:
kNewType	debugallocation.cc	/^  static const int kNewType = 0xFEBADC81;$/;"	m	class:MallocBlock	file:
magic1_	debugallocation.cc	/^  size_t magic1_;$/;"	m	class:MallocBlock	file:
magic2_	debugallocation.cc	/^  int magic2_;$/;"	m	class:MallocBlock	file:
magic2_addr	debugallocation.cc	/^  const int* magic2_addr() const { return (const int*)(size2_addr() + 1); }$/;"	f	class:MallocBlock	file:
magic2_addr	debugallocation.cc	/^  int* magic2_addr() { return (int*)(size2_addr() + 1); }$/;"	f	class:MallocBlock	file:
memalign_retry_data	debugallocation.cc	/^struct memalign_retry_data {$/;"	s	file:
new_type	debugallocation.cc	/^  int new_type;$/;"	m	struct:debug_alloc_retry_data	file:
num_deleter_pcs	debugallocation.cc	/^  int num_deleter_pcs;$/;"	m	struct:MallocBlockQueueEntry	file:
offset_	debugallocation.cc	/^  size_t offset_;   \/\/ normally 0 unless memaligned memory$/;"	m	class:MallocBlock	file:
ptr	debugallocation.cc	/^  void *ptr;$/;"	m	union:__anon17	file:
q_	debugallocation.cc	/^  QueueEntry q_[kFreeQueueSize];$/;"	m	class:FreeQueue	file:
q_back_	debugallocation.cc	/^  int q_back_;$/;"	m	class:FreeQueue	file:
q_front_	debugallocation.cc	/^  int q_front_;$/;"	m	class:FreeQueue	file:
real_malloced_size	debugallocation.cc	/^  static size_t real_malloced_size(size_t size) {$/;"	f	class:MallocBlock	file:
real_mmapped_size	debugallocation.cc	/^  static size_t real_mmapped_size(size_t size) {$/;"	f	class:MallocBlock	file:
real_size	debugallocation.cc	/^  size_t real_size() {$/;"	f	class:MallocBlock	file:
retry_debug_allocate	debugallocation.cc	/^static void *retry_debug_allocate(void *arg) {$/;"	f	file:
retry_debug_memalign	debugallocation.cc	/^static void *retry_debug_memalign(void *arg) {$/;"	f	file:
set_offset	debugallocation.cc	/^  void set_offset(int offset) { this->offset_ = offset; }$/;"	f	class:MallocBlock
size	debugallocation.cc	/^  size_t size() const {$/;"	f	class:FreeQueue
size	debugallocation.cc	/^  size_t size;$/;"	m	struct:MallocBlockQueueEntry	file:
size	debugallocation.cc	/^  size_t size;$/;"	m	struct:debug_alloc_retry_data	file:
size	debugallocation.cc	/^  size_t size;$/;"	m	struct:memalign_retry_data	file:
size1_	debugallocation.cc	/^  size_t size1_;$/;"	m	class:MallocBlock	file:
size2_	debugallocation.cc	/^  size_t size2_;$/;"	m	class:MallocBlock	file:
size2_addr	debugallocation.cc	/^  const size_t* size2_addr() const {$/;"	f	class:MallocBlock	file:
size2_addr	debugallocation.cc	/^  size_t* size2_addr() { return (size_t*)((char*)&size2_ + size1_); }$/;"	f	class:MallocBlock	file:
stats_blocks_	debugallocation.cc	/^  static int stats_blocks_;$/;"	m	class:MallocBlock	file:
stats_blocks_	debugallocation.cc	/^int MallocBlock::stats_blocks_;$/;"	m	class:MallocBlock	file:
stats_histogram_	debugallocation.cc	/^  static int* stats_histogram_;$/;"	m	class:MallocBlock	file:
stats_histogram_	debugallocation.cc	/^int* MallocBlock::stats_histogram_;$/;"	m	class:MallocBlock	file:
stats_total_	debugallocation.cc	/^  static size_t stats_total_;$/;"	m	class:MallocBlock	file:
stats_total_	debugallocation.cc	/^size_t MallocBlock::stats_total_;$/;"	m	class:MallocBlock	file:
tc_delete_sized	debugallocation.cc	/^extern "C" PERFTOOLS_DLL_DECL void tc_delete_sized(void* p, size_t size) throw() {$/;"	f
tc_deletearray_sized	debugallocation.cc	/^extern "C" PERFTOOLS_DLL_DECL void tc_deletearray_sized(void* p, size_t size) throw() {$/;"	f
tc_new	debugallocation.cc	/^extern "C" PERFTOOLS_DLL_DECL void* tc_new(size_t size) {$/;"	f
tc_newarray	debugallocation.cc	/^extern "C" PERFTOOLS_DLL_DECL void* tc_newarray(size_t size) {$/;"	f
EmergencyArenaPagesAllocator	emergency_malloc.cc	/^  class EmergencyArenaPagesAllocator : public LowLevelAlloc::PagesAllocator {$/;"	c	namespace:tcmalloc	file:
EmergencyCalloc	emergency_malloc.cc	/^  PERFTOOLS_DLL_DECL void *EmergencyCalloc(size_t n, size_t elem_size) {$/;"	f	namespace:tcmalloc
EmergencyFree	emergency_malloc.cc	/^  PERFTOOLS_DLL_DECL void EmergencyFree(void *p) {$/;"	f	namespace:tcmalloc
EmergencyMalloc	emergency_malloc.cc	/^  PERFTOOLS_DLL_DECL void *EmergencyMalloc(size_t size) {$/;"	f	namespace:tcmalloc
EmergencyRealloc	emergency_malloc.cc	/^  PERFTOOLS_DLL_DECL void *EmergencyRealloc(void *_old_ptr, size_t new_size) {$/;"	f	namespace:tcmalloc
InitEmergencyMalloc	emergency_malloc.cc	/^  static void InitEmergencyMalloc(void) {$/;"	f	namespace:tcmalloc
MapPages	emergency_malloc.cc	/^    void *MapPages(int32 flags, size_t size) {$/;"	f	class:tcmalloc::EmergencyArenaPagesAllocator	file:
UnMapPages	emergency_malloc.cc	/^    void UnMapPages(int32 flags, void *addr, size_t size) {$/;"	f	class:tcmalloc::EmergencyArenaPagesAllocator	file:
bytes	emergency_malloc.cc	/^    char bytes[sizeof(EmergencyArenaPagesAllocator)];$/;"	m	union:tcmalloc::__anon18	file:
emergency_arena	emergency_malloc.cc	/^  static LowLevelAlloc::Arena *emergency_arena;$/;"	m	namespace:tcmalloc	file:
emergency_arena_end	emergency_malloc.cc	/^  static char *emergency_arena_end;$/;"	m	namespace:tcmalloc	file:
emergency_arena_start	emergency_malloc.cc	/^  __attribute__ ((visibility("internal"))) char *emergency_arena_start;$/;"	m	namespace:tcmalloc	file:
emergency_arena_start_shifted	emergency_malloc.cc	/^  __attribute__ ((visibility("internal"))) uintptr_t emergency_arena_start_shifted;$/;"	m	namespace:tcmalloc	file:
pages_allocator_place	emergency_malloc.cc	/^  } pages_allocator_place;$/;"	m	namespace:tcmalloc	typeref:union:tcmalloc::__anon18	file:
ptr	emergency_malloc.cc	/^    void *ptr;$/;"	m	union:tcmalloc::__anon18	file:
tcmalloc	emergency_malloc.cc	/^namespace tcmalloc {$/;"	n	file:
~EmergencyArenaPagesAllocator	emergency_malloc.cc	/^    ~EmergencyArenaPagesAllocator() {}$/;"	f	class:tcmalloc::EmergencyArenaPagesAllocator	file:
EMERGENCY_MALLOC_H	emergency_malloc.h	32;"	d
IsEmergencyPtr	emergency_malloc.h	/^  static inline bool IsEmergencyPtr(const void *_ptr) {$/;"	f	namespace:tcmalloc
kEmergencyArenaShift	emergency_malloc.h	/^  static const uintptr_t kEmergencyArenaShift = 20+4; \/\/ 16 megs$/;"	m	namespace:tcmalloc
kEmergencyArenaSize	emergency_malloc.h	/^  static const uintptr_t kEmergencyArenaSize = 1 << kEmergencyArenaShift;$/;"	m	namespace:tcmalloc
tcmalloc	emergency_malloc.h	/^namespace tcmalloc {$/;"	n
EnterStacktraceScope	emergency_malloc_for_stacktrace.cc	/^bool tcmalloc::EnterStacktraceScope(void) {$/;"	f	class:tcmalloc
LeaveStacktraceScope	emergency_malloc_for_stacktrace.cc	/^void tcmalloc::LeaveStacktraceScope(void) {$/;"	f	class:tcmalloc
tcmalloc	emergency_malloc_for_stacktrace.cc	/^namespace tcmalloc {$/;"	n	file:
EnterStacktraceScope	fake_stacktrace_scope.cc	/^  ATTRIBUTE_WEAK bool EnterStacktraceScope(void) {$/;"	f	namespace:tcmalloc
LeaveStacktraceScope	fake_stacktrace_scope.cc	/^  ATTRIBUTE_WEAK void LeaveStacktraceScope(void) {$/;"	f	namespace:tcmalloc
tcmalloc	fake_stacktrace_scope.cc	/^namespace tcmalloc {$/;"	n	file:
GETENV_SAFE_H	getenv_safe.h	33;"	d
BASE_GETPC_H_	getpc.h	45;"	d
CallUnrollInfo	getpc.h	/^struct CallUnrollInfo {$/;"	s
GetPC	getpc.h	/^inline void* GetPC(const struct ucontext_t& signal_ucontext) {$/;"	f
GetPC	getpc.h	/^inline void* GetPC(const ucontext_t& signal_ucontext) {$/;"	f
_GNU_SOURCE	getpc.h	52;"	d
callunrollinfo	getpc.h	/^static const CallUnrollInfo callunrollinfo[] = {$/;"	v
ins	getpc.h	/^  unsigned char ins[16];$/;"	m	struct:CallUnrollInfo
ins_size	getpc.h	/^  int ins_size;$/;"	m	struct:CallUnrollInfo
pc_offset	getpc.h	/^  int pc_offset;$/;"	m	struct:CallUnrollInfo
return_sp_offset	getpc.h	/^  int return_sp_offset;$/;"	m	struct:CallUnrollInfo
ucontext_t	getpc.h	/^typedef int ucontext_t;$/;"	t
ucontext_t	getpc.h	/^typedef ucontext ucontext_t;$/;"	t
BASE_HEAP_CHECKER_H_	gperftools\heap-checker.h	53;"	d
BriefNoLeaks	gperftools\heap-checker.h	/^  bool BriefNoLeaks()  { return NoLeaks(); }$/;"	f	class:HeapLeakChecker
BriefSameHeap	gperftools\heap-checker.h	/^  bool BriefSameHeap() { return NoLeaks(); }$/;"	f	class:HeapLeakChecker
CANT_OPEN_PROC_MAPS	gperftools\heap-checker.h	/^    CANT_OPEN_PROC_MAPS,$/;"	e	enum:HeapLeakChecker::ProcMapsResult
DISABLE_LIBRARY_ALLOCS	gperftools\heap-checker.h	/^    DISABLE_LIBRARY_ALLOCS$/;"	e	enum:HeapLeakChecker::ProcMapsTask
DO_NOT_SYMBOLIZE	gperftools\heap-checker.h	/^  enum ShouldSymbolize { SYMBOLIZE, DO_NOT_SYMBOLIZE };$/;"	e	enum:HeapLeakChecker::ShouldSymbolize
Disabler	gperftools\heap-checker.h	/^  class Disabler {$/;"	c	class:HeapLeakChecker
HeapCleaner	gperftools\heap-checker.h	/^class PERFTOOLS_DLL_DECL HeapCleaner {$/;"	c
HeapLeakChecker	gperftools\heap-checker.h	/^class PERFTOOLS_DLL_DECL HeapLeakChecker {$/;"	c
HiddenPointer	gperftools\heap-checker.h	/^  explicit HiddenPointer(T* t)$/;"	f	class:HiddenPointer
HiddenPointer	gperftools\heap-checker.h	/^class HiddenPointer {$/;"	c
IgnoreObject	gperftools\heap-checker.h	/^  static T* IgnoreObject(T* ptr) {$/;"	f	class:HeapLeakChecker
NO_SHARED_LIBS_IN_PROC_MAPS	gperftools\heap-checker.h	/^    NO_SHARED_LIBS_IN_PROC_MAPS$/;"	e	enum:HeapLeakChecker::ProcMapsResult
NoLeaks	gperftools\heap-checker.h	/^  bool NoLeaks() { return DoNoLeaks(DO_NOT_SYMBOLIZE); }$/;"	f	class:HeapLeakChecker
PERFTOOLS_DLL_DECL	gperftools\heap-checker.h	69;"	d
PERFTOOLS_DLL_DECL	gperftools\heap-checker.h	71;"	d
PROC_MAPS_USED	gperftools\heap-checker.h	/^    PROC_MAPS_USED,$/;"	e	enum:HeapLeakChecker::ProcMapsResult
ProcMapsResult	gperftools\heap-checker.h	/^  enum ProcMapsResult {$/;"	g	class:HeapLeakChecker
ProcMapsTask	gperftools\heap-checker.h	/^  enum ProcMapsTask {$/;"	g	class:HeapLeakChecker
QuickNoLeaks	gperftools\heap-checker.h	/^  bool QuickNoLeaks()  { return NoLeaks(); }$/;"	f	class:HeapLeakChecker
QuickSameHeap	gperftools\heap-checker.h	/^  bool QuickSameHeap() { return NoLeaks(); }$/;"	f	class:HeapLeakChecker
RECORD_GLOBAL_DATA	gperftools\heap-checker.h	/^    RECORD_GLOBAL_DATA,$/;"	e	enum:HeapLeakChecker::ProcMapsTask
REGISTER_HEAPCHECK_CLEANUP	gperftools\heap-checker.h	416;"	d
SYMBOLIZE	gperftools\heap-checker.h	/^  enum ShouldSymbolize { SYMBOLIZE, DO_NOT_SYMBOLIZE };$/;"	e	enum:HeapLeakChecker::ShouldSymbolize
SameHeap	gperftools\heap-checker.h	/^  bool SameHeap()      { return NoLeaks(); }$/;"	f	class:HeapLeakChecker
ShouldSymbolize	gperftools\heap-checker.h	/^  enum ShouldSymbolize { SYMBOLIZE, DO_NOT_SYMBOLIZE };$/;"	g	class:HeapLeakChecker
get	gperftools\heap-checker.h	/^  T* get() const { return reinterpret_cast<T*>(masked_t_ ^ kHideMask); }$/;"	f	class:HiddenPointer
has_checked_	gperftools\heap-checker.h	/^  bool has_checked_;  \/\/ if we have done the leak check, so these are ready:$/;"	m	class:HeapLeakChecker
heap_cleanups_	gperftools\heap-checker.h	/^  static std::vector<void_function>* heap_cleanups_;$/;"	m	class:HeapCleaner
inuse_allocs_increase_	gperftools\heap-checker.h	/^  ssize_t inuse_allocs_increase_;  \/\/ allocations-in-use increase$/;"	m	class:HeapLeakChecker
inuse_bytes_increase_	gperftools\heap-checker.h	/^  ssize_t inuse_bytes_increase_;  \/\/ bytes-in-use increase for this checker$/;"	m	class:HeapLeakChecker
kHideMask	gperftools\heap-checker.h	/^  static const uintptr_t kHideMask =$/;"	m	class:HiddenPointer
keep_profiles_	gperftools\heap-checker.h	/^  bool keep_profiles_;  \/\/ iff we should keep the heap profiles we've made$/;"	m	class:HeapLeakChecker
lock_	gperftools\heap-checker.h	/^  class SpinLock* lock_;  \/\/ to make HeapLeakChecker objects thread-safe$/;"	m	class:HeapLeakChecker	typeref:class:HeapLeakChecker::SpinLock
masked_t_	gperftools\heap-checker.h	/^  uintptr_t masked_t_;$/;"	m	class:HiddenPointer
name_	gperftools\heap-checker.h	/^  const char* name_;  \/\/ our remembered name (we own it)$/;"	m	class:HeapLeakChecker
start_snapshot_	gperftools\heap-checker.h	/^  void* start_snapshot_;$/;"	m	class:HeapLeakChecker
void_function	gperftools\heap-checker.h	/^  typedef void (*void_function)(void);$/;"	t	class:HeapCleaner
BASE_HEAP_PROFILER_H_	gperftools\heap-profiler.h	52;"	d
PERFTOOLS_DLL_DECL	gperftools\heap-profiler.h	59;"	d
PERFTOOLS_DLL_DECL	gperftools\heap-profiler.h	61;"	d
BASE_MALLOC_EXTENSION_H_	gperftools\malloc_extension.h	43;"	d
FREE	gperftools\malloc_extension.h	/^    FREE,                 \/\/ Range is currently free$/;"	e	enum:base::MallocRange::Type
FreeListInfo	gperftools\malloc_extension.h	/^  struct FreeListInfo {$/;"	s	class:MallocExtension
INUSE	gperftools\malloc_extension.h	/^    INUSE,                \/\/ Application is using this range$/;"	e	enum:base::MallocRange::Type
MallocExtension	gperftools\malloc_extension.h	/^class PERFTOOLS_DLL_DECL MallocExtension {$/;"	c
MallocExtensionWriter	gperftools\malloc_extension.h	/^typedef std::string MallocExtensionWriter;$/;"	t
MallocRange	gperftools\malloc_extension.h	/^struct MallocRange {$/;"	s	namespace:base
Ownership	gperftools\malloc_extension.h	/^  enum Ownership {$/;"	g	class:MallocExtension
PERFTOOLS_DLL_DECL	gperftools\malloc_extension.h	59;"	d
PERFTOOLS_DLL_DECL	gperftools\malloc_extension.h	61;"	d
RangeFunction	gperftools\malloc_extension.h	/^  typedef void (RangeFunction)(void*, const base::MallocRange*);$/;"	t	class:MallocExtension
SysAllocator	gperftools\malloc_extension.h	/^  SysAllocator() {$/;"	f	class:SysAllocator
SysAllocator	gperftools\malloc_extension.h	/^class PERFTOOLS_DLL_DECL SysAllocator {$/;"	c
Type	gperftools\malloc_extension.h	/^  enum Type {$/;"	g	struct:base::MallocRange
UNKNOWN	gperftools\malloc_extension.h	/^    UNKNOWN$/;"	e	enum:base::MallocRange::Type
UNMAPPED	gperftools\malloc_extension.h	/^    UNMAPPED,             \/\/ Backing physical memory has been returned to the OS$/;"	e	enum:base::MallocRange::Type
address	gperftools\malloc_extension.h	/^  uintptr_t address;    \/\/ Address of range$/;"	m	struct:base::MallocRange
base	gperftools\malloc_extension.h	/^namespace base {$/;"	n
fraction	gperftools\malloc_extension.h	/^  double fraction;      \/\/ Fraction of range that is being used (0 if !INUSE)$/;"	m	struct:base::MallocRange
kMallocHistogramSize	gperftools\malloc_extension.h	/^static const int kMallocHistogramSize = 64;$/;"	v
kNotOwned	gperftools\malloc_extension.h	/^    kNotOwned$/;"	e	enum:MallocExtension::Ownership
kOwned	gperftools\malloc_extension.h	/^    kOwned,$/;"	e	enum:MallocExtension::Ownership
kUnknownOwnership	gperftools\malloc_extension.h	/^    kUnknownOwnership = 0,$/;"	e	enum:MallocExtension::Ownership
length	gperftools\malloc_extension.h	/^  size_t length;        \/\/ Byte length of range$/;"	m	struct:base::MallocRange
max_object_size	gperftools\malloc_extension.h	/^    size_t max_object_size;$/;"	m	struct:MallocExtension::FreeListInfo
min_object_size	gperftools\malloc_extension.h	/^    size_t min_object_size;$/;"	m	struct:MallocExtension::FreeListInfo
total_bytes_free	gperftools\malloc_extension.h	/^    size_t total_bytes_free;$/;"	m	struct:MallocExtension::FreeListInfo
type	gperftools\malloc_extension.h	/^    const char* type;$/;"	m	struct:MallocExtension::FreeListInfo
type	gperftools\malloc_extension.h	/^  Type type;            \/\/ Type of this range$/;"	m	struct:base::MallocRange
MallocExtension_Ownership	gperftools\malloc_extension_c.h	/^} MallocExtension_Ownership;$/;"	t	typeref:enum:__anon19
MallocExtension_kNotOwned	gperftools\malloc_extension_c.h	/^  MallocExtension_kNotOwned$/;"	e	enum:__anon19
MallocExtension_kOwned	gperftools\malloc_extension_c.h	/^  MallocExtension_kOwned,$/;"	e	enum:__anon19
MallocExtension_kUnknownOwnership	gperftools\malloc_extension_c.h	/^  MallocExtension_kUnknownOwnership = 0,$/;"	e	enum:__anon19
PERFTOOLS_DLL_DECL	gperftools\malloc_extension_c.h	48;"	d
PERFTOOLS_DLL_DECL	gperftools\malloc_extension_c.h	50;"	d
_MALLOC_EXTENSION_C_H_	gperftools\malloc_extension_c.h	40;"	d
kMallocExtensionHistogramSize	gperftools\malloc_extension_c.h	58;"	d
AddDeleteHook	gperftools\malloc_hook.h	/^  inline static bool AddDeleteHook(DeleteHook hook) {$/;"	f	class:MallocHook
AddMmapHook	gperftools\malloc_hook.h	/^  inline static bool AddMmapHook(MmapHook hook) {$/;"	f	class:MallocHook
AddMremapHook	gperftools\malloc_hook.h	/^  inline static bool AddMremapHook(MremapHook hook) {$/;"	f	class:MallocHook
AddMunmapHook	gperftools\malloc_hook.h	/^  inline static bool AddMunmapHook(MunmapHook hook) {$/;"	f	class:MallocHook
AddNewHook	gperftools\malloc_hook.h	/^  inline static bool AddNewHook(NewHook hook) {$/;"	f	class:MallocHook
AddPreMmapHook	gperftools\malloc_hook.h	/^  inline static bool AddPreMmapHook(PreMmapHook hook) {$/;"	f	class:MallocHook
AddPreSbrkHook	gperftools\malloc_hook.h	/^  inline static bool AddPreSbrkHook(PreSbrkHook hook) {$/;"	f	class:MallocHook
AddSbrkHook	gperftools\malloc_hook.h	/^  inline static bool AddSbrkHook(SbrkHook hook) {$/;"	f	class:MallocHook
DeleteHook	gperftools\malloc_hook.h	/^  typedef MallocHook_DeleteHook DeleteHook;$/;"	t	class:MallocHook
GetCallerStackTrace	gperftools\malloc_hook.h	/^  inline static int GetCallerStackTrace(void** result, int max_depth,$/;"	f	class:MallocHook
MallocHook	gperftools\malloc_hook.h	/^class PERFTOOLS_DLL_DECL MallocHook {$/;"	c
MmapHook	gperftools\malloc_hook.h	/^  typedef MallocHook_MmapHook MmapHook;$/;"	t	class:MallocHook
MmapReplacement	gperftools\malloc_hook.h	/^  typedef MallocHook_MmapReplacement MmapReplacement;$/;"	t	class:MallocHook
MremapHook	gperftools\malloc_hook.h	/^  typedef MallocHook_MremapHook MremapHook;$/;"	t	class:MallocHook
MunmapHook	gperftools\malloc_hook.h	/^  typedef MallocHook_MunmapHook MunmapHook;$/;"	t	class:MallocHook
MunmapReplacement	gperftools\malloc_hook.h	/^  typedef MallocHook_MunmapReplacement MunmapReplacement;$/;"	t	class:MallocHook
NewHook	gperftools\malloc_hook.h	/^  typedef MallocHook_NewHook NewHook;$/;"	t	class:MallocHook
PERFTOOLS_DLL_DECL	gperftools\malloc_hook.h	79;"	d
PERFTOOLS_DLL_DECL	gperftools\malloc_hook.h	81;"	d
PreMmapHook	gperftools\malloc_hook.h	/^  typedef MallocHook_PreMmapHook PreMmapHook;$/;"	t	class:MallocHook
PreSbrkHook	gperftools\malloc_hook.h	/^  typedef MallocHook_PreSbrkHook PreSbrkHook;$/;"	t	class:MallocHook
RemoveDeleteHook	gperftools\malloc_hook.h	/^  inline static bool RemoveDeleteHook(DeleteHook hook) {$/;"	f	class:MallocHook
RemoveMmapHook	gperftools\malloc_hook.h	/^  inline static bool RemoveMmapHook(MmapHook hook) {$/;"	f	class:MallocHook
RemoveMmapReplacement	gperftools\malloc_hook.h	/^  inline static bool RemoveMmapReplacement(MmapReplacement hook) {$/;"	f	class:MallocHook
RemoveMremapHook	gperftools\malloc_hook.h	/^  inline static bool RemoveMremapHook(MremapHook hook) {$/;"	f	class:MallocHook
RemoveMunmapHook	gperftools\malloc_hook.h	/^  inline static bool RemoveMunmapHook(MunmapHook hook) {$/;"	f	class:MallocHook
RemoveMunmapReplacement	gperftools\malloc_hook.h	/^  inline static bool RemoveMunmapReplacement(MunmapReplacement hook) {$/;"	f	class:MallocHook
RemoveNewHook	gperftools\malloc_hook.h	/^  inline static bool RemoveNewHook(NewHook hook) {$/;"	f	class:MallocHook
RemovePreMmapHook	gperftools\malloc_hook.h	/^  inline static bool RemovePreMmapHook(PreMmapHook hook) {$/;"	f	class:MallocHook
RemovePreSbrkHook	gperftools\malloc_hook.h	/^  inline static bool RemovePreSbrkHook(PreSbrkHook hook) {$/;"	f	class:MallocHook
RemoveSbrkHook	gperftools\malloc_hook.h	/^  inline static bool RemoveSbrkHook(SbrkHook hook) {$/;"	f	class:MallocHook
SbrkHook	gperftools\malloc_hook.h	/^  typedef MallocHook_SbrkHook SbrkHook;$/;"	t	class:MallocHook
SetDeleteHook	gperftools\malloc_hook.h	/^  inline static DeleteHook SetDeleteHook(DeleteHook hook) {$/;"	f	class:MallocHook
SetMmapHook	gperftools\malloc_hook.h	/^  inline static MmapHook SetMmapHook(MmapHook hook) {$/;"	f	class:MallocHook
SetMmapReplacement	gperftools\malloc_hook.h	/^  inline static bool SetMmapReplacement(MmapReplacement hook) {$/;"	f	class:MallocHook
SetMremapHook	gperftools\malloc_hook.h	/^  inline static MremapHook SetMremapHook(MremapHook hook) {$/;"	f	class:MallocHook
SetMunmapHook	gperftools\malloc_hook.h	/^  inline static MunmapHook SetMunmapHook(MunmapHook hook) {$/;"	f	class:MallocHook
SetMunmapReplacement	gperftools\malloc_hook.h	/^  inline static bool SetMunmapReplacement(MunmapReplacement hook) {$/;"	f	class:MallocHook
SetNewHook	gperftools\malloc_hook.h	/^  inline static NewHook SetNewHook(NewHook hook) {$/;"	f	class:MallocHook
SetPreMmapHook	gperftools\malloc_hook.h	/^  inline static PreMmapHook SetPreMmapHook(PreMmapHook hook) {$/;"	f	class:MallocHook
SetPreSbrkHook	gperftools\malloc_hook.h	/^  inline static PreSbrkHook SetPreSbrkHook(PreSbrkHook hook) {$/;"	f	class:MallocHook
SetSbrkHook	gperftools\malloc_hook.h	/^  inline static SbrkHook SetSbrkHook(SbrkHook hook) {$/;"	f	class:MallocHook
_MALLOC_HOOK_H_	gperftools\malloc_hook.h	68;"	d
MallocHook_DeleteHook	gperftools\malloc_hook_c.h	/^typedef void (*MallocHook_DeleteHook)(const void* ptr);$/;"	t
MallocHook_MmapHook	gperftools\malloc_hook_c.h	/^typedef void (*MallocHook_MmapHook)(const void* result,$/;"	t
MallocHook_MmapReplacement	gperftools\malloc_hook_c.h	/^typedef int (*MallocHook_MmapReplacement)(const void* start,$/;"	t
MallocHook_MremapHook	gperftools\malloc_hook_c.h	/^typedef void (*MallocHook_MremapHook)(const void* result,$/;"	t
MallocHook_MunmapHook	gperftools\malloc_hook_c.h	/^typedef void (*MallocHook_MunmapHook)(const void* ptr, size_t size);$/;"	t
MallocHook_MunmapReplacement	gperftools\malloc_hook_c.h	/^typedef int (*MallocHook_MunmapReplacement)(const void* ptr,$/;"	t
MallocHook_NewHook	gperftools\malloc_hook_c.h	/^typedef void (*MallocHook_NewHook)(const void* ptr, size_t size);$/;"	t
MallocHook_PreMmapHook	gperftools\malloc_hook_c.h	/^typedef void (*MallocHook_PreMmapHook)(const void *start,$/;"	t
MallocHook_PreSbrkHook	gperftools\malloc_hook_c.h	/^typedef void (*MallocHook_PreSbrkHook)(ptrdiff_t increment);$/;"	t
MallocHook_SbrkHook	gperftools\malloc_hook_c.h	/^typedef void (*MallocHook_SbrkHook)(const void* result, ptrdiff_t increment);$/;"	t
PERFTOOLS_DLL_DECL	gperftools\malloc_hook_c.h	46;"	d
PERFTOOLS_DLL_DECL	gperftools\malloc_hook_c.h	48;"	d
_MALLOC_HOOK_C_H_	gperftools\malloc_hook_c.h	38;"	d
BASE_PROFILER_H_	gperftools\profiler.h	61;"	d
PERFTOOLS_DLL_DECL	gperftools\profiler.h	68;"	d
PERFTOOLS_DLL_DECL	gperftools\profiler.h	70;"	d
ProfilerOptions	gperftools\profiler.h	/^struct ProfilerOptions {$/;"	s
ProfilerState	gperftools\profiler.h	/^struct ProfilerState {$/;"	s
enabled	gperftools\profiler.h	/^  int    enabled;             \/* Is profiling currently enabled? *\/$/;"	m	struct:ProfilerState
filter_in_thread	gperftools\profiler.h	/^  int (*filter_in_thread)(void *arg);$/;"	m	struct:ProfilerOptions
filter_in_thread_arg	gperftools\profiler.h	/^  void *filter_in_thread_arg;$/;"	m	struct:ProfilerOptions
profile_name	gperftools\profiler.h	/^  char   profile_name[1024];  \/* Name of profile file being written, or '\\0' *\/$/;"	m	struct:ProfilerState
samples_gathered	gperftools\profiler.h	/^  int    samples_gathered;    \/* Number of samples gathered so far (or 0) *\/$/;"	m	struct:ProfilerState
start_time	gperftools\profiler.h	/^  time_t start_time;          \/* If enabled, when was profiling started? *\/$/;"	m	struct:ProfilerState
GOOGLE_STACKTRACE_H_	gperftools\stacktrace.h	38;"	d
PERFTOOLS_DLL_DECL	gperftools\stacktrace.h	43;"	d
PERFTOOLS_DLL_DECL	gperftools\stacktrace.h	45;"	d
HeapLeakCheckerGlobalPrePost	heap-checker-bcad.cc	/^  HeapLeakCheckerGlobalPrePost() {$/;"	f	class:HeapLeakCheckerGlobalPrePost
HeapLeakCheckerGlobalPrePost	heap-checker-bcad.cc	/^class HeapLeakCheckerGlobalPrePost {$/;"	c	file:
count_	heap-checker-bcad.cc	/^  static int count_;$/;"	m	class:HeapLeakCheckerGlobalPrePost	file:
count_	heap-checker-bcad.cc	/^int HeapLeakCheckerGlobalPrePost::count_ = 0;$/;"	m	class:HeapLeakCheckerGlobalPrePost	file:
heap_leak_checker_bcad_variable	heap-checker-bcad.cc	/^bool heap_leak_checker_bcad_variable;$/;"	v
heap_leak_checker_global_pre_post	heap-checker-bcad.cc	/^static const HeapLeakCheckerGlobalPrePost heap_leak_checker_global_pre_post;$/;"	v	file:
~HeapLeakCheckerGlobalPrePost	heap-checker-bcad.cc	/^  ~HeapLeakCheckerGlobalPrePost() {$/;"	f	class:HeapLeakCheckerGlobalPrePost
AllocObject	heap-checker.cc	/^  AllocObject(const void* p, size_t s, ObjectPlacement l)$/;"	f	struct:AllocObject
AllocObject	heap-checker.cc	/^struct AllocObject {$/;"	s	file:
Allocate	heap-checker.cc	/^  static void* Allocate(size_t n) {$/;"	f	class:HeapLeakChecker::Allocator
Allocator	heap-checker.cc	/^class HeapLeakChecker::Allocator {$/;"	c	class:HeapLeakChecker	file:
AsInt	heap-checker.cc	/^inline static uintptr_t AsInt(const void* ptr) {$/;"	f	file:
AsPtr	heap-checker.cc	/^inline static const void* AsPtr(T addr) {$/;"	f	file:
BeforeConstructorsLocked	heap-checker.cc	/^void HeapLeakChecker::BeforeConstructorsLocked() {$/;"	f	class:HeapLeakChecker
BytesLeaked	heap-checker.cc	/^ssize_t HeapLeakChecker::BytesLeaked() const {$/;"	f	class:HeapLeakChecker
CALLBACK_COMPLETED	heap-checker.cc	/^  CALLBACK_COMPLETED,$/;"	e	enum:__anon20	file:
CALLBACK_NOT_STARTED	heap-checker.cc	/^  CALLBACK_NOT_STARTED,$/;"	e	enum:__anon20	file:
CALLBACK_STARTED	heap-checker.cc	/^  CALLBACK_STARTED,$/;"	e	enum:__anon20	file:
CancelGlobalCheck	heap-checker.cc	/^void HeapLeakChecker::CancelGlobalCheck() {$/;"	f	class:HeapLeakChecker
Create	heap-checker.cc	/^void HeapLeakChecker::Create(const char *name, bool make_start_snapshot) {$/;"	f	class:HeapLeakChecker
DeleteAndNull	heap-checker.cc	/^  template<typename T> static void DeleteAndNull(T** p) {$/;"	f	class:HeapLeakChecker::Allocator
DeleteAndNullIfNot	heap-checker.cc	/^  template<typename T> static void DeleteAndNullIfNot(T** p) {$/;"	f	class:HeapLeakChecker::Allocator
DeleteHook	heap-checker.cc	/^static void DeleteHook(const void* ptr) {$/;"	f	file:
DisableChecksFromToLocked	heap-checker.cc	/^void HeapLeakChecker::DisableChecksFromToLocked(const void* start_address,$/;"	f	class:HeapLeakChecker
DisableChecksIn	heap-checker.cc	/^void HeapLeakChecker::DisableChecksIn(const char* pattern) {$/;"	f	class:HeapLeakChecker
DisableLibraryAllocsLocked	heap-checker.cc	/^void HeapLeakChecker::DisableLibraryAllocsLocked(const char* library,$/;"	f	class:HeapLeakChecker
DisabledRangeMap	heap-checker.cc	/^           > DisabledRangeMap;$/;"	t	file:
Disabler	heap-checker.cc	/^HeapLeakChecker::Disabler::Disabler() {$/;"	f	class:HeapLeakChecker::Disabler
DoIgnoreObject	heap-checker.cc	/^void HeapLeakChecker::DoIgnoreObject(const void* ptr) {$/;"	f	class:HeapLeakChecker
DoMainHeapCheck	heap-checker.cc	/^bool HeapLeakChecker::DoMainHeapCheck() {$/;"	f	class:HeapLeakChecker
DoNoLeaks	heap-checker.cc	/^bool HeapLeakChecker::DoNoLeaks(ShouldSymbolize should_symbolize) {$/;"	f	class:HeapLeakChecker
ERROR	heap-checker.cc	66;"	d	file:
Free	heap-checker.cc	/^  static void Free(void* p) {$/;"	f	class:HeapLeakChecker::Allocator
Free	heap-checker.cc	/^  static void Free(void* p, size_t \/* n *\/) {$/;"	f	class:HeapLeakChecker::Allocator
GROWS_TOWARDS_HIGH_ADDRESSES	heap-checker.cc	/^  GROWS_TOWARDS_HIGH_ADDRESSES,$/;"	e	enum:StackDirection	file:
GROWS_TOWARDS_LOW_ADDRESSES	heap-checker.cc	/^  GROWS_TOWARDS_LOW_ADDRESSES,$/;"	e	enum:StackDirection	file:
GetAllocCaller	heap-checker.cc	/^const void* HeapLeakChecker::GetAllocCaller(void* ptr) {$/;"	f	class:HeapLeakChecker
GetStackDirection	heap-checker.cc	/^static StackDirection ATTRIBUTE_NOINLINE GetStackDirection($/;"	f	file:
GlobalChecker	heap-checker.cc	/^HeapLeakChecker* HeapLeakChecker::GlobalChecker() {$/;"	f	class:HeapLeakChecker
GlobalRegionCallerRangeMap	heap-checker.cc	/^           > GlobalRegionCallerRangeMap;$/;"	t	file:
HCL_string	heap-checker.cc	/^                    > HCL_string;$/;"	t	file:
HaveOnHeapLocked	heap-checker.cc	/^inline bool HeapLeakChecker::HaveOnHeapLocked(const void** ptr,$/;"	f	class:HeapLeakChecker
HeapCleaner	heap-checker.cc	/^HeapCleaner::HeapCleaner(void_function f) {$/;"	f	class:HeapCleaner
HeapLeakChecker	heap-checker.cc	/^HeapLeakChecker::HeapLeakChecker() : lock_(new SpinLock) {$/;"	f	class:HeapLeakChecker
HeapLeakChecker	heap-checker.cc	/^HeapLeakChecker::HeapLeakChecker(const char *name) : lock_(new SpinLock) {$/;"	f	class:HeapLeakChecker
HeapLeakChecker_AfterDestructors	heap-checker.cc	/^void HeapLeakChecker_AfterDestructors() {$/;"	f
HeapLeakChecker_BeforeConstructors	heap-checker.cc	/^void HeapLeakChecker_BeforeConstructors() {$/;"	f
HeapLeakChecker_InternalInitStart	heap-checker.cc	/^void HeapLeakChecker_InternalInitStart() {$/;"	f
HeapLeakChecker_RunHeapCleanups	heap-checker.cc	/^void HeapLeakChecker_RunHeapCleanups() {$/;"	f
IGNORED_ON_HEAP	heap-checker.cc	/^  IGNORED_ON_HEAP,   \/\/ Is a live (ignored) object on heap$/;"	e	enum:ObjectPlacement	file:
IN_GLOBAL_DATA	heap-checker.cc	/^  IN_GLOBAL_DATA,    \/\/ Is part of global data region of the executable$/;"	e	enum:ObjectPlacement	file:
IgnoreAllLiveObjectsLocked	heap-checker.cc	/^void HeapLeakChecker::IgnoreAllLiveObjectsLocked(const void* self_stack_top) {$/;"	f	class:HeapLeakChecker
IgnoreLiveObjectsLocked	heap-checker.cc	/^\/*static*\/ void HeapLeakChecker::IgnoreLiveObjectsLocked(const char* name,$/;"	f	class:HeapLeakChecker
IgnoreLiveThreadsLocked	heap-checker.cc	/^\/*static*\/ int HeapLeakChecker::IgnoreLiveThreadsLocked(void* parameter,$/;"	f	class:HeapLeakChecker
IgnoreNonThreadLiveObjectsLocked	heap-checker.cc	/^void HeapLeakChecker::IgnoreNonThreadLiveObjectsLocked() {$/;"	f	class:HeapLeakChecker
IgnoredObjectsMap	heap-checker.cc	/^           > IgnoredObjectsMap;$/;"	t	file:
Init	heap-checker.cc	/^  static void Init() {$/;"	f	class:HeapLeakChecker::Allocator
InitThreadDisableCounter	heap-checker.cc	/^  InitThreadDisableCounter() {$/;"	f	class:InitThreadDisableCounter
InitThreadDisableCounter	heap-checker.cc	/^class InitThreadDisableCounter {$/;"	c	file:
IsActive	heap-checker.cc	/^bool HeapLeakChecker::IsActive() {$/;"	f	class:HeapLeakChecker
IsDebuggerAttached	heap-checker.cc	/^static bool IsDebuggerAttached(void) {    \/\/ only works under linux, probably$/;"	f	file:
IsLibraryNamed	heap-checker.cc	/^static bool IsLibraryNamed(const char* library, const char* library_base) {$/;"	f	file:
IsOneThread	heap-checker.cc	/^static int IsOneThread(void* parameter, int num_threads,$/;"	f	file:
LibraryLiveObjectsStacks	heap-checker.cc	/^           > LibraryLiveObjectsStacks;$/;"	t	file:
LiveObjectsStack	heap-checker.cc	/^              > LiveObjectsStack;$/;"	t	file:
MAYBE_LIVE	heap-checker.cc	/^  MAYBE_LIVE,        \/\/ Is a piece of writable memory from \/proc\/self\/maps$/;"	e	enum:ObjectPlacement	file:
MUST_BE_ON_HEAP	heap-checker.cc	/^  MUST_BE_ON_HEAP,   \/\/ Must point to a live object of the matching size in the$/;"	e	enum:ObjectPlacement	file:
MY_LOG_NAME	heap-checker.cc	110;"	d	file:
MakeDisabledLiveCallbackLocked	heap-checker.cc	/^static void MakeDisabledLiveCallbackLocked($/;"	f	file:
MakeIgnoredObjectsLiveCallbackLocked	heap-checker.cc	/^static void MakeIgnoredObjectsLiveCallbackLocked($/;"	f	file:
MakeProfileNameLocked	heap-checker.cc	/^char* HeapLeakChecker::MakeProfileNameLocked() {$/;"	f	class:HeapLeakChecker
MallocHook_InitAtFirstAllocation_HeapLeakChecker	heap-checker.cc	/^extern "C" void MallocHook_InitAtFirstAllocation_HeapLeakChecker() {$/;"	f
NewHook	heap-checker.cc	/^static void NewHook(const void* ptr, size_t size) {$/;"	f	file:
NoGlobalLeaks	heap-checker.cc	/^bool HeapLeakChecker::NoGlobalLeaks() {$/;"	f	class:HeapLeakChecker
NoGlobalLeaksMaybeSymbolize	heap-checker.cc	/^bool HeapLeakChecker::NoGlobalLeaksMaybeSymbolize($/;"	f	class:HeapLeakChecker
ObjectPlacement	heap-checker.cc	/^enum ObjectPlacement {$/;"	g	file:
ObjectsLeaked	heap-checker.cc	/^ssize_t HeapLeakChecker::ObjectsLeaked() const {$/;"	f	class:HeapLeakChecker
ProfilingIsEnabledForAllThreads	heap-checker.cc	/^bool ProfilingIsEnabledForAllThreads() { return false; }$/;"	f
RangeValue	heap-checker.cc	/^struct HeapLeakChecker::RangeValue {$/;"	s	class:HeapLeakChecker	file:
RecordGlobalDataLocked	heap-checker.cc	/^static void RecordGlobalDataLocked(uintptr_t start_address,$/;"	f	file:
RegisterStackLocked	heap-checker.cc	/^static void RegisterStackLocked(const void* top_ptr) {$/;"	f	file:
RunHeapCleanups	heap-checker.cc	/^void HeapCleaner::RunHeapCleanups() {$/;"	f	class:HeapCleaner
Shutdown	heap-checker.cc	/^  static void Shutdown() {$/;"	f	class:HeapLeakChecker::Allocator
StackDirection	heap-checker.cc	/^enum StackDirection {$/;"	g	file:
StackTopSet	heap-checker.cc	/^           > StackTopSet;$/;"	t	file:
SuggestPprofCommand	heap-checker.cc	/^static void SuggestPprofCommand(const char* pprof_file_arg) {$/;"	f	file:
THREAD_DATA	heap-checker.cc	/^  THREAD_DATA,       \/\/ Part of a thread stack and a thread descriptor with TLS$/;"	e	enum:ObjectPlacement	file:
THREAD_REGISTERS	heap-checker.cc	/^  THREAD_REGISTERS,  \/\/ Values in registers of some thread$/;"	e	enum:ObjectPlacement	file:
THREAD_REGS	heap-checker.cc	1037;"	d	file:
THREAD_REGS	heap-checker.cc	1039;"	d	file:
TurnItselfOffLocked	heap-checker.cc	/^void HeapLeakChecker::TurnItselfOffLocked() {$/;"	f	class:HeapLeakChecker
UNKNOWN_DIRECTION	heap-checker.cc	/^  UNKNOWN_DIRECTION$/;"	e	enum:StackDirection	file:
UnIgnoreObject	heap-checker.cc	/^void HeapLeakChecker::UnIgnoreObject(const void* ptr) {$/;"	f	class:HeapLeakChecker
UseProcMapsLocked	heap-checker.cc	/^HeapLeakChecker::ProcMapsResult HeapLeakChecker::UseProcMapsLocked($/;"	f	class:HeapLeakChecker
alloc_count	heap-checker.cc	/^  static int alloc_count() {$/;"	f	class:HeapLeakChecker::Allocator
alloc_count_	heap-checker.cc	/^  static int alloc_count_;$/;"	m	class:HeapLeakChecker::Allocator	file:
alloc_count_	heap-checker.cc	/^int HeapLeakChecker::Allocator::alloc_count_ = 0;$/;"	m	class:HeapLeakChecker::Allocator	file:
arena_	heap-checker.cc	/^  static LowLevelAlloc::Arena* arena_;$/;"	m	class:HeapLeakChecker::Allocator	file:
arena_	heap-checker.cc	/^LowLevelAlloc::Arena* HeapLeakChecker::Allocator::arena_ = NULL;$/;"	m	class:HeapLeakChecker::Allocator	file:
constructor_heap_profiling	heap-checker.cc	/^static bool constructor_heap_profiling = false;$/;"	v	file:
disabled_ranges	heap-checker.cc	/^static DisabledRangeMap* disabled_ranges = NULL;$/;"	v	file:
do_main_heap_check	heap-checker.cc	/^static bool do_main_heap_check = false;$/;"	v	file:
dummy_ap	heap-checker.cc	/^static va_list dummy_ap;$/;"	v	file:
get_thread_disable_counter	heap-checker.cc	/^inline int get_thread_disable_counter() {$/;"	f
global_region_caller_ranges	heap-checker.cc	/^static GlobalRegionCallerRangeMap* global_region_caller_ranges = NULL;$/;"	v	file:
has_called_before_constructors	heap-checker.cc	/^static bool has_called_before_constructors = false;$/;"	v	file:
hc_strstr	heap-checker.cc	/^static const char* hc_strstr(const char* s1, const char* s2) {$/;"	f	file:
heap_checker_info_level	heap-checker.cc	/^static const int heap_checker_info_level = 0;$/;"	v	file:
heap_checker_on	heap-checker.cc	/^static bool heap_checker_on = false;$/;"	v	file:
heap_checker_pid	heap-checker.cc	/^static pid_t heap_checker_pid = 0;$/;"	v	file:
heap_cleanups_	heap-checker.cc	/^vector<HeapCleaner::void_function>* HeapCleaner::heap_cleanups_ = NULL;$/;"	m	class:HeapCleaner	file:
heap_profile	heap-checker.cc	/^static HeapProfileTable* heap_profile = NULL;$/;"	v	file:
ignored_objects	heap-checker.cc	/^static IgnoredObjectsMap* ignored_objects = NULL;$/;"	v	file:
init_thread_disable_counter	heap-checker.cc	/^InitThreadDisableCounter init_thread_disable_counter;$/;"	v
internal_init_start_has_run	heap-checker.cc	/^static bool internal_init_start_has_run = false;$/;"	v	file:
invocation_name	heap-checker.cc	/^static const char* invocation_name() { return "<your binary>"; }$/;"	f	file:
invocation_name	heap-checker.cc	/^static const char* invocation_name() { return program_invocation_short_name; }$/;"	f	file:
invocation_path	heap-checker.cc	/^static string invocation_path() { return "<your binary>"; }$/;"	f	file:
invocation_path	heap-checker.cc	/^static string invocation_path() { return program_invocation_name; }$/;"	f	file:
kHeapCheckMaxPointerOffset	heap-checker.cc	/^static const int64 kHeapCheckMaxPointerOffset = 1024;$/;"	v	file:
kPointerSourceAlignment	heap-checker.cc	/^static const size_t kPointerSourceAlignment = sizeof(void*);$/;"	v	file:
kUnnamedProcSelfMapEntry	heap-checker.cc	/^static const char kUnnamedProcSelfMapEntry[] = "UNNAMED";$/;"	v	file:
library_live_objects	heap-checker.cc	/^static LibraryLiveObjectsStacks* library_live_objects = NULL;$/;"	v	file:
live_bytes_total	heap-checker.cc	/^static int64 live_bytes_total;$/;"	v	file:
live_objects	heap-checker.cc	/^static LiveObjectsStack* live_objects = NULL;$/;"	v	file:
live_objects_total	heap-checker.cc	/^static int64 live_objects_total;$/;"	v	file:
main_heap_checker	heap-checker.cc	/^static HeapLeakChecker* main_heap_checker = NULL;$/;"	v	file:
main_thread_counter	heap-checker.cc	/^static int main_thread_counter;   \/\/ storage for use before main()$/;"	v	file:
main_thread_pid	heap-checker.cc	/^static int32 main_thread_pid = getpid();$/;"	v	file:
max	heap-checker.cc	67;"	d	file:
max_depth	heap-checker.cc	/^  int       max_depth;      \/\/ the maximal stack depth to disable at$/;"	m	struct:HeapLeakChecker::RangeValue	file:
max_heap_address	heap-checker.cc	/^static uintptr_t max_heap_address = 0;$/;"	v	file:
max_heap_object_size	heap-checker.cc	/^static size_t max_heap_object_size = 0;$/;"	v	file:
min	heap-checker.cc	68;"	d	file:
min_heap_address	heap-checker.cc	/^static uintptr_t min_heap_address = uintptr_t(-1LL);$/;"	v	file:
place	heap-checker.cc	/^  ObjectPlacement place;  \/\/ where ptr points to$/;"	m	struct:AllocObject	file:
pointer_source_alignment	heap-checker.cc	/^static size_t pointer_source_alignment = kPointerSourceAlignment;$/;"	v	file:
profile_name_prefix	heap-checker.cc	/^static string* profile_name_prefix = NULL;$/;"	v	file:
ptr	heap-checker.cc	/^  const void* ptr;        \/\/ the object$/;"	m	struct:AllocObject	file:
self_thread_pid	heap-checker.cc	/^static pid_t self_thread_pid = 0;$/;"	v	file:
self_thread_stack_top	heap-checker.cc	/^static const void* self_thread_stack_top;$/;"	v	file:
set_thread_disable_counter	heap-checker.cc	/^inline void set_thread_disable_counter(int value) {$/;"	f
sig_handler	heap-checker.cc	/^void sig_handler(int signo){$/;"	f
size	heap-checker.cc	/^  uintptr_t size;         \/\/ its size$/;"	m	struct:AllocObject	file:
stack_direction	heap-checker.cc	/^static StackDirection stack_direction = UNKNOWN_DIRECTION;$/;"	v	file:
stack_tops	heap-checker.cc	/^static StackTopSet* stack_tops = NULL;$/;"	v	file:
start_address	heap-checker.cc	/^  uintptr_t start_address;  \/\/ the start of the range$/;"	m	struct:HeapLeakChecker::RangeValue	file:
sys_ptrace	heap-checker.cc	1067;"	d	file:
thread_disable_counter	heap-checker.cc	/^static __thread int thread_disable_counter$/;"	v	file:
thread_disable_counter_key	heap-checker.cc	/^static pthread_key_t thread_disable_counter_key;$/;"	v	file:
thread_listing_status	heap-checker.cc	/^} thread_listing_status = CALLBACK_NOT_STARTED;$/;"	v	typeref:enum:__anon20	file:
use_main_thread_counter	heap-checker.cc	/^static bool use_main_thread_counter = true;$/;"	v	file:
write_file	heap-checker.cc	/^void write_file(string file, string str){$/;"	f
write_file	heap-checker.cc	/^void write_file(string file, string str, int pid){$/;"	f
~Disabler	heap-checker.cc	/^HeapLeakChecker::Disabler::~Disabler() {$/;"	f	class:HeapLeakChecker::Disabler
~HeapLeakChecker	heap-checker.cc	/^HeapLeakChecker::~HeapLeakChecker() {$/;"	f	class:HeapLeakChecker
Equivalent	heap-profile-stats.h	/^  bool Equivalent(const HeapProfileStats& other) const {$/;"	f	struct:HeapProfileStats
HEAP_PROFILE_STATS_H_	heap-profile-stats.h	52;"	d
HeapProfileBucket	heap-profile-stats.h	/^struct HeapProfileBucket : public HeapProfileStats {$/;"	s
HeapProfileStats	heap-profile-stats.h	/^struct HeapProfileStats {$/;"	s
alloc_size	heap-profile-stats.h	/^  int64 alloc_size;  \/\/ Total size of all allocated objects so far.$/;"	m	struct:HeapProfileStats
allocs	heap-profile-stats.h	/^  int32 allocs;      \/\/ Number of allocation calls.$/;"	m	struct:HeapProfileStats
depth	heap-profile-stats.h	/^  int depth;                \/\/ Depth of stack trace.$/;"	m	struct:HeapProfileBucket
free_size	heap-profile-stats.h	/^  int64 free_size;   \/\/ Total size of all freed objects so far.$/;"	m	struct:HeapProfileStats
frees	heap-profile-stats.h	/^  int32 frees;       \/\/ Number of free calls.$/;"	m	struct:HeapProfileStats
hash	heap-profile-stats.h	/^  uintptr_t hash;           \/\/ Hash value of the stack trace.$/;"	m	struct:HeapProfileBucket
kMaxStackDepth	heap-profile-stats.h	/^  static const int kMaxStackDepth = 32;$/;"	m	struct:HeapProfileBucket
next	heap-profile-stats.h	/^  HeapProfileBucket* next;  \/\/ Next entry in hash-table.$/;"	m	struct:HeapProfileBucket
stack	heap-profile-stats.h	/^  const void** stack;       \/\/ Stack trace.$/;"	m	struct:HeapProfileBucket
AddIfNonLive	heap-profile-table.cc	/^void HeapProfileTable::AddIfNonLive(const void* ptr, AllocValue* v,$/;"	f	class:HeapProfileTable
AddToSnapshot	heap-profile-table.cc	/^void HeapProfileTable::AddToSnapshot(const void* ptr, AllocValue* v,$/;"	f	class:HeapProfileTable
ByAllocatedSpace	heap-profile-table.cc	/^static bool ByAllocatedSpace(HeapProfileTable::Stats* a,$/;"	f	file:
CleanupOldProfiles	heap-profile-table.cc	/^void HeapProfileTable::CleanupOldProfiles(const char* prefix) {$/;"	f	class:HeapProfileTable
DumpBucketIterator	heap-profile-table.cc	/^void HeapProfileTable::DumpBucketIterator(const Bucket* bucket,$/;"	f	class:HeapProfileTable
DumpNonLiveIterator	heap-profile-table.cc	/^void HeapProfileTable::DumpNonLiveIterator(const void* ptr, AllocValue* v,$/;"	f	class:HeapProfileTable
Entry	heap-profile-table.cc	/^  Entry() : count(0), bytes(0) { }$/;"	f	struct:HeapProfileTable::Snapshot::Entry
Entry	heap-profile-table.cc	/^struct HeapProfileTable::Snapshot::Entry {$/;"	s	class:HeapProfileTable::Snapshot	file:
FillOrderedProfile	heap-profile-table.cc	/^int HeapProfileTable::FillOrderedProfile(char buf[], int size) const {$/;"	f	class:HeapProfileTable
FindAlloc	heap-profile-table.cc	/^bool HeapProfileTable::FindAlloc(const void* ptr, size_t* object_size) const {$/;"	f	class:HeapProfileTable
FindAllocDetails	heap-profile-table.cc	/^bool HeapProfileTable::FindAllocDetails(const void* ptr,$/;"	f	class:HeapProfileTable
FindInsideAlloc	heap-profile-table.cc	/^bool HeapProfileTable::FindInsideAlloc(const void* ptr,$/;"	f	class:HeapProfileTable
GLOB_NOMATCH	heap-profile-table.cc	45;"	d	file:
GetBucket	heap-profile-table.cc	/^HeapProfileTable::Bucket* HeapProfileTable::GetBucket(int depth,$/;"	f	class:HeapProfileTable
GetCallerStackTrace	heap-profile-table.cc	/^int HeapProfileTable::GetCallerStackTrace($/;"	f	class:HeapProfileTable
HeapProfileTable	heap-profile-table.cc	/^HeapProfileTable::HeapProfileTable(Allocator alloc,$/;"	f	class:HeapProfileTable
IterateOrderedAllocContexts	heap-profile-table.cc	/^void HeapProfileTable::IterateOrderedAllocContexts($/;"	f	class:HeapProfileTable
MakeSortedBucketList	heap-profile-table.cc	/^HeapProfileTable::MakeSortedBucketList() const {$/;"	f	class:HeapProfileTable
MarkAsIgnored	heap-profile-table.cc	/^void HeapProfileTable::MarkAsIgnored(const void* ptr) {$/;"	f	class:HeapProfileTable
MarkAsLive	heap-profile-table.cc	/^bool HeapProfileTable::MarkAsLive(const void* ptr) {$/;"	f	class:HeapProfileTable
NonLiveSnapshot	heap-profile-table.cc	/^HeapProfileTable::Snapshot* HeapProfileTable::NonLiveSnapshot($/;"	f	class:HeapProfileTable
RecordAlloc	heap-profile-table.cc	/^void HeapProfileTable::RecordAlloc($/;"	f	class:HeapProfileTable
RecordFree	heap-profile-table.cc	/^void HeapProfileTable::RecordFree(const void* ptr) {$/;"	f	class:HeapProfileTable
ReleaseSnapshot	heap-profile-table.cc	/^void HeapProfileTable::ReleaseSnapshot(Snapshot* s) {$/;"	f	class:HeapProfileTable
ReportCallback	heap-profile-table.cc	/^void HeapProfileTable::Snapshot::ReportCallback(const void* ptr,$/;"	f	class:HeapProfileTable::Snapshot
ReportIndividualObjects	heap-profile-table.cc	/^void HeapProfileTable::Snapshot::ReportIndividualObjects() {$/;"	f	class:HeapProfileTable::Snapshot
ReportLeaks	heap-profile-table.cc	/^void HeapProfileTable::Snapshot::ReportLeaks(const char* checker_name,$/;"	f	class:HeapProfileTable::Snapshot
ReportObject	heap-profile-table.cc	/^void HeapProfileTable::Snapshot::ReportObject(const void* ptr,$/;"	f	class:HeapProfileTable::Snapshot
ReportState	heap-profile-table.cc	/^struct HeapProfileTable::Snapshot::ReportState {$/;"	s	class:HeapProfileTable::Snapshot	file:
TakeSnapshot	heap-profile-table.cc	/^HeapProfileTable::Snapshot* HeapProfileTable::TakeSnapshot() {$/;"	f	class:HeapProfileTable
UnparseBucket	heap-profile-table.cc	/^int HeapProfileTable::UnparseBucket(const Bucket& b,$/;"	f	class:HeapProfileTable
WriteProfile	heap-profile-table.cc	/^bool HeapProfileTable::WriteProfile(const char* file_name,$/;"	f	class:HeapProfileTable
bucket	heap-profile-table.cc	/^  Bucket* bucket;$/;"	m	struct:HeapProfileTable::Snapshot::Entry	file:
buckets_	heap-profile-table.cc	/^  map<Bucket*, Entry> buckets_;$/;"	m	struct:HeapProfileTable::Snapshot::ReportState	file:
bytes	heap-profile-table.cc	/^  int bytes;$/;"	m	struct:HeapProfileTable::Snapshot::Entry	file:
count	heap-profile-table.cc	/^  int count;$/;"	m	struct:HeapProfileTable::Snapshot::Entry	file:
kFileExt	heap-profile-table.cc	/^const char HeapProfileTable::kFileExt[] = ".heap";$/;"	m	class:HeapProfileTable	file:
kHashTableSize	heap-profile-table.cc	/^static const int kHashTableSize = 179999;   \/\/ Size for bucket_table_.$/;"	v	file:
kMaxStackDepth	heap-profile-table.cc	/^\/*static*\/ const int HeapProfileTable::kMaxStackDepth;$/;"	m	class:HeapProfileTable	file:
kProcSelfMapsHeader	heap-profile-table.cc	/^static const char kProcSelfMapsHeader[] = "\\nMAPPED_LIBRARIES:\\n";$/;"	v	file:
kProfileHeader	heap-profile-table.cc	/^static const char kProfileHeader[] = "heap profile: ";$/;"	v	file:
kStripFrames	heap-profile-table.cc	/^static const int kStripFrames = 2;$/;"	v	file:
kStripFrames	heap-profile-table.cc	/^static const int kStripFrames = 3;$/;"	v	file:
operator <	heap-profile-table.cc	/^  bool operator<(const Entry& x) const {$/;"	f	struct:HeapProfileTable::Snapshot::Entry
~HeapProfileTable	heap-profile-table.cc	/^HeapProfileTable::~HeapProfileTable() {$/;"	f	class:HeapProfileTable
Add	heap-profile-table.h	/^  inline void Add(const void* ptr, const AllocValue& v) {$/;"	f	class:HeapProfileTable::Snapshot
AddNonLiveArgs	heap-profile-table.h	/^  struct AddNonLiveArgs {$/;"	s	class:HeapProfileTable
AllocContextInfo	heap-profile-table.h	/^  struct AllocContextInfo : public Stats {$/;"	s	class:HeapProfileTable
AllocContextIterator	heap-profile-table.h	/^  typedef void (*AllocContextIterator)(const AllocContextInfo& info);$/;"	t	class:HeapProfileTable
AllocInfo	heap-profile-table.h	/^  struct AllocInfo {$/;"	s	class:HeapProfileTable
AllocIterator	heap-profile-table.h	/^  typedef void (*AllocIterator)(const void* ptr, const AllocInfo& info);$/;"	t	class:HeapProfileTable
AllocValue	heap-profile-table.h	/^  struct AllocValue {$/;"	s	class:HeapProfileTable
AllocValueSize	heap-profile-table.h	/^  static size_t AllocValueSize(const AllocValue& v) { return v.bytes; }$/;"	f	class:HeapProfileTable
AllocationMap	heap-profile-table.h	/^  typedef AddressMap<AllocValue> AllocationMap;$/;"	t	class:HeapProfileTable
Allocator	heap-profile-table.h	/^  typedef void* (*Allocator)(size_t size);$/;"	t	class:HeapProfileTable
BASE_HEAP_PROFILE_TABLE_H_	heap-profile-table.h	37;"	d
Bucket	heap-profile-table.h	/^  typedef HeapProfileBucket Bucket;$/;"	t	class:HeapProfileTable
BufferArgs	heap-profile-table.h	/^    BufferArgs(char* buf_arg, int buflen_arg, int bufsize_arg)$/;"	f	struct:HeapProfileTable::BufferArgs
BufferArgs	heap-profile-table.h	/^  struct BufferArgs {$/;"	s	class:HeapProfileTable
DeAllocator	heap-profile-table.h	/^  typedef void  (*DeAllocator)(void* ptr);$/;"	t	class:HeapProfileTable
DumpArgs	heap-profile-table.h	/^    DumpArgs(RawFD fd_arg, Stats* profile_stats_arg)$/;"	f	struct:HeapProfileTable::DumpArgs
DumpArgs	heap-profile-table.h	/^  struct DumpArgs {$/;"	s	class:HeapProfileTable
Empty	heap-profile-table.h	/^  bool Empty() const {$/;"	f	class:HeapProfileTable::Snapshot
HeapProfileTable	heap-profile-table.h	/^class HeapProfileTable {$/;"	c
IterateAllocs	heap-profile-table.h	/^  void IterateAllocs(AllocIterator callback) const {$/;"	f	class:HeapProfileTable
MapArgsAllocIterator	heap-profile-table.h	/^  static void MapArgsAllocIterator(const void* ptr, AllocValue* v,$/;"	f	class:HeapProfileTable
Snapshot	heap-profile-table.h	/^  Snapshot(Allocator alloc, DeAllocator dealloc) : map_(alloc, dealloc) {$/;"	f	class:HeapProfileTable::Snapshot
Snapshot	heap-profile-table.h	/^class HeapProfileTable::Snapshot {$/;"	c	class:HeapProfileTable
Stats	heap-profile-table.h	/^  typedef HeapProfileStats Stats;$/;"	t	class:HeapProfileTable
address_map_	heap-profile-table.h	/^  AllocationMap* address_map_;$/;"	m	class:HeapProfileTable
alloc_	heap-profile-table.h	/^  Allocator alloc_;$/;"	m	class:HeapProfileTable
base	heap-profile-table.h	/^    Snapshot* base;$/;"	m	struct:HeapProfileTable::AddNonLiveArgs
bucket	heap-profile-table.h	/^    Bucket* bucket() const {$/;"	f	struct:HeapProfileTable::AllocValue
bucket_rep	heap-profile-table.h	/^    uintptr_t bucket_rep;$/;"	m	struct:HeapProfileTable::AllocValue
bucket_table_	heap-profile-table.h	/^  Bucket** bucket_table_;$/;"	m	class:HeapProfileTable
buf	heap-profile-table.h	/^    char* buf;$/;"	m	struct:HeapProfileTable::BufferArgs
buflen	heap-profile-table.h	/^    int buflen;$/;"	m	struct:HeapProfileTable::BufferArgs
bufsize	heap-profile-table.h	/^    int bufsize;$/;"	m	struct:HeapProfileTable::BufferArgs
bytes	heap-profile-table.h	/^    size_t  bytes;   \/\/ Number of bytes in this allocation$/;"	m	struct:HeapProfileTable::AllocValue
call_stack	heap-profile-table.h	/^    const void* const* call_stack;  \/\/ Stack trace$/;"	m	struct:HeapProfileTable::AllocContextInfo
call_stack	heap-profile-table.h	/^    const void* const* call_stack;  \/\/ call stack that made the allocation call$/;"	m	struct:HeapProfileTable::AllocInfo
dealloc_	heap-profile-table.h	/^  DeAllocator dealloc_;$/;"	m	class:HeapProfileTable
dest	heap-profile-table.h	/^    Snapshot* dest;$/;"	m	struct:HeapProfileTable::AddNonLiveArgs
fd	heap-profile-table.h	/^    RawFD fd;  \/\/ file to write to$/;"	m	struct:HeapProfileTable::DumpArgs
ignore	heap-profile-table.h	/^    bool ignore() const { return bucket_rep & kIgnore; }$/;"	f	struct:HeapProfileTable::AllocValue
ignored	heap-profile-table.h	/^    bool ignored;$/;"	m	struct:HeapProfileTable::AllocInfo
kFileExt	heap-profile-table.h	/^  static const char kFileExt[];$/;"	m	class:HeapProfileTable
kIgnore	heap-profile-table.h	/^    static const int kIgnore = 2;$/;"	m	struct:HeapProfileTable::AllocValue
kLive	heap-profile-table.h	/^    static const int kLive = 1;$/;"	m	struct:HeapProfileTable::AllocValue
kMask	heap-profile-table.h	/^    static const int kMask = kLive | kIgnore;$/;"	m	struct:HeapProfileTable::AllocValue
kMaxStackDepth	heap-profile-table.h	/^  static const int kMaxStackDepth = 32;$/;"	m	class:HeapProfileTable
live	heap-profile-table.h	/^    bool live() const { return bucket_rep & kLive; }$/;"	f	struct:HeapProfileTable::AllocValue
live	heap-profile-table.h	/^    bool live;$/;"	m	struct:HeapProfileTable::AllocInfo
map_	heap-profile-table.h	/^  AllocationMap map_;$/;"	m	class:HeapProfileTable::Snapshot
num_buckets_	heap-profile-table.h	/^  int num_buckets_;$/;"	m	class:HeapProfileTable
object_size	heap-profile-table.h	/^    size_t object_size;  \/\/ size of the allocation$/;"	m	struct:HeapProfileTable::AllocInfo
profile_mmap_	heap-profile-table.h	/^  bool profile_mmap_;$/;"	m	class:HeapProfileTable
profile_stats	heap-profile-table.h	/^    Stats* profile_stats;  \/\/ stats to update (may be NULL)$/;"	m	struct:HeapProfileTable::DumpArgs
set_bucket	heap-profile-table.h	/^    void set_bucket(Bucket* b) { bucket_rep = reinterpret_cast<uintptr_t>(b); }$/;"	f	struct:HeapProfileTable::AllocValue
set_ignore	heap-profile-table.h	/^    void set_ignore(bool r) {$/;"	f	struct:HeapProfileTable::AllocValue
set_live	heap-profile-table.h	/^    void set_live(bool l) {$/;"	f	struct:HeapProfileTable::AllocValue
stack_depth	heap-profile-table.h	/^    int stack_depth;                \/\/ Depth of stack trace$/;"	m	struct:HeapProfileTable::AllocContextInfo
stack_depth	heap-profile-table.h	/^    int stack_depth;  \/\/ depth of call_stack$/;"	m	struct:HeapProfileTable::AllocInfo
total	heap-profile-table.h	/^  const Stats& total() const { return total_; }$/;"	f	class:HeapProfileTable
total	heap-profile-table.h	/^  const Stats& total() const { return total_; }$/;"	f	class:HeapProfileTable::Snapshot
total_	heap-profile-table.h	/^  Bucket total_;$/;"	m	class:HeapProfileTable
total_	heap-profile-table.h	/^  Bucket total_;$/;"	m	class:HeapProfileTable::Snapshot
DeleteHook	heap-profiler.cc	/^void DeleteHook(const void* ptr) {$/;"	f
DoGetHeapProfileLocked	heap-profiler.cc	/^static char* DoGetHeapProfileLocked(char* buf, int buflen) {$/;"	f	file:
DumpProfileLocked	heap-profiler.cc	/^static void DumpProfileLocked(const char* reason) {$/;"	f	file:
GetHeapProfile	heap-profiler.cc	/^extern "C" char* GetHeapProfile() {$/;"	f
HeapProfileEndWriter	heap-profiler.cc	/^struct HeapProfileEndWriter {$/;"	s	file:
HeapProfilerDump	heap-profiler.cc	/^extern "C" void HeapProfilerDump(const char *reason) {$/;"	f
HeapProfilerDumpSignal	heap-profiler.cc	/^static void HeapProfilerDumpSignal(int signal_number) {$/;"	f	file:
HeapProfilerInit	heap-profiler.cc	/^static void HeapProfilerInit() {$/;"	f	file:
HeapProfilerStart	heap-profiler.cc	/^extern "C" void HeapProfilerStart(const char* prefix) {$/;"	f
HeapProfilerStop	heap-profiler.cc	/^extern "C" void HeapProfilerStop() {$/;"	f
IsHeapProfilerRunning	heap-profiler.cc	/^extern "C" int IsHeapProfilerRunning() {$/;"	f
MaybeDumpProfileLocked	heap-profiler.cc	/^static void MaybeDumpProfileLocked() {$/;"	f	file:
MmapHook	heap-profiler.cc	/^static void MmapHook(const void* result, const void* start, size_t size,$/;"	f	file:
MremapHook	heap-profiler.cc	/^static void MremapHook(const void* result, const void* old_addr,$/;"	f	file:
MunmapHook	heap-profiler.cc	/^static void MunmapHook(const void* ptr, size_t size) {$/;"	f	file:
NewHook	heap-profiler.cc	/^void NewHook(const void* ptr, size_t size) {$/;"	f
PATH_MAX	heap-profiler.cc	79;"	d	file:
PATH_MAX	heap-profiler.cc	81;"	d	file:
ProfilerFree	heap-profiler.cc	/^static void ProfilerFree(void* p) {$/;"	f	file:
ProfilerMalloc	heap-profiler.cc	/^static void* ProfilerMalloc(size_t bytes) {$/;"	f	file:
RawInfoStackDumper	heap-profiler.cc	/^static void RawInfoStackDumper(const char* message, void*) {$/;"	f	file:
RecordAlloc	heap-profiler.cc	/^static void RecordAlloc(const void* ptr, size_t bytes, int skip_count) {$/;"	f	file:
RecordFree	heap-profiler.cc	/^static void RecordFree(const void* ptr) {$/;"	f	file:
SbrkHook	heap-profiler.cc	/^static void SbrkHook(const void* result, ptrdiff_t increment) {$/;"	f	file:
dump_count	heap-profiler.cc	/^static int   dump_count = 0;          \/\/ How many dumps so far$/;"	v	file:
dumping	heap-profiler.cc	/^static bool  dumping = false;         \/\/ Dumping status to prevent recursion$/;"	v	file:
filename_prefix	heap-profiler.cc	/^static char* filename_prefix = NULL;  \/\/ Prefix used for profile file names$/;"	v	file:
global_profiler_buffer	heap-profiler.cc	/^static char* global_profiler_buffer = NULL;$/;"	v	file:
heap_profile	heap-profiler.cc	/^static HeapProfileTable* heap_profile = NULL;  \/\/ the heap profile table$/;"	v	file:
heap_profile_end_writer	heap-profiler.cc	/^static HeapProfileEndWriter heap_profile_end_writer;$/;"	v	file:
heap_profiler_memory	heap-profiler.cc	/^static LowLevelAlloc::Arena *heap_profiler_memory;$/;"	v	file:
high_water_mark	heap-profiler.cc	/^static int64 high_water_mark = 0;     \/\/ In-use-bytes at last high-water dump$/;"	v	file:
is_on	heap-profiler.cc	/^static bool  is_on = false;           \/\/ If are on as a subsytem.$/;"	v	file:
kProfileBufferSize	heap-profiler.cc	/^static const int kProfileBufferSize = 1 << 20;$/;"	v	file:
last_dump_alloc	heap-profiler.cc	/^static int64 last_dump_alloc = 0;     \/\/ alloc_size when did we last dump$/;"	v	file:
last_dump_free	heap-profiler.cc	/^static int64 last_dump_free = 0;      \/\/ free_size when did we last dump$/;"	v	file:
last_dump_time	heap-profiler.cc	/^static int64 last_dump_time = 0;      \/\/ The time of the last dump$/;"	v	file:
tcmalloc_initializer	heap-profiler.cc	/^static const TCMallocGuard tcmalloc_initializer;$/;"	v	file:
~HeapProfileEndWriter	heap-profiler.cc	/^  ~HeapProfileEndWriter() {$/;"	f	struct:HeapProfileEndWriter
Add	internal_logging.cc	/^bool Logger::Add(const LogItem& item) {$/;"	f	class:tcmalloc::Logger
AddNum	internal_logging.cc	/^bool Logger::AddNum(uint64_t num, int base) {$/;"	f	class:tcmalloc::Logger
AddStr	internal_logging.cc	/^bool Logger::AddStr(const char* str, int n) {$/;"	f	class:tcmalloc::Logger
Log	internal_logging.cc	/^void Log(LogMode mode, const char* filename, int line,$/;"	f	namespace:tcmalloc
Logger	internal_logging.cc	/^class Logger {$/;"	c	namespace:tcmalloc	file:
WriteMessage	internal_logging.cc	/^static void WriteMessage(const char* msg, int length) {$/;"	f	namespace:tcmalloc
buf_	internal_logging.cc	/^  char buf_[kBufSize];$/;"	m	class:tcmalloc::Logger	file:
crashed	internal_logging.cc	/^static bool crashed = false;$/;"	v	file:
end_	internal_logging.cc	/^  char* end_;$/;"	m	class:tcmalloc::Logger	file:
kBufSize	internal_logging.cc	/^  static const int kBufSize = 200;$/;"	m	class:tcmalloc::Logger	file:
kStatsBufferSize	internal_logging.cc	/^static const int kStatsBufferSize = 16 << 10;$/;"	v	file:
log_message_writer	internal_logging.cc	/^void (*log_message_writer)(const char* msg, int length) = WriteMessage;$/;"	m	namespace:tcmalloc	file:
p_	internal_logging.cc	/^  char* p_;$/;"	m	class:tcmalloc::Logger	file:
printf	internal_logging.cc	/^void TCMalloc_Printer::printf(const char* format, ...) {$/;"	f	class:TCMalloc_Printer
stats_buffer	internal_logging.cc	/^static char stats_buffer[kStatsBufferSize] = { 0 };$/;"	v	file:
tcmalloc	internal_logging.cc	/^namespace tcmalloc {$/;"	n	file:
ASSERT	internal_logging.h	120;"	d
CHECK_CONDITION	internal_logging.h	109;"	d
CHECK_CONDITION	internal_logging.h	110;"	d
LogItem	internal_logging.h	/^  LogItem()                     : tag_(kEnd)      { }$/;"	f	class:tcmalloc::LogItem
LogItem	internal_logging.h	/^  LogItem(const char* v)        : tag_(kStr)      { u_.str = v; }$/;"	f	class:tcmalloc::LogItem
LogItem	internal_logging.h	/^  LogItem(const void* v)        : tag_(kPtr)      { u_.ptr = v; }$/;"	f	class:tcmalloc::LogItem
LogItem	internal_logging.h	/^  LogItem(int v)                : tag_(kSigned)   { u_.snum = v; }$/;"	f	class:tcmalloc::LogItem
LogItem	internal_logging.h	/^  LogItem(long long v)          : tag_(kSigned)   { u_.snum = v; }$/;"	f	class:tcmalloc::LogItem
LogItem	internal_logging.h	/^  LogItem(long v)               : tag_(kSigned)   { u_.snum = v; }$/;"	f	class:tcmalloc::LogItem
LogItem	internal_logging.h	/^  LogItem(unsigned int v)       : tag_(kUnsigned) { u_.unum = v; }$/;"	f	class:tcmalloc::LogItem
LogItem	internal_logging.h	/^  LogItem(unsigned long long v) : tag_(kUnsigned) { u_.unum = v; }$/;"	f	class:tcmalloc::LogItem
LogItem	internal_logging.h	/^  LogItem(unsigned long v)      : tag_(kUnsigned) { u_.unum = v; }$/;"	f	class:tcmalloc::LogItem
LogItem	internal_logging.h	/^class LogItem {$/;"	c	namespace:tcmalloc
LogMode	internal_logging.h	/^enum LogMode {$/;"	g	namespace:tcmalloc
TCMALLOC_INTERNAL_LOGGING_H_	internal_logging.h	37;"	d
TCMalloc_Printer	internal_logging.h	/^  TCMalloc_Printer(char* buf, int length) : buf_(buf), left_(length) {$/;"	f	class:TCMalloc_Printer
TCMalloc_Printer	internal_logging.h	/^class TCMalloc_Printer {$/;"	c
Tag	internal_logging.h	/^  enum Tag {$/;"	g	class:tcmalloc::LogItem
buf_	internal_logging.h	/^  char* buf_;           \/\/ Where should we write next$/;"	m	class:TCMalloc_Printer
kCrash	internal_logging.h	/^  kCrash,                     \/\/ Print the message and crash$/;"	e	enum:tcmalloc::LogMode
kCrashWithStats	internal_logging.h	/^  kCrashWithStats             \/\/ Print the message, some stats, and crash$/;"	e	enum:tcmalloc::LogMode
kEnd	internal_logging.h	/^    kEnd$/;"	e	enum:tcmalloc::LogItem::Tag
kLog	internal_logging.h	/^  kLog,                       \/\/ Just print the message$/;"	e	enum:tcmalloc::LogMode
kPtr	internal_logging.h	/^    kPtr,$/;"	e	enum:tcmalloc::LogItem::Tag
kSigned	internal_logging.h	/^    kSigned,$/;"	e	enum:tcmalloc::LogItem::Tag
kStr	internal_logging.h	/^    kStr,$/;"	e	enum:tcmalloc::LogItem::Tag
kUnsigned	internal_logging.h	/^    kUnsigned,$/;"	e	enum:tcmalloc::LogItem::Tag
left_	internal_logging.h	/^  int   left_;          \/\/ Space left in buffer (including space for \\0)$/;"	m	class:TCMalloc_Printer
ptr	internal_logging.h	/^    const void* ptr;$/;"	m	union:tcmalloc::LogItem::__anon21
snum	internal_logging.h	/^    int64_t snum;$/;"	m	union:tcmalloc::LogItem::__anon21
str	internal_logging.h	/^    const char* str;$/;"	m	union:tcmalloc::LogItem::__anon21
tag_	internal_logging.h	/^  Tag tag_;$/;"	m	class:tcmalloc::LogItem
tcmalloc	internal_logging.h	/^namespace tcmalloc {$/;"	n
u_	internal_logging.h	/^  } u_;$/;"	m	class:tcmalloc::LogItem	typeref:union:tcmalloc::LogItem::__anon21
unum	internal_logging.h	/^    uint64_t unum;$/;"	m	union:tcmalloc::LogItem::__anon21
ReplaceSystemAlloc	libc_override.h	/^static void ReplaceSystemAlloc() { PatchWindowsFunctions(); }$/;"	f
TCMALLOC_LIBC_OVERRIDE_INL_H_	libc_override.h	53;"	d
ALIAS	libc_override_gcc_and_weak.h	166;"	d
ALIAS	libc_override_gcc_and_weak.h	58;"	d
ReplaceSystemAlloc	libc_override_gcc_and_weak.h	/^static void ReplaceSystemAlloc() { }$/;"	f
TCMALLOC_LIBC_OVERRIDE_GCC_AND_WEAK_INL_H_	libc_override_gcc_and_weak.h	40;"	d
__THROW	libc_override_gcc_and_weak.h	51;"	d
delegate_sized_delete	libc_override_gcc_and_weak.h	/^static void delegate_sized_delete(void *p, size_t s) throw() {$/;"	f
delegate_sized_deletearray	libc_override_gcc_and_weak.h	/^static void delegate_sized_deletearray(void *p, size_t s) throw() {$/;"	f
resolve_delete_sized	libc_override_gcc_and_weak.h	/^static void *resolve_delete_sized(void) {$/;"	f
resolve_deletearray_sized	libc_override_gcc_and_weak.h	/^static void *resolve_deletearray_sized(void) {$/;"	f
sized_delete_enabled	libc_override_gcc_and_weak.h	/^static bool sized_delete_enabled(void) {$/;"	f
tc_delete	libc_override_gcc_and_weak.h	/^    ALIAS(tc_delete);$/;"	v
tc_delete	libc_override_gcc_and_weak.h	/^  ALIAS(tc_delete);$/;"	v
tc_delete_nothrow	libc_override_gcc_and_weak.h	/^    ALIAS(tc_delete_nothrow);$/;"	v
tc_delete_sized	libc_override_gcc_and_weak.h	/^    ALIAS(tc_delete_sized);$/;"	v
tc_deletearray	libc_override_gcc_and_weak.h	/^    ALIAS(tc_deletearray);$/;"	v
tc_deletearray	libc_override_gcc_and_weak.h	/^  ALIAS(tc_deletearray);$/;"	v
tc_deletearray_nothrow	libc_override_gcc_and_weak.h	/^    ALIAS(tc_deletearray_nothrow);$/;"	v
tc_deletearray_sized	libc_override_gcc_and_weak.h	/^    ALIAS(tc_deletearray_sized);$/;"	v
tc_new	libc_override_gcc_and_weak.h	/^    ALIAS(tc_new);$/;"	v
tc_new_nothrow	libc_override_gcc_and_weak.h	/^    ALIAS(tc_new_nothrow);$/;"	v
tc_newarray	libc_override_gcc_and_weak.h	/^    ALIAS(tc_newarray);$/;"	v
tc_newarray_nothrow	libc_override_gcc_and_weak.h	/^    ALIAS(tc_newarray_nothrow);$/;"	v
ALIAS	libc_override_glibc.h	73;"	d
ALIAS	libc_override_glibc.h	85;"	d
TCMALLOC_LIBC_OVERRIDE_GLIBC_INL_H_	libc_override_glibc.h	37;"	d
__free_hook	libc_override_glibc.h	/^void (* MALLOC_HOOK_MAYBE_VOLATILE __free_hook)(void*, const void*)$/;"	v
__malloc_hook	libc_override_glibc.h	/^void* (* MALLOC_HOOK_MAYBE_VOLATILE __malloc_hook)(size_t, const void*)$/;"	v
__memalign_hook	libc_override_glibc.h	/^void* (* MALLOC_HOOK_MAYBE_VOLATILE __memalign_hook)(size_t,size_t, const void*)$/;"	v
__realloc_hook	libc_override_glibc.h	/^void* (* MALLOC_HOOK_MAYBE_VOLATILE __realloc_hook)(void*, size_t, const void*)$/;"	v
glibc_override_free	libc_override_glibc.h	/^static void glibc_override_free(void *ptr, const void *caller) {$/;"	f
glibc_override_malloc	libc_override_glibc.h	/^static void* glibc_override_malloc(size_t size, const void *caller) {$/;"	f
glibc_override_memalign	libc_override_glibc.h	/^static void* glibc_override_memalign(size_t align, size_t size,$/;"	f
glibc_override_realloc	libc_override_glibc.h	/^static void* glibc_override_realloc(void *ptr, size_t size,$/;"	f
tc_calloc	libc_override_glibc.h	/^  void* __libc_calloc(size_t n, size_t size)      ALIAS(tc_calloc);$/;"	v
tc_cfree	libc_override_glibc.h	/^  void __libc_cfree(void* ptr)                    ALIAS(tc_cfree);$/;"	v
tc_free	libc_override_glibc.h	/^  void __libc_free(void* ptr)                     ALIAS(tc_free);$/;"	v
tc_malloc	libc_override_glibc.h	/^  void* __libc_malloc(size_t size)                ALIAS(tc_malloc);$/;"	v
tc_memalign	libc_override_glibc.h	/^  void* __libc_memalign(size_t align, size_t s)   ALIAS(tc_memalign);$/;"	v
tc_posix_memalign	libc_override_glibc.h	/^  int __posix_memalign(void** r, size_t a, size_t s)  ALIAS(tc_posix_memalign);$/;"	v
tc_pvalloc	libc_override_glibc.h	/^  void* __libc_pvalloc(size_t size)               ALIAS(tc_pvalloc);$/;"	v
tc_realloc	libc_override_glibc.h	/^  void* __libc_realloc(void* ptr, size_t size)    ALIAS(tc_realloc);$/;"	v
tc_valloc	libc_override_glibc.h	/^  void* __libc_valloc(size_t size)                ALIAS(tc_valloc);$/;"	v
ReplaceSystemAlloc	libc_override_osx.h	/^static void ReplaceSystemAlloc() {$/;"	f
TCMALLOC_LIBC_OVERRIDE_OSX_INL_H_	libc_override_osx.h	73;"	d
cfree	libc_override_osx.h	/^  void  cfree(void* p)                   { tc_cfree(p);               }$/;"	f
malloc_stats	libc_override_osx.h	/^  void malloc_stats(void)                { tc_malloc_stats();         }$/;"	f
malloc_usable_size	libc_override_osx.h	/^  size_t malloc_usable_size(void* p)     { return tc_malloc_size(p); }$/;"	f
mallopt	libc_override_osx.h	/^  int mallopt(int cmd, int v)            { return tc_mallopt(cmd, v); }$/;"	f
mi_check	libc_override_osx.h	/^boolean_t mi_check(malloc_zone_t *zone) {$/;"	f	namespace:__anon22
mi_enumerator	libc_override_osx.h	/^kern_return_t mi_enumerator(task_t task, void *,$/;"	f	namespace:__anon22
mi_force_lock	libc_override_osx.h	/^void mi_force_lock(malloc_zone_t *zone) {$/;"	f	namespace:__anon22
mi_force_unlock	libc_override_osx.h	/^void mi_force_unlock(malloc_zone_t *zone) {$/;"	f	namespace:__anon22
mi_good_size	libc_override_osx.h	/^size_t mi_good_size(malloc_zone_t *zone, size_t size) {$/;"	f	namespace:__anon22
mi_log	libc_override_osx.h	/^void mi_log(malloc_zone_t *zone, void *address) {$/;"	f	namespace:__anon22
mi_print	libc_override_osx.h	/^void mi_print(malloc_zone_t *zone, boolean_t verbose) {$/;"	f	namespace:__anon22
mi_statistics	libc_override_osx.h	/^void mi_statistics(malloc_zone_t *zone, malloc_statistics_t *stats) {$/;"	f	namespace:__anon22
mi_zone_locked	libc_override_osx.h	/^boolean_t mi_zone_locked(malloc_zone_t *zone) {$/;"	f	namespace:__anon22
mz_calloc	libc_override_osx.h	/^void* mz_calloc(malloc_zone_t* zone, size_t num_items, size_t size) {$/;"	f	namespace:__anon22
mz_destroy	libc_override_osx.h	/^void mz_destroy(malloc_zone_t* zone) {$/;"	f	namespace:__anon22
mz_free	libc_override_osx.h	/^void mz_free(malloc_zone_t* zone, void* ptr) {$/;"	f	namespace:__anon22
mz_malloc	libc_override_osx.h	/^void* mz_malloc(malloc_zone_t* zone, size_t size) {$/;"	f	namespace:__anon22
mz_memalign	libc_override_osx.h	/^void* mz_memalign(malloc_zone_t* zone, size_t align, size_t size) {$/;"	f	namespace:__anon22
mz_realloc	libc_override_osx.h	/^void* mz_realloc(malloc_zone_t* zone, void* ptr, size_t size) {$/;"	f	namespace:__anon22
mz_size	libc_override_osx.h	/^size_t mz_size(malloc_zone_t* zone, const void* ptr) {$/;"	f	namespace:__anon22
mz_valloc	libc_override_osx.h	/^void* mz_valloc(malloc_zone_t* zone, size_t size) {$/;"	f	namespace:__anon22
pvalloc	libc_override_osx.h	/^  void* pvalloc(size_t s)                { return tc_pvalloc(s);      }$/;"	f
tcmalloc	libc_override_osx.h	/^namespace tcmalloc {$/;"	n
ReplaceSystemAlloc	libc_override_redefine.h	/^static void ReplaceSystemAlloc() { }$/;"	f
TCMALLOC_LIBC_OVERRIDE_REDEFINE_H_	libc_override_redefine.h	43;"	d
calloc	libc_override_redefine.h	/^  void* calloc(size_t n, size_t s)               { return tc_calloc(n, s);    }$/;"	f
cfree	libc_override_redefine.h	/^  void  cfree(void* p)                           { tc_cfree(p);               }$/;"	f
free	libc_override_redefine.h	/^  void  free(void* p)                            { tc_free(p);                }$/;"	f
mallinfo	libc_override_redefine.h	/^  struct mallinfo mallinfo(void)                 { return tc_mallinfo();      }$/;"	f
malloc	libc_override_redefine.h	/^  void* malloc(size_t s)                         { return tc_malloc(s);       }$/;"	f
malloc_size	libc_override_redefine.h	/^  size_t malloc_size(void* p)                    { return tc_malloc_size(p); }$/;"	f
malloc_stats	libc_override_redefine.h	/^  void malloc_stats(void)                        { tc_malloc_stats();         }$/;"	f
malloc_usable_size	libc_override_redefine.h	/^  size_t malloc_usable_size(void* p)             { return tc_malloc_size(p); }$/;"	f
mallopt	libc_override_redefine.h	/^  int mallopt(int cmd, int v)                    { return tc_mallopt(cmd, v); }$/;"	f
memalign	libc_override_redefine.h	/^  void* memalign(size_t a, size_t s)             { return tc_memalign(a, s);  }$/;"	f
operator delete	libc_override_redefine.h	/^void operator delete(void* p) throw()            { tc_delete(p);              }$/;"	f
operator delete	libc_override_redefine.h	/^void operator delete(void* p, size_t s) throw()  { tc_delete_sized(p, s);     }$/;"	f
operator delete	libc_override_redefine.h	/^void operator delete(void* ptr, const std::nothrow_t& nt) throw() {$/;"	f
operator delete[]	libc_override_redefine.h	/^void operator delete[](void* p) throw()          { tc_deletearray(p);         }$/;"	f
operator delete[]	libc_override_redefine.h	/^void operator delete[](void* p, size_t s) throw(){ tc_deletearray_sized(p);   }$/;"	f
operator delete[]	libc_override_redefine.h	/^void operator delete[](void* ptr, const std::nothrow_t& nt) throw() {$/;"	f
operator new	libc_override_redefine.h	/^void* operator new(size_t size)                  { return tc_new(size);       }$/;"	f
operator new	libc_override_redefine.h	/^void* operator new(size_t size, const std::nothrow_t& nt) throw() {$/;"	f
operator new[]	libc_override_redefine.h	/^void* operator new[](size_t size)                { return tc_newarray(size);  }$/;"	f
operator new[]	libc_override_redefine.h	/^void* operator new[](size_t size, const std::nothrow_t& nt) throw() {$/;"	f
posix_memalign	libc_override_redefine.h	/^  int posix_memalign(void** r, size_t a, size_t s)         {$/;"	f
pvalloc	libc_override_redefine.h	/^  void* pvalloc(size_t s)                        { return tc_pvalloc(s);      }$/;"	f
realloc	libc_override_redefine.h	/^  void* realloc(void* p, size_t s)               { return tc_realloc(p, s);   }$/;"	f
valloc	libc_override_redefine.h	/^  void* valloc(size_t s)                         { return tc_valloc(s);       }$/;"	f
SLL_Next	linked_list.h	/^inline void *SLL_Next(void *t) {$/;"	f	namespace:tcmalloc
SLL_Pop	linked_list.h	/^inline void *SLL_Pop(void **list) {$/;"	f	namespace:tcmalloc
SLL_PopRange	linked_list.h	/^inline void SLL_PopRange(void **head, int N, void **start, void **end) {$/;"	f	namespace:tcmalloc
SLL_Push	linked_list.h	/^inline void SLL_Push(void **list, void *element) {$/;"	f	namespace:tcmalloc
SLL_PushRange	linked_list.h	/^inline void SLL_PushRange(void **head, void *start, void *end) {$/;"	f	namespace:tcmalloc
SLL_SetNext	linked_list.h	/^inline void SLL_SetNext(void *t, void *n) {$/;"	f	namespace:tcmalloc
SLL_Size	linked_list.h	/^inline size_t SLL_Size(void *head) {$/;"	f	namespace:tcmalloc
TCMALLOC_LINKED_LIST_H_	linked_list.h	38;"	d
tcmalloc	linked_list.h	/^namespace tcmalloc {$/;"	n
C_SHIM	malloc_extension.cc	354;"	d	file:
Count	malloc_extension.cc	/^uintptr_t Count(void** entry) {$/;"	f	namespace:__anon23
Depth	malloc_extension.cc	/^uintptr_t Depth(void** entry) {$/;"	f	namespace:__anon23
DumpAddressMap	malloc_extension.cc	/^static void DumpAddressMap(string* result) {$/;"	f	file:
GetAllocatedSize	malloc_extension.cc	/^size_t MallocExtension::GetAllocatedSize(const void* p) {$/;"	f	class:MallocExtension
GetEstimatedAllocatedSize	malloc_extension.cc	/^size_t MallocExtension::GetEstimatedAllocatedSize(size_t size) {$/;"	f	class:MallocExtension
GetFreeListSizes	malloc_extension.cc	/^void MallocExtension::GetFreeListSizes($/;"	f	class:MallocExtension
GetHeapGrowthStacks	malloc_extension.cc	/^void MallocExtension::GetHeapGrowthStacks(MallocExtensionWriter* writer) {$/;"	f	class:MallocExtension
GetHeapSample	malloc_extension.cc	/^void MallocExtension::GetHeapSample(MallocExtensionWriter* writer) {$/;"	f	class:MallocExtension
GetMemoryReleaseRate	malloc_extension.cc	/^double MallocExtension::GetMemoryReleaseRate() {$/;"	f	class:MallocExtension
GetNumericProperty	malloc_extension.cc	/^bool MallocExtension::GetNumericProperty(const char* property, size_t* value) {$/;"	f	class:MallocExtension
GetOwnership	malloc_extension.cc	/^MallocExtension::Ownership MallocExtension::GetOwnership(const void* p) {$/;"	f	class:MallocExtension
GetStats	malloc_extension.cc	/^void MallocExtension::GetStats(char* buffer, int length) {$/;"	f	class:MallocExtension
GetSystemAllocator	malloc_extension.cc	/^SysAllocator* MallocExtension::GetSystemAllocator() {$/;"	f	class:MallocExtension
GetThreadCacheSize	malloc_extension.cc	/^size_t MallocExtension::GetThreadCacheSize() {$/;"	f	class:MallocExtension
InitModule	malloc_extension.cc	/^static void InitModule() {$/;"	f	file:
Initialize	malloc_extension.cc	/^void MallocExtension::Initialize() {$/;"	f	class:MallocExtension
MallocExtension_GetOwnership	malloc_extension.cc	/^MallocExtension_Ownership MallocExtension_GetOwnership(const void* p) {$/;"	f
MallocMemoryStats	malloc_extension.cc	/^bool MallocExtension::MallocMemoryStats(int* blocks, size_t* total,$/;"	f	class:MallocExtension
MarkThreadBusy	malloc_extension.cc	/^void MallocExtension::MarkThreadBusy() {$/;"	f	class:MallocExtension
MarkThreadIdle	malloc_extension.cc	/^void MallocExtension::MarkThreadIdle() {$/;"	f	class:MallocExtension
MarkThreadTemporarilyIdle	malloc_extension.cc	/^void MallocExtension::MarkThreadTemporarilyIdle() {$/;"	f	class:MallocExtension
PC	malloc_extension.cc	/^void* PC(void** entry, int i) {$/;"	f	namespace:__anon23
PrintCountAndSize	malloc_extension.cc	/^void PrintCountAndSize(MallocExtensionWriter* writer,$/;"	f	namespace:__anon23
PrintHeader	malloc_extension.cc	/^void PrintHeader(MallocExtensionWriter* writer,$/;"	f	namespace:__anon23
PrintStackEntry	malloc_extension.cc	/^void PrintStackEntry(MallocExtensionWriter* writer, void** entry) {$/;"	f	namespace:__anon23
Ranges	malloc_extension.cc	/^void MallocExtension::Ranges(void* arg, RangeFunction func) {$/;"	f	class:MallocExtension
ReadHeapGrowthStackTraces	malloc_extension.cc	/^void** MallocExtension::ReadHeapGrowthStackTraces() {$/;"	f	class:MallocExtension
ReadStackTraces	malloc_extension.cc	/^void** MallocExtension::ReadStackTraces(int* sample_period) {$/;"	f	class:MallocExtension
Register	malloc_extension.cc	/^void MallocExtension::Register(MallocExtension* implementation) {$/;"	f	class:MallocExtension
ReleaseFreeMemory	malloc_extension.cc	/^void MallocExtension::ReleaseFreeMemory() {$/;"	f	class:MallocExtension
ReleaseToSystem	malloc_extension.cc	/^void MallocExtension::ReleaseToSystem(size_t num_bytes) {$/;"	f	class:MallocExtension
SetMemoryReleaseRate	malloc_extension.cc	/^void MallocExtension::SetMemoryReleaseRate(double rate) {$/;"	f	class:MallocExtension
SetNumericProperty	malloc_extension.cc	/^bool MallocExtension::SetNumericProperty(const char* property, size_t value) {$/;"	f	class:MallocExtension
SetSystemAllocator	malloc_extension.cc	/^void MallocExtension::SetSystemAllocator(SysAllocator *a) {$/;"	f	class:MallocExtension
Size	malloc_extension.cc	/^uintptr_t Size(void** entry) {$/;"	f	namespace:__anon23
VerifyAllMemory	malloc_extension.cc	/^bool MallocExtension::VerifyAllMemory() { return true; }$/;"	f	class:MallocExtension
VerifyArrayNewMemory	malloc_extension.cc	/^bool MallocExtension::VerifyArrayNewMemory(const void* p) { return true; }$/;"	f	class:MallocExtension
VerifyMallocMemory	malloc_extension.cc	/^bool MallocExtension::VerifyMallocMemory(const void* p) { return true; }$/;"	f	class:MallocExtension
VerifyNewMemory	malloc_extension.cc	/^bool MallocExtension::VerifyNewMemory(const void* p) { return true; }$/;"	f	class:MallocExtension
current_instance	malloc_extension.cc	/^static MallocExtension* current_instance;$/;"	v	file:
instance	malloc_extension.cc	/^MallocExtension* MallocExtension::instance() {$/;"	f	class:MallocExtension
~MallocExtension	malloc_extension.cc	/^MallocExtension::~MallocExtension() { }$/;"	f	class:MallocExtension
~SysAllocator	malloc_extension.cc	/^SysAllocator::~SysAllocator() {}$/;"	f	class:SysAllocator
GetDeleteHook	malloc_hook-inl.h	/^inline MallocHook::DeleteHook MallocHook::GetDeleteHook() {$/;"	f	class:MallocHook
GetMmapHook	malloc_hook-inl.h	/^inline MallocHook::MmapHook MallocHook::GetMmapHook() {$/;"	f	class:MallocHook
GetMremapHook	malloc_hook-inl.h	/^inline MallocHook::MremapHook MallocHook::GetMremapHook() {$/;"	f	class:MallocHook
GetMunmapHook	malloc_hook-inl.h	/^inline MallocHook::MunmapHook MallocHook::GetMunmapHook() {$/;"	f	class:MallocHook
GetNewHook	malloc_hook-inl.h	/^inline MallocHook::NewHook MallocHook::GetNewHook() {$/;"	f	class:MallocHook
GetPreMmapHook	malloc_hook-inl.h	/^inline MallocHook::PreMmapHook MallocHook::GetPreMmapHook() {$/;"	f	class:MallocHook
GetPreSbrkHook	malloc_hook-inl.h	/^inline MallocHook::PreSbrkHook MallocHook::GetPreSbrkHook() {$/;"	f	class:MallocHook
GetSbrkHook	malloc_hook-inl.h	/^inline MallocHook::SbrkHook MallocHook::GetSbrkHook() {$/;"	f	class:MallocHook
GetSingular	malloc_hook-inl.h	/^  T GetSingular() const {$/;"	f	struct:base::internal::HookList
HookList	malloc_hook-inl.h	/^struct PERFTOOLS_DLL_DECL HookList {$/;"	s	namespace:base::internal
InvokeDeleteHook	malloc_hook-inl.h	/^inline void MallocHook::InvokeDeleteHook(const void* p) {$/;"	f	class:MallocHook
InvokeMmapHook	malloc_hook-inl.h	/^inline void MallocHook::InvokeMmapHook(const void* result,$/;"	f	class:MallocHook
InvokeMmapReplacement	malloc_hook-inl.h	/^inline bool MallocHook::InvokeMmapReplacement(const void* start,$/;"	f	class:MallocHook
InvokeMremapHook	malloc_hook-inl.h	/^inline void MallocHook::InvokeMremapHook(const void* result,$/;"	f	class:MallocHook
InvokeMunmapHook	malloc_hook-inl.h	/^inline void MallocHook::InvokeMunmapHook(const void* p, size_t size) {$/;"	f	class:MallocHook
InvokeMunmapReplacement	malloc_hook-inl.h	/^inline bool MallocHook::InvokeMunmapReplacement($/;"	f	class:MallocHook
InvokeNewHook	malloc_hook-inl.h	/^inline void MallocHook::InvokeNewHook(const void* p, size_t s) {$/;"	f	class:MallocHook
InvokePreMmapHook	malloc_hook-inl.h	/^inline void MallocHook::InvokePreMmapHook(const void* start,$/;"	f	class:MallocHook
InvokePreSbrkHook	malloc_hook-inl.h	/^inline void MallocHook::InvokePreSbrkHook(ptrdiff_t increment) {$/;"	f	class:MallocHook
InvokeSbrkHook	malloc_hook-inl.h	/^inline void MallocHook::InvokeSbrkHook(const void* result,$/;"	f	class:MallocHook
T_should_fit_in_AtomicWord	malloc_hook-inl.h	/^  COMPILE_ASSERT(sizeof(T) <= sizeof(AtomicWord), T_should_fit_in_AtomicWord);$/;"	m	struct:base::internal::HookList
_MALLOC_HOOK_INL_H_	malloc_hook-inl.h	39;"	d
base	malloc_hook-inl.h	/^namespace base { namespace internal {$/;"	n
empty	malloc_hook-inl.h	/^  bool empty() const {$/;"	f	struct:base::internal::HookList
internal	malloc_hook-inl.h	/^namespace base { namespace internal {$/;"	n	namespace:base
kHookListCapacity	malloc_hook-inl.h	/^static const int kHookListCapacity = 8;$/;"	m	namespace:base::internal
kHookListMaxValues	malloc_hook-inl.h	/^static const int kHookListMaxValues = 7;$/;"	m	namespace:base::internal
kHookListSingularIdx	malloc_hook-inl.h	/^static const int kHookListSingularIdx = 7;$/;"	m	namespace:base::internal
priv_data	malloc_hook-inl.h	/^  AtomicWord priv_data[kHookListCapacity];$/;"	m	struct:base::internal::HookList
priv_end	malloc_hook-inl.h	/^  AtomicWord priv_end;$/;"	m	struct:base::internal::HookList
ADDR_IN_ATTRIBUTE_SECTION	malloc_hook.cc	579;"	d	file:
ADDR_IN_ATTRIBUTE_SECTION	malloc_hook.cc	595;"	d	file:
Add	malloc_hook.cc	/^bool HookList<T>::Add(T value_as_t) {$/;"	f	class:base::internal::HookList
CheckInHookCaller	malloc_hook.cc	/^static inline void CheckInHookCaller() {$/;"	f	file:
ExchangeSingular	malloc_hook.cc	/^T HookList<T>::ExchangeSingular(T value_as_t) {$/;"	f	class:base::internal::HookList
FixupPrivEndLocked	malloc_hook.cc	/^void HookList<T>::FixupPrivEndLocked() {$/;"	f	class:base::internal::HookList
GetStackTrace	malloc_hook.cc	61;"	d	file:
INIT_HOOK_LIST	malloc_hook.cc	253;"	d	file:
INIT_HOOK_LIST	malloc_hook.cc	278;"	d	file:
INIT_HOOK_LIST_WITH_VALUE	malloc_hook.cc	254;"	d	file:
INIT_HOOK_LIST_WITH_VALUE	malloc_hook.cc	277;"	d	file:
INVOKE_HOOKS	malloc_hook.cc	477;"	d	file:
INVOKE_HOOKS	malloc_hook.cc	568;"	d	file:
INVOKE_REPLACEMENT	malloc_hook.cc	487;"	d	file:
InHookCaller	malloc_hook.cc	/^static inline bool InHookCaller(const void* caller) {$/;"	f	file:
InitialNewHook	malloc_hook.cc	/^void InitialNewHook(const void* ptr, size_t size) {$/;"	f	namespace:__anon24
InitialPreMMapHook	malloc_hook.cc	/^void InitialPreMMapHook(const void* start,$/;"	f	namespace:__anon24
InitialPreSbrkHook	malloc_hook.cc	/^void InitialPreSbrkHook(ptrdiff_t increment) {$/;"	f	namespace:__anon24
InvokeDeleteHookSlow	malloc_hook.cc	/^void MallocHook::InvokeDeleteHookSlow(const void* p) {$/;"	f	class:MallocHook
InvokeMmapHookSlow	malloc_hook.cc	/^void MallocHook::InvokeMmapHookSlow(const void* result,$/;"	f	class:MallocHook
InvokeMmapReplacementSlow	malloc_hook.cc	/^bool MallocHook::InvokeMmapReplacementSlow(const void* start,$/;"	f	class:MallocHook
InvokeMremapHookSlow	malloc_hook.cc	/^void MallocHook::InvokeMremapHookSlow(const void* result,$/;"	f	class:MallocHook
InvokeMunmapHookSlow	malloc_hook.cc	/^void MallocHook::InvokeMunmapHookSlow(const void* p, size_t s) {$/;"	f	class:MallocHook
InvokeMunmapReplacementSlow	malloc_hook.cc	/^bool MallocHook::InvokeMunmapReplacementSlow(const void* p,$/;"	f	class:MallocHook
InvokeNewHookSlow	malloc_hook.cc	/^void MallocHook::InvokeNewHookSlow(const void* p, size_t s) {$/;"	f	class:MallocHook
InvokePreMmapHookSlow	malloc_hook.cc	/^void MallocHook::InvokePreMmapHookSlow(const void* start,$/;"	f	class:MallocHook
InvokePreSbrkHookSlow	malloc_hook.cc	/^void MallocHook::InvokePreSbrkHookSlow(ptrdiff_t increment) {$/;"	f	class:MallocHook
InvokeSbrkHookSlow	malloc_hook.cc	/^void MallocHook::InvokeSbrkHookSlow(const void* result, ptrdiff_t increment) {$/;"	f	class:MallocHook
MallocHook_AddDeleteHook	malloc_hook.cc	/^int MallocHook_AddDeleteHook(MallocHook_DeleteHook hook) {$/;"	f
MallocHook_AddMmapHook	malloc_hook.cc	/^int MallocHook_AddMmapHook(MallocHook_MmapHook hook) {$/;"	f
MallocHook_AddMremapHook	malloc_hook.cc	/^int MallocHook_AddMremapHook(MallocHook_MremapHook hook) {$/;"	f
MallocHook_AddMunmapHook	malloc_hook.cc	/^int MallocHook_AddMunmapHook(MallocHook_MunmapHook hook) {$/;"	f
MallocHook_AddNewHook	malloc_hook.cc	/^int MallocHook_AddNewHook(MallocHook_NewHook hook) {$/;"	f
MallocHook_AddPreMmapHook	malloc_hook.cc	/^int MallocHook_AddPreMmapHook(MallocHook_PreMmapHook hook) {$/;"	f
MallocHook_AddPreSbrkHook	malloc_hook.cc	/^int MallocHook_AddPreSbrkHook(MallocHook_PreSbrkHook hook) {$/;"	f
MallocHook_AddSbrkHook	malloc_hook.cc	/^int MallocHook_AddSbrkHook(MallocHook_SbrkHook hook) {$/;"	f
MallocHook_GetCallerStackTrace	malloc_hook.cc	/^extern "C" int MallocHook_GetCallerStackTrace(void** result, int max_depth,$/;"	f
MallocHook_InitAtFirstAllocation_HeapLeakChecker	malloc_hook.cc	/^extern "C" void MallocHook_InitAtFirstAllocation_HeapLeakChecker() {$/;"	f
MallocHook_RemoveDeleteHook	malloc_hook.cc	/^int MallocHook_RemoveDeleteHook(MallocHook_DeleteHook hook) {$/;"	f
MallocHook_RemoveMmapHook	malloc_hook.cc	/^int MallocHook_RemoveMmapHook(MallocHook_MmapHook hook) {$/;"	f
MallocHook_RemoveMmapReplacement	malloc_hook.cc	/^int MallocHook_RemoveMmapReplacement(MallocHook_MmapReplacement hook) {$/;"	f
MallocHook_RemoveMremapHook	malloc_hook.cc	/^int MallocHook_RemoveMremapHook(MallocHook_MremapHook hook) {$/;"	f
MallocHook_RemoveMunmapHook	malloc_hook.cc	/^int MallocHook_RemoveMunmapHook(MallocHook_MunmapHook hook) {$/;"	f
MallocHook_RemoveMunmapReplacement	malloc_hook.cc	/^int MallocHook_RemoveMunmapReplacement(MallocHook_MunmapReplacement hook) {$/;"	f
MallocHook_RemoveNewHook	malloc_hook.cc	/^int MallocHook_RemoveNewHook(MallocHook_NewHook hook) {$/;"	f
MallocHook_RemovePreMmapHook	malloc_hook.cc	/^int MallocHook_RemovePreMmapHook(MallocHook_PreMmapHook hook) {$/;"	f
MallocHook_RemovePreSbrkHook	malloc_hook.cc	/^int MallocHook_RemovePreSbrkHook(MallocHook_PreSbrkHook hook) {$/;"	f
MallocHook_RemoveSbrkHook	malloc_hook.cc	/^int MallocHook_RemoveSbrkHook(MallocHook_SbrkHook hook) {$/;"	f
MallocHook_SetDeleteHook	malloc_hook.cc	/^MallocHook_DeleteHook MallocHook_SetDeleteHook(MallocHook_DeleteHook hook) {$/;"	f
MallocHook_SetMmapHook	malloc_hook.cc	/^MallocHook_MmapHook MallocHook_SetMmapHook(MallocHook_MmapHook hook) {$/;"	f
MallocHook_SetMmapReplacement	malloc_hook.cc	/^int MallocHook_SetMmapReplacement(MallocHook_MmapReplacement hook) {$/;"	f
MallocHook_SetMremapHook	malloc_hook.cc	/^MallocHook_MremapHook MallocHook_SetMremapHook(MallocHook_MremapHook hook) {$/;"	f
MallocHook_SetMunmapHook	malloc_hook.cc	/^MallocHook_MunmapHook MallocHook_SetMunmapHook(MallocHook_MunmapHook hook) {$/;"	f
MallocHook_SetMunmapReplacement	malloc_hook.cc	/^int MallocHook_SetMunmapReplacement(MallocHook_MunmapReplacement hook) {$/;"	f
MallocHook_SetNewHook	malloc_hook.cc	/^MallocHook_NewHook MallocHook_SetNewHook(MallocHook_NewHook hook) {$/;"	f
MallocHook_SetPreMmapHook	malloc_hook.cc	/^MallocHook_PreMmapHook MallocHook_SetPreMmapHook(MallocHook_PreMmapHook hook) {$/;"	f
MallocHook_SetPreSbrkHook	malloc_hook.cc	/^MallocHook_PreSbrkHook MallocHook_SetPreSbrkHook(MallocHook_PreSbrkHook hook) {$/;"	f
MallocHook_SetSbrkHook	malloc_hook.cc	/^MallocHook_SbrkHook MallocHook_SetSbrkHook(MallocHook_SbrkHook hook) {$/;"	f
Remove	malloc_hook.cc	/^bool HookList<T>::Remove(T value_as_t) {$/;"	f	class:base::internal::HookList
RemoveInitialHooksAndCallInitializers	malloc_hook.cc	/^void RemoveInitialHooksAndCallInitializers() {$/;"	f	namespace:__anon24
Traverse	malloc_hook.cc	/^int HookList<T>::Traverse(T* output_array, int n) const {$/;"	f	class:base::internal::HookList
UnhookedMMap	malloc_hook.cc	/^\/*static*\/void* MallocHook::UnhookedMMap(void *start, size_t length, int prot,$/;"	f	class:MallocHook
UnhookedMUnmap	malloc_hook.cc	/^\/*static*\/int MallocHook::UnhookedMUnmap(void *start, size_t length) {$/;"	f	class:MallocHook
__THROW	malloc_hook.cc	70;"	d	file:
base	malloc_hook.cc	/^namespace base { namespace internal {$/;"	n	file:
checked_sections	malloc_hook.cc	/^static bool checked_sections = false;$/;"	v	file:
delete_hooks_	malloc_hook.cc	/^HookList<MallocHook::DeleteHook> delete_hooks_ = INIT_HOOK_LIST;$/;"	m	namespace:base::internal	file:
google_malloc	malloc_hook.cc	/^DECLARE_ATTRIBUTE_SECTION_VARS(google_malloc);$/;"	v
google_malloc	malloc_hook.cc	/^DEFINE_ATTRIBUTE_SECTION_VARS(google_malloc);$/;"	v
internal	malloc_hook.cc	/^namespace base { namespace internal {$/;"	n	namespace:base	file:
malloc_hook	malloc_hook.cc	/^DECLARE_ATTRIBUTE_SECTION_VARS(malloc_hook);$/;"	v
malloc_hook	malloc_hook.cc	/^DEFINE_ATTRIBUTE_SECTION_VARS(malloc_hook);$/;"	v
mmap_hooks_	malloc_hook.cc	/^HookList<MallocHook::MmapHook> mmap_hooks_ = INIT_HOOK_LIST;$/;"	m	namespace:base::internal	file:
mmap_replacement_	malloc_hook.cc	/^HookList<MallocHook::MmapReplacement> mmap_replacement_ = { 0 };$/;"	m	namespace:base::internal	file:
mremap	malloc_hook.cc	40;"	d	file:
mremap	malloc_hook.cc	42;"	d	file:
mremap_hooks_	malloc_hook.cc	/^HookList<MallocHook::MremapHook> mremap_hooks_ = INIT_HOOK_LIST;$/;"	m	namespace:base::internal	file:
munmap_hooks_	malloc_hook.cc	/^HookList<MallocHook::MunmapHook> munmap_hooks_ = INIT_HOOK_LIST;$/;"	m	namespace:base::internal	file:
munmap_replacement_	malloc_hook.cc	/^HookList<MallocHook::MunmapReplacement> munmap_replacement_ = { 0 };$/;"	m	namespace:base::internal	file:
new_hooks_	malloc_hook.cc	/^HookList<MallocHook::NewHook> new_hooks_ =$/;"	m	namespace:base::internal	file:
once	malloc_hook.cc	/^pthread_once_t once = PTHREAD_ONCE_INIT;$/;"	m	namespace:__anon24	file:
premmap_hooks_	malloc_hook.cc	/^HookList<MallocHook::PreMmapHook> premmap_hooks_ =$/;"	m	namespace:base::internal	file:
presbrk_hooks_	malloc_hook.cc	/^HookList<MallocHook::PreSbrkHook> presbrk_hooks_ =$/;"	m	namespace:base::internal	file:
sbrk_hooks_	malloc_hook.cc	/^HookList<MallocHook::SbrkHook> sbrk_hooks_ = INIT_HOOK_LIST;$/;"	m	namespace:base::internal	file:
MALLOC_HOOK_SYSCALL	malloc_hook_mmap_freebsd.h	135;"	d
MALLOC_HOOK_SYSCALL	malloc_hook_mmap_freebsd.h	54;"	d
MALLOC_HOOK_SYSCALL	malloc_hook_mmap_freebsd.h	56;"	d
UnhookedMMap	malloc_hook_mmap_freebsd.h	/^\/*static*\/void* MallocHook::UnhookedMMap(void *start, size_t length, int prot,$/;"	f	class:MallocHook
UnhookedMUnmap	malloc_hook_mmap_freebsd.h	/^\/*static*\/int MallocHook::UnhookedMUnmap(void *start, size_t length) {$/;"	f	class:MallocHook
do_sbrk	malloc_hook_mmap_freebsd.h	/^static inline void* do_sbrk(intptr_t increment) {$/;"	f
mmap	malloc_hook_mmap_freebsd.h	46;"	d
MALLOC_HOOK_HAVE_DO_MMAP64	malloc_hook_mmap_linux.h	120;"	d
MALLOC_HOOK_HAVE_DO_MMAP64	malloc_hook_mmap_linux.h	134;"	d
MALLOC_HOOK_HAVE_DO_MMAP64	malloc_hook_mmap_linux.h	250;"	d
MALLOC_HOOK_HAVE_DO_MMAP64	malloc_hook_mmap_linux.h	63;"	d
UnhookedMMap	malloc_hook_mmap_linux.h	/^\/*static*\/void* MallocHook::UnhookedMMap(void *start, size_t length, int prot,$/;"	f	class:MallocHook
UnhookedMUnmap	malloc_hook_mmap_linux.h	/^\/*static*\/int MallocHook::UnhookedMUnmap(void *start, size_t length) {$/;"	f	class:MallocHook
mmap	malloc_hook_mmap_linux.h	151;"	d
EmergencyCalloc	maybe_emergency_malloc.h	/^  static inline void *EmergencyCalloc(size_t n, size_t elem_size) {return NULL;}$/;"	f	namespace:tcmalloc
EmergencyFree	maybe_emergency_malloc.h	/^  static inline void EmergencyFree(void *p) {}$/;"	f	namespace:tcmalloc
EmergencyMalloc	maybe_emergency_malloc.h	/^  static inline void *EmergencyMalloc(size_t size) {return NULL;}$/;"	f	namespace:tcmalloc
EmergencyRealloc	maybe_emergency_malloc.h	/^  static inline void *EmergencyRealloc(void *old_ptr, size_t new_size) {return NULL;}$/;"	f	namespace:tcmalloc
IsEmergencyPtr	maybe_emergency_malloc.h	/^  static inline bool IsEmergencyPtr(const void *_ptr) {$/;"	f	namespace:tcmalloc
MAYBE_EMERGENCY_MALLOC_H	maybe_emergency_malloc.h	32;"	d
tcmalloc	maybe_emergency_malloc.h	/^namespace tcmalloc {$/;"	n
ATTRIBUTE_WEAK	maybe_threads.cc	/^      __THROW ATTRIBUTE_WEAK;$/;"	v
ATTRIBUTE_WEAK	maybe_threads.cc	/^    __THROW ATTRIBUTE_WEAK;$/;"	v
MAX_PERTHREAD_VALS	maybe_threads.cc	78;"	d	file:
__THROW	maybe_threads.cc	57;"	d	file:
memcpy_cast	maybe_threads.cc	/^static T2 memcpy_cast(const T1 &input) {$/;"	f	file:
next_key	maybe_threads.cc	/^static int next_key;$/;"	v	file:
perftools_pthread_atfork	maybe_threads.cc	/^void perftools_pthread_atfork(void (*before)(),$/;"	f
perftools_pthread_getspecific	maybe_threads.cc	/^void *perftools_pthread_getspecific(pthread_key_t key) {$/;"	f
perftools_pthread_key_create	maybe_threads.cc	/^int perftools_pthread_key_create(pthread_key_t *key,$/;"	f
perftools_pthread_key_delete	maybe_threads.cc	/^int perftools_pthread_key_delete(pthread_key_t key) {$/;"	f
perftools_pthread_once	maybe_threads.cc	/^int perftools_pthread_once(pthread_once_t *ctl,$/;"	f
perftools_pthread_setspecific	maybe_threads.cc	/^int perftools_pthread_setspecific(pthread_key_t key, void *val) {$/;"	f
perftools_pthread_specific_vals	maybe_threads.cc	/^static void *perftools_pthread_specific_vals[MAX_PERTHREAD_VALS];$/;"	v	file:
pthread_once_init	maybe_threads.cc	/^static pthread_once_t pthread_once_init = PTHREAD_ONCE_INIT;$/;"	v	file:
GOOGLE_MAYBE_THREADS_H_	maybe_threads.h	40;"	d
Alloc	memfs_malloc.cc	/^void* HugetlbSysAllocator::Alloc(size_t size, size_t *actual_size,$/;"	f	class:HugetlbSysAllocator
AllocInternal	memfs_malloc.cc	/^void* HugetlbSysAllocator::AllocInternal(size_t size, size_t* actual_size,$/;"	f	class:HugetlbSysAllocator
HugetlbSysAllocator	memfs_malloc.cc	/^  explicit HugetlbSysAllocator(SysAllocator* fallback)$/;"	f	class:HugetlbSysAllocator
HugetlbSysAllocator	memfs_malloc.cc	/^class HugetlbSysAllocator: public SysAllocator {$/;"	c	file:
Initialize	memfs_malloc.cc	/^bool HugetlbSysAllocator::Initialize() {$/;"	f	class:HugetlbSysAllocator
big_page_size_	memfs_malloc.cc	/^  int64 big_page_size_;$/;"	m	class:HugetlbSysAllocator	file:
buf	memfs_malloc.cc	/^  char buf[sizeof(HugetlbSysAllocator)];$/;"	m	union:__anon25	file:
failed_	memfs_malloc.cc	/^  bool failed_;          \/\/ Whether failed to allocate memory.$/;"	m	class:HugetlbSysAllocator	file:
fallback_	memfs_malloc.cc	/^  SysAllocator* fallback_;  \/\/ Default system allocator to fall back to.$/;"	m	class:HugetlbSysAllocator	file:
hugetlb_base_	memfs_malloc.cc	/^  off_t hugetlb_base_;$/;"	m	class:HugetlbSysAllocator	file:
hugetlb_fd_	memfs_malloc.cc	/^  int hugetlb_fd_;       \/\/ file descriptor for hugetlb$/;"	m	class:HugetlbSysAllocator	file:
hugetlb_space	memfs_malloc.cc	/^} hugetlb_space;$/;"	v	typeref:union:__anon25	file:
ptr	memfs_malloc.cc	/^  void *ptr;$/;"	m	union:__anon25	file:
BeginRegionLocked	memory_region_map.cc	/^MemoryRegionMap::RegionIterator MemoryRegionMap::BeginRegionLocked() {$/;"	f	class:MemoryRegionMap
DoFindRegionLocked	memory_region_map.cc	/^MemoryRegionMap::DoFindRegionLocked(uintptr_t addr) {$/;"	f	class:MemoryRegionMap
DoInsertRegionLocked	memory_region_map.cc	/^inline void MemoryRegionMap::DoInsertRegionLocked(const Region& region) {$/;"	f	class:MemoryRegionMap
EndRegionLocked	memory_region_map.cc	/^MemoryRegionMap::RegionIterator MemoryRegionMap::EndRegionLocked() {$/;"	f	class:MemoryRegionMap
FindAndMarkStackRegion	memory_region_map.cc	/^bool MemoryRegionMap::FindAndMarkStackRegion(uintptr_t stack_top,$/;"	f	class:MemoryRegionMap
FindRegion	memory_region_map.cc	/^bool MemoryRegionMap::FindRegion(uintptr_t addr, Region* result) {$/;"	f	class:MemoryRegionMap
GetBucket	memory_region_map.cc	/^HeapProfileBucket* MemoryRegionMap::GetBucket(int depth,$/;"	f	class:MemoryRegionMap
HandleSavedRegionsLocked	memory_region_map.cc	/^inline void MemoryRegionMap::HandleSavedRegionsLocked($/;"	f	class:MemoryRegionMap
Init	memory_region_map.cc	/^void MemoryRegionMap::Init(int max_stack_depth, bool use_buckets) {$/;"	f	class:MemoryRegionMap
InsertRegionLocked	memory_region_map.cc	/^inline void MemoryRegionMap::InsertRegionLocked(const Region& region) {$/;"	f	class:MemoryRegionMap
IsRecordingLocked	memory_region_map.cc	/^bool MemoryRegionMap::IsRecordingLocked() {$/;"	f	class:MemoryRegionMap
Lock	memory_region_map.cc	/^void MemoryRegionMap::Lock() {$/;"	f	class:MemoryRegionMap
LockIsHeld	memory_region_map.cc	/^bool MemoryRegionMap::LockIsHeld() {$/;"	f	class:MemoryRegionMap
LogAllLocked	memory_region_map.cc	/^void MemoryRegionMap::LogAllLocked() {$/;"	f	class:MemoryRegionMap
MAP_FAILED	memory_region_map.cc	111;"	d	file:
MREMAP_FIXED	memory_region_map.cc	135;"	d	file:
MmapHook	memory_region_map.cc	/^void MemoryRegionMap::MmapHook(const void* result,$/;"	f	class:MemoryRegionMap
MremapHook	memory_region_map.cc	/^void MemoryRegionMap::MremapHook(const void* result,$/;"	f	class:MemoryRegionMap
MunmapHook	memory_region_map.cc	/^void MemoryRegionMap::MunmapHook(const void* ptr, size_t size) {$/;"	f	class:MemoryRegionMap
RecordRegionAddition	memory_region_map.cc	/^void MemoryRegionMap::RecordRegionAddition(const void* start, size_t size) {$/;"	f	class:MemoryRegionMap
RecordRegionRemoval	memory_region_map.cc	/^void MemoryRegionMap::RecordRegionRemoval(const void* start, size_t size) {$/;"	f	class:MemoryRegionMap
RecordRegionRemovalInBucket	memory_region_map.cc	/^void MemoryRegionMap::RecordRegionRemovalInBucket(int depth,$/;"	f	class:MemoryRegionMap
RegionSetRep	memory_region_map.cc	/^union MemoryRegionMap::RegionSetRep {$/;"	u	class:MemoryRegionMap	file:
RestoreSavedBucketsLocked	memory_region_map.cc	/^void MemoryRegionMap::RestoreSavedBucketsLocked() {$/;"	f	class:MemoryRegionMap
SbrkHook	memory_region_map.cc	/^void MemoryRegionMap::SbrkHook(const void* result, ptrdiff_t increment) {$/;"	f	class:MemoryRegionMap
Shutdown	memory_region_map.cc	/^bool MemoryRegionMap::Shutdown() {$/;"	f	class:MemoryRegionMap
Unlock	memory_region_map.cc	/^void MemoryRegionMap::Unlock() {$/;"	f	class:MemoryRegionMap
align_it	memory_region_map.cc	/^  void* align_it;  \/\/ do not need a better alignment for 'rep' than this$/;"	m	union:MemoryRegionMap::RegionSetRep	file:
arena_	memory_region_map.cc	/^LowLevelAlloc::Arena* MemoryRegionMap::arena_ = NULL;$/;"	m	class:MemoryRegionMap	file:
bucket_table_	memory_region_map.cc	/^HeapProfileBucket** MemoryRegionMap::bucket_table_ = NULL;  \/\/ GUARDED_BY(lock_)$/;"	m	class:MemoryRegionMap	file:
client_count_	memory_region_map.cc	/^int MemoryRegionMap::client_count_ = 0;$/;"	m	class:MemoryRegionMap	file:
current_thread_is	memory_region_map.cc	/^static inline bool current_thread_is(pthread_t should_be) {$/;"	f	file:
kStripFrames	memory_region_map.cc	/^static const int kStripFrames = 1;$/;"	v	file:
kStripFrames	memory_region_map.cc	/^static const int kStripFrames = 3;$/;"	v	file:
libpthread_initialized	memory_region_map.cc	/^static bool libpthread_initialized = false;$/;"	v	file:
lock_owner_tid_	memory_region_map.cc	/^pthread_t MemoryRegionMap::lock_owner_tid_;  \/\/ GUARDED_BY(owner_lock_)$/;"	m	class:MemoryRegionMap	file:
map_size_	memory_region_map.cc	/^int64 MemoryRegionMap::map_size_ = 0;$/;"	m	class:MemoryRegionMap	file:
max_stack_depth_	memory_region_map.cc	/^int MemoryRegionMap::max_stack_depth_ = 0;$/;"	m	class:MemoryRegionMap	file:
num_buckets_	memory_region_map.cc	/^int MemoryRegionMap::num_buckets_ = 0;  \/\/ GUARDED_BY(lock_)$/;"	m	class:MemoryRegionMap	file:
recursion_count_	memory_region_map.cc	/^int MemoryRegionMap::recursion_count_ = 0;  \/\/ GUARDED_BY(owner_lock_)$/;"	m	class:MemoryRegionMap	file:
recursive_insert	memory_region_map.cc	/^static bool recursive_insert = false;$/;"	v	file:
region_set	memory_region_map.cc	/^  RegionSet* region_set() { return reinterpret_cast<RegionSet*>(rep); }$/;"	f	union:MemoryRegionMap::RegionSetRep
regions_	memory_region_map.cc	/^MemoryRegionMap::RegionSet* MemoryRegionMap::regions_ = NULL;$/;"	m	class:MemoryRegionMap	file:
regions_rep	memory_region_map.cc	/^static MemoryRegionMap::RegionSetRep regions_rep;$/;"	v	file:
rep	memory_region_map.cc	/^  char rep[sizeof(RegionSet)];$/;"	m	union:MemoryRegionMap::RegionSetRep	file:
saved_buckets_	memory_region_map.cc	/^HeapProfileBucket MemoryRegionMap::saved_buckets_[20];  \/\/ GUARDED_BY(lock_)$/;"	m	class:MemoryRegionMap	file:
saved_buckets_count_	memory_region_map.cc	/^int MemoryRegionMap::saved_buckets_count_ = 0;  \/\/ GUARDED_BY(lock_)$/;"	m	class:MemoryRegionMap	file:
saved_buckets_keys_	memory_region_map.cc	/^const void* MemoryRegionMap::saved_buckets_keys_[20][kMaxStackDepth];$/;"	m	class:MemoryRegionMap	file:
saved_regions	memory_region_map.cc	/^static MemoryRegionMap::Region saved_regions[20];$/;"	v	file:
saved_regions_count	memory_region_map.cc	/^static int saved_regions_count = 0;$/;"	v	file:
unmap_size_	memory_region_map.cc	/^int64 MemoryRegionMap::unmap_size_ = 0;$/;"	m	class:MemoryRegionMap	file:
Allocate	memory_region_map.h	/^    static void *Allocate(size_t n) {$/;"	f	struct:MemoryRegionMap::MyAllocator
AssertIsConsistent	memory_region_map.h	/^    void AssertIsConsistent() const {$/;"	f	struct:MemoryRegionMap::Region
BASE_MEMORY_REGION_MAP_H_	memory_region_map.h	36;"	d
Create	memory_region_map.h	/^    void Create(const void* start, size_t size) {$/;"	f	struct:MemoryRegionMap::Region
Free	memory_region_map.h	/^    static void Free(const void *p, size_t \/* n *\/) {$/;"	f	struct:MemoryRegionMap::MyAllocator
IterateBuckets	memory_region_map.h	/^void MemoryRegionMap::IterateBuckets($/;"	f	class:MemoryRegionMap
LockHolder	memory_region_map.h	/^    LockHolder() { Lock(); }$/;"	f	class:MemoryRegionMap::LockHolder
LockHolder	memory_region_map.h	/^  class LockHolder {$/;"	c	class:MemoryRegionMap
MapSize	memory_region_map.h	/^  static int64 MapSize() { return map_size_; }$/;"	f	class:MemoryRegionMap
MemoryRegionMap	memory_region_map.h	/^class MemoryRegionMap {$/;"	c
MyAllocator	memory_region_map.h	/^  struct MyAllocator {$/;"	s	class:MemoryRegionMap
Overlaps	memory_region_map.h	/^    bool Overlaps(const Region& x) const {$/;"	f	struct:MemoryRegionMap::Region
Region	memory_region_map.h	/^  struct Region {$/;"	s	class:MemoryRegionMap
RegionCmp	memory_region_map.h	/^  struct RegionCmp {$/;"	s	class:MemoryRegionMap
RegionIterator	memory_region_map.h	/^  typedef RegionSet::const_iterator RegionIterator;$/;"	t	class:MemoryRegionMap
RegionSet	memory_region_map.h	/^              STL_Allocator<Region, MyAllocator> > RegionSet;$/;"	t	class:MemoryRegionMap
SetRegionSetKey	memory_region_map.h	/^    void SetRegionSetKey(uintptr_t addr) {$/;"	f	struct:MemoryRegionMap::Region
UnmapSize	memory_region_map.h	/^  static int64 UnmapSize() { return unmap_size_; }$/;"	f	class:MemoryRegionMap
arena_	memory_region_map.h	/^  static LowLevelAlloc::Arena* arena_;$/;"	m	class:MemoryRegionMap
call_stack	memory_region_map.h	/^    const void* call_stack[kMaxStackDepth];  \/\/ caller address stack array$/;"	m	struct:MemoryRegionMap::Region
call_stack_depth	memory_region_map.h	/^    int call_stack_depth;  \/\/ number of caller stack frames that we saved$/;"	m	struct:MemoryRegionMap::Region
caller	memory_region_map.h	/^    uintptr_t caller() const {$/;"	f	struct:MemoryRegionMap::Region
client_count_	memory_region_map.h	/^  static int client_count_;$/;"	m	class:MemoryRegionMap
end_addr	memory_region_map.h	/^    uintptr_t end_addr;  \/\/ region end address$/;"	m	struct:MemoryRegionMap::Region
is_stack	memory_region_map.h	/^    bool is_stack;  \/\/ does this region contain a thread's stack:$/;"	m	struct:MemoryRegionMap::Region
kHashTableSize	memory_region_map.h	/^  static const int kHashTableSize = 179999;$/;"	m	class:MemoryRegionMap
kMaxStackDepth	memory_region_map.h	/^  static const int kMaxStackDepth = 32;$/;"	m	class:MemoryRegionMap
lock_	memory_region_map.h	/^  static SpinLock lock_;$/;"	m	class:MemoryRegionMap
lock_owner_tid_	memory_region_map.h	/^  static pthread_t lock_owner_tid_;$/;"	m	class:MemoryRegionMap
map_size_	memory_region_map.h	/^  static int64 map_size_;$/;"	m	class:MemoryRegionMap
max_stack_depth_	memory_region_map.h	/^  static int max_stack_depth_;$/;"	m	class:MemoryRegionMap
operator ()	memory_region_map.h	/^    bool operator()(const Region& x, const Region& y) const {$/;"	f	struct:MemoryRegionMap::RegionCmp
owner_lock_	memory_region_map.h	/^  static SpinLock owner_lock_;$/;"	m	class:MemoryRegionMap
recursion_count_	memory_region_map.h	/^  static int recursion_count_;$/;"	m	class:MemoryRegionMap
regions_	memory_region_map.h	/^  static RegionSet* regions_;$/;"	m	class:MemoryRegionMap
set_call_stack_depth	memory_region_map.h	/^    void set_call_stack_depth(int depth) {$/;"	f	struct:MemoryRegionMap::Region
set_end_addr	memory_region_map.h	/^    void set_end_addr(uintptr_t addr) {$/;"	f	struct:MemoryRegionMap::Region
set_is_stack	memory_region_map.h	/^    void set_is_stack() { is_stack = true; }$/;"	f	struct:MemoryRegionMap::Region
set_start_addr	memory_region_map.h	/^    void set_start_addr(uintptr_t addr) {$/;"	f	struct:MemoryRegionMap::Region
start_addr	memory_region_map.h	/^    uintptr_t start_addr;  \/\/ region start address$/;"	m	struct:MemoryRegionMap::Region
unmap_size_	memory_region_map.h	/^  static int64 unmap_size_;$/;"	m	class:MemoryRegionMap
~LockHolder	memory_region_map.h	/^    ~LockHolder() { Unlock(); }$/;"	f	class:MemoryRegionMap::LockHolder
Clear	packed-cache-inl.h	/^  void Clear(V value) {$/;"	f	class:PackedCache
EntryToValue	packed-cache-inl.h	/^  static V EntryToValue(T t) { return t & kValueMask; }$/;"	f	class:PackedCache
GetOrDefault	packed-cache-inl.h	/^  V GetOrDefault(K key, V default_value) const {$/;"	f	class:PackedCache
Has	packed-cache-inl.h	/^  bool Has(K key) const {$/;"	f	class:PackedCache
Hash	packed-cache-inl.h	/^  static size_t Hash(K key) {$/;"	f	class:PackedCache
K	packed-cache-inl.h	/^  typedef uintptr_t K;$/;"	t	class:PackedCache
KeyMatch	packed-cache-inl.h	/^  static bool KeyMatch(T entry, K key) {$/;"	f	class:PackedCache
KeyToUpper	packed-cache-inl.h	/^  static UPPER KeyToUpper(K k) {$/;"	f	class:PackedCache
N_ONES_	packed-cache-inl.h	125;"	d
N_ONES_	packed-cache-inl.h	237;"	d
PackedCache	packed-cache-inl.h	/^  explicit PackedCache(V initial_value) {$/;"	f	class:PackedCache
PackedCache	packed-cache-inl.h	/^class PackedCache {$/;"	c
Put	packed-cache-inl.h	/^  void Put(K key, V value) {$/;"	f	class:PackedCache
TCMALLOC_PACKED_CACHE_INL_H_	packed-cache-inl.h	113;"	d
UPPER	packed-cache-inl.h	/^  typedef T UPPER;$/;"	t	class:PackedCache
V	packed-cache-inl.h	/^  typedef size_t V;$/;"	t	class:PackedCache
array_	packed-cache-inl.h	/^  volatile T array_[1 << kHashbits];$/;"	m	class:PackedCache
kHashbits	packed-cache-inl.h	/^  static const int kHashbits = 12;$/;"	m	class:PackedCache
kHashbits	packed-cache-inl.h	/^  static const int kHashbits = 16;$/;"	m	class:PackedCache
kKeyMask	packed-cache-inl.h	/^  static const K kKeyMask = N_ONES_(K, kKeybits);$/;"	m	class:PackedCache
kTbits	packed-cache-inl.h	/^  static const int kTbits = 8 * sizeof(T);$/;"	m	class:PackedCache
kUpperMask	packed-cache-inl.h	/^  static const T kUpperMask = N_ONES_(T, kUpperbits) << kValuebits;$/;"	m	class:PackedCache
kUpperbits	packed-cache-inl.h	/^  static const int kUpperbits = kUseWholeKeys ? kKeybits : kKeybits - kHashbits;$/;"	m	class:PackedCache
kUseWholeKeys	packed-cache-inl.h	/^  static const bool kUseWholeKeys = kKeybits + kValuebits <= 8 * sizeof(T);$/;"	m	class:PackedCache
kValueMask	packed-cache-inl.h	/^  static const V kValueMask = N_ONES_(V, kValuebits);$/;"	m	class:PackedCache
kValuebits	packed-cache-inl.h	/^  static const int kValuebits = 7;$/;"	m	class:PackedCache
AllocLarge	page_heap.cc	/^Span* PageHeap::AllocLarge(Length n) {$/;"	f	class:tcmalloc::PageHeap
Carve	page_heap.cc	/^Span* PageHeap::Carve(Span* span, Length n) {$/;"	f	class:tcmalloc::PageHeap
Check	page_heap.cc	/^bool PageHeap::Check() {$/;"	f	class:tcmalloc::PageHeap
CheckExpensive	page_heap.cc	/^bool PageHeap::CheckExpensive() {$/;"	f	class:tcmalloc::PageHeap
CheckList	page_heap.cc	/^bool PageHeap::CheckList(Span* list, Length min_pages, Length max_pages,$/;"	f	class:tcmalloc::PageHeap
CommitSpan	page_heap.cc	/^void PageHeap::CommitSpan(Span* span) {$/;"	f	class:tcmalloc::PageHeap
DecommitSpan	page_heap.cc	/^bool PageHeap::DecommitSpan(Span* span) {$/;"	f	class:tcmalloc::PageHeap
Delete	page_heap.cc	/^void PageHeap::Delete(Span* span) {$/;"	f	class:tcmalloc::PageHeap
EnsureLimit	page_heap.cc	/^bool PageHeap::EnsureLimit(Length n, bool withRelease)$/;"	f	class:tcmalloc::PageHeap
GetLargeSpanStats	page_heap.cc	/^void PageHeap::GetLargeSpanStats(LargeSpanStats* result) {$/;"	f	class:tcmalloc::PageHeap
GetNextRange	page_heap.cc	/^bool PageHeap::GetNextRange(PageID start, base::MallocRange* r) {$/;"	f	class:tcmalloc::PageHeap
GetSmallSpanStats	page_heap.cc	/^void PageHeap::GetSmallSpanStats(SmallSpanStats* result) {$/;"	f	class:tcmalloc::PageHeap
GrowHeap	page_heap.cc	/^bool PageHeap::GrowHeap(Length n) {$/;"	f	class:tcmalloc::PageHeap
IncrementalScavenge	page_heap.cc	/^void PageHeap::IncrementalScavenge(Length n) {$/;"	f	class:tcmalloc::PageHeap
MayMergeSpans	page_heap.cc	/^bool PageHeap::MayMergeSpans(Span *span, Span *other) {$/;"	f	class:tcmalloc::PageHeap
MergeIntoFreeList	page_heap.cc	/^void PageHeap::MergeIntoFreeList(Span* span) {$/;"	f	class:tcmalloc::PageHeap
New	page_heap.cc	/^Span* PageHeap::New(Length n) {$/;"	f	class:tcmalloc::PageHeap
PageHeap	page_heap.cc	/^PageHeap::PageHeap()$/;"	f	class:tcmalloc::PageHeap
PrependToFreeList	page_heap.cc	/^void PageHeap::PrependToFreeList(Span* span) {$/;"	f	class:tcmalloc::PageHeap
RecordGrowth	page_heap.cc	/^static void RecordGrowth(size_t growth) {$/;"	f	namespace:tcmalloc
RegisterSizeClass	page_heap.cc	/^void PageHeap::RegisterSizeClass(Span* span, size_t sc) {$/;"	f	class:tcmalloc::PageHeap
ReleaseAtLeastNPages	page_heap.cc	/^Length PageHeap::ReleaseAtLeastNPages(Length num_pages) {$/;"	f	class:tcmalloc::PageHeap
ReleaseLastNormalSpan	page_heap.cc	/^Length PageHeap::ReleaseLastNormalSpan(SpanList* slist) {$/;"	f	class:tcmalloc::PageHeap
RemoveFromFreeList	page_heap.cc	/^void PageHeap::RemoveFromFreeList(Span* span) {$/;"	f	class:tcmalloc::PageHeap
SearchFreeAndLargeLists	page_heap.cc	/^Span* PageHeap::SearchFreeAndLargeLists(Length n) {$/;"	f	class:tcmalloc::PageHeap
Split	page_heap.cc	/^Span* PageHeap::Split(Span* span, Length n) {$/;"	f	class:tcmalloc::PageHeap
kForcedCoalesceInterval	page_heap.cc	/^static const size_t kForcedCoalesceInterval = 128*1024*1024;$/;"	m	namespace:tcmalloc	file:
tcmalloc	page_heap.cc	/^namespace tcmalloc {$/;"	n	file:
CacheSizeClass	page_heap.h	/^  void CacheSizeClass(PageID p, size_t cl) const { pagemap_cache_.Put(p, cl); }$/;"	f	class:tcmalloc::PageHeap
CacheType	page_heap.h	/^  typedef PackedCache<32-kPageShift, uint16_t> CacheType;$/;"	t	class:tcmalloc::MapSelector
CacheType	page_heap.h	/^  typedef PackedCache<BITS-kPageShift, uint64_t> CacheType;$/;"	t	class:tcmalloc::MapSelector
GetAggressiveDecommit	page_heap.h	/^  bool GetAggressiveDecommit(void) {return aggressive_decommit_;}$/;"	f	class:tcmalloc::PageHeap
GetDescriptor	page_heap.h	/^  inline Span* GetDescriptor(PageID p) const {$/;"	f	class:tcmalloc::PageHeap
GetSizeClassIfCached	page_heap.h	/^  size_t GetSizeClassIfCached(PageID p) const {$/;"	f	class:tcmalloc::PageHeap
GetStackTrace	page_heap.h	63;"	d
LargeSpanStats	page_heap.h	/^  struct LargeSpanStats {$/;"	s	class:tcmalloc::PageHeap
MapSelector	page_heap.h	/^template <> class MapSelector<32> {$/;"	c	namespace:tcmalloc
MapSelector	page_heap.h	/^template <int BITS> class MapSelector {$/;"	c	namespace:tcmalloc
PageHeap	page_heap.h	/^class PERFTOOLS_DLL_DECL PageHeap {$/;"	c	namespace:tcmalloc
PageMap	page_heap.h	/^  typedef MapSelector<kAddressBits>::Type PageMap;$/;"	t	class:tcmalloc::PageHeap
PageMapCache	page_heap.h	/^  typedef MapSelector<kAddressBits>::CacheType PageMapCache;$/;"	t	class:tcmalloc::PageHeap
RecordSpan	page_heap.h	/^  void RecordSpan(Span* span) {$/;"	f	class:tcmalloc::PageHeap
SetAggressiveDecommit	page_heap.h	/^  void SetAggressiveDecommit(bool aggressive_decommit) {$/;"	f	class:tcmalloc::PageHeap
SmallSpanStats	page_heap.h	/^  struct SmallSpanStats {$/;"	s	class:tcmalloc::PageHeap
SpanList	page_heap.h	/^  struct SpanList {$/;"	s	class:tcmalloc::PageHeap
Stats	page_heap.h	/^    Stats() : system_bytes(0), free_bytes(0), unmapped_bytes(0), committed_bytes(0) {}$/;"	f	struct:tcmalloc::PageHeap::Stats
Stats	page_heap.h	/^  struct Stats {$/;"	s	class:tcmalloc::PageHeap
TCMALLOC_PAGE_HEAP_H_	page_heap.h	35;"	d
Type	page_heap.h	/^  typedef TCMalloc_PageMap2<32-kPageShift> Type;$/;"	t	class:tcmalloc::MapSelector
Type	page_heap.h	/^  typedef TCMalloc_PageMap3<BITS-kPageShift> Type;$/;"	t	class:tcmalloc::MapSelector
aggressive_decommit_	page_heap.h	/^  bool aggressive_decommit_;$/;"	m	class:tcmalloc::PageHeap
base	page_heap.h	/^namespace base {$/;"	n
committed_bytes	page_heap.h	/^    uint64_t committed_bytes;  \/\/ Bytes committed, always <= system_bytes_.$/;"	m	struct:tcmalloc::PageHeap::Stats
free_	page_heap.h	/^  SpanList free_[kMaxPages];$/;"	m	class:tcmalloc::PageHeap
free_bytes	page_heap.h	/^    uint64_t free_bytes;      \/\/ Total bytes on normal freelists$/;"	m	struct:tcmalloc::PageHeap::Stats
kDefaultReleaseDelay	page_heap.h	/^  static const int kDefaultReleaseDelay = 1 << 18;$/;"	m	class:tcmalloc::PageHeap
kMaxReleaseDelay	page_heap.h	/^  static const int kMaxReleaseDelay = 1 << 20;$/;"	m	class:tcmalloc::PageHeap
kMinSystemAlloc	page_heap.h	/^  static const int kMinSystemAlloc = kMaxPages;$/;"	m	class:tcmalloc::PageHeap
kPageMapBigAllocationThreshold	page_heap.h	/^  static const size_t kPageMapBigAllocationThreshold = 128 << 20;$/;"	m	class:tcmalloc::PageHeap
large_	page_heap.h	/^  SpanList large_;$/;"	m	class:tcmalloc::PageHeap
normal	page_heap.h	/^    Span        normal;$/;"	m	struct:tcmalloc::PageHeap::SpanList
normal_length	page_heap.h	/^    int64 normal_length[kMaxPages];$/;"	m	struct:tcmalloc::PageHeap::SmallSpanStats
normal_pages	page_heap.h	/^    int64 normal_pages;    \/\/ Combined page length of normal large spans$/;"	m	struct:tcmalloc::PageHeap::LargeSpanStats
pagemap_	page_heap.h	/^  PageMap pagemap_;$/;"	m	class:tcmalloc::PageHeap
pagemap_cache_	page_heap.h	/^  mutable PageMapCache pagemap_cache_;$/;"	m	class:tcmalloc::PageHeap
release_index_	page_heap.h	/^  int release_index_;$/;"	m	class:tcmalloc::PageHeap
returned	page_heap.h	/^    Span        returned;$/;"	m	struct:tcmalloc::PageHeap::SpanList
returned_length	page_heap.h	/^    int64 returned_length[kMaxPages];$/;"	m	struct:tcmalloc::PageHeap::SmallSpanStats
returned_pages	page_heap.h	/^    int64 returned_pages;  \/\/ Combined page length of unmapped spans$/;"	m	struct:tcmalloc::PageHeap::LargeSpanStats
scavenge_counter_	page_heap.h	/^  int64_t scavenge_counter_;$/;"	m	class:tcmalloc::PageHeap
spans	page_heap.h	/^    int64 spans;           \/\/ Number of such spans$/;"	m	struct:tcmalloc::PageHeap::LargeSpanStats
stats	page_heap.h	/^  inline Stats stats() const { return stats_; }$/;"	f	class:tcmalloc::PageHeap
stats_	page_heap.h	/^  Stats stats_;$/;"	m	class:tcmalloc::PageHeap
system_bytes	page_heap.h	/^    uint64_t system_bytes;    \/\/ Total bytes allocated from system$/;"	m	struct:tcmalloc::PageHeap::Stats
tcmalloc	page_heap.h	/^namespace tcmalloc {$/;"	n
unmapped_bytes	page_heap.h	/^    uint64_t unmapped_bytes;  \/\/ Total bytes on returned freelists$/;"	m	struct:tcmalloc::PageHeap::Stats
Delete	page_heap_allocator.h	/^  void Delete(T* p) {$/;"	f	class:tcmalloc::PageHeapAllocator
Init	page_heap_allocator.h	/^  void Init() {$/;"	f	class:tcmalloc::PageHeapAllocator
New	page_heap_allocator.h	/^  T* New() {$/;"	f	class:tcmalloc::PageHeapAllocator
PageHeapAllocator	page_heap_allocator.h	/^class PageHeapAllocator {$/;"	c	namespace:tcmalloc
TCMALLOC_PAGE_HEAP_ALLOCATOR_H_	page_heap_allocator.h	35;"	d
free_area_	page_heap_allocator.h	/^  char* free_area_;$/;"	m	class:tcmalloc::PageHeapAllocator
free_avail_	page_heap_allocator.h	/^  size_t free_avail_;$/;"	m	class:tcmalloc::PageHeapAllocator
free_list_	page_heap_allocator.h	/^  void* free_list_;$/;"	m	class:tcmalloc::PageHeapAllocator
inuse	page_heap_allocator.h	/^  int inuse() const { return inuse_; }$/;"	f	class:tcmalloc::PageHeapAllocator
inuse_	page_heap_allocator.h	/^  int inuse_;$/;"	m	class:tcmalloc::PageHeapAllocator
kAllocIncrement	page_heap_allocator.h	/^  static const int kAllocIncrement = 128 << 10;$/;"	m	class:tcmalloc::PageHeapAllocator
tcmalloc	page_heap_allocator.h	/^namespace tcmalloc {$/;"	n
Ensure	pagemap.h	/^  bool Ensure(Number start, size_t n) {$/;"	f	class:TCMalloc_PageMap2
Ensure	pagemap.h	/^  bool Ensure(Number start, size_t n) {$/;"	f	class:TCMalloc_PageMap3
Ensure	pagemap.h	/^  bool Ensure(Number x, size_t n) {$/;"	f	class:TCMalloc_PageMap1
INTERIOR_BITS	pagemap.h	/^  static const int INTERIOR_BITS = (BITS + 2) \/ 3; \/\/ Round-up$/;"	m	class:TCMalloc_PageMap3
INTERIOR_LENGTH	pagemap.h	/^  static const int INTERIOR_LENGTH = 1 << INTERIOR_BITS;$/;"	m	class:TCMalloc_PageMap3
LEAF_BITS	pagemap.h	/^  static const int LEAF_BITS = BITS - 2*INTERIOR_BITS;$/;"	m	class:TCMalloc_PageMap3
LEAF_BITS	pagemap.h	/^  static const int LEAF_BITS = BITS - ROOT_BITS;$/;"	m	class:TCMalloc_PageMap2
LEAF_LENGTH	pagemap.h	/^  static const int LEAF_LENGTH = 1 << LEAF_BITS;$/;"	m	class:TCMalloc_PageMap2
LEAF_LENGTH	pagemap.h	/^  static const int LEAF_LENGTH = 1 << LEAF_BITS;$/;"	m	class:TCMalloc_PageMap3
LENGTH	pagemap.h	/^  static const int LENGTH = 1 << BITS;$/;"	m	class:TCMalloc_PageMap1
Leaf	pagemap.h	/^  struct Leaf {$/;"	s	class:TCMalloc_PageMap2
Leaf	pagemap.h	/^  struct Leaf {$/;"	s	class:TCMalloc_PageMap3
NewNode	pagemap.h	/^  Node* NewNode() {$/;"	f	class:TCMalloc_PageMap3
Next	pagemap.h	/^  void* Next(Number k) const {$/;"	f	class:TCMalloc_PageMap1
Next	pagemap.h	/^  void* Next(Number k) const {$/;"	f	class:TCMalloc_PageMap2
Next	pagemap.h	/^  void* Next(Number k) const {$/;"	f	class:TCMalloc_PageMap3
Node	pagemap.h	/^  struct Node {$/;"	s	class:TCMalloc_PageMap3
Number	pagemap.h	/^  typedef uintptr_t Number;$/;"	t	class:TCMalloc_PageMap1
Number	pagemap.h	/^  typedef uintptr_t Number;$/;"	t	class:TCMalloc_PageMap2
Number	pagemap.h	/^  typedef uintptr_t Number;$/;"	t	class:TCMalloc_PageMap3
PreallocateMoreMemory	pagemap.h	/^  void PreallocateMoreMemory() {$/;"	f	class:TCMalloc_PageMap2
PreallocateMoreMemory	pagemap.h	/^  void PreallocateMoreMemory() {$/;"	f	class:TCMalloc_PageMap3
PreallocateMoreMemory	pagemap.h	/^  void PreallocateMoreMemory() {}$/;"	f	class:TCMalloc_PageMap1
ROOT_BITS	pagemap.h	/^  static const int ROOT_BITS = 5;$/;"	m	class:TCMalloc_PageMap2
ROOT_LENGTH	pagemap.h	/^  static const int ROOT_LENGTH = 1 << ROOT_BITS;$/;"	m	class:TCMalloc_PageMap2
TCMALLOC_PAGEMAP_H_	pagemap.h	47;"	d
TCMalloc_PageMap1	pagemap.h	/^  explicit TCMalloc_PageMap1(void* (*allocator)(size_t)) {$/;"	f	class:TCMalloc_PageMap1
TCMalloc_PageMap1	pagemap.h	/^class TCMalloc_PageMap1 {$/;"	c
TCMalloc_PageMap2	pagemap.h	/^  explicit TCMalloc_PageMap2(void* (*allocator)(size_t)) {$/;"	f	class:TCMalloc_PageMap2
TCMalloc_PageMap2	pagemap.h	/^class TCMalloc_PageMap2 {$/;"	c
TCMalloc_PageMap3	pagemap.h	/^  explicit TCMalloc_PageMap3(void* (*allocator)(size_t)) {$/;"	f	class:TCMalloc_PageMap3
TCMalloc_PageMap3	pagemap.h	/^class TCMalloc_PageMap3 {$/;"	c
allocator_	pagemap.h	/^  void* (*allocator_)(size_t);          \/\/ Memory allocator$/;"	m	class:TCMalloc_PageMap2
allocator_	pagemap.h	/^  void* (*allocator_)(size_t);          \/\/ Memory allocator$/;"	m	class:TCMalloc_PageMap3
array_	pagemap.h	/^  void** array_;$/;"	m	class:TCMalloc_PageMap1
get	pagemap.h	/^  void* get(Number k) const {$/;"	f	class:TCMalloc_PageMap1
get	pagemap.h	/^  void* get(Number k) const {$/;"	f	class:TCMalloc_PageMap2
get	pagemap.h	/^  void* get(Number k) const {$/;"	f	class:TCMalloc_PageMap3
ptrs	pagemap.h	/^    Node* ptrs[INTERIOR_LENGTH];$/;"	m	struct:TCMalloc_PageMap3::Node
root_	pagemap.h	/^  Leaf* root_[ROOT_LENGTH];             \/\/ Pointers to 32 child nodes$/;"	m	class:TCMalloc_PageMap2
root_	pagemap.h	/^  Node* root_;                          \/\/ Root of radix tree$/;"	m	class:TCMalloc_PageMap3
set	pagemap.h	/^  void set(Number k, void* v) {$/;"	f	class:TCMalloc_PageMap1
set	pagemap.h	/^  void set(Number k, void* v) {$/;"	f	class:TCMalloc_PageMap2
set	pagemap.h	/^  void set(Number k, void* v) {$/;"	f	class:TCMalloc_PageMap3
values	pagemap.h	/^    void* values[LEAF_LENGTH];$/;"	m	struct:TCMalloc_PageMap2::Leaf
values	pagemap.h	/^    void* values[LEAF_LENGTH];$/;"	m	struct:TCMalloc_PageMap3::Leaf
CallbackIterator	profile-handler.cc	/^  typedef CallbackList::iterator CallbackIterator;$/;"	t	class:ProfileHandler	file:
CallbackList	profile-handler.cc	/^  typedef list<ProfileHandlerToken*> CallbackList;$/;"	t	class:ProfileHandler	file:
CreateThreadTimerKey	profile-handler.cc	/^static void CreateThreadTimerKey(pthread_key_t *pkey) {$/;"	f	file:
GetState	profile-handler.cc	/^void ProfileHandler::GetState(ProfileHandlerState* state) {$/;"	f	class:ProfileHandler
Init	profile-handler.cc	/^void ProfileHandler::Init() {$/;"	f	class:ProfileHandler
Instance	profile-handler.cc	/^ProfileHandler* ProfileHandler::Instance() {$/;"	f	class:ProfileHandler
IsSignalHandlerAvailable	profile-handler.cc	/^bool ProfileHandler::IsSignalHandlerAvailable() {$/;"	f	class:ProfileHandler
NO_THREAD_SAFETY_ANALYSIS	profile-handler.cc	/^      NO_THREAD_SAFETY_ANALYSIS;$/;"	m	class:ProfileHandler	file:
ProfileHandler	profile-handler.cc	/^ProfileHandler::ProfileHandler()$/;"	f	class:ProfileHandler
ProfileHandler	profile-handler.cc	/^class ProfileHandler {$/;"	c	file:
ProfileHandlerGetState	profile-handler.cc	/^void ProfileHandlerGetState(ProfileHandlerState* state) {$/;"	f
ProfileHandlerRegisterCallback	profile-handler.cc	/^ProfileHandlerToken* ProfileHandlerRegisterCallback($/;"	f
ProfileHandlerRegisterThread	profile-handler.cc	/^void ProfileHandlerRegisterThread() {$/;"	f
ProfileHandlerReset	profile-handler.cc	/^void ProfileHandlerReset() {$/;"	f
ProfileHandlerToken	profile-handler.cc	/^  ProfileHandlerToken(ProfileHandlerCallback cb, void* cb_arg)$/;"	f	struct:ProfileHandlerToken
ProfileHandlerToken	profile-handler.cc	/^struct ProfileHandlerToken {$/;"	s	file:
ProfileHandlerUnregisterCallback	profile-handler.cc	/^void ProfileHandlerUnregisterCallback(ProfileHandlerToken* token) {$/;"	f
RegisterCallback	profile-handler.cc	/^ProfileHandlerToken* ProfileHandler::RegisterCallback($/;"	f	class:ProfileHandler
RegisterThread	profile-handler.cc	/^void ProfileHandler::RegisterThread() {$/;"	f	class:ProfileHandler
Reset	profile-handler.cc	/^void ProfileHandler::Reset() {$/;"	f	class:ProfileHandler
ScopedSignalBlocker	profile-handler.cc	/^  ScopedSignalBlocker(int signo) {$/;"	f	class:ScopedSignalBlocker
ScopedSignalBlocker	profile-handler.cc	/^class ScopedSignalBlocker {$/;"	c	file:
SignalHandler	profile-handler.cc	/^void ProfileHandler::SignalHandler(int sig, siginfo_t* sinfo, void* ucontext) {$/;"	f	class:ProfileHandler
StartLinuxThreadTimer	profile-handler.cc	/^static void StartLinuxThreadTimer(int timer_type, int signal_number,$/;"	f	file:
ThreadTimerDestructor	profile-handler.cc	/^  static void ThreadTimerDestructor(void *arg) {$/;"	f	file:
UnregisterCallback	profile-handler.cc	/^void ProfileHandler::UnregisterCallback(ProfileHandlerToken* token) {$/;"	f	class:ProfileHandler
UpdateTimer	profile-handler.cc	/^void ProfileHandler::UpdateTimer(bool enable) {$/;"	f	class:ProfileHandler
allowed_	profile-handler.cc	/^  bool allowed_;$/;"	m	class:ProfileHandler	file:
callback	profile-handler.cc	/^  ProfileHandlerCallback callback;$/;"	m	struct:ProfileHandlerToken	file:
callback_arg	profile-handler.cc	/^  void* callback_arg;$/;"	m	struct:ProfileHandlerToken	file:
frequency_	profile-handler.cc	/^  int32 frequency_;$/;"	m	class:ProfileHandler	file:
instance_	profile-handler.cc	/^  static ProfileHandler* instance_;$/;"	m	class:ProfileHandler	file:
instance_	profile-handler.cc	/^ProfileHandler* ProfileHandler::instance_ = NULL;$/;"	m	class:ProfileHandler	file:
kDefaultFrequency	profile-handler.cc	/^  static const int32 kDefaultFrequency = 100;$/;"	m	class:ProfileHandler	file:
kDefaultFrequency	profile-handler.cc	/^const int32 ProfileHandler::kDefaultFrequency;$/;"	m	class:ProfileHandler	file:
kMaxFrequency	profile-handler.cc	/^  static const int32 kMaxFrequency = 4000;$/;"	m	class:ProfileHandler	file:
kMaxFrequency	profile-handler.cc	/^const int32 ProfileHandler::kMaxFrequency;$/;"	m	class:ProfileHandler	file:
once_	profile-handler.cc	/^  static pthread_once_t once_;$/;"	m	class:ProfileHandler	file:
once_	profile-handler.cc	/^pthread_once_t ProfileHandler::once_ = PTHREAD_ONCE_INIT;$/;"	m	class:ProfileHandler	file:
per_thread_timer_enabled_	profile-handler.cc	/^  bool per_thread_timer_enabled_;$/;"	m	class:ProfileHandler	file:
sig_set_	profile-handler.cc	/^  sigset_t sig_set_;$/;"	m	class:ScopedSignalBlocker	file:
signal_lock_	profile-handler.cc	/^  SpinLock signal_lock_;$/;"	m	class:ProfileHandler	file:
signal_number_	profile-handler.cc	/^  int signal_number_;$/;"	m	class:ProfileHandler	file:
thread_timer_key	profile-handler.cc	/^  pthread_key_t thread_timer_key;$/;"	m	class:ProfileHandler	file:
timer_id_holder	profile-handler.cc	/^  timer_id_holder(timer_t _timerid) : timerid(_timerid) {}$/;"	f	struct:timer_id_holder
timer_id_holder	profile-handler.cc	/^struct timer_id_holder {$/;"	s	file:
timer_running_	profile-handler.cc	/^  bool timer_running_;$/;"	m	class:ProfileHandler	file:
timer_type_	profile-handler.cc	/^  int timer_type_;$/;"	m	class:ProfileHandler	file:
timerid	profile-handler.cc	/^  timer_t timerid;$/;"	m	struct:timer_id_holder	file:
~ProfileHandler	profile-handler.cc	/^ProfileHandler::~ProfileHandler() {$/;"	f	class:ProfileHandler
~ScopedSignalBlocker	profile-handler.cc	/^  ~ScopedSignalBlocker() {$/;"	f	class:ScopedSignalBlocker
BASE_PROFILE_HANDLER_H_	profile-handler.h	49;"	d
ProfileHandlerCallback	profile-handler.h	/^typedef void (*ProfileHandlerCallback)(int sig, siginfo_t* sig_info,$/;"	t
ProfileHandlerState	profile-handler.h	/^struct ProfileHandlerState {$/;"	s
allowed	profile-handler.h	/^  bool allowed; \/* Profiling is allowed *\/$/;"	m	struct:ProfileHandlerState
callback_count	profile-handler.h	/^  int32 callback_count;  \/* Number of callbacks registered *\/$/;"	m	struct:ProfileHandlerState
frequency	profile-handler.h	/^  int32 frequency;  \/* Profiling frequency *\/$/;"	m	struct:ProfileHandlerState
interrupts	profile-handler.h	/^  int64 interrupts;  \/* Number of interrupts received *\/$/;"	m	struct:ProfileHandlerState
Add	profiledata.cc	/^void ProfileData::Add(int depth, const void* const* stack) {$/;"	f	class:ProfileData
DumpProcSelfMaps	profiledata.cc	/^static void DumpProcSelfMaps(int fd) {$/;"	f	file:
Evict	profiledata.cc	/^void ProfileData::Evict(const Entry& entry) {$/;"	f	class:ProfileData
FDWrite	profiledata.cc	/^static void FDWrite(int fd, const char* buf, size_t len) {$/;"	f	file:
FlushEvicted	profiledata.cc	/^void ProfileData::FlushEvicted() {$/;"	f	class:ProfileData
FlushTable	profiledata.cc	/^void ProfileData::FlushTable() {$/;"	f	class:ProfileData
GetCurrentState	profiledata.cc	/^void ProfileData::GetCurrentState(State* state) const {$/;"	f	class:ProfileData
NO_INTR	profiledata.cc	139;"	d	file:
Options	profiledata.cc	/^ProfileData::Options::Options()$/;"	f	class:ProfileData::Options
ProfileData	profiledata.cc	/^ProfileData::ProfileData()$/;"	f	class:ProfileData
Reset	profiledata.cc	/^void ProfileData::Reset() {$/;"	f	class:ProfileData
Start	profiledata.cc	/^bool ProfileData::Start(const char* fname,$/;"	f	class:ProfileData
Stop	profiledata.cc	/^void ProfileData::Stop() {$/;"	f	class:ProfileData
Stop	profiledata.cc	/^void ProfileData::Stop(char* fname){$/;"	f	class:ProfileData
kAssociativity	profiledata.cc	/^const int ProfileData::kAssociativity;$/;"	m	class:ProfileData	file:
kBuckets	profiledata.cc	/^const int ProfileData::kBuckets;$/;"	m	class:ProfileData	file:
kBufferLength	profiledata.cc	/^const int ProfileData::kBufferLength;$/;"	m	class:ProfileData	file:
kMaxStackDepth	profiledata.cc	/^const int ProfileData::kMaxStackDepth;$/;"	m	class:ProfileData	file:
~ProfileData	profiledata.cc	/^ProfileData::~ProfileData() {$/;"	f	class:ProfileData
BASE_PROFILEDATA_H_	profiledata.h	42;"	d
Bucket	profiledata.h	/^  struct Bucket {$/;"	s	class:ProfileData
Entry	profiledata.h	/^  struct Entry {$/;"	s	class:ProfileData
Options	profiledata.h	/^  class Options {$/;"	c	class:ProfileData
ProfileData	profiledata.h	/^class ProfileData {$/;"	c
Slot	profiledata.h	/^  typedef uintptr_t Slot;$/;"	t	class:ProfileData
State	profiledata.h	/^  struct State {$/;"	s	class:ProfileData
count	profiledata.h	/^    Slot count;                  \/\/ Number of hits$/;"	m	struct:ProfileData::Entry
count_	profiledata.h	/^  int           count_;         \/\/ How many samples recorded$/;"	m	class:ProfileData
depth	profiledata.h	/^    Slot depth;                  \/\/ Stack depth$/;"	m	struct:ProfileData::Entry
enabled	profiledata.h	/^    bool     enabled;             \/\/ Is profiling currently enabled?$/;"	m	struct:ProfileData::State
enabled	profiledata.h	/^  bool enabled() const { return out_ >= 0; }$/;"	f	class:ProfileData
entry	profiledata.h	/^    Entry entry[kAssociativity];$/;"	m	struct:ProfileData::Bucket
evict_	profiledata.h	/^  Slot*         evict_;         \/\/ evicted entries$/;"	m	class:ProfileData
evictions_	profiledata.h	/^  int           evictions_;     \/\/ How many evictions$/;"	m	class:ProfileData
fname_	profiledata.h	/^  char*         fname_;         \/\/ Profile file name$/;"	m	class:ProfileData
frequency	profiledata.h	/^    int frequency() const {$/;"	f	class:ProfileData::Options
frequency_	profiledata.h	/^    int      frequency_;                  \/\/ Sample frequency.$/;"	m	class:ProfileData::Options
hash_	profiledata.h	/^  Bucket*       hash_;          \/\/ hash table$/;"	m	class:ProfileData
kAssociativity	profiledata.h	/^  static const int kAssociativity = 4;          \/\/ For hashtable$/;"	m	class:ProfileData
kBuckets	profiledata.h	/^  static const int kBuckets = 1 << 10;          \/\/ For hashtable$/;"	m	class:ProfileData
kBufferLength	profiledata.h	/^  static const int kBufferLength = 1 << 18;     \/\/ For eviction buffer$/;"	m	class:ProfileData
kMaxStackDepth	profiledata.h	/^  static const int kMaxStackDepth = 64;  \/\/ Max stack depth stored in profile$/;"	m	class:ProfileData
num_evicted_	profiledata.h	/^  int           num_evicted_;   \/\/ how many evicted entries?$/;"	m	class:ProfileData
out_	profiledata.h	/^  int           out_;           \/\/ fd for output file.$/;"	m	class:ProfileData
profile_name	profiledata.h	/^    char     profile_name[1024];  \/\/ Name of file being written, or '\\0'$/;"	m	struct:ProfileData::State
samples_gathered	profiledata.h	/^    int      samples_gathered;    \/\/ Number of samples gathered to far (or 0)$/;"	m	struct:ProfileData::State
set_frequency	profiledata.h	/^    void set_frequency(int frequency) {$/;"	f	class:ProfileData::Options
stack	profiledata.h	/^    Slot stack[kMaxStackDepth];  \/\/ Stack contents$/;"	m	struct:ProfileData::Entry
start_time	profiledata.h	/^    time_t   start_time;          \/\/ If enabled, when was profiling started?$/;"	m	struct:ProfileData::State
start_time_	profiledata.h	/^  time_t        start_time_;    \/\/ Start time, or 0$/;"	m	class:ProfileData
total_bytes_	profiledata.h	/^  size_t        total_bytes_;   \/\/ How much output$/;"	m	class:ProfileData
CpuProfiler	profiler.cc	/^CpuProfiler::CpuProfiler(): prof_handler_token_(NULL) {$/;"	f	class:CpuProfiler
CpuProfiler	profiler.cc	/^class CpuProfiler {$/;"	c	file:
CpuProfilerSwitch	profiler.cc	/^static void CpuProfilerSwitch(int signal_number){$/;"	f	file:
DisableHandler	profiler.cc	/^void CpuProfiler::DisableHandler() {$/;"	f	class:CpuProfiler
EnableHandler	profiler.cc	/^void CpuProfiler::EnableHandler() {$/;"	f	class:CpuProfiler
Enabled	profiler.cc	/^bool CpuProfiler::Enabled() {$/;"	f	class:CpuProfiler
FlushTable	profiler.cc	/^void CpuProfiler::FlushTable() {$/;"	f	class:CpuProfiler
GetCurrentState	profiler.cc	/^void CpuProfiler::GetCurrentState(ProfilerState* state) {$/;"	f	class:CpuProfiler
MY_LOG_NAME	profiler.cc	71;"	d	file:
ProfilerDisable	profiler.cc	/^extern "C" PERFTOOLS_DLL_DECL void ProfilerDisable() { }$/;"	f
ProfilerEnable	profiler.cc	/^extern "C" PERFTOOLS_DLL_DECL void ProfilerEnable() { }$/;"	f
ProfilerFlush	profiler.cc	/^extern "C" PERFTOOLS_DLL_DECL void ProfilerFlush() {$/;"	f
ProfilerFlush	profiler.cc	/^extern "C" void ProfilerFlush() { }$/;"	f
ProfilerGetCurrentState	profiler.cc	/^extern "C" PERFTOOLS_DLL_DECL void ProfilerGetCurrentState($/;"	f
ProfilerGetCurrentState	profiler.cc	/^extern "C" void ProfilerGetCurrentState(ProfilerState* state) {$/;"	f
ProfilerRegisterThread	profiler.cc	/^extern "C" PERFTOOLS_DLL_DECL void ProfilerRegisterThread() {$/;"	f
ProfilerRegisterThread	profiler.cc	/^extern "C" void ProfilerRegisterThread() { }$/;"	f
ProfilerStart	profiler.cc	/^extern "C" PERFTOOLS_DLL_DECL int ProfilerStart(const char* fname) {$/;"	f
ProfilerStart	profiler.cc	/^extern "C" int ProfilerStart(const char* fname) { return 0; }$/;"	f
ProfilerStartWithOptions	profiler.cc	/^extern "C" PERFTOOLS_DLL_DECL int ProfilerStartWithOptions($/;"	f
ProfilerStartWithOptions	profiler.cc	/^extern "C" int ProfilerStartWithOptions(const char *fname,$/;"	f
ProfilerStop	profiler.cc	/^extern "C" PERFTOOLS_DLL_DECL void ProfilerStop() {$/;"	f
ProfilerStop	profiler.cc	/^extern "C" void ProfilerStop() { }$/;"	f
ProfilingIsEnabledForAllThreads	profiler.cc	/^extern "C" PERFTOOLS_DLL_DECL int ProfilingIsEnabledForAllThreads() {$/;"	f
ProfilingIsEnabledForAllThreads	profiler.cc	/^extern "C" int ProfilingIsEnabledForAllThreads() { return 0; }$/;"	f
Start	profiler.cc	/^bool CpuProfiler::Start(const char* fname, const ProfilerOptions* options) {$/;"	f	class:CpuProfiler
Stop	profiler.cc	/^void CpuProfiler::Stop(char* fname) {$/;"	f	class:CpuProfiler
collector_	profiler.cc	/^  ProfileData   collector_;$/;"	m	class:CpuProfiler	file:
filter_	profiler.cc	/^  int           (*filter_)(void*);$/;"	m	class:CpuProfiler	file:
filter_arg_	profiler.cc	/^  void*         filter_arg_;$/;"	m	class:CpuProfiler	file:
fname	profiler.cc	/^char fname[PATH_MAX];$/;"	v
instance_	profiler.cc	/^  static CpuProfiler instance_;$/;"	m	class:CpuProfiler	file:
instance_	profiler.cc	/^CpuProfiler CpuProfiler::instance_;$/;"	m	class:CpuProfiler	file:
lock_	profiler.cc	/^  SpinLock      lock_;$/;"	m	class:CpuProfiler	file:
prof_handler	profiler.cc	/^void CpuProfiler::prof_handler(int sig, siginfo_t*, void* signal_ucontext,$/;"	f	class:CpuProfiler
prof_handler_token_	profiler.cc	/^  ProfileHandlerToken* prof_handler_token_;$/;"	m	class:CpuProfiler	file:
ucontext_t	profiler.cc	/^typedef int ucontext_t;   \/\/ just to quiet the compiler, mostly$/;"	t	file:
ucontext_t	profiler.cc	/^typedef ucontext ucontext_t;$/;"	t	file:
write_log	profiler.cc	/^void write_log(string file, string str){$/;"	f
write_log	profiler.cc	/^void write_log(string file, string str, int pid){$/;"	f
~CpuProfiler	profiler.cc	/^CpuProfiler::~CpuProfiler() {$/;"	f	class:CpuProfiler
Printf	raw_printer.cc	/^void RawPrinter::Printf(const char* format, ...) {$/;"	f	class:base::RawPrinter
RawPrinter	raw_printer.cc	/^RawPrinter::RawPrinter(char* buf, int length)$/;"	f	class:base::RawPrinter
base	raw_printer.cc	/^namespace base {$/;"	n	file:
BASE_RAW_PRINTER_H_	raw_printer.h	44;"	d
RawPrinter	raw_printer.h	/^class RawPrinter {$/;"	c	namespace:base
base	raw_printer.h	/^namespace base {$/;"	n
base_	raw_printer.h	/^  char* base_;          \/\/ Initial pointer$/;"	m	class:base::RawPrinter
length	raw_printer.h	/^  int length() const { return (ptr_ - base_); }$/;"	f	class:base::RawPrinter
limit_	raw_printer.h	/^  char* limit_;         \/\/ One past last non-\\0 char we can write$/;"	m	class:base::RawPrinter
ptr_	raw_printer.h	/^  char* ptr_;           \/\/ Where should we write next$/;"	m	class:base::RawPrinter
space_left	raw_printer.h	/^  int space_left() const { return (limit_ - ptr_); }$/;"	f	class:base::RawPrinter
GetSamplePeriod	sampler.cc	/^int Sampler::GetSamplePeriod() {$/;"	f	class:tcmalloc::Sampler
Init	sampler.cc	/^void Sampler::Init(uint32_t seed) {$/;"	f	class:tcmalloc::Sampler
InitStatics	sampler.cc	/^void Sampler::InitStatics() {$/;"	f	class:tcmalloc::Sampler
PickNextSamplingPoint	sampler.cc	/^size_t Sampler::PickNextSamplingPoint() {$/;"	f	class:tcmalloc::Sampler
PopulateFastLog2Table	sampler.cc	/^void Sampler::PopulateFastLog2Table() {$/;"	f	class:tcmalloc::Sampler
log_table_	sampler.cc	/^double Sampler::log_table_[1<<kFastlogNumBits];$/;"	m	class:tcmalloc::Sampler	file:
tcmalloc	sampler.cc	/^namespace tcmalloc {$/;"	n	file:
FastLog2	sampler.h	/^inline double Sampler::FastLog2(const double & d) {$/;"	f	class:tcmalloc::Sampler
NextRandom	sampler.h	/^inline uint64_t Sampler::NextRandom(uint64_t rnd) {$/;"	f	class:tcmalloc::Sampler
SampleAllocation	sampler.h	/^inline bool Sampler::SampleAllocation(size_t k) {$/;"	f	class:tcmalloc::Sampler
Sampler	sampler.h	/^class PERFTOOLS_DLL_DECL Sampler {$/;"	c	namespace:tcmalloc
TCMALLOC_SAMPLER_H_	sampler.h	37;"	d
bytes_until_sample_	sampler.h	/^  size_t        bytes_until_sample_;    \/\/ Bytes until we sample next$/;"	m	class:tcmalloc::Sampler
kFastlogMask	sampler.h	/^  static const int kFastlogMask = (1 << kFastlogNumBits) - 1;$/;"	m	class:tcmalloc::Sampler
kFastlogNumBits	sampler.h	/^  static const int kFastlogNumBits = 10;$/;"	m	class:tcmalloc::Sampler
log_table_	sampler.h	/^  static double log_table_[1<<kFastlogNumBits];  \/\/ Constant$/;"	m	class:tcmalloc::Sampler
rnd_	sampler.h	/^  uint64_t      rnd_;                   \/\/ Cheap random number generator$/;"	m	class:tcmalloc::Sampler
tcmalloc	sampler.h	/^namespace tcmalloc {$/;"	n
DLL_Init	span.cc	/^void DLL_Init(Span* list) {$/;"	f	namespace:tcmalloc
DLL_Length	span.cc	/^int DLL_Length(const Span* list) {$/;"	f	namespace:tcmalloc
DLL_Prepend	span.cc	/^void DLL_Prepend(Span* list, Span* span) {$/;"	f	namespace:tcmalloc
DLL_Remove	span.cc	/^void DLL_Remove(Span* span) {$/;"	f	namespace:tcmalloc
DeleteSpan	span.cc	/^void DeleteSpan(Span* span) {$/;"	f	namespace:tcmalloc
Event	span.cc	/^void Event(Span* span, char op, int v = 0) {$/;"	f	namespace:tcmalloc
NewSpan	span.cc	/^Span* NewSpan(PageID p, Length len) {$/;"	f	namespace:tcmalloc
tcmalloc	span.cc	/^namespace tcmalloc {$/;"	n	file:
DLL_IsEmpty	span.h	/^inline bool DLL_IsEmpty(const Span* list) {$/;"	f	namespace:tcmalloc
Event	span.h	71;"	d
IN_USE	span.h	/^  enum { IN_USE, ON_NORMAL_FREELIST, ON_RETURNED_FREELIST };$/;"	e	enum:tcmalloc::Span::__anon26
ON_NORMAL_FREELIST	span.h	/^  enum { IN_USE, ON_NORMAL_FREELIST, ON_RETURNED_FREELIST };$/;"	e	enum:tcmalloc::Span::__anon26
ON_RETURNED_FREELIST	span.h	/^  enum { IN_USE, ON_NORMAL_FREELIST, ON_RETURNED_FREELIST };$/;"	e	enum:tcmalloc::Span::__anon26
SPAN_HISTORY	span.h	56;"	d
Span	span.h	/^struct Span {$/;"	s	namespace:tcmalloc
TCMALLOC_SPAN_H_	span.h	37;"	d
history	span.h	/^  char history[64];$/;"	m	struct:tcmalloc::Span
length	span.h	/^  Length        length;         \/\/ Number of pages in span$/;"	m	struct:tcmalloc::Span
location	span.h	/^  unsigned int  location : 2;   \/\/ Is the span on a freelist, and if so, which?$/;"	m	struct:tcmalloc::Span
next	span.h	/^  Span*         next;           \/\/ Used when in link list$/;"	m	struct:tcmalloc::Span
nexthistory	span.h	/^  int nexthistory;$/;"	m	struct:tcmalloc::Span
objects	span.h	/^  void*         objects;        \/\/ Linked list of free objects$/;"	m	struct:tcmalloc::Span
prev	span.h	/^  Span*         prev;           \/\/ Used when in link list$/;"	m	struct:tcmalloc::Span
refcount	span.h	/^  unsigned int  refcount : 16;  \/\/ Number of non-free objects$/;"	m	struct:tcmalloc::Span
sample	span.h	/^  unsigned int  sample : 1;     \/\/ Sampled object?$/;"	m	struct:tcmalloc::Span
sizeclass	span.h	/^  unsigned int  sizeclass : 8;  \/\/ Size-class for small objects (or 0)$/;"	m	struct:tcmalloc::Span
start	span.h	/^  PageID        start;          \/\/ Starting page number$/;"	m	struct:tcmalloc::Span
tcmalloc	span.h	/^namespace tcmalloc {$/;"	n
value	span.h	/^  int value[64];$/;"	m	struct:tcmalloc::Span
AddTrace	stack_trace_table.cc	/^void StackTraceTable::AddTrace(const StackTrace& t) {$/;"	f	class:tcmalloc::StackTraceTable
KeyEqual	stack_trace_table.cc	/^bool StackTraceTable::Bucket::KeyEqual(uintptr_t h,$/;"	f	class:tcmalloc::StackTraceTable::Bucket
ReadStackTracesAndClear	stack_trace_table.cc	/^void** StackTraceTable::ReadStackTracesAndClear() {$/;"	f	class:tcmalloc::StackTraceTable
StackTraceTable	stack_trace_table.cc	/^StackTraceTable::StackTraceTable()$/;"	f	class:tcmalloc::StackTraceTable
tcmalloc	stack_trace_table.cc	/^namespace tcmalloc {$/;"	n	file:
~StackTraceTable	stack_trace_table.cc	/^StackTraceTable::~StackTraceTable() {$/;"	f	class:tcmalloc::StackTraceTable
Bucket	stack_trace_table.h	/^  struct Bucket {$/;"	s	class:tcmalloc::StackTraceTable
StackTraceTable	stack_trace_table.h	/^class PERFTOOLS_DLL_DECL StackTraceTable {$/;"	c	namespace:tcmalloc
TCMALLOC_STACK_TRACE_TABLE_H_	stack_trace_table.h	37;"	d
bucket_total	stack_trace_table.h	/^  int bucket_total() const { return bucket_total_; }$/;"	f	class:tcmalloc::StackTraceTable
bucket_total_	stack_trace_table.h	/^  int bucket_total_;$/;"	m	class:tcmalloc::StackTraceTable
count	stack_trace_table.h	/^    int count;$/;"	m	struct:tcmalloc::StackTraceTable::Bucket
depth_total	stack_trace_table.h	/^  int depth_total() const { return depth_total_; }$/;"	f	class:tcmalloc::StackTraceTable
depth_total_	stack_trace_table.h	/^  int depth_total_;$/;"	m	class:tcmalloc::StackTraceTable
error_	stack_trace_table.h	/^  bool error_;$/;"	m	class:tcmalloc::StackTraceTable
hash	stack_trace_table.h	/^    uintptr_t hash;$/;"	m	struct:tcmalloc::StackTraceTable::Bucket
kHashTableSize	stack_trace_table.h	/^  static const int kHashTableSize = 1 << 14; \/\/ => table_ is 128k$/;"	m	class:tcmalloc::StackTraceTable
next	stack_trace_table.h	/^    Bucket* next;$/;"	m	struct:tcmalloc::StackTraceTable::Bucket
table_	stack_trace_table.h	/^  Bucket** table_;$/;"	m	class:tcmalloc::StackTraceTable
tcmalloc	stack_trace_table.h	/^namespace tcmalloc {$/;"	n
trace	stack_trace_table.h	/^    StackTrace trace;$/;"	m	struct:tcmalloc::StackTraceTable::Bucket
GST_SUFFIX	stacktrace.cc	106;"	d	file:
GST_SUFFIX	stacktrace.cc	108;"	d	file:
GST_SUFFIX	stacktrace.cc	115;"	d	file:
GST_SUFFIX	stacktrace.cc	117;"	d	file:
GST_SUFFIX	stacktrace.cc	128;"	d	file:
GST_SUFFIX	stacktrace.cc	130;"	d	file:
GST_SUFFIX	stacktrace.cc	137;"	d	file:
GST_SUFFIX	stacktrace.cc	139;"	d	file:
GST_SUFFIX	stacktrace.cc	146;"	d	file:
GST_SUFFIX	stacktrace.cc	148;"	d	file:
GST_SUFFIX	stacktrace.cc	157;"	d	file:
GST_SUFFIX	stacktrace.cc	159;"	d	file:
GST_SUFFIX	stacktrace.cc	86;"	d	file:
GST_SUFFIX	stacktrace.cc	88;"	d	file:
GST_SUFFIX	stacktrace.cc	95;"	d	file:
GST_SUFFIX	stacktrace.cc	97;"	d	file:
GetStackFrames	stacktrace.cc	/^PERFTOOLS_DLL_DECL int GetStackFrames(void** result, int* sizes, int max_depth,$/;"	f
GetStackFramesPtr	stacktrace.cc	/^  int (*GetStackFramesPtr)(void** result, int* sizes, int max_depth,$/;"	m	struct:GetStackImplementation	file:
GetStackFramesWithContext	stacktrace.cc	/^PERFTOOLS_DLL_DECL int GetStackFramesWithContext(void** result, int* sizes, int max_depth,$/;"	f
GetStackFramesWithContextPtr	stacktrace.cc	/^  int (*GetStackFramesWithContextPtr)(void** result, int* sizes, int max_depth,$/;"	m	struct:GetStackImplementation	file:
GetStackImplementation	stacktrace.cc	/^struct GetStackImplementation {$/;"	s	file:
GetStackTrace	stacktrace.cc	/^PERFTOOLS_DLL_DECL int GetStackTrace(void** result, int max_depth,$/;"	f
GetStackTracePtr	stacktrace.cc	/^  int (*GetStackTracePtr)(void** result, int max_depth,$/;"	m	struct:GetStackImplementation	file:
GetStackTraceWithContext	stacktrace.cc	/^PERFTOOLS_DLL_DECL int GetStackTraceWithContext(void** result, int max_depth,$/;"	f
GetStackTraceWithContextPtr	stacktrace.cc	/^  int (*GetStackTraceWithContextPtr)(void** result, int max_depth,$/;"	m	struct:GetStackImplementation	file:
HAVE_GST_arm	stacktrace.cc	141;"	d	file:
HAVE_GST_generic	stacktrace.cc	90;"	d	file:
HAVE_GST_instrument	stacktrace.cc	150;"	d	file:
HAVE_GST_libgcc	stacktrace.cc	99;"	d	file:
HAVE_GST_libunwind	stacktrace.cc	110;"	d	file:
HAVE_GST_ppc	stacktrace.cc	132;"	d	file:
HAVE_GST_win32	stacktrace.cc	161;"	d	file:
HAVE_GST_x86	stacktrace.cc	119;"	d	file:
IsStacktraceAllowed	stacktrace.cc	/^    bool IsStacktraceAllowed() {$/;"	f	class:__anon27::StacktraceScope
STACKTRACE_INL_HEADER	stacktrace.cc	105;"	d	file:
STACKTRACE_INL_HEADER	stacktrace.cc	109;"	d	file:
STACKTRACE_INL_HEADER	stacktrace.cc	114;"	d	file:
STACKTRACE_INL_HEADER	stacktrace.cc	118;"	d	file:
STACKTRACE_INL_HEADER	stacktrace.cc	124;"	d	file:
STACKTRACE_INL_HEADER	stacktrace.cc	126;"	d	file:
STACKTRACE_INL_HEADER	stacktrace.cc	131;"	d	file:
STACKTRACE_INL_HEADER	stacktrace.cc	136;"	d	file:
STACKTRACE_INL_HEADER	stacktrace.cc	140;"	d	file:
STACKTRACE_INL_HEADER	stacktrace.cc	145;"	d	file:
STACKTRACE_INL_HEADER	stacktrace.cc	149;"	d	file:
STACKTRACE_INL_HEADER	stacktrace.cc	156;"	d	file:
STACKTRACE_INL_HEADER	stacktrace.cc	160;"	d	file:
STACKTRACE_INL_HEADER	stacktrace.cc	85;"	d	file:
STACKTRACE_INL_HEADER	stacktrace.cc	89;"	d	file:
STACKTRACE_INL_HEADER	stacktrace.cc	94;"	d	file:
STACKTRACE_INL_HEADER	stacktrace.cc	98;"	d	file:
StacktraceScope	stacktrace.cc	/^    StacktraceScope() {$/;"	f	class:__anon27::StacktraceScope
StacktraceScope	stacktrace.cc	/^  class StacktraceScope {$/;"	c	namespace:__anon27	file:
TCMALLOC_DONT_PREFER_LIBUNWIND	stacktrace.cc	196;"	d	file:
all_impls	stacktrace.cc	/^static GetStackImplementation *all_impls[] = {$/;"	v	file:
frame_forcer	stacktrace.cc	/^static int ATTRIBUTE_NOINLINE frame_forcer(int rv) {$/;"	f	file:
get_stack_impl	stacktrace.cc	/^static GetStackImplementation *get_stack_impl = &impl__arm;$/;"	v	file:
get_stack_impl	stacktrace.cc	/^static GetStackImplementation *get_stack_impl = &impl__generic;$/;"	v	file:
get_stack_impl	stacktrace.cc	/^static GetStackImplementation *get_stack_impl = &impl__instrument;$/;"	v	file:
get_stack_impl	stacktrace.cc	/^static GetStackImplementation *get_stack_impl = &impl__libgcc;$/;"	v	file:
get_stack_impl	stacktrace.cc	/^static GetStackImplementation *get_stack_impl = &impl__libunwind;$/;"	v	file:
get_stack_impl	stacktrace.cc	/^static GetStackImplementation *get_stack_impl = &impl__ppc;$/;"	v	file:
get_stack_impl	stacktrace.cc	/^static GetStackImplementation *get_stack_impl = &impl__win32;$/;"	v	file:
get_stack_impl	stacktrace.cc	/^static GetStackImplementation *get_stack_impl = &impl__x86;$/;"	v	file:
get_stack_impl_inited	stacktrace.cc	/^static bool get_stack_impl_inited;$/;"	v	file:
init_default_stack_impl	stacktrace.cc	/^static void init_default_stack_impl(void) {$/;"	f	file:
init_default_stack_impl_inner	stacktrace.cc	/^static void init_default_stack_impl_inner(void) {$/;"	f	file:
name	stacktrace.cc	/^  const char *name;$/;"	m	struct:GetStackImplementation	file:
stacktrace_allowed	stacktrace.cc	/^    bool stacktrace_allowed;$/;"	m	class:__anon27::StacktraceScope	file:
tcmalloc	stacktrace.cc	/^namespace tcmalloc {$/;"	n	file:
~StacktraceScope	stacktrace.cc	/^    ~StacktraceScope() {$/;"	f	class:__anon27::StacktraceScope
BASE_STACKTRACE_ARM_INL_H_	stacktrace_arm-inl.h	37;"	d
NextStackFrame	stacktrace_arm-inl.h	/^static void **NextStackFrame(void **old_sp) {$/;"	f
StacktraceArmDummyFunction	stacktrace_arm-inl.h	/^void StacktraceArmDummyFunction() { __asm__ volatile(""); }$/;"	f
BASE_STACKTRACE_GENERIC_INL_H_	stacktrace_generic-inl.h	40;"	d
GET_STACK_TRACE_OR_FRAMES	stacktrace_impl_setup-inl.h	49;"	d
GET_STACK_TRACE_OR_FRAMES	stacktrace_impl_setup-inl.h	54;"	d
GET_STACK_TRACE_OR_FRAMES	stacktrace_impl_setup-inl.h	58;"	d
GET_STACK_TRACE_OR_FRAMES	stacktrace_impl_setup-inl.h	63;"	d
GET_STACK_TRACE_OR_FRAMES	stacktrace_impl_setup-inl.h	67;"	d
GET_STACK_TRACE_OR_FRAMES	stacktrace_impl_setup-inl.h	73;"	d
GET_STACK_TRACE_OR_FRAMES	stacktrace_impl_setup-inl.h	77;"	d
GET_STACK_TRACE_OR_FRAMES	stacktrace_impl_setup-inl.h	83;"	d
IS_STACK_FRAMES	stacktrace_impl_setup-inl.h	47;"	d
IS_STACK_FRAMES	stacktrace_impl_setup-inl.h	52;"	d
IS_STACK_FRAMES	stacktrace_impl_setup-inl.h	56;"	d
IS_STACK_FRAMES	stacktrace_impl_setup-inl.h	61;"	d
IS_STACK_FRAMES	stacktrace_impl_setup-inl.h	65;"	d
IS_STACK_FRAMES	stacktrace_impl_setup-inl.h	71;"	d
IS_STACK_FRAMES	stacktrace_impl_setup-inl.h	75;"	d
IS_STACK_FRAMES	stacktrace_impl_setup-inl.h	81;"	d
IS_WITH_CONTEXT	stacktrace_impl_setup-inl.h	48;"	d
IS_WITH_CONTEXT	stacktrace_impl_setup-inl.h	53;"	d
IS_WITH_CONTEXT	stacktrace_impl_setup-inl.h	57;"	d
IS_WITH_CONTEXT	stacktrace_impl_setup-inl.h	62;"	d
IS_WITH_CONTEXT	stacktrace_impl_setup-inl.h	66;"	d
IS_WITH_CONTEXT	stacktrace_impl_setup-inl.h	72;"	d
IS_WITH_CONTEXT	stacktrace_impl_setup-inl.h	76;"	d
IS_WITH_CONTEXT	stacktrace_impl_setup-inl.h	82;"	d
SIS_CONCAT	stacktrace_impl_setup-inl.h	42;"	d
SIS_CONCAT	stacktrace_impl_setup-inl.h	94;"	d
SIS_CONCAT2	stacktrace_impl_setup-inl.h	41;"	d
SIS_CONCAT2	stacktrace_impl_setup-inl.h	93;"	d
SIS_STRINGIFY	stacktrace_impl_setup-inl.h	44;"	d
SIS_STRINGIFY2	stacktrace_impl_setup-inl.h	45;"	d
ATTRIBUTE_NOINSTRUMENT	stacktrace_instrument-inl.h	63;"	d
BACK_TRACE	stacktrace_instrument-inl.h	/^}BACK_TRACE;$/;"	t	typeref:struct:__anon28
BASE_STACKTRACE_INSTRUMENT_INL_H_	stacktrace_instrument-inl.h	46;"	d
MAX_DEPTH	stacktrace_instrument-inl.h	62;"	d
MAX_THREAD	stacktrace_instrument-inl.h	58;"	d
MAX_THREAD	stacktrace_instrument-inl.h	60;"	d
__cyg_profile_func_enter	stacktrace_instrument-inl.h	/^void __cyg_profile_func_enter(void *func_address, void *call_site) {$/;"	f
__cyg_profile_func_exit	stacktrace_instrument-inl.h	/^void __cyg_profile_func_exit(void *func_address, void *call_site) {$/;"	f
cyg_backtrace	stacktrace_instrument-inl.h	/^static int cyg_backtrace(void **buffer, int size) {$/;"	f
frame	stacktrace_instrument-inl.h	/^  void* frame[MAX_DEPTH];$/;"	m	struct:__anon28
gettid	stacktrace_instrument-inl.h	56;"	d
stack_depth	stacktrace_instrument-inl.h	/^  int   stack_depth;$/;"	m	struct:__anon28
thread_back_trace	stacktrace_instrument-inl.h	/^static BACK_TRACE thread_back_trace[MAX_THREAD];$/;"	v
BASE_STACKTRACE_LIBGCC_INL_H_	stacktrace_libgcc-inl.h	38;"	d
array	stacktrace_libgcc-inl.h	/^  void **array;$/;"	m	struct:libgcc_backtrace_data
libgcc_backtrace_data	stacktrace_libgcc-inl.h	/^struct libgcc_backtrace_data {$/;"	s
libgcc_backtrace_helper	stacktrace_libgcc-inl.h	/^static _Unwind_Reason_Code libgcc_backtrace_helper(struct _Unwind_Context *ctx,$/;"	f
limit	stacktrace_libgcc-inl.h	/^  int limit;$/;"	m	struct:libgcc_backtrace_data
pos	stacktrace_libgcc-inl.h	/^  int pos;$/;"	m	struct:libgcc_backtrace_data
skip	stacktrace_libgcc-inl.h	/^  int skip;$/;"	m	struct:libgcc_backtrace_data
BASE_STACKTRACE_LIBINWIND_INL_H_	stacktrace_libunwind-inl.h	37;"	d
BASE_STACKTRACE_UNW_CONTEXT_IS_UCONTEXT	stacktrace_libunwind-inl.h	62;"	d
UNW_LOCAL_ONLY	stacktrace_libunwind-inl.h	42;"	d
recursive	stacktrace_libunwind-inl.h	/^static __thread int recursive;$/;"	v
BASE_STACKTRACE_POWERPC_INL_H_	stacktrace_powerpc-darwin-inl.h	38;"	d
NextStackFrame	stacktrace_powerpc-darwin-inl.h	/^static void **NextStackFrame(void **old_sp) {$/;"	f
StacktracePowerPCDummyFunction	stacktrace_powerpc-darwin-inl.h	/^void StacktracePowerPCDummyFunction() { __asm__ volatile(""); }$/;"	f
BASE_STACKTRACE_POWERPC_INL_H_	stacktrace_powerpc-inl.h	41;"	d
LOAD	stacktrace_powerpc-inl.h	100;"	d
LOAD	stacktrace_powerpc-inl.h	102;"	d
NextStackFrame	stacktrace_powerpc-inl.h	/^static layout_ppc *NextStackFrame(layout_ppc *current) {$/;"	f
StacktracePowerPCDummyFunction	stacktrace_powerpc-inl.h	/^void StacktracePowerPCDummyFunction() { __asm__ volatile(""); }$/;"	f
TOP_STACK	stacktrace_powerpc-inl.h	106;"	d
TOP_STACK	stacktrace_powerpc-inl.h	113;"	d
condition_register	stacktrace_powerpc-inl.h	/^  long condition_register;$/;"	m	struct:layout_ppc
layout_ppc	stacktrace_powerpc-inl.h	/^struct layout_ppc {$/;"	s
next	stacktrace_powerpc-inl.h	/^  struct layout_ppc *next;$/;"	m	struct:layout_ppc	typeref:struct:layout_ppc::layout_ppc
return_addr	stacktrace_powerpc-inl.h	/^  void *return_addr;$/;"	m	struct:layout_ppc
BASE_STACKTRACE_POWERPC_INL_H_	stacktrace_powerpc-linux-inl.h	41;"	d
LOAD	stacktrace_powerpc-linux-inl.h	121;"	d
LOAD	stacktrace_powerpc-linux-inl.h	123;"	d
NextStackFrame	stacktrace_powerpc-linux-inl.h	/^static layout_ppc *NextStackFrame(layout_ppc *current) {$/;"	f
StacktracePowerPCDummyFunction	stacktrace_powerpc-linux-inl.h	/^void StacktracePowerPCDummyFunction() { __asm__ volatile(""); }$/;"	f
condition_register	stacktrace_powerpc-linux-inl.h	/^  long condition_register;$/;"	m	struct:layout_ppc
layout_ppc	stacktrace_powerpc-linux-inl.h	/^struct layout_ppc {$/;"	s
next	stacktrace_powerpc-linux-inl.h	/^  struct layout_ppc *next;$/;"	m	struct:layout_ppc	typeref:struct:layout_ppc::layout_ppc
return_addr	stacktrace_powerpc-linux-inl.h	/^  void *return_addr;$/;"	m	struct:layout_ppc
ucontext_t	stacktrace_powerpc-linux-inl.h	/^typedef ucontext ucontext_t;$/;"	t
BASE_STACKTRACE_WIN32_INL_H_	stacktrace_win32-inl.h	54;"	d
GetStackFramesWithContext_win32	stacktrace_win32-inl.h	/^static int GetStackFramesWithContext_win32(void** result, int* sizes, int max_depth,$/;"	f
GetStackFrames_win32	stacktrace_win32-inl.h	/^static int GetStackFrames_win32(void** \/* pcs *\/,$/;"	f
GetStackTraceWithContext_win32	stacktrace_win32-inl.h	/^static int GetStackTraceWithContext_win32(void** result, int max_depth,$/;"	f
GetStackTrace_win32	stacktrace_win32-inl.h	/^static int GetStackTrace_win32(void** result, int max_depth,$/;"	f
RtlCaptureStackBackTrace_Function	stacktrace_win32-inl.h	/^typedef USHORT NTAPI RtlCaptureStackBackTrace_Function($/;"	t
RtlCaptureStackBackTrace_fn	stacktrace_win32-inl.h	/^static RtlCaptureStackBackTrace_Function* const RtlCaptureStackBackTrace_fn =$/;"	v
not_implemented	stacktrace_win32-inl.h	/^static int not_implemented(void) {$/;"	f
BASE_STACKTRACE_X86_INL_H_	stacktrace_x86-inl.h	37;"	d
CountPushInstructions	stacktrace_x86-inl.h	/^static int CountPushInstructions(const unsigned char *const addr) {$/;"	f
NextStackFrame	stacktrace_x86-inl.h	/^static void **NextStackFrame(void **old_sp, const void *uc) {$/;"	f
kMaxBytes	stacktrace_x86-inl.h	/^static const int kMaxBytes = 10;$/;"	v
ucontext_t	stacktrace_x86-inl.h	/^typedef ucontext ucontext_t;$/;"	t
CentralCacheLockAll	static_vars.cc	/^void CentralCacheLockAll()$/;"	f	namespace:tcmalloc
CentralCacheUnlockAll	static_vars.cc	/^void CentralCacheUnlockAll()$/;"	f	namespace:tcmalloc
InitStaticVars	static_vars.cc	/^void Static::InitStaticVars() {$/;"	f	class:tcmalloc::Static
SetupAtForkLocksHandler	static_vars.cc	/^void SetupAtForkLocksHandler()$/;"	f	namespace:tcmalloc
bucket_allocator_	static_vars.cc	/^PageHeapAllocator<StackTraceTable::Bucket> Static::bucket_allocator_;$/;"	m	class:tcmalloc::Static	file:
central_cache_	static_vars.cc	/^CentralFreeListPadded Static::central_cache_[kNumClasses];$/;"	m	class:tcmalloc::Static	file:
growth_stacks_	static_vars.cc	/^StackTrace* Static::growth_stacks_ = NULL;$/;"	m	class:tcmalloc::Static	file:
pageheap_	static_vars.cc	/^PageHeap* Static::pageheap_ = NULL;$/;"	m	class:tcmalloc::Static	file:
sampled_objects_	static_vars.cc	/^Span Static::sampled_objects_;$/;"	m	class:tcmalloc::Static	file:
sizemap_	static_vars.cc	/^SizeMap Static::sizemap_;$/;"	m	class:tcmalloc::Static	file:
span_allocator_	static_vars.cc	/^PageHeapAllocator<Span> Static::span_allocator_;$/;"	m	class:tcmalloc::Static	file:
stacktrace_allocator_	static_vars.cc	/^PageHeapAllocator<StackTrace> Static::stacktrace_allocator_;$/;"	m	class:tcmalloc::Static	file:
tcmalloc	static_vars.cc	/^namespace tcmalloc {$/;"	n	file:
IsInited	static_vars.h	/^  static bool IsInited() { return pageheap() != NULL; }$/;"	f	class:tcmalloc::Static
Static	static_vars.h	/^class Static {$/;"	c	namespace:tcmalloc
TCMALLOC_STATIC_VARS_H_	static_vars.h	37;"	d
bucket_allocator	static_vars.h	/^  static PageHeapAllocator<StackTraceTable::Bucket>* bucket_allocator() {$/;"	f	class:tcmalloc::Static
bucket_allocator_	static_vars.h	/^  static PageHeapAllocator<StackTraceTable::Bucket> bucket_allocator_;$/;"	m	class:tcmalloc::Static
central_cache	static_vars.h	/^  static CentralFreeListPadded* central_cache() { return central_cache_; }$/;"	f	class:tcmalloc::Static
central_cache_	static_vars.h	/^  static CentralFreeListPadded central_cache_[kNumClasses];$/;"	m	class:tcmalloc::Static
growth_stacks	static_vars.h	/^  static StackTrace* growth_stacks() { return growth_stacks_; }$/;"	f	class:tcmalloc::Static
growth_stacks_	static_vars.h	/^  static StackTrace* growth_stacks_;$/;"	m	class:tcmalloc::Static
pageheap	static_vars.h	/^  static PageHeap* pageheap() { return pageheap_; }$/;"	f	class:tcmalloc::Static
pageheap_	static_vars.h	/^  static PageHeap* pageheap_;$/;"	m	class:tcmalloc::Static
pageheap_lock	static_vars.h	/^  static SpinLock* pageheap_lock() { return &pageheap_lock_; }$/;"	f	class:tcmalloc::Static
pageheap_lock_	static_vars.h	/^  static SpinLock pageheap_lock_;$/;"	m	class:tcmalloc::Static
sampled_objects	static_vars.h	/^  static Span* sampled_objects() { return &sampled_objects_; }$/;"	f	class:tcmalloc::Static
sampled_objects_	static_vars.h	/^  static Span sampled_objects_;$/;"	m	class:tcmalloc::Static
set_growth_stacks	static_vars.h	/^  static void set_growth_stacks(StackTrace* s) { growth_stacks_ = s; }$/;"	f	class:tcmalloc::Static
sizemap	static_vars.h	/^  static SizeMap* sizemap() { return &sizemap_; }$/;"	f	class:tcmalloc::Static
sizemap_	static_vars.h	/^  static SizeMap sizemap_;$/;"	m	class:tcmalloc::Static
span_allocator	static_vars.h	/^  static PageHeapAllocator<Span>* span_allocator() { return &span_allocator_; }$/;"	f	class:tcmalloc::Static
span_allocator_	static_vars.h	/^  static PageHeapAllocator<Span> span_allocator_;$/;"	m	class:tcmalloc::Static
stacktrace_allocator	static_vars.h	/^  static PageHeapAllocator<StackTrace>* stacktrace_allocator() {$/;"	f	class:tcmalloc::Static
stacktrace_allocator_	static_vars.h	/^  static PageHeapAllocator<StackTrace> stacktrace_allocator_;$/;"	m	class:tcmalloc::Static
tcmalloc	static_vars.h	/^namespace tcmalloc {$/;"	n
Add	symbolize.cc	/^void SymbolTable::Add(const void* addr) {$/;"	f	class:SymbolTable
GetProgramInvocationName	symbolize.cc	/^static const char* GetProgramInvocationName() {$/;"	f	file:
GetSymbol	symbolize.cc	/^const char* SymbolTable::GetSymbol(const void* addr) {$/;"	f	class:SymbolTable
PrintError	symbolize.cc	/^static void PrintError(const char* reason) {$/;"	f	file:
Symbolize	symbolize.cc	/^int SymbolTable::Symbolize() {$/;"	f	class:SymbolTable
g_pprof_path	symbolize.cc	/^static string* g_pprof_path = new string(FLAGS_symbolize_pprof);$/;"	v	file:
SymbolMap	symbolize.h	/^  typedef map<const void*, const char*> SymbolMap;$/;"	t	class:SymbolTable
SymbolTable	symbolize.h	/^  SymbolTable()$/;"	f	class:SymbolTable
SymbolTable	symbolize.h	/^class SymbolTable {$/;"	c
TCMALLOC_SYMBOLIZE_H_	symbolize.h	35;"	d
kSymbolSize	symbolize.h	/^  static const int kSymbolSize = 1024;$/;"	m	class:SymbolTable
symbol_buffer_	symbolize.h	/^  char *symbol_buffer_;$/;"	m	class:SymbolTable
symbolization_table_	symbolize.h	/^  SymbolMap symbolization_table_;$/;"	m	class:SymbolTable
~SymbolTable	symbolize.h	/^  ~SymbolTable() {$/;"	f	class:SymbolTable
Alloc	system-alloc.cc	/^void* DefaultSysAllocator::Alloc(size_t size, size_t *actual_size,$/;"	f	class:DefaultSysAllocator
Alloc	system-alloc.cc	/^void* DevMemSysAllocator::Alloc(size_t size, size_t *actual_size,$/;"	f	class:DevMemSysAllocator
Alloc	system-alloc.cc	/^void* MmapSysAllocator::Alloc(size_t size, size_t *actual_size,$/;"	f	class:MmapSysAllocator
Alloc	system-alloc.cc	/^void* SbrkSysAllocator::Alloc(size_t size, size_t *actual_size,$/;"	f	class:SbrkSysAllocator
CheckAddressBits	system-alloc.cc	/^template <> bool CheckAddressBits<8 * sizeof(void*)>(uintptr_t ptr) {$/;"	f	namespace:__anon29
CheckAddressBits	system-alloc.cc	/^template <int ADDRESS_BITS> bool CheckAddressBits(uintptr_t ptr) {$/;"	f	namespace:__anon29
DefaultSysAllocator	system-alloc.cc	/^  DefaultSysAllocator() : SysAllocator() {$/;"	f	class:DefaultSysAllocator
DefaultSysAllocator	system-alloc.cc	/^class DefaultSysAllocator : public SysAllocator {$/;"	c	file:
DevMemSysAllocator	system-alloc.cc	/^  DevMemSysAllocator() : SysAllocator() {$/;"	f	class:DevMemSysAllocator
DevMemSysAllocator	system-alloc.cc	/^class DevMemSysAllocator : public SysAllocator {$/;"	c	file:
InitSystemAllocators	system-alloc.cc	/^void InitSystemAllocators(void) {$/;"	f
MADV_FREE	system-alloc.cc	69;"	d	file:
MAP_ANONYMOUS	system-alloc.cc	62;"	d	file:
MmapSysAllocator	system-alloc.cc	/^  MmapSysAllocator() : SysAllocator() {$/;"	f	class:MmapSysAllocator
MmapSysAllocator	system-alloc.cc	/^class MmapSysAllocator : public SysAllocator {$/;"	c	file:
SbrkSysAllocator	system-alloc.cc	/^  SbrkSysAllocator() : SysAllocator() {$/;"	f	class:SbrkSysAllocator
SbrkSysAllocator	system-alloc.cc	/^class SbrkSysAllocator : public SysAllocator {$/;"	c	file:
SetChildAllocator	system-alloc.cc	/^  void SetChildAllocator(SysAllocator* alloc, unsigned int index,$/;"	f	class:DefaultSysAllocator
TCMalloc_SystemAlloc	system-alloc.cc	/^void* TCMalloc_SystemAlloc(size_t size, size_t *actual_size,$/;"	f
TCMalloc_SystemCommit	system-alloc.cc	/^void TCMalloc_SystemCommit(void* start, size_t length) {$/;"	f
TCMalloc_SystemRelease	system-alloc.cc	/^bool TCMalloc_SystemRelease(void* start, size_t length) {$/;"	f
TCMalloc_SystemTaken	system-alloc.cc	/^size_t TCMalloc_SystemTaken = 0;$/;"	v
allocs_	system-alloc.cc	/^  SysAllocator* allocs_[kMaxAllocators];$/;"	m	class:DefaultSysAllocator	file:
buf	system-alloc.cc	/^  char buf[sizeof(DefaultSysAllocator)];$/;"	m	union:__anon32	file:
buf	system-alloc.cc	/^  char buf[sizeof(MmapSysAllocator)];$/;"	m	union:__anon31	file:
buf	system-alloc.cc	/^  char buf[sizeof(SbrkSysAllocator)];$/;"	m	union:__anon30	file:
default_space	system-alloc.cc	/^} default_space;$/;"	v	typeref:union:__anon32	file:
failed_	system-alloc.cc	/^  bool failed_[kMaxAllocators];$/;"	m	class:DefaultSysAllocator	file:
kDebugMode	system-alloc.cc	/^static const bool kDebugMode = false;$/;"	v	file:
kDebugMode	system-alloc.cc	/^static const bool kDebugMode = true;$/;"	v	file:
kMaxAllocators	system-alloc.cc	/^  static const int kMaxAllocators = 2;$/;"	m	class:DefaultSysAllocator	file:
mmap_name	system-alloc.cc	/^static const char mmap_name[] = "MmapSysAllocator";$/;"	v	file:
mmap_space	system-alloc.cc	/^} mmap_space;$/;"	v	typeref:union:__anon31	file:
names_	system-alloc.cc	/^  const char* names_[kMaxAllocators];$/;"	m	class:DefaultSysAllocator	file:
pagesize	system-alloc.cc	/^static size_t pagesize = 0;$/;"	v	file:
ptr	system-alloc.cc	/^  void *ptr;$/;"	m	union:__anon30	file:
ptr	system-alloc.cc	/^  void *ptr;$/;"	m	union:__anon31	file:
ptr	system-alloc.cc	/^  void *ptr;$/;"	m	union:__anon32	file:
sbrk_name	system-alloc.cc	/^static const char sbrk_name[] = "SbrkSysAllocator";$/;"	v	file:
sbrk_space	system-alloc.cc	/^} sbrk_space;$/;"	v	typeref:union:__anon30	file:
sys_alloc	system-alloc.cc	/^SysAllocator* sys_alloc = NULL;$/;"	v
system_alloc_inited	system-alloc.cc	/^static bool system_alloc_inited = false;$/;"	v	file:
tc_get_sysalloc_override	system-alloc.cc	/^SysAllocator *tc_get_sysalloc_override(SysAllocator *def)$/;"	f
TCMALLOC_SYSTEM_ALLOC_H_	system-alloc.h	38;"	d
ALWAYS_INLINE	tcmalloc.cc	138;"	d	file:
ALWAYS_INLINE	tcmalloc.cc	140;"	d	file:
CheckCachedSizeClass	tcmalloc.cc	/^static inline bool CheckCachedSizeClass(void *ptr) {$/;"	f	file:
CheckedMallocResult	tcmalloc.cc	/^static inline void* CheckedMallocResult(void *result) {$/;"	f	file:
DoSampledAllocation	tcmalloc.cc	/^static void* DoSampledAllocation(size_t size) {$/;"	f	file:
DumpHeapGrowthStackTraces	tcmalloc.cc	/^static void** DumpHeapGrowthStackTraces() {$/;"	f	file:
DumpStats	tcmalloc.cc	/^static void DumpStats(TCMalloc_Printer* out, int level) {$/;"	f	file:
ExtractStats	tcmalloc.cc	/^static void ExtractStats(TCMallocStats* r, uint64_t* class_count,$/;"	f	file:
GetAllocatedSize	tcmalloc.cc	/^size_t TCMallocImplementation::GetAllocatedSize(const void* ptr) {$/;"	f	class:TCMallocImplementation
GetEstimatedAllocatedSize	tcmalloc.cc	/^  virtual size_t GetEstimatedAllocatedSize(size_t size) {$/;"	f	class:TCMallocImplementation
GetFreeListSizes	tcmalloc.cc	/^  virtual void GetFreeListSizes(vector<MallocExtension::FreeListInfo>* v) {$/;"	f	class:TCMallocImplementation
GetHeapSample	tcmalloc.cc	/^  virtual void GetHeapSample(MallocExtensionWriter* writer) {$/;"	f	class:TCMallocImplementation
GetMemoryReleaseRate	tcmalloc.cc	/^  virtual double GetMemoryReleaseRate() {$/;"	f	class:TCMallocImplementation
GetNumericProperty	tcmalloc.cc	/^  virtual bool GetNumericProperty(const char* name, size_t* value) {$/;"	f	class:TCMallocImplementation
GetOwnership	tcmalloc.cc	/^  virtual Ownership GetOwnership(const void* ptr) {$/;"	f	class:TCMallocImplementation
GetSizeWithCallback	tcmalloc.cc	/^inline size_t GetSizeWithCallback(const void* ptr,$/;"	f	namespace:__anon34
GetStats	tcmalloc.cc	/^  virtual void GetStats(char* buffer, int buffer_length) {$/;"	f	class:TCMallocImplementation
GetSystemAllocator	tcmalloc.cc	/^  virtual SysAllocator* GetSystemAllocator() {$/;"	f	class:TCMallocImplementation
GetThreadCacheSize	tcmalloc.cc	/^  virtual size_t GetThreadCacheSize() {$/;"	f	class:TCMallocImplementation
InvalidFree	tcmalloc.cc	/^void InvalidFree(void* ptr) {$/;"	f	namespace:__anon33
InvalidGetAllocatedSize	tcmalloc.cc	/^size_t InvalidGetAllocatedSize(const void* ptr) {$/;"	f	namespace:__anon33
InvalidGetSizeForRealloc	tcmalloc.cc	/^size_t InvalidGetSizeForRealloc(const void* old_ptr) {$/;"	f	namespace:__anon33
IterateOverRanges	tcmalloc.cc	/^static void IterateOverRanges(void* arg, MallocExtension::RangeFunction func) {$/;"	f	file:
MarkThreadBusy	tcmalloc.cc	/^void TCMallocImplementation::MarkThreadBusy() {$/;"	f	class:TCMallocImplementation
MarkThreadIdle	tcmalloc.cc	/^  virtual void MarkThreadIdle() {$/;"	f	class:TCMallocImplementation
MarkThreadTemporarilyIdle	tcmalloc.cc	/^  virtual void MarkThreadTemporarilyIdle() {$/;"	f	class:TCMallocImplementation
PagesToMiB	tcmalloc.cc	/^static double PagesToMiB(uint64_t pages) {$/;"	f	file:
PrintStats	tcmalloc.cc	/^static void PrintStats(int level) {$/;"	f	file:
Ranges	tcmalloc.cc	/^  virtual void Ranges(void* arg, RangeFunction func) {$/;"	f	class:TCMallocImplementation
ReadHeapGrowthStackTraces	tcmalloc.cc	/^  virtual void** ReadHeapGrowthStackTraces() {$/;"	f	class:TCMallocImplementation
ReadStackTraces	tcmalloc.cc	/^  virtual void** ReadStackTraces(int* sample_period) {$/;"	f	class:TCMallocImplementation
ReleaseToSystem	tcmalloc.cc	/^  virtual void ReleaseToSystem(size_t num_bytes) {$/;"	f	class:TCMallocImplementation
ReportLargeAlloc	tcmalloc.cc	/^static void ReportLargeAlloc(Length num_pages, void* result) {$/;"	f	namespace:__anon34
SetMemoryReleaseRate	tcmalloc.cc	/^  virtual void SetMemoryReleaseRate(double rate) {$/;"	f	class:TCMallocImplementation
SetNumericProperty	tcmalloc.cc	/^  virtual bool SetNumericProperty(const char* name, size_t value) {$/;"	f	class:TCMallocImplementation
SetSystemAllocator	tcmalloc.cc	/^  virtual void SetSystemAllocator(SysAllocator* alloc) {$/;"	f	class:TCMallocImplementation
SpanToMallocResult	tcmalloc.cc	/^static inline void* SpanToMallocResult(Span *span) {$/;"	f	file:
TCMallocGuard	tcmalloc.cc	/^TCMallocGuard::TCMallocGuard() {$/;"	f	class:TCMallocGuard
TCMallocImplementation	tcmalloc.cc	/^  TCMallocImplementation()$/;"	f	class:TCMallocImplementation
TCMallocImplementation	tcmalloc.cc	/^class TCMallocImplementation : public MallocExtension {$/;"	c	file:
TCMallocStats	tcmalloc.cc	/^struct TCMallocStats {$/;"	s	file:
TC_ALIAS	tcmalloc.cc	1594;"	d	file:
WIN32_DO_PATCHING	tcmalloc.cc	146;"	d	file:
align	tcmalloc.cc	/^  size_t align;$/;"	m	struct:__anon34::retry_memaligh_data	file:
central_bytes	tcmalloc.cc	/^  uint64_t central_bytes;     \/\/ Bytes in central cache$/;"	m	struct:TCMallocStats	file:
cpp_alloc	tcmalloc.cc	/^inline void* cpp_alloc(size_t size, bool nothrow) {$/;"	f	namespace:__anon34
do_calloc	tcmalloc.cc	/^ALWAYS_INLINE void* do_calloc(size_t n, size_t elem_size) {$/;"	f	namespace:__anon34
do_free	tcmalloc.cc	/^ALWAYS_INLINE void do_free(void* ptr) {$/;"	f	namespace:__anon34
do_free_helper	tcmalloc.cc	/^ALWAYS_INLINE void do_free_helper(void* ptr,$/;"	f	namespace:__anon34
do_free_with_callback	tcmalloc.cc	/^ALWAYS_INLINE void do_free_with_callback(void* ptr,$/;"	f	namespace:__anon34
do_mallinfo	tcmalloc.cc	/^inline struct mallinfo do_mallinfo() {$/;"	f	namespace:__anon34
do_malloc	tcmalloc.cc	/^ALWAYS_INLINE void* do_malloc(size_t size) {$/;"	f	namespace:__anon34
do_malloc_or_cpp_alloc	tcmalloc.cc	/^ALWAYS_INLINE void* do_malloc_or_cpp_alloc(size_t size) {$/;"	f	namespace:__anon34
do_malloc_pages	tcmalloc.cc	/^inline void* do_malloc_pages(ThreadCache* heap, size_t size) {$/;"	f	namespace:__anon34
do_malloc_small	tcmalloc.cc	/^ALWAYS_INLINE void* do_malloc_small(ThreadCache* heap, size_t size) {$/;"	f	namespace:__anon34
do_malloc_stats	tcmalloc.cc	/^inline void do_malloc_stats() {$/;"	f	namespace:__anon34
do_mallopt	tcmalloc.cc	/^inline int do_mallopt(int cmd, int value) {$/;"	f	namespace:__anon34
do_memalign	tcmalloc.cc	/^void* do_memalign(size_t align, size_t size) {$/;"	f	namespace:__anon34
do_memalign_or_cpp_memalign	tcmalloc.cc	/^inline void* do_memalign_or_cpp_memalign(size_t align, size_t size) {$/;"	f	namespace:__anon34
do_realloc	tcmalloc.cc	/^ALWAYS_INLINE void* do_realloc(void* old_ptr, size_t new_size) {$/;"	f	namespace:__anon34
do_realloc_with_callback	tcmalloc.cc	/^ALWAYS_INLINE void* do_realloc_with_callback($/;"	f	namespace:__anon34
extra_bytes_released_	tcmalloc.cc	/^  size_t extra_bytes_released_;$/;"	m	class:TCMallocImplementation	file:
free_null_or_invalid	tcmalloc.cc	/^inline void free_null_or_invalid(void* ptr, void (*invalid_free_fn)(void*)) {$/;"	f	namespace:__anon34
google_malloc	tcmalloc.cc	/^      ATTRIBUTE_SECTION(google_malloc);$/;"	v
handle_oom	tcmalloc.cc	/^void* handle_oom(malloc_fn retry_fn,$/;"	f	namespace:__anon34
kDefaultLargeAllocReportThreshold	tcmalloc.cc	/^const int64 kDefaultLargeAllocReportThreshold = static_cast<int64>(1) << 30;$/;"	v
kDefaultLargeAllocReportThreshold	tcmalloc.cc	/^const int64 kDefaultLargeAllocReportThreshold = static_cast<int64>(1) << 62;$/;"	v
large_alloc_threshold	tcmalloc.cc	/^static int64_t large_alloc_threshold =$/;"	m	namespace:__anon34	file:
malloc_fn	tcmalloc.cc	/^typedef void* (*malloc_fn)(void *arg);$/;"	t	namespace:__anon34	file:
maybe_do_cpp_memalign_slow	tcmalloc.cc	/^static void *maybe_do_cpp_memalign_slow(size_t align, size_t size) {$/;"	f	namespace:__anon34
metadata_bytes	tcmalloc.cc	/^  uint64_t metadata_bytes;    \/\/ Bytes alloced for metadata$/;"	m	struct:TCMallocStats	file:
module_enter_exit_hook	tcmalloc.cc	/^static TCMallocGuard module_enter_exit_hook;$/;"	v	file:
pageheap	tcmalloc.cc	/^  PageHeap::Stats pageheap;   \/\/ Stats from page heap$/;"	m	struct:TCMallocStats	file:
pagesize	tcmalloc.cc	/^static size_t pagesize = 0;$/;"	v	file:
retry_do_memalign	tcmalloc.cc	/^static void *retry_do_memalign(void *arg) {$/;"	f	namespace:__anon34
retry_malloc	tcmalloc.cc	/^static void *retry_malloc(void* size) {$/;"	f	namespace:__anon34
retry_memaligh_data	tcmalloc.cc	/^struct retry_memaligh_data {$/;"	s	namespace:__anon34	file:
should_report_large	tcmalloc.cc	/^inline bool should_report_large(Length num_pages) {$/;"	f	namespace:__anon34
size	tcmalloc.cc	/^  size_t size;$/;"	m	struct:__anon34::retry_memaligh_data	file:
small	tcmalloc.cc	150;"	d	file:
tc_delete_sized	tcmalloc.cc	/^extern "C" PERFTOOLS_DLL_DECL void tc_delete_sized(void *p, size_t size) throw() {$/;"	f
tc_deletearray_sized	tcmalloc.cc	/^extern "C" PERFTOOLS_DLL_DECL void tc_deletearray_sized(void *p, size_t size) throw() {$/;"	f
tc_free_sized	tcmalloc.cc	/^  TC_ALIAS(tc_free_sized);$/;"	v
tc_new	tcmalloc.cc	/^TC_ALIAS(tc_new);$/;"	v
tc_new	tcmalloc.cc	/^extern "C" PERFTOOLS_DLL_DECL void* tc_new(size_t size) {$/;"	f
tc_new_mode	tcmalloc.cc	/^static int tc_new_mode = 0;  \/\/ See tc_set_new_mode().$/;"	v	file:
tcmallocguard_refcount	tcmalloc.cc	/^static int tcmallocguard_refcount = 0;  \/\/ no lock needed: runs before main()$/;"	v	file:
thread_bytes	tcmalloc.cc	/^  uint64_t thread_bytes;      \/\/ Bytes in thread caches$/;"	m	struct:TCMallocStats	file:
transfer_bytes	tcmalloc.cc	/^  uint64_t transfer_bytes;    \/\/ Bytes in central transfer cache$/;"	m	struct:TCMallocStats	file:
~TCMallocGuard	tcmalloc.cc	/^TCMallocGuard::~TCMallocGuard() {$/;"	f	class:TCMallocGuard
_XOPEN_SOURCE	tcmalloc.h	41;"	d
__THROW	tcmalloc.h	53;"	d
TCMALLOC_TCMALLOC_GUARD_H_	tcmalloc_guard.h	41;"	d
TCMallocGuard	tcmalloc_guard.h	/^class TCMallocGuard {$/;"	c
PtrAndSize	tests\addressmap_unittest.cc	/^  PtrAndSize(char* p, size_t s) : ptr(p), size(s) {}$/;"	f	struct:PtrAndSize
PtrAndSize	tests\addressmap_unittest.cc	/^struct PtrAndSize {$/;"	s	file:
SetCheckCallback	tests\addressmap_unittest.cc	/^static void SetCheckCallback(const void* ptr, ValueT* val,$/;"	f	file:
SizeFunc	tests\addressmap_unittest.cc	/^size_t SizeFunc(const ValueT& v) { return v.second; }$/;"	f
Uniform	tests\addressmap_unittest.cc	/^  size_t Uniform(size_t max_size) {$/;"	f	struct:UniformRandomNumberGenerator
UniformRandomNumberGenerator	tests\addressmap_unittest.cc	/^struct UniformRandomNumberGenerator {$/;"	s	file:
ValueT	tests\addressmap_unittest.cc	/^typedef pair<int, size_t> ValueT;$/;"	t	file:
main	tests\addressmap_unittest.cc	/^int main(int argc, char** argv) {$/;"	f
ptr	tests\addressmap_unittest.cc	/^  char* ptr;$/;"	m	struct:PtrAndSize	file:
rnd	tests\addressmap_unittest.cc	/^static UniformRandomNumberGenerator rnd;$/;"	v	file:
size	tests\addressmap_unittest.cc	/^  size_t size;$/;"	m	struct:PtrAndSize	file:
GG_ULONGLONG	tests\atomicops_unittest.cc	39;"	d	file:
NUM_BITS	tests\atomicops_unittest.cc	42;"	d	file:
TestAtomicExchange	tests\atomicops_unittest.cc	/^static void TestAtomicExchange(AtomicType (*atomic_exchange_func)$/;"	f	file:
TestAtomicOps	tests\atomicops_unittest.cc	/^static void TestAtomicOps() {$/;"	f	file:
TestCompareAndSwap	tests\atomicops_unittest.cc	/^static void TestCompareAndSwap(AtomicType (*compare_and_swap_func)$/;"	f	file:
TestLoad	tests\atomicops_unittest.cc	/^static void TestLoad() {$/;"	f	file:
TestStore	tests\atomicops_unittest.cc	/^static void TestStore() {$/;"	f	file:
main	tests\atomicops_unittest.cc	/^int main(int argc, char** argv) {$/;"	f
main	tests\current_allocated_bytes_test.cc	/^int main() {$/;"	f
CurrentlyAllocatedBytes	tests\debugallocation_test.cc	/^static size_t CurrentlyAllocatedBytes() {$/;"	f	file:
IF_DEBUG_EXPECT_DEATH	tests\debugallocation_test.cc	71;"	d	file:
RUN_ALL_TESTS	tests\debugallocation_test.cc	/^static int RUN_ALL_TESTS() {$/;"	f	file:
TEST	tests\debugallocation_test.cc	/^TEST(DebugAllocationTest, CurrentlyAllocated) {$/;"	f
TEST	tests\debugallocation_test.cc	/^TEST(DebugAllocationTest, DanglingPointerWriteTest) {$/;"	f
TEST	tests\debugallocation_test.cc	/^TEST(DebugAllocationTest, DanglingWriteAtExitTest) {$/;"	f
TEST	tests\debugallocation_test.cc	/^TEST(DebugAllocationTest, DeallocMismatch) {$/;"	f
TEST	tests\debugallocation_test.cc	/^TEST(DebugAllocationTest, DoubleFree) {$/;"	f
TEST	tests\debugallocation_test.cc	/^TEST(DebugAllocationTest, FreeQueueTest) {$/;"	f
TEST	tests\debugallocation_test.cc	/^TEST(DebugAllocationTest, GetAllocatedSizeTest) {$/;"	f
TEST	tests\debugallocation_test.cc	/^TEST(DebugAllocationTest, HugeAlloc) {$/;"	f
TEST	tests\debugallocation_test.cc	/^TEST(DebugAllocationTest, ReallocAfterMemalign) {$/;"	f
TEST	tests\debugallocation_test.cc	/^TEST(DebugAllocationTest, StackTraceWithDanglingWriteAtExitTest) {$/;"	f
TEST	tests\debugallocation_test.cc	/^TEST(DebugAllocationTest, StompAfter) {$/;"	f
TEST	tests\debugallocation_test.cc	/^TEST(DebugAllocationTest, StompBefore) {$/;"	f
TEST	tests\debugallocation_test.cc	46;"	d	file:
main	tests\debugallocation_test.cc	/^int main(int argc, char** argv) {$/;"	f
max_free_queue_size	tests\debugallocation_test.cc	/^DECLARE_int32(max_free_queue_size);$/;"	v
test_counter	tests\debugallocation_test.cc	/^static int test_counter = 0;    \/\/ incremented every time the macro is called$/;"	v	file:
test_to_run	tests\debugallocation_test.cc	/^static int test_to_run = 0;     \/\/ set in main() based on argv$/;"	v	file:
OneDeathTest	tests\debugallocation_test.sh	/^OneDeathTest() {$/;"	f
main	tests\frag_unittest.cc	/^int main(int argc, char** argv) {$/;"	f
RoutineCallingTheSignal	tests\getpc_test.cc	/^static void RoutineCallingTheSignal() {$/;"	f	file:
getpc_retval	tests\getpc_test.cc	/^static volatile void* getpc_retval = NULL;    \/\/ what GetPC returns$/;"	v	file:
kRoutineSize	tests\getpc_test.cc	/^const int kRoutineSize = 512 * sizeof(void*)\/4;    \/\/ allow 1024 for 64-bit$/;"	v
main	tests\getpc_test.cc	/^int main(int argc, char** argv) {$/;"	f
prof_handler	tests\getpc_test.cc	/^static void prof_handler(int sig, siginfo_t*, void* signal_ucontext) {$/;"	f	file:
prof_handler_called	tests\getpc_test.cc	/^static volatile bool prof_handler_called = false;$/;"	v	file:
ALARM	tests\heap-checker-death_unittest.sh	/^ALARM() {$/;"	f
Test	tests\heap-checker-death_unittest.sh	/^Test() {$/;"	f
A	tests\heap-checker_unittest.cc	/^  virtual void A() { }$/;"	f	class:ClassMltD1
A	tests\heap-checker_unittest.cc	/^  virtual void A() { }$/;"	f	class:ClassMltD2
AllocHidden	tests\heap-checker_unittest.cc	/^static void* AllocHidden(size_t size) {$/;"	f	file:
Array	tests\heap-checker_unittest.cc	/^  Array() {$/;"	f	struct:Array
Array	tests\heap-checker_unittest.cc	/^  Array(const Array& x) {$/;"	f	struct:Array
Array	tests\heap-checker_unittest.cc	/^struct Array {$/;"	s	file:
B	tests\heap-checker_unittest.cc	/^  virtual void B() { }$/;"	f	class:ClassMltD1
B	tests\heap-checker_unittest.cc	/^  virtual void B() { }$/;"	f	class:ClassMltD2
C	tests\heap-checker_unittest.cc	/^  virtual void C() { }$/;"	f	class:ClassMltD1
Callback0	tests\heap-checker_unittest.cc	/^  inline Callback0(FunctionSignature f) : f_(f) {}$/;"	f	class:Callback0
Callback0	tests\heap-checker_unittest.cc	/^class Callback0 : public Closure {$/;"	c	file:
Callback1	tests\heap-checker_unittest.cc	/^  inline Callback1<P1>(FunctionSignature f, P1 p1) : f_(f), p1_(p1) {}$/;"	f	class:Callback1
Callback1	tests\heap-checker_unittest.cc	/^template <class P1> class Callback1 : public Closure {$/;"	c	file:
Callback2	tests\heap-checker_unittest.cc	/^  inline Callback2<P1,P2>(FunctionSignature f, P1 p1, P2 p2) : f_(f), p1_(p1), p2_(p2) {}$/;"	f	class:Callback2
Callback2	tests\heap-checker_unittest.cc	/^template <class P1, class P2> class Callback2 : public Closure {$/;"	c	file:
CheckType	tests\heap-checker_unittest.cc	/^enum CheckType { SAME_HEAP, NO_LEAKS };$/;"	g	file:
ClassA	tests\heap-checker_unittest.cc	/^  explicit ClassA(int a) : ptr(NULL) { }$/;"	f	class:ClassA
ClassA	tests\heap-checker_unittest.cc	/^class ClassA {$/;"	c	file:
ClassB	tests\heap-checker_unittest.cc	/^  ClassB() { }$/;"	f	class:ClassB
ClassB	tests\heap-checker_unittest.cc	/^class ClassB {$/;"	c	file:
ClassB2	tests\heap-checker_unittest.cc	/^  ClassB2() { }$/;"	f	class:ClassB2
ClassB2	tests\heap-checker_unittest.cc	/^class ClassB2 {$/;"	c	file:
ClassD	tests\heap-checker_unittest.cc	/^class ClassD : public ClassD1, public ClassD2 {$/;"	c	file:
ClassD1	tests\heap-checker_unittest.cc	/^class ClassD1 : public ClassB {$/;"	c	file:
ClassD2	tests\heap-checker_unittest.cc	/^class ClassD2 : public ClassB2 {$/;"	c	file:
ClassMltD1	tests\heap-checker_unittest.cc	/^class ClassMltD1 : public ClassB, public InterfaceB, public InterfaceC {$/;"	c	file:
ClassMltD2	tests\heap-checker_unittest.cc	/^class ClassMltD2 : public InterfaceA, public InterfaceB, public ClassB {$/;"	c	file:
Closure	tests\heap-checker_unittest.cc	/^class Closure {$/;"	c	file:
DTSL	tests\heap-checker_unittest.cc	1506;"	d	file:
DTSL	tests\heap-checker_unittest.cc	1519;"	d	file:
DeAllocHidden	tests\heap-checker_unittest.cc	/^static void DeAllocHidden(void** ptr) {$/;"	f	file:
DirectTestSTLAlloc	tests\heap-checker_unittest.cc	/^static void DirectTestSTLAlloc(Alloc allocator, const char* name) {$/;"	f	file:
DoAllocHidden	tests\heap-checker_unittest.cc	/^static void DoAllocHidden(size_t size, void** ptr) {$/;"	f	file:
DoDeAllocHidden	tests\heap-checker_unittest.cc	/^static void DoDeAllocHidden(void** ptr) {$/;"	f	file:
DoRunHidden	tests\heap-checker_unittest.cc	/^static void DoRunHidden(Closure* c, int n) {$/;"	f	file:
DoTestSTLAlloc	tests\heap-checker_unittest.cc	/^static void DoTestSTLAlloc() {$/;"	f	file:
DoTestSTLAllocInverse	tests\heap-checker_unittest.cc	/^static void DoTestSTLAllocInverse(IntSet** setx) {$/;"	f	file:
DoWipeStack	tests\heap-checker_unittest.cc	/^\/*static*\/ void DoWipeStack(int n) {$/;"	f
FreeTestSTLAllocInverse	tests\heap-checker_unittest.cc	/^static void FreeTestSTLAllocInverse(IntSet** setx) {$/;"	f	file:
FunctionSignature	tests\heap-checker_unittest.cc	/^  typedef void (*FunctionSignature)();$/;"	t	class:Callback0	file:
FunctionSignature	tests\heap-checker_unittest.cc	/^  typedef void (*FunctionSignature)(P1);$/;"	t	class:Callback1	file:
FunctionSignature	tests\heap-checker_unittest.cc	/^  typedef void (*FunctionSignature)(P1,P2);$/;"	t	class:Callback2	file:
GetFunctionAddress	tests\heap-checker_unittest.cc	/^static inline uintptr_t GetFunctionAddress (void* (*func)(uintptr_t*))$/;"	f	file:
HeapBusyThreadBody	tests\heap-checker_unittest.cc	/^static void* HeapBusyThreadBody(void* a) {$/;"	f	file:
Hide	tests\heap-checker_unittest.cc	/^static void Hide(T** ptr) {$/;"	f	file:
Initialized	tests\heap-checker_unittest.cc	/^struct Initialized { };$/;"	s	file:
Inner	tests\heap-checker_unittest.cc	/^    Inner(Nesting* p) : parent(p) {}$/;"	f	struct:Nesting::Inner
Inner	tests\heap-checker_unittest.cc	/^  struct Inner {$/;"	s	struct:Nesting	file:
IntSet	tests\heap-checker_unittest.cc	/^typedef set<int> IntSet;$/;"	t	file:
InterfaceA	tests\heap-checker_unittest.cc	/^  InterfaceA() { }$/;"	f	class:InterfaceA
InterfaceA	tests\heap-checker_unittest.cc	/^class InterfaceA {$/;"	c	file:
InterfaceB	tests\heap-checker_unittest.cc	/^  InterfaceB() { }$/;"	f	class:InterfaceB
InterfaceB	tests\heap-checker_unittest.cc	/^class InterfaceB {$/;"	c	file:
InterfaceC	tests\heap-checker_unittest.cc	/^  InterfaceC() { }$/;"	f	class:InterfaceC
InterfaceC	tests\heap-checker_unittest.cc	/^class InterfaceC : public InterfaceA {$/;"	c	file:
KeyFree	tests\heap-checker_unittest.cc	/^static void KeyFree(void* ptr) {$/;"	f	file:
KeyInit	tests\heap-checker_unittest.cc	/^static void KeyInit() {$/;"	f	file:
LOGF	tests\heap-checker_unittest.cc	169;"	d	file:
LogHidden	tests\heap-checker_unittest.cc	/^static void LogHidden(const char* message, const void* ptr) {$/;"	f	file:
MAP_ANONYMOUS	tests\heap-checker_unittest.cc	113;"	d	file:
MakeALeak	tests\heap-checker_unittest.cc	/^static void MakeALeak(void** arr) {$/;"	f	file:
MakeDeathLoop	tests\heap-checker_unittest.cc	/^static void MakeDeathLoop(void** arr1, void** arr2) {$/;"	f	file:
Mallocer	tests\heap-checker_unittest.cc	/^static void* Mallocer(uintptr_t* addr_after_malloc_call) {$/;"	f	file:
Mmapper	tests\heap-checker_unittest.cc	/^static void* Mmapper(uintptr_t* addr_after_mmap_call) {$/;"	f	file:
NO_LEAKS	tests\heap-checker_unittest.cc	/^enum CheckType { SAME_HEAP, NO_LEAKS };$/;"	e	enum:CheckType	file:
Nesting	tests\heap-checker_unittest.cc	/^  Nesting() : i0(this), i1(this), i2(this), i3(this) {}$/;"	f	struct:Nesting
Nesting	tests\heap-checker_unittest.cc	/^struct Nesting {$/;"	s	file:
NewCallback	tests\heap-checker_unittest.cc	/^inline Callback0* NewCallback(void (*function)()) {$/;"	f
NewCallback	tests\heap-checker_unittest.cc	/^inline Callback1<P1>* NewCallback(void (*function)(P1), P1 p1) {$/;"	f
NewCallback	tests\heap-checker_unittest.cc	/^inline Callback2<P1,P2>* NewCallback(void (*function)(P1,P2), P1 p1, P2 p2) {$/;"	f
ObjMakerFunc	tests\heap-checker_unittest.cc	/^typedef void* (*ObjMakerFunc)();$/;"	t	file:
ObjMakerRegistrar	tests\heap-checker_unittest.cc	/^  ObjMakerRegistrar(ObjMakerFunc obj_maker) { obj_makers.push_back(obj_maker); }$/;"	f	struct:ObjMakerRegistrar
ObjMakerRegistrar	tests\heap-checker_unittest.cc	/^struct ObjMakerRegistrar {$/;"	s	file:
Pass	tests\heap-checker_unittest.cc	/^static int Pass() {$/;"	f	file:
Pause	tests\heap-checker_unittest.cc	/^static void Pause() {$/;"	f	file:
PreventHeapReclaiming	tests\heap-checker_unittest.cc	/^void PreventHeapReclaiming(size_t size) {$/;"	f
REGISTER_OBJ_MAKER	tests\heap-checker_unittest.cc	981;"	d	file:
RUN_SILENT	tests\heap-checker_unittest.cc	421;"	d	file:
Run	tests\heap-checker_unittest.cc	/^  virtual void Run() { (*f_)(); delete this; }$/;"	f	class:Callback0
Run	tests\heap-checker_unittest.cc	/^  virtual void Run() { (*f_)(p1_); delete this; }$/;"	f	class:Callback1
Run	tests\heap-checker_unittest.cc	/^  virtual void Run() { (*f_)(p1_, p2_); delete this; }$/;"	f	class:Callback2
RunDisabledLeaks	tests\heap-checker_unittest.cc	/^static void* RunDisabledLeaks(void* a) {$/;"	f	file:
RunHeapBusyThreads	tests\heap-checker_unittest.cc	/^static void RunHeapBusyThreads() {$/;"	f	file:
RunHidden	tests\heap-checker_unittest.cc	/^static void RunHidden(Closure* c) {$/;"	f	file:
RunSilent	tests\heap-checker_unittest.cc	/^static bool RunSilent(HeapLeakChecker* check,$/;"	f	file:
SAME_HEAP	tests\heap-checker_unittest.cc	/^enum CheckType { SAME_HEAP, NO_LEAKS };$/;"	e	enum:CheckType	file:
ScopedDisabledLeaks	tests\heap-checker_unittest.cc	/^static void ScopedDisabledLeaks() {$/;"	f	file:
TClass	tests\heap-checker_unittest.cc	/^  explicit TClass(int a) : ptr(NULL) { }$/;"	f	class:TClass
TClass	tests\heap-checker_unittest.cc	/^class TClass {$/;"	c	file:
TestHeapLeakChecker	tests\heap-checker_unittest.cc	/^static void TestHeapLeakChecker() {$/;"	f	file:
TestHeapLeakCheckerDeathCountLess	tests\heap-checker_unittest.cc	/^static void TestHeapLeakCheckerDeathCountLess() {$/;"	f	file:
TestHeapLeakCheckerDeathCountMore	tests\heap-checker_unittest.cc	/^static void TestHeapLeakCheckerDeathCountMore() {$/;"	f	file:
TestHeapLeakCheckerDeathInverse	tests\heap-checker_unittest.cc	/^static void TestHeapLeakCheckerDeathInverse() {$/;"	f	file:
TestHeapLeakCheckerDeathLoop	tests\heap-checker_unittest.cc	/^static void TestHeapLeakCheckerDeathLoop() {$/;"	f	file:
TestHeapLeakCheckerDeathNoLeaks	tests\heap-checker_unittest.cc	/^static void TestHeapLeakCheckerDeathNoLeaks() {$/;"	f	file:
TestHeapLeakCheckerDeathSimple	tests\heap-checker_unittest.cc	/^static void TestHeapLeakCheckerDeathSimple() {$/;"	f	file:
TestHeapLeakCheckerDeathTrick	tests\heap-checker_unittest.cc	/^static void TestHeapLeakCheckerDeathTrick() {$/;"	f	file:
TestHeapLeakCheckerDisabling	tests\heap-checker_unittest.cc	/^static void TestHeapLeakCheckerDisabling() {$/;"	f	file:
TestHeapLeakCheckerLiveness	tests\heap-checker_unittest.cc	/^static void TestHeapLeakCheckerLiveness() {$/;"	f	file:
TestHeapLeakCheckerNoFalsePositives	tests\heap-checker_unittest.cc	/^static void TestHeapLeakCheckerNoFalsePositives() {$/;"	f	file:
TestHiddenPointer	tests\heap-checker_unittest.cc	/^static void TestHiddenPointer() {$/;"	f	file:
TestLeakButTotalsMatch	tests\heap-checker_unittest.cc	/^static void TestLeakButTotalsMatch() {$/;"	f	file:
TestLibCAllocate	tests\heap-checker_unittest.cc	/^static void TestLibCAllocate() {$/;"	f	file:
TestObjMakers	tests\heap-checker_unittest.cc	/^static void TestObjMakers() {$/;"	f	file:
TestPointerReach	tests\heap-checker_unittest.cc	/^static void TestPointerReach(ObjMakerFunc obj_maker) {$/;"	f	file:
TestSTLAlloc	tests\heap-checker_unittest.cc	/^static void TestSTLAlloc() {$/;"	f	file:
TestSTLAllocInverse	tests\heap-checker_unittest.cc	/^static void TestSTLAllocInverse() {$/;"	f	file:
ThreadDisabledLeaks	tests\heap-checker_unittest.cc	/^static void ThreadDisabledLeaks() {$/;"	f	file:
TransLeaks	tests\heap-checker_unittest.cc	/^static void TransLeaks() {$/;"	f	file:
UnHide	tests\heap-checker_unittest.cc	/^static void UnHide(T** ptr) {$/;"	f	file:
Use	tests\heap-checker_unittest.cc	/^static void Use(T** foo) {$/;"	f	file:
VLOG	tests\heap-checker_unittest.cc	166;"	d	file:
VLOG	tests\heap-checker_unittest.cc	167;"	d	file:
VerifyHeapProfileTableStackGet	tests\heap-checker_unittest.cc	/^extern void VerifyHeapProfileTableStackGet() {$/;"	f
VerifyLeaks	tests\heap-checker_unittest.cc	/^static void VerifyLeaks(HeapLeakChecker* check, CheckType type,$/;"	f	file:
VerifyMemoryRegionMapStackGet	tests\heap-checker_unittest.cc	/^static void VerifyMemoryRegionMapStackGet() {$/;"	f	file:
WARN_IF	tests\heap-checker_unittest.cc	163;"	d	file:
WipeStack	tests\heap-checker_unittest.cc	/^static void WipeStack() { DoWipeStack(20); }$/;"	f	file:
append	tests\heap-checker_unittest.cc	/^  void append(const Array& x) {$/;"	f	struct:Array
b	tests\heap-checker_unittest.cc	/^  char b[7];$/;"	m	class:ClassB	file:
b2	tests\heap-checker_unittest.cc	/^  char b2[11];$/;"	m	class:ClassB2	file:
can_create_leaks_reliably	tests\heap-checker_unittest.cc	/^static bool can_create_leaks_reliably = false;$/;"	v	file:
d	tests\heap-checker_unittest.cc	/^  char d[3];$/;"	m	class:ClassD	file:
d1	tests\heap-checker_unittest.cc	/^  char d1[11];$/;"	m	class:ClassMltD1	file:
d1	tests\heap-checker_unittest.cc	/^  char d1[15];$/;"	m	class:ClassD1	file:
d2	tests\heap-checker_unittest.cc	/^  char d2[15];$/;"	m	class:ClassMltD2	file:
d2	tests\heap-checker_unittest.cc	/^  char d2[19];$/;"	m	class:ClassD2	file:
f	tests\heap-checker_unittest.cc	/^  virtual void f() { }$/;"	f	class:ClassB
f	tests\heap-checker_unittest.cc	/^  virtual void f() { }$/;"	f	class:ClassD	file:
f	tests\heap-checker_unittest.cc	/^  virtual void f() { }$/;"	f	class:ClassD1	file:
f	tests\heap-checker_unittest.cc	/^  virtual void f() { }$/;"	f	class:ClassMltD1
f	tests\heap-checker_unittest.cc	/^  virtual void f() { }$/;"	f	class:ClassMltD2
f2	tests\heap-checker_unittest.cc	/^  virtual void f2() { }$/;"	f	class:ClassB2
f2	tests\heap-checker_unittest.cc	/^  virtual void f2() { }$/;"	f	class:ClassD	file:
f2	tests\heap-checker_unittest.cc	/^  virtual void f2() { }$/;"	f	class:ClassD2	file:
f_	tests\heap-checker_unittest.cc	/^  FunctionSignature f_;$/;"	m	class:Callback0	file:
f_	tests\heap-checker_unittest.cc	/^  FunctionSignature f_;$/;"	m	class:Callback1	file:
f_	tests\heap-checker_unittest.cc	/^  FunctionSignature f_;$/;"	m	class:Callback2	file:
g_have_exited_main	tests\heap-checker_unittest.cc	/^static bool g_have_exited_main = false;$/;"	v	file:
grp	tests\heap-checker_unittest.cc	/^static struct group* grp = NULL;$/;"	v	typeref:struct:group	file:
heap_check	tests\heap-checker_unittest.cc	/^DECLARE_string(heap_check);  \/\/ in heap-checker.cc$/;"	v
heap_check_max_pointer_offset	tests\heap-checker_unittest.cc	/^DECLARE_int64(heap_check_max_pointer_offset);   \/\/ heap-checker.cc$/;"	v
i0	tests\heap-checker_unittest.cc	/^  Inner i0;$/;"	m	struct:Nesting	file:
i1	tests\heap-checker_unittest.cc	/^  Inner i1;$/;"	m	struct:Nesting	file:
i2	tests\heap-checker_unittest.cc	/^  Inner i2;$/;"	m	struct:Nesting	file:
i3	tests\heap-checker_unittest.cc	/^  Inner i3;$/;"	m	struct:Nesting	file:
init_forcer	tests\heap-checker_unittest.cc	/^void (* volatile init_forcer)(...);$/;"	v
initialized	tests\heap-checker_unittest.cc	/^static Initialized initialized;$/;"	v	file:
kHideMask	tests\heap-checker_unittest.cc	/^static const uintptr_t kHideMask =$/;"	v	file:
kKeys	tests\heap-checker_unittest.cc	/^static const int kKeys = 50;$/;"	v	file:
key	tests\heap-checker_unittest.cc	/^static pthread_key_t key[kKeys];$/;"	v	file:
key_init_has_run	tests\heap-checker_unittest.cc	/^static bool key_init_has_run = false;$/;"	v	file:
live_objects	tests\heap-checker_unittest.cc	/^static list<void*>* live_objects = new list<void*>;$/;"	v	file:
main	tests\heap-checker_unittest.cc	/^int main(int argc, char** argv) {$/;"	f
mallocer_addr	tests\heap-checker_unittest.cc	/^static void* (* volatile mallocer_addr)(uintptr_t* addr) = &Mallocer;$/;"	v	file:
mmapper_addr	tests\heap-checker_unittest.cc	/^static void* (*mmapper_addr)(uintptr_t* addr) = &Mmapper;$/;"	v	file:
n1	tests\heap-checker_unittest.cc	/^  char n1[5];$/;"	m	struct:Nesting	file:
n2	tests\heap-checker_unittest.cc	/^  char n2[11];$/;"	m	struct:Nesting	file:
n3	tests\heap-checker_unittest.cc	/^  char n3[27];$/;"	m	struct:Nesting	file:
obj_makers	tests\heap-checker_unittest.cc	/^static list<ObjMakerFunc> obj_makers;  \/\/ list of registered object makers$/;"	v	file:
operator =	tests\heap-checker_unittest.cc	/^  void operator=(const Array& x) {$/;"	f	struct:Array
operator new	tests\heap-checker_unittest.cc	/^void* operator new(size_t size, const Initialized&) {$/;"	f
operator new[]	tests\heap-checker_unittest.cc	/^void* operator new[](size_t size, const Initialized&) {$/;"	f
p1_	tests\heap-checker_unittest.cc	/^  P1 p1_;$/;"	m	class:Callback1	file:
p1_	tests\heap-checker_unittest.cc	/^  P1 p1_;$/;"	m	class:Callback2	file:
p2_	tests\heap-checker_unittest.cc	/^  P2 p2_;$/;"	m	class:Callback2	file:
parent	tests\heap-checker_unittest.cc	/^    Nesting* parent;$/;"	m	struct:Nesting::Inner	file:
ptr	tests\heap-checker_unittest.cc	/^  T* ptr;$/;"	m	struct:Array	file:
ptr	tests\heap-checker_unittest.cc	/^  mutable C* ptr;$/;"	m	class:TClass	file:
ptr	tests\heap-checker_unittest.cc	/^  mutable char* ptr;$/;"	m	class:ClassA	file:
run_hidden_ptr	tests\heap-checker_unittest.cc	/^void (*volatile run_hidden_ptr)(Closure* c, int n);$/;"	v
set_data	tests\heap-checker_unittest.cc	/^static int set_data[] = { 1, 2, 3, 4, 5, 6, 7, 21, 22, 23, 24, 25, 26, 27 };$/;"	v	file:
size	tests\heap-checker_unittest.cc	/^  size_t size;$/;"	m	struct:Array	file:
some_ints	tests\heap-checker_unittest.cc	/^static int some_ints[] = { 1, 2, 3, 21, 22, 23, 24, 25 };$/;"	v	file:
val	tests\heap-checker_unittest.cc	/^  mutable C val;$/;"	m	class:TClass	file:
wipe_stack_ptr	tests\heap-checker_unittest.cc	/^void (*volatile wipe_stack_ptr)(int n);$/;"	v
~Array	tests\heap-checker_unittest.cc	/^  ~Array() { delete [] ptr; }$/;"	f	struct:Array
~ClassB	tests\heap-checker_unittest.cc	/^  virtual ~ClassB() { }$/;"	f	class:ClassB
~ClassB2	tests\heap-checker_unittest.cc	/^  virtual ~ClassB2() { }$/;"	f	class:ClassB2
~Closure	tests\heap-checker_unittest.cc	/^  virtual ~Closure() { }$/;"	f	class:Closure
~InterfaceA	tests\heap-checker_unittest.cc	/^  virtual ~InterfaceA() { }$/;"	f	class:InterfaceA
~InterfaceB	tests\heap-checker_unittest.cc	/^  virtual ~InterfaceB() { }$/;"	f	class:InterfaceB
~InterfaceC	tests\heap-checker_unittest.cc	/^  virtual ~InterfaceC() { }$/;"	f	class:InterfaceC
run_check	tests\heap-checker_unittest.sh	/^run_check() {$/;"	f
Allocate	tests\heap-profiler_unittest.cc	/^static ATTRIBUTE_NOINLINE void Allocate(int start, int end, int size) {$/;"	f	file:
Allocate2	tests\heap-profiler_unittest.cc	/^static ATTRIBUTE_NOINLINE void Allocate2(int start, int end, int size) {$/;"	f	file:
Deallocate	tests\heap-profiler_unittest.cc	/^static void Deallocate(int start, int end) {$/;"	f	file:
TestDumpHeapProfiler	tests\heap-profiler_unittest.cc	/^static void TestDumpHeapProfiler() {$/;"	f	file:
TestHeapProfilerStartStopIsRunning	tests\heap-profiler_unittest.cc	/^static void TestHeapProfilerStartStopIsRunning() {$/;"	f	file:
g_array	tests\heap-profiler_unittest.cc	/^int* g_array[kMaxCount];              \/\/ an array of int-vectors$/;"	v
kMaxCount	tests\heap-profiler_unittest.cc	/^static const int kMaxCount = 100000;$/;"	v	file:
main	tests\heap-profiler_unittest.cc	/^int main(int argc, char** argv) {$/;"	f
VerifyMemFunction	tests\heap-profiler_unittest.sh	/^VerifyMemFunction() {$/;"	f
VerifyOutputContains	tests\heap-profiler_unittest.sh	/^VerifyOutputContains() {$/;"	f
main	tests\large_heap_fragmentation_unittest.cc	/^int main (int argc, char** argv) {$/;"	f
AllocHook	tests\low_level_alloc_unittest.cc	/^static void AllocHook(const void *p, size_t size) {$/;"	f	file:
BlockDesc	tests\low_level_alloc_unittest.cc	/^struct BlockDesc {$/;"	s	file:
CheckBlockDesc	tests\low_level_alloc_unittest.cc	/^static void CheckBlockDesc(const BlockDesc &d) {$/;"	f	file:
FreeHook	tests\low_level_alloc_unittest.cc	/^static void FreeHook(const void *p) {$/;"	f	file:
RandomizeBlockDesc	tests\low_level_alloc_unittest.cc	/^static void RandomizeBlockDesc(BlockDesc *d) {$/;"	f	file:
Test	tests\low_level_alloc_unittest.cc	/^static void Test(bool use_new_arena, bool call_malloc_hook, int n) {$/;"	f	file:
allocates	tests\low_level_alloc_unittest.cc	/^static int32 allocates;$/;"	v	file:
fill	tests\low_level_alloc_unittest.cc	/^  int fill;       \/\/ filled with data starting with this$/;"	m	struct:BlockDesc	file:
frees	tests\low_level_alloc_unittest.cc	/^static int32 frees;$/;"	v	file:
len	tests\low_level_alloc_unittest.cc	/^  int len;        \/\/ number of bytes$/;"	m	struct:BlockDesc	file:
main	tests\low_level_alloc_unittest.cc	/^int main(int argc, char *argv[]) {$/;"	f
ptr	tests\low_level_alloc_unittest.cc	/^  char *ptr;      \/\/ pointer to memory$/;"	m	struct:BlockDesc	file:
using_low_level_alloc	tests\low_level_alloc_unittest.cc	/^static bool using_low_level_alloc = false;$/;"	v	file:
FAIL	tests\malloc_extension_c_test.c	47;"	d	file:
TestDeleteHook	tests\malloc_extension_c_test.c	/^void TestDeleteHook(const void* ptr) {$/;"	f
TestMallocExtension	tests\malloc_extension_c_test.c	/^void TestMallocExtension(void) {$/;"	f
TestMallocHook	tests\malloc_extension_c_test.c	/^void TestMallocHook(void) {$/;"	f
TestNewHook	tests\malloc_extension_c_test.c	/^void TestNewHook(const void* ptr, size_t size) {$/;"	f
forced_malloc	tests\malloc_extension_c_test.c	/^void *forced_malloc(size_t size)$/;"	f	file:
g_delete_hook_calls	tests\malloc_extension_c_test.c	/^static int g_delete_hook_calls = 0;$/;"	v	file:
g_new_hook_calls	tests\malloc_extension_c_test.c	/^static int g_new_hook_calls = 0;$/;"	v	file:
main	tests\malloc_extension_c_test.c	/^int main(int argc, char** argv) {$/;"	f
main	tests\malloc_extension_test.cc	/^int main(int argc, char** argv) {$/;"	f
INIT_HOOK_LIST	tests\malloc_hook_test.cc	120;"	d	file:
MAP_ANONYMOUS	tests\malloc_hook_test.cc	56;"	d	file:
MmapReplacement	tests\malloc_hook_test.cc	/^int MmapReplacement(const void* start,$/;"	f	namespace:__anon35
MultithreadedTestThread	tests\malloc_hook_test.cc	/^void MultithreadedTestThread(TestHookList* list, int shift,$/;"	f	namespace:__anon35
MultithreadedTestThreadRunner	tests\malloc_hook_test.cc	/^void MultithreadedTestThreadRunner(int thread_num) {$/;"	f	namespace:__anon35
MunmapReplacement	tests\malloc_hook_test.cc	/^int MunmapReplacement(const void* ptr, size_t size, int* result) {$/;"	f	namespace:__anon35
RUN_ALL_TESTS	tests\malloc_hook_test.cc	/^static int RUN_ALL_TESTS() {$/;"	f	namespace:__anon35
Sleep	tests\malloc_hook_test.cc	/^void Sleep(int seconds) {$/;"	f	namespace:__anon35
TEST	tests\malloc_hook_test.cc	/^TEST(HookListTest, AddAppends) {$/;"	f	namespace:__anon35
TEST	tests\malloc_hook_test.cc	/^TEST(HookListTest, AddPrependsAfterRemove) {$/;"	f	namespace:__anon35
TEST	tests\malloc_hook_test.cc	/^TEST(HookListTest, CanRemoveInitialValue) {$/;"	f	namespace:__anon35
TEST	tests\malloc_hook_test.cc	/^TEST(HookListTest, FillUpTheList) {$/;"	f	namespace:__anon35
TEST	tests\malloc_hook_test.cc	/^TEST(HookListTest, InitialValueExists) {$/;"	f	namespace:__anon35
TEST	tests\malloc_hook_test.cc	/^TEST(HookListTest, InvalidAddRejected) {$/;"	f	namespace:__anon35
TEST	tests\malloc_hook_test.cc	/^TEST(HookListTest, MultithreadedTest) {$/;"	f	namespace:__anon35
TEST	tests\malloc_hook_test.cc	/^TEST(HookListTest, RemoveWorksAndWillClearSize) {$/;"	f	namespace:__anon35
TEST	tests\malloc_hook_test.cc	/^TEST(MallocMookTest, MmapReplacements) {$/;"	f	namespace:__anon35
TEST	tests\malloc_hook_test.cc	66;"	d	file:
TestHookList	tests\malloc_hook_test.cc	/^typedef base::internal::HookList<MallocHook::NewHook> TestHookList;$/;"	t	namespace:__anon35	file:
TestHookList_Add	tests\malloc_hook_test.cc	/^bool TestHookList_Add(TestHookList* list, int val) {$/;"	f	namespace:__anon35
TestHookList_Remove	tests\malloc_hook_test.cc	/^bool TestHookList_Remove(TestHookList* list, int val) {$/;"	f	namespace:__anon35
TestHookList_Traverse	tests\malloc_hook_test.cc	/^int TestHookList_Traverse(const TestHookList& list, uintptr_t* output_array, int n) {$/;"	f	namespace:__anon35
kMmapMagicFd	tests\malloc_hook_test.cc	/^const int kMmapMagicFd = 1;$/;"	m	namespace:__anon35	file:
kMmapMagicPointer	tests\malloc_hook_test.cc	/^void* const kMmapMagicPointer = reinterpret_cast<void*>(1);$/;"	m	namespace:__anon35	file:
list	tests\malloc_hook_test.cc	/^static TestHookList list = INIT_HOOK_LIST(69);$/;"	m	namespace:__anon35	file:
main	tests\malloc_hook_test.cc	/^int main(int argc, char** argv) {$/;"	f
mmap_calls	tests\malloc_hook_test.cc	/^int mmap_calls = 0;$/;"	m	namespace:__anon35	file:
mmap_matching_calls	tests\malloc_hook_test.cc	/^int mmap_matching_calls = 0;$/;"	m	namespace:__anon35	file:
munmap_calls	tests\malloc_hook_test.cc	/^int munmap_calls = 0;$/;"	m	namespace:__anon35	file:
munmap_matching_calls	tests\malloc_hook_test.cc	/^int munmap_matching_calls = 0;$/;"	m	namespace:__anon35	file:
num_threads_remaining	tests\malloc_hook_test.cc	/^static volatile int num_threads_remaining;$/;"	m	namespace:__anon35	file:
threadcount_lock	tests\malloc_hook_test.cc	/^static Mutex threadcount_lock;$/;"	m	namespace:__anon35	file:
GetTotalThreadCacheSize	tests\markidle_unittest.cc	/^static size_t GetTotalThreadCacheSize() {$/;"	f	file:
MultipleIdleCalls	tests\markidle_unittest.cc	/^static void MultipleIdleCalls() {$/;"	f	file:
MultipleIdleNonIdlePhases	tests\markidle_unittest.cc	/^static void MultipleIdleNonIdlePhases() {$/;"	f	file:
TestAllocation	tests\markidle_unittest.cc	/^static void TestAllocation() {$/;"	f	file:
TestIdleUsage	tests\markidle_unittest.cc	/^static void TestIdleUsage() {$/;"	f	file:
TestTemporarilyIdleUsage	tests\markidle_unittest.cc	/^static void TestTemporarilyIdleUsage() {$/;"	f	file:
main	tests\markidle_unittest.cc	/^int main(int argc, char** argv) {$/;"	f
CheckAlignment	tests\memalign_unittest.cc	/^static void CheckAlignment(void* p, int align) {$/;"	f	file:
Fill	tests\memalign_unittest.cc	/^static void Fill(void* p, int n, char seed) {$/;"	f	file:
NextSize	tests\memalign_unittest.cc	/^static int NextSize(int size) {$/;"	f	file:
Number	tests\memalign_unittest.cc	/^static uintptr_t Number(void* p) {$/;"	f	file:
Valid	tests\memalign_unittest.cc	/^static bool Valid(const void* p, int n, char seed) {$/;"	f	file:
main	tests\memalign_unittest.cc	/^int main(int argc, char** argv) {$/;"	f
PackedCacheTest_basic	tests\packed-cache_test.cc	/^void PackedCacheTest_basic() {$/;"	f
kHashbits	tests\packed-cache_test.cc	/^static const int kHashbits = PackedCache<64, uint64>::kHashbits;$/;"	v	file:
main	tests\packed-cache_test.cc	/^int main(int argc, char **argv) {$/;"	f
CheckStats	tests\page_heap_test.cc	/^static void CheckStats(const tcmalloc::PageHeap* ph,$/;"	f	namespace:__anon36
HaveSystemRelease	tests\page_heap_test.cc	/^static bool HaveSystemRelease =$/;"	m	namespace:__anon36	file:
TestPageHeap_Limit	tests\page_heap_test.cc	/^static void TestPageHeap_Limit() {$/;"	f	namespace:__anon36
TestPageHeap_Stats	tests\page_heap_test.cc	/^static void TestPageHeap_Stats() {$/;"	f	namespace:__anon36
main	tests\page_heap_test.cc	/^int main(int argc, char **argv) {$/;"	f
tcmalloc_heap_limit_mb	tests\page_heap_test.cc	/^DECLARE_int64(tcmalloc_heap_limit_mb);$/;"	v
Permute	tests\pagemap_unittest.cc	/^static void Permute(vector<intptr_t>* elements) {$/;"	f	file:
TestMap	tests\pagemap_unittest.cc	/^void TestMap(int limit, bool limit_is_below_the_overflow_boundary) {$/;"	f
TestNext	tests\pagemap_unittest.cc	/^void TestNext(const char* name) {$/;"	f
main	tests\pagemap_unittest.cc	/^int main(int argc, char** argv) {$/;"	f
BusyThread	tests\profile-handler_unittest.cc	/^  BusyThread() : stop_work_(false) {$/;"	f	class:__anon37::BusyThread
BusyThread	tests\profile-handler_unittest.cc	/^class BusyThread : public Thread {$/;"	c	namespace:__anon37	file:
Delay	tests\profile-handler_unittest.cc	/^void Delay(int delay_ns) {$/;"	f	namespace:__anon37
DoRun	tests\profile-handler_unittest.cc	/^  static void* DoRun(void* cls) {$/;"	f	class:__anon37::Thread	file:
GetCallbackCount	tests\profile-handler_unittest.cc	/^  uint32 GetCallbackCount() {$/;"	f	class:__anon37::ProfileHandlerTest
GetInterruptCount	tests\profile-handler_unittest.cc	/^  uint64 GetInterruptCount() {$/;"	f	class:__anon37::ProfileHandlerTest
IsTimerEnabled	tests\profile-handler_unittest.cc	/^bool IsTimerEnabled() {$/;"	f	namespace:__anon37
Join	tests\profile-handler_unittest.cc	/^  void Join()  {$/;"	f	class:__anon37::Thread
NullThread	tests\profile-handler_unittest.cc	/^class NullThread : public Thread {$/;"	c	namespace:__anon37	file:
ProfileHandlerTest	tests\profile-handler_unittest.cc	/^class ProfileHandlerTest {$/;"	c	namespace:__anon37	file:
RUN	tests\profile-handler_unittest.cc	289;"	d	file:
RUN_ALL_TESTS	tests\profile-handler_unittest.cc	/^  static int RUN_ALL_TESTS() {$/;"	f	class:__anon37::ProfileHandlerTest
RegisterCallback	tests\profile-handler_unittest.cc	/^  ProfileHandlerToken* RegisterCallback(void* callback_arg) {$/;"	f	class:__anon37::ProfileHandlerTest
Run	tests\profile-handler_unittest.cc	/^  void Run() {$/;"	f	class:__anon37::BusyThread	file:
Run	tests\profile-handler_unittest.cc	/^  void Run() {$/;"	f	class:__anon37::NullThread	file:
SetJoinable	tests\profile-handler_unittest.cc	/^  void SetJoinable(bool value) { joinable_ = value; }$/;"	f	class:__anon37::Thread
SetUp	tests\profile-handler_unittest.cc	/^  virtual void SetUp() {$/;"	f	class:__anon37::ProfileHandlerTest
SetUpTestCase	tests\profile-handler_unittest.cc	/^  static void SetUpTestCase() {$/;"	f	class:__anon37::ProfileHandlerTest
Start	tests\profile-handler_unittest.cc	/^  void Start() {$/;"	f	class:__anon37::Thread
StartWorker	tests\profile-handler_unittest.cc	/^  void StartWorker() {$/;"	f	class:__anon37::ProfileHandlerTest
StopWorker	tests\profile-handler_unittest.cc	/^  void StopWorker() {$/;"	f	class:__anon37::ProfileHandlerTest
TEST_F	tests\profile-handler_unittest.cc	/^TEST_F(ProfileHandlerTest, MultipleCallbacks) {$/;"	f	namespace:__anon37
TEST_F	tests\profile-handler_unittest.cc	/^TEST_F(ProfileHandlerTest, RegisterCallbackBeforeThread) {$/;"	f	namespace:__anon37
TEST_F	tests\profile-handler_unittest.cc	/^TEST_F(ProfileHandlerTest, RegisterUnregisterCallback) {$/;"	f	namespace:__anon37
TEST_F	tests\profile-handler_unittest.cc	/^TEST_F(ProfileHandlerTest, Reset) {$/;"	f	namespace:__anon37
TEST_F	tests\profile-handler_unittest.cc	23;"	d	file:
TearDown	tests\profile-handler_unittest.cc	/^  virtual void TearDown() {$/;"	f	class:__anon37::ProfileHandlerTest
Thread	tests\profile-handler_unittest.cc	/^  Thread() : joinable_(false) { }$/;"	f	class:__anon37::Thread
Thread	tests\profile-handler_unittest.cc	/^class Thread {$/;"	c	namespace:__anon37	file:
TickCounter	tests\profile-handler_unittest.cc	/^static void TickCounter(int sig, siginfo_t* sig_info, void *vuc,$/;"	f	namespace:__anon37
UnregisterCallback	tests\profile-handler_unittest.cc	/^  void UnregisterCallback(ProfileHandlerToken* token) {$/;"	f	class:__anon37::ProfileHandlerTest
VerifyDisabled	tests\profile-handler_unittest.cc	/^  void VerifyDisabled() {$/;"	f	class:__anon37::ProfileHandlerTest
VerifyRegistration	tests\profile-handler_unittest.cc	/^  void VerifyRegistration(const int& tick_counter) {$/;"	f	class:__anon37::ProfileHandlerTest
VerifyUnregistration	tests\profile-handler_unittest.cc	/^  void VerifyUnregistration(const int& tick_counter) {$/;"	f	class:__anon37::ProfileHandlerTest
busy_worker_	tests\profile-handler_unittest.cc	/^  BusyThread* busy_worker_;$/;"	m	class:__anon37::ProfileHandlerTest	file:
joinable_	tests\profile-handler_unittest.cc	/^  bool joinable_;$/;"	m	class:__anon37::Thread	file:
kSleepInterval	tests\profile-handler_unittest.cc	/^int kSleepInterval = 200000000;$/;"	m	namespace:__anon37	file:
kTimerResetInterval	tests\profile-handler_unittest.cc	/^int kTimerResetInterval = 5000000;$/;"	m	namespace:__anon37	file:
linux_per_thread_timers_mode_	tests\profile-handler_unittest.cc	/^static bool linux_per_thread_timers_mode_ = false;$/;"	m	namespace:__anon37	file:
main	tests\profile-handler_unittest.cc	/^int main(int argc, char** argv) {$/;"	f
mu_	tests\profile-handler_unittest.cc	/^  Mutex mu_;$/;"	m	class:__anon37::BusyThread	file:
set_stop_work	tests\profile-handler_unittest.cc	/^  void set_stop_work(bool stop_work) {$/;"	f	class:__anon37::BusyThread
stop_work	tests\profile-handler_unittest.cc	/^  bool stop_work() {$/;"	f	class:__anon37::BusyThread
stop_work_	tests\profile-handler_unittest.cc	/^  bool stop_work_;$/;"	m	class:__anon37::BusyThread	file:
thread_	tests\profile-handler_unittest.cc	/^  pthread_t thread_;$/;"	m	class:__anon37::Thread	file:
timer_type_	tests\profile-handler_unittest.cc	/^static int timer_type_ = ITIMER_PROF;$/;"	m	namespace:__anon37	file:
~Thread	tests\profile-handler_unittest.cc	/^  virtual ~Thread() { }$/;"	f	class:__anon37::Thread
Check	tests\profiledata_unittest.cc	/^  string Check(const ProfileDataSlot* slots, int num_slots) {$/;"	f	class:__anon38::ProfileDataChecker
CheckWithSkips	tests\profiledata_unittest.cc	/^string ProfileDataChecker::CheckWithSkips(const ProfileDataSlot* slots,$/;"	f	class:__anon38::ProfileDataChecker
ExpectRunningSamples	tests\profiledata_unittest.cc	/^  void ExpectRunningSamples(int samples) {$/;"	f	class:__anon38::ProfileDataTest
ExpectSameState	tests\profiledata_unittest.cc	/^  void ExpectSameState(const ProfileData::State& before,$/;"	f	class:__anon38::ProfileDataTest
ExpectStopped	tests\profiledata_unittest.cc	/^  void ExpectStopped() {$/;"	f	class:__anon38::ProfileDataTest
FileDescriptor	tests\profiledata_unittest.cc	/^  explicit FileDescriptor(int fd) : fd_(fd) {}$/;"	f	struct:__anon38::FileDescriptor
FileDescriptor	tests\profiledata_unittest.cc	/^struct FileDescriptor {$/;"	s	namespace:__anon38	file:
NO_INTR	tests\profiledata_unittest.cc	70;"	d	file:
ProfileDataChecker	tests\profiledata_unittest.cc	/^  ProfileDataChecker() {$/;"	f	class:__anon38::ProfileDataChecker
ProfileDataChecker	tests\profiledata_unittest.cc	/^class ProfileDataChecker {$/;"	c	namespace:__anon38	file:
ProfileDataSlot	tests\profiledata_unittest.cc	/^typedef uintptr_t ProfileDataSlot;$/;"	t	namespace:__anon38	file:
ProfileDataTest	tests\profiledata_unittest.cc	/^class ProfileDataTest {$/;"	c	namespace:__anon38	file:
RUN	tests\profiledata_unittest.cc	354;"	d	file:
RUN_ALL_TESTS	tests\profiledata_unittest.cc	/^  static int RUN_ALL_TESTS() {$/;"	f	class:__anon38::ProfileDataTest
ReadPersistent	tests\profiledata_unittest.cc	/^static ssize_t ReadPersistent(const int fd, void *buf, const size_t count) {$/;"	f	namespace:__anon38
TEST_F	tests\profiledata_unittest.cc	/^TEST_F(ProfileDataTest, CollectOne) {$/;"	f	namespace:__anon38
TEST_F	tests\profiledata_unittest.cc	/^TEST_F(ProfileDataTest, CollectTwoFlush) {$/;"	f	namespace:__anon38
TEST_F	tests\profiledata_unittest.cc	/^TEST_F(ProfileDataTest, CollectTwoMatching) {$/;"	f	namespace:__anon38
TEST_F	tests\profiledata_unittest.cc	/^TEST_F(ProfileDataTest, OpsWhenStopped) {$/;"	f	namespace:__anon38
TEST_F	tests\profiledata_unittest.cc	/^TEST_F(ProfileDataTest, StartResetRestart) {$/;"	f	namespace:__anon38
TEST_F	tests\profiledata_unittest.cc	/^TEST_F(ProfileDataTest, StartStopEmpty) {$/;"	f	namespace:__anon38
TEST_F	tests\profiledata_unittest.cc	/^TEST_F(ProfileDataTest, StartStopEmpty2) {$/;"	f	namespace:__anon38
TEST_F	tests\profiledata_unittest.cc	/^TEST_F(ProfileDataTest, StartStopNoOptionsEmpty) {$/;"	f	namespace:__anon38
TEST_F	tests\profiledata_unittest.cc	/^TEST_F(ProfileDataTest, StartWhenStarted) {$/;"	f	namespace:__anon38
TEST_F	tests\profiledata_unittest.cc	55;"	d	file:
V	tests\profiledata_unittest.cc	/^inline void* V(intptr_t x) { return reinterpret_cast<void*>(x); }$/;"	f	namespace:__anon38
ValidateProfile	tests\profiledata_unittest.cc	/^string ProfileDataChecker::ValidateProfile() {$/;"	f	class:__anon38::ProfileDataChecker
checker_	tests\profiledata_unittest.cc	/^  ProfileDataChecker checker_;$/;"	m	class:__anon38::ProfileDataTest	file:
collector_	tests\profiledata_unittest.cc	/^  ProfileData        collector_;$/;"	m	class:__anon38::ProfileDataTest	file:
data_	tests\profiledata_unittest.cc	/^  T* const data_;$/;"	m	class:__anon38::scoped_array	file:
fd_	tests\profiledata_unittest.cc	/^  const int fd_;$/;"	m	struct:__anon38::FileDescriptor	file:
filename	tests\profiledata_unittest.cc	/^  string filename() const { return filename_; }$/;"	f	class:__anon38::ProfileDataChecker
filename_	tests\profiledata_unittest.cc	/^  string filename_;$/;"	m	class:__anon38::ProfileDataChecker	file:
get	tests\profiledata_unittest.cc	/^  T* get() { return data_; }$/;"	f	class:__anon38::scoped_array
get	tests\profiledata_unittest.cc	/^  int get() { return fd_; }$/;"	f	struct:__anon38::FileDescriptor
kNoError	tests\profiledata_unittest.cc	/^const char kNoError[] = "";$/;"	m	namespace:__anon38	file:
main	tests\profiledata_unittest.cc	/^int main(int argc, char** argv) {$/;"	f
operator []	tests\profiledata_unittest.cc	/^  T& operator[](int i) { return data_[i]; }$/;"	f	class:__anon38::scoped_array
scoped_array	tests\profiledata_unittest.cc	/^  scoped_array(T* data) : data_(data) { }$/;"	f	class:__anon38::scoped_array
scoped_array	tests\profiledata_unittest.cc	/^template<typename T> class scoped_array {$/;"	c	namespace:__anon38	file:
~FileDescriptor	tests\profiledata_unittest.cc	/^  ~FileDescriptor() {$/;"	f	struct:__anon38::FileDescriptor
~scoped_array	tests\profiledata_unittest.cc	/^  ~scoped_array() { delete[] data_; }$/;"	f	class:__anon38::scoped_array
g_iters	tests\profiler_unittest.cc	/^static int g_iters = 0;   \/\/ argv[1]$/;"	v	file:
main	tests\profiler_unittest.cc	/^int main(int argc, char** argv) {$/;"	f
result	tests\profiler_unittest.cc	/^static volatile int result = 0;$/;"	v	file:
test_main_thread	tests\profiler_unittest.cc	/^static void test_main_thread() {$/;"	f	file:
test_other_thread	tests\profiler_unittest.cc	/^static void test_other_thread() {$/;"	f	file:
Realname	tests\profiler_unittest.sh	/^Realname() {$/;"	f
RegisterFailure	tests\profiler_unittest.sh	/^RegisterFailure() {$/;"	f
VerifyAcrossThreads	tests\profiler_unittest.sh	/^VerifyAcrossThreads() {$/;"	f
VerifyIdentical	tests\profiler_unittest.sh	/^VerifyIdentical() {$/;"	f
VerifySimilar	tests\profiler_unittest.sh	/^VerifySimilar() {$/;"	f
RUN_TEST	tests\raw_printer_test.cc	16;"	d	file:
TEST	tests\raw_printer_test.cc	/^TEST(RawPrinter, Empty) {$/;"	f
TEST	tests\raw_printer_test.cc	/^TEST(RawPrinter, ExactlyFilled) {$/;"	f
TEST	tests\raw_printer_test.cc	/^TEST(RawPrinter, PartiallyFilled) {$/;"	f
TEST	tests\raw_printer_test.cc	/^TEST(RawPrinter, Truncated) {$/;"	f
TEST	tests\raw_printer_test.cc	15;"	d	file:
main	tests\raw_printer_test.cc	/^int main(int argc, char **argv) {$/;"	f
Fill	tests\realloc_unittest.cc	/^static void Fill(unsigned char* buffer, int n) {$/;"	f	file:
NextSize	tests\realloc_unittest.cc	/^static int NextSize(int size) {$/;"	f	file:
Valid	tests\realloc_unittest.cc	/^static bool Valid(unsigned char* buffer, int n) {$/;"	f	file:
main	tests\realloc_unittest.cc	/^int main(int argc, char** argv) {$/;"	f
ADCDF	tests\sampler_test.cc	/^void ADCDF() {$/;"	f
ADTestTest	tests\sampler_test.cc	/^void ADTestTest(int n) {$/;"	f
AndersonDarlingErrFix	tests\sampler_test.cc	/^double AndersonDarlingErrFix(int n, double x) {$/;"	f
AndersonDarlingInf	tests\sampler_test.cc	/^double AndersonDarlingInf(double z) {$/;"	f
AndersonDarlingPValue	tests\sampler_test.cc	/^double AndersonDarlingPValue(int n, double z) {$/;"	f
AndersonDarlingStatistic	tests\sampler_test.cc	/^double AndersonDarlingStatistic(int n, double* random_sample) {$/;"	f
AndersonDarlingTest	tests\sampler_test.cc	/^double AndersonDarlingTest(int n, double* random_sample) {$/;"	f
CheckMean	tests\sampler_test.cc	/^bool CheckMean(size_t mean, int num_samples) {$/;"	f
Cleanup	tests\sampler_test.cc	/^  void Cleanup() {}$/;"	f	class:OldSampler
FLAGS_mock_tcmalloc_sample_parameter	tests\sampler_test.cc	/^const int64 FLAGS_mock_tcmalloc_sample_parameter = 1<<19;$/;"	v
Init	tests\sampler_test.cc	/^void OldSampler::Init(uint32_t seed) {$/;"	f	class:OldSampler
InitStatics	tests\sampler_test.cc	/^  static void InitStatics() {$/;"	f	class:OldSampler
LOG	tests\sampler_test.cc	82;"	d	file:
LOG	tests\sampler_test.cc	85;"	d	file:
OldSampler	tests\sampler_test.cc	/^class OldSampler {$/;"	c	file:
OutputSequence	tests\sampler_test.cc	/^void OutputSequence(int sequence_length) {$/;"	f
PickNextSample	tests\sampler_test.cc	/^void OldSampler::PickNextSample(size_t k) {$/;"	f	class:OldSampler
RUN_ALL_TESTS	tests\sampler_test.cc	/^static int RUN_ALL_TESTS() {$/;"	f	file:
SampleAllocation	tests\sampler_test.cc	/^inline bool OldSampler::SampleAllocation(size_t k) {$/;"	f	class:OldSampler
StandardDeviationsErrorInSample	tests\sampler_test.cc	/^double StandardDeviationsErrorInSample($/;"	f
StringPrintf	tests\sampler_test.cc	/^static std::string StringPrintf(const char* format, ...) {$/;"	f	file:
TEST	tests\sampler_test.cc	/^TEST(Sample, size_of_class) {$/;"	f
TEST	tests\sampler_test.cc	/^TEST(Sampler, FastLog2) {$/;"	f
TEST	tests\sampler_test.cc	/^TEST(Sampler, IsMeanRight) {$/;"	f
TEST	tests\sampler_test.cc	/^TEST(Sampler, LargeAndSmallAllocs_CombinedTest) {$/;"	f
TEST	tests\sampler_test.cc	/^TEST(Sampler, NextRand_range) {$/;"	f
TEST	tests\sampler_test.cc	/^TEST(Sampler, TestGetSamplePeriod) {$/;"	f
TEST	tests\sampler_test.cc	/^TEST(Sampler, TestNextRandom_MultipleValues) {$/;"	f
TEST	tests\sampler_test.cc	/^TEST(Sampler, TestPickNextSample_MultipleValues) {$/;"	f
TEST	tests\sampler_test.cc	/^TEST(Sampler, arithmetic_1) {$/;"	f
TEST	tests\sampler_test.cc	/^TEST(Sampler, arithmetic_2) {$/;"	f
TEST	tests\sampler_test.cc	/^TEST(Sampler, bytes_until_sample_Overflow_Underflow) {$/;"	f
TEST	tests\sampler_test.cc	64;"	d	file:
TestLRand64Spread	tests\sampler_test.cc	/^void TestLRand64Spread() {$/;"	f
TestNextRandom	tests\sampler_test.cc	/^void TestNextRandom(int n) {$/;"	f
TestPickNextSample	tests\sampler_test.cc	/^void TestPickNextSample(int n) {$/;"	f
bytes_until_sample_	tests\sampler_test.cc	/^  size_t bytes_until_sample_;$/;"	m	class:OldSampler	file:
get	tests\sampler_test.cc	/^  T* get() { return p_; }$/;"	f	class:__anon39::scoped_array
get	tests\sampler_test.cc	/^  const T* get() const { return p_; }$/;"	f	class:__anon39::scoped_array
kSamplingInterval	tests\sampler_test.cc	/^static const size_t kSamplingInterval = 512*1024;$/;"	v	file:
kSigmas	tests\sampler_test.cc	/^static const double kSigmas = 4;$/;"	v	file:
main	tests\sampler_test.cc	/^int main(int argc, char **argv) {$/;"	f
operator []	tests\sampler_test.cc	/^  T& operator[](int i) { return p_[i]; }$/;"	f	class:__anon39::scoped_array
p_	tests\sampler_test.cc	/^  T* p_;$/;"	m	class:__anon39::scoped_array	file:
rnd_	tests\sampler_test.cc	/^  uint32_t rnd_;                   \/\/ Cheap random number generator$/;"	m	class:OldSampler	file:
sample_period	tests\sampler_test.cc	/^  static uint64_t sample_period;$/;"	m	class:OldSampler	file:
sample_period	tests\sampler_test.cc	/^uint64_t OldSampler::sample_period;$/;"	m	class:OldSampler	file:
scoped_array	tests\sampler_test.cc	/^  scoped_array(T* p) : p_(p) { }$/;"	f	class:__anon39::scoped_array
scoped_array	tests\sampler_test.cc	/^template<typename T> class scoped_array {$/;"	c	namespace:__anon39	file:
tcmalloc_sample_parameter	tests\sampler_test.cc	/^DECLARE_int64(tcmalloc_sample_parameter);$/;"	v
test_arithmetic	tests\sampler_test.cc	/^void test_arithmetic(uint64_t rnd) {$/;"	f
~scoped_array	tests\sampler_test.cc	/^  ~scoped_array() { delete[] p_; }$/;"	f	class:__anon39::scoped_array
AllocateAllocate	tests\sampling_test.cc	/^extern "C" void* AllocateAllocate() {$/;"	f
WriteStringToFile	tests\sampling_test.cc	/^static void WriteStringToFile(const string& s, const string& filename) {$/;"	f	file:
main	tests\sampling_test.cc	/^int main(int argc, char** argv) {$/;"	f
die	tests\sampling_test.sh	/^die() {    # runs the command given as arguments, and then dies.$/;"	f
heap_checker_h	tests\simple_compat_test.cc	/^HeapLeakChecker::Disabler* heap_checker_h;$/;"	v
heap_profiler_h	tests\simple_compat_test.cc	/^void (*heap_profiler_h)(const char*) = &HeapProfilerStart;$/;"	v
main	tests\simple_compat_test.cc	/^int main(int argc, char** argv) {$/;"	f
malloc_extension_c_h	tests\simple_compat_test.cc	/^MallocExtension_Ownership malloc_extension_c_h;$/;"	v
malloc_extension_h	tests\simple_compat_test.cc	/^MallocExtension::Ownership malloc_extension_h;$/;"	v
malloc_hook_c_h	tests\simple_compat_test.cc	/^MallocHook_NewHook* malloc_hook_c_h;$/;"	v
malloc_hook_h	tests\simple_compat_test.cc	/^MallocHook::NewHook* malloc_hook_h;$/;"	v
profiler_h	tests\simple_compat_test.cc	/^ProfilerOptions* profiler_h;$/;"	v
stacktrace_h	tests\simple_compat_test.cc	/^int (*stacktrace_h)(void**, int, int) = &GetStackTrace;$/;"	v
tcmalloc_h	tests\simple_compat_test.cc	/^void* (*tcmalloc_h)(size_t) = &tc_new;$/;"	v
ARRAYSIZE	tests\stack_trace_table_test.cc	16;"	d	file:
ARRAYSIZE	tests\stack_trace_table_test.cc	17;"	d	file:
AddTrace	tests\stack_trace_table_test.cc	/^static void AddTrace(tcmalloc::StackTraceTable* table,$/;"	f	file:
CheckTracesAndReset	tests\stack_trace_table_test.cc	/^static void CheckTracesAndReset(tcmalloc::StackTraceTable* table,$/;"	f	file:
main	tests\stack_trace_table_test.cc	/^int main(int argc, char **argv) {$/;"	f
ADJUST_ADDRESS_RANGE_FROM_RA	tests\stacktrace_unittest.cc	77;"	d	file:
ADJUST_ADDRESS_RANGE_FROM_RA	tests\stacktrace_unittest.cc	96;"	d	file:
AddressRange	tests\stacktrace_unittest.cc	/^struct AddressRange {$/;"	s	namespace:__anon40	file:
BACKTRACE_STEPS	tests\stacktrace_unittest.cc	/^const int BACKTRACE_STEPS = 6;$/;"	m	namespace:__anon40	file:
CheckRetAddrIsInFunction	tests\stacktrace_unittest.cc	/^void CheckRetAddrIsInFunction(void *ret_addr, const AddressRange &range)$/;"	f	namespace:__anon40
CheckStackTrace	tests\stacktrace_unittest.cc	/^void ATTRIBUTE_NOINLINE CheckStackTrace(int i) {$/;"	f	namespace:__anon40
CheckStackTrace1	tests\stacktrace_unittest.cc	/^void ATTRIBUTE_NOINLINE CheckStackTrace1(int i) {$/;"	f	namespace:__anon40
CheckStackTrace2	tests\stacktrace_unittest.cc	/^void ATTRIBUTE_NOINLINE CheckStackTrace2(int i) {$/;"	f	namespace:__anon40
CheckStackTrace3	tests\stacktrace_unittest.cc	/^void ATTRIBUTE_NOINLINE CheckStackTrace3(int i) {$/;"	f	namespace:__anon40
CheckStackTrace4	tests\stacktrace_unittest.cc	/^void ATTRIBUTE_NOINLINE CheckStackTrace4(int i) {$/;"	f	namespace:__anon40
CheckStackTraceLeaf	tests\stacktrace_unittest.cc	/^void ATTRIBUTE_NOINLINE CheckStackTraceLeaf(void) {$/;"	f	namespace:__anon40
DECLARE_ADDRESS_LABEL	tests\stacktrace_unittest.cc	71;"	d	file:
DECLARE_ADDRESS_LABEL	tests\stacktrace_unittest.cc	95;"	d	file:
INIT_ADDRESS_RANGE	tests\stacktrace_unittest.cc	60;"	d	file:
INIT_ADDRESS_RANGE	tests\stacktrace_unittest.cc	90;"	d	file:
end	tests\stacktrace_unittest.cc	/^  const void *start, *end;$/;"	m	struct:__anon40::AddressRange	file:
expected_range	tests\stacktrace_unittest.cc	/^AddressRange expected_range[BACKTRACE_STEPS];$/;"	m	namespace:__anon40	file:
main	tests\stacktrace_unittest.cc	/^int main(int argc, char ** argv) {$/;"	f
start	tests\stacktrace_unittest.cc	/^  const void *start, *end;$/;"	m	struct:__anon40::AddressRange	file:
Alloc	tests\system-alloc_unittest.cc	/^  void* Alloc(size_t size, size_t *actual_size, size_t alignment) {$/;"	f	class:ArraySysAllocator
ArraySysAllocator	tests\system-alloc_unittest.cc	/^  ArraySysAllocator() : SysAllocator() {$/;"	f	class:ArraySysAllocator
ArraySysAllocator	tests\system-alloc_unittest.cc	/^class ArraySysAllocator : public SysAllocator {$/;"	c	file:
DumpStats	tests\system-alloc_unittest.cc	/^  void DumpStats() {$/;"	f	class:ArraySysAllocator
TestBasicInvoked	tests\system-alloc_unittest.cc	/^static void TestBasicInvoked() {$/;"	f	file:
TestBasicRetryFailTest	tests\system-alloc_unittest.cc	/^static void TestBasicRetryFailTest() {$/;"	f	file:
a	tests\system-alloc_unittest.cc	/^ArraySysAllocator a;$/;"	v
array_	tests\system-alloc_unittest.cc	/^  char array_[kArraySize];$/;"	m	class:ArraySysAllocator	file:
invoked_	tests\system-alloc_unittest.cc	/^  bool invoked_;$/;"	m	class:ArraySysAllocator	file:
kArraySize	tests\system-alloc_unittest.cc	/^  static const int kArraySize = 8 * 1024 * 1024;$/;"	m	class:ArraySysAllocator	file:
kArraySize	tests\system-alloc_unittest.cc	/^const int ArraySysAllocator::kArraySize;$/;"	m	class:ArraySysAllocator	file:
main	tests\system-alloc_unittest.cc	/^int main(int argc, char** argv) {$/;"	f
ptr_	tests\system-alloc_unittest.cc	/^  int ptr_;$/;"	m	class:ArraySysAllocator	file:
TryAllocExpectFail	tests\tcmalloc_large_unittest.cc	/^void TryAllocExpectFail(size_t size) {$/;"	f
TryAllocMightFail	tests\tcmalloc_large_unittest.cc	/^void TryAllocMightFail(size_t size) {$/;"	f
main	tests\tcmalloc_large_unittest.cc	/^int main (int argc, char** argv) {$/;"	f
ACMRandom	tests\tcmalloc_unittest.cc	/^    explicit ACMRandom(int32 seed) { seed_ = seed; }$/;"	f	class:testing::TesterThread::ACMRandom
ACMRandom	tests\tcmalloc_unittest.cc	/^  class ACMRandom {$/;"	c	class:testing::TesterThread	file:
ALLOC	tests\tcmalloc_unittest.cc	/^  enum Type { ALLOC, FREE, UPDATE, PASS };$/;"	e	enum:testing::TesterThread::Type	file:
AcquirePassedObjects	tests\tcmalloc_unittest.cc	/^  void AcquirePassedObjects() {$/;"	f	class:testing::TesterThread
AddType	tests\tcmalloc_unittest.cc	/^void TestHarness::AddType(int type, int weight, const char* name) {$/;"	f	class:testing::TestHarness
AggressiveDecommitChanger	tests\tcmalloc_unittest.cc	/^  AggressiveDecommitChanger(size_t new_value) {$/;"	f	class:testing::AggressiveDecommitChanger
AggressiveDecommitChanger	tests\tcmalloc_unittest.cc	/^class AggressiveDecommitChanger {$/;"	c	namespace:testing	file:
AllocateObject	tests\tcmalloc_unittest.cc	/^  void AllocateObject() {$/;"	f	class:testing::TesterThread
AllocatorState	tests\tcmalloc_unittest.cc	/^  explicit AllocatorState(int seed) : TestHarness(seed), memalign_fraction_(0) {$/;"	f	class:testing::AllocatorState
AllocatorState	tests\tcmalloc_unittest.cc	/^class AllocatorState : public TestHarness {$/;"	c	namespace:testing	file:
CheckContents	tests\tcmalloc_unittest.cc	/^  void CheckContents(const Object& object) {$/;"	f	class:testing::TesterThread
CheckRangeCallback	tests\tcmalloc_unittest.cc	/^static void CheckRangeCallback(void* ptr, base::MallocRange::Type type,$/;"	f	namespace:testing::__anon41
DeleteHeap	tests\tcmalloc_unittest.cc	/^  void DeleteHeap() {$/;"	f	class:testing::TesterThread
FLAGS_allocweight	tests\tcmalloc_unittest.cc	/^static const int FLAGS_allocweight = 50;    \/\/ Weight for picking allocation$/;"	m	namespace:testing	file:
FLAGS_freeweight	tests\tcmalloc_unittest.cc	/^static const int FLAGS_freeweight = 50;     \/\/ Weight for picking free$/;"	m	namespace:testing	file:
FLAGS_lg_max_memalign	tests\tcmalloc_unittest.cc	/^static const int FLAGS_lg_max_memalign = 18; \/\/ lg of max alignment for memalign$/;"	m	namespace:testing	file:
FLAGS_lgmaxsize	tests\tcmalloc_unittest.cc	/^static const int FLAGS_lgmaxsize = 16;   \/\/ lg() of the max size object to alloc$/;"	m	namespace:testing	file:
FLAGS_log_every_n_tests	tests\tcmalloc_unittest.cc	/^static const int FLAGS_log_every_n_tests = 50000; \/\/ log exactly once$/;"	m	namespace:testing	file:
FLAGS_memalign_max_alignment_ratio	tests\tcmalloc_unittest.cc	/^static const double FLAGS_memalign_max_alignment_ratio = 6;  \/\/ alignment\/size$/;"	m	namespace:testing	file:
FLAGS_memalign_max_fraction	tests\tcmalloc_unittest.cc	/^static const double FLAGS_memalign_max_fraction = 0.4;  \/\/ max expected%$/;"	m	namespace:testing	file:
FLAGS_memalign_min_fraction	tests\tcmalloc_unittest.cc	/^static const double FLAGS_memalign_min_fraction = 0;    \/\/ min expected%$/;"	m	namespace:testing	file:
FLAGS_numtests	tests\tcmalloc_unittest.cc	/^static const int FLAGS_numtests = 50000;$/;"	m	namespace:testing	file:
FLAGS_numthreads	tests\tcmalloc_unittest.cc	/^static const int FLAGS_numthreads = 10;  \/\/ Number of threads$/;"	m	namespace:testing	file:
FLAGS_passweight	tests\tcmalloc_unittest.cc	/^static const int FLAGS_passweight = 1;      \/\/ Weight for passing object$/;"	m	namespace:testing	file:
FLAGS_threadmb	tests\tcmalloc_unittest.cc	/^static const int FLAGS_threadmb = 4;     \/\/ Max memory size allocated by thread$/;"	m	namespace:testing	file:
FLAGS_updateweight	tests\tcmalloc_unittest.cc	/^static const int FLAGS_updateweight = 10;   \/\/ Weight for picking update$/;"	m	namespace:testing	file:
FREE	tests\tcmalloc_unittest.cc	/^  enum Type { ALLOC, FREE, UPDATE, PASS };$/;"	e	enum:testing::TesterThread::Type	file:
FillContents	tests\tcmalloc_unittest.cc	/^  void FillContents(Object* object) {$/;"	f	class:testing::TesterThread
FreeObject	tests\tcmalloc_unittest.cc	/^  void FreeObject() {$/;"	f	class:testing::TesterThread
GetUnmappedBytes	tests\tcmalloc_unittest.cc	/^static size_t GetUnmappedBytes() {$/;"	f	namespace:testing
HaveSystemRelease	tests\tcmalloc_unittest.cc	/^static bool HaveSystemRelease =$/;"	m	namespace:testing	file:
LOGSTREAM	tests\tcmalloc_unittest.cc	152;"	d	file:
MAKE_HOOK_CALLBACK	tests\tcmalloc_unittest.cc	728;"	d	file:
MAP_ANONYMOUS	tests\tcmalloc_unittest.cc	149;"	d	file:
Memalign	tests\tcmalloc_unittest.cc	/^static inline void* Memalign(size_t align, size_t size) {$/;"	f	file:
Next	tests\tcmalloc_unittest.cc	/^    int32 Next() {$/;"	f	class:testing::TesterThread::ACMRandom
Object	tests\tcmalloc_unittest.cc	/^  struct Object {$/;"	s	class:testing::TesterThread	file:
OnNoMemory	tests\tcmalloc_unittest.cc	/^static void OnNoMemory() {$/;"	f	namespace:testing
PASS	tests\tcmalloc_unittest.cc	/^  enum Type { ALLOC, FREE, UPDATE, PASS };$/;"	e	enum:testing::TesterThread::Type	file:
PassObject	tests\tcmalloc_unittest.cc	/^  void PassObject() {$/;"	f	class:testing::TesterThread
PickType	tests\tcmalloc_unittest.cc	/^int TestHarness::PickType() {$/;"	f	class:testing::TestHarness
PosixMemalign	tests\tcmalloc_unittest.cc	/^static inline int PosixMemalign(void** ptr, size_t align, size_t size) {$/;"	f	file:
RangeCallback	tests\tcmalloc_unittest.cc	/^static void RangeCallback(void* arg, const base::MallocRange* r) {$/;"	f	namespace:testing::__anon41
RangeCallbackState	tests\tcmalloc_unittest.cc	/^struct RangeCallbackState {$/;"	s	namespace:testing::__anon41	file:
Run	tests\tcmalloc_unittest.cc	/^  virtual void Run() {$/;"	f	class:testing::TesterThread
RunAllTests	tests\tcmalloc_unittest.cc	/^static int RunAllTests(int argc, char** argv) {$/;"	f	namespace:testing
RunThread	tests\tcmalloc_unittest.cc	/^static void RunThread(int thread_id) {$/;"	f	namespace:testing
ShrinkHeap	tests\tcmalloc_unittest.cc	/^  void ShrinkHeap() {$/;"	f	class:testing::TesterThread
Skewed	tests\tcmalloc_unittest.cc	/^  int Skewed(int max_log) {$/;"	f	class:testing::TestHarness
TestAggressiveDecommit	tests\tcmalloc_unittest.cc	/^static void TestAggressiveDecommit() {$/;"	f	namespace:testing
TestAlignmentForSize	tests\tcmalloc_unittest.cc	/^static void TestAlignmentForSize(int size) {$/;"	f	namespace:testing
TestCalloc	tests\tcmalloc_unittest.cc	/^static void TestCalloc(size_t n, size_t s, bool ok) {$/;"	f	namespace:testing
TestErrno	tests\tcmalloc_unittest.cc	/^static void TestErrno(void) {$/;"	f	namespace:testing
TestHarness	tests\tcmalloc_unittest.cc	/^  TestHarness(int seed)$/;"	f	class:testing::TestHarness
TestHarness	tests\tcmalloc_unittest.cc	/^class TestHarness {$/;"	c	namespace:testing	file:
TestHugeAllocations	tests\tcmalloc_unittest.cc	/^static void TestHugeAllocations(AllocatorState* rnd) {$/;"	f	namespace:testing
TestHugeThreadCache	tests\tcmalloc_unittest.cc	/^static void TestHugeThreadCache() {$/;"	f	namespace:testing
TestMallocAlignment	tests\tcmalloc_unittest.cc	/^static void TestMallocAlignment() {$/;"	f	namespace:testing
TestNew	tests\tcmalloc_unittest.cc	/^static void TestNew(void* (*func)(size_t)) {$/;"	f	namespace:testing
TestNewHandler	tests\tcmalloc_unittest.cc	/^static void TestNewHandler() throw (std::bad_alloc) {$/;"	f	namespace:testing
TestNothrowNew	tests\tcmalloc_unittest.cc	/^static void TestNothrowNew(void* (*func)(size_t, const std::nothrow_t&)) {$/;"	f	namespace:testing
TestOneNew	tests\tcmalloc_unittest.cc	/^static void TestOneNew(void* (*func)(size_t)) {$/;"	f	namespace:testing
TestOneNothrowNew	tests\tcmalloc_unittest.cc	/^static void TestOneNothrowNew(void* (*func)(size_t, const std::nothrow_t&)) {$/;"	f	namespace:testing
TestRanges	tests\tcmalloc_unittest.cc	/^static void TestRanges() {$/;"	f	namespace:testing
TestRealloc	tests\tcmalloc_unittest.cc	/^static void TestRealloc() {$/;"	f	namespace:testing
TestReleaseToSystem	tests\tcmalloc_unittest.cc	/^static void TestReleaseToSystem() {$/;"	f	namespace:testing
TestSetNewMode	tests\tcmalloc_unittest.cc	/^static void TestSetNewMode() {$/;"	f	namespace:testing
TesterThread	tests\tcmalloc_unittest.cc	/^  TesterThread(int id)$/;"	f	class:testing::TesterThread
TesterThread	tests\tcmalloc_unittest.cc	/^class TesterThread {$/;"	c	namespace:testing	file:
TryHugeAllocation	tests\tcmalloc_unittest.cc	/^static void TryHugeAllocation(size_t s, AllocatorState* rnd) {$/;"	f	namespace:testing
Type	tests\tcmalloc_unittest.cc	/^  enum Type { ALLOC, FREE, UPDATE, PASS };$/;"	g	class:testing::TesterThread	file:
Type	tests\tcmalloc_unittest.cc	/^  struct Type {$/;"	s	class:testing::TestHarness	file:
UPDATE	tests\tcmalloc_unittest.cc	/^  enum Type { ALLOC, FREE, UPDATE, PASS };$/;"	e	enum:testing::TesterThread::Type	file:
Uniform	tests\tcmalloc_unittest.cc	/^  int Uniform(int n) {$/;"	f	class:testing::TestHarness
UpdateObject	tests\tcmalloc_unittest.cc	/^  void UpdateObject() {$/;"	f	class:testing::TesterThread
alloc	tests\tcmalloc_unittest.cc	/^  void* alloc(size_t size) {$/;"	f	class:testing::AllocatorState
cfree	tests\tcmalloc_unittest.cc	102;"	d	file:
expected_type	tests\tcmalloc_unittest.cc	/^  base::MallocRange::Type expected_type;$/;"	m	struct:testing::__anon41::RangeCallbackState	file:
g_no_memory	tests\tcmalloc_unittest.cc	/^volatile bool g_no_memory = false;$/;"	m	namespace:testing	file:
g_old_handler	tests\tcmalloc_unittest.cc	/^std::new_handler g_old_handler = NULL;$/;"	m	namespace:testing	file:
generation	tests\tcmalloc_unittest.cc	/^    int         generation;             \/\/ Generation counter of object contents$/;"	m	struct:testing::TesterThread::Object	file:
heap_	tests\tcmalloc_unittest.cc	/^  vector<Object>        heap_;          \/\/ This thread's heap$/;"	m	class:testing::TesterThread	file:
heap_size_	tests\tcmalloc_unittest.cc	/^  size_t                heap_size_;     \/\/ Current heap size$/;"	m	class:testing::TesterThread	file:
id_	tests\tcmalloc_unittest.cc	/^  int                   id_;            \/\/ My thread id$/;"	m	class:testing::TesterThread	file:
kMaxSignedSize	tests\tcmalloc_unittest.cc	/^static const size_t kMaxSignedSize = ((size_t(1) << (kSizeBits-1)) - 1);$/;"	m	namespace:testing	file:
kMaxSize	tests\tcmalloc_unittest.cc	/^static const size_t kMaxSize = ~static_cast<size_t>(0);$/;"	m	namespace:testing	file:
kNotTooBig	tests\tcmalloc_unittest.cc	/^static const size_t kNotTooBig = 100000;$/;"	m	namespace:testing	file:
kOSSupportsMemalign	tests\tcmalloc_unittest.cc	/^static bool kOSSupportsMemalign = false;$/;"	v	file:
kOSSupportsMemalign	tests\tcmalloc_unittest.cc	/^static bool kOSSupportsMemalign = true;$/;"	v	file:
kSizeBits	tests\tcmalloc_unittest.cc	/^static const int kSizeBits = 8 * sizeof(size_t);$/;"	m	namespace:testing	file:
kTooBig	tests\tcmalloc_unittest.cc	/^static const size_t kTooBig = kMaxSize - 100000;$/;"	m	namespace:testing	file:
lock_	tests\tcmalloc_unittest.cc	/^  Mutex                 lock_;          \/\/ For passing in another thread's obj$/;"	m	class:testing::TesterThread	file:
locks_failed_	tests\tcmalloc_unittest.cc	/^  int                   locks_failed_;  \/\/ Number of failed TryLock() ops$/;"	m	class:testing::TesterThread	file:
locks_ok_	tests\tcmalloc_unittest.cc	/^  int                   locks_ok_;      \/\/ Number of OK TryLock() ops$/;"	m	class:testing::TesterThread	file:
main	tests\tcmalloc_unittest.cc	/^int main(int argc, char** argv) {$/;"	f
matched	tests\tcmalloc_unittest.cc	/^  bool matched;$/;"	m	struct:testing::__anon41::RangeCallbackState	file:
max_free_queue_size	tests\tcmalloc_unittest.cc	/^DECLARE_int32(max_free_queue_size);     \/\/ in debugallocation.cc$/;"	v
memalign_fraction_	tests\tcmalloc_unittest.cc	/^  double memalign_fraction_;$/;"	m	class:testing::AllocatorState	file:
min_size	tests\tcmalloc_unittest.cc	/^  size_t min_size;$/;"	m	struct:testing::__anon41::RangeCallbackState	file:
name	tests\tcmalloc_unittest.cc	/^    string      name;$/;"	m	struct:testing::TestHarness::Type	file:
news_handled	tests\tcmalloc_unittest.cc	/^static int news_handled = 0;$/;"	m	namespace:testing	file:
num_tests_	tests\tcmalloc_unittest.cc	/^  int                   num_tests_;     \/\/ Num tests run so far$/;"	m	class:testing::TestHarness	file:
old_value_	tests\tcmalloc_unittest.cc	/^  size_t old_value_;$/;"	m	class:testing::AggressiveDecommitChanger	file:
passed_	tests\tcmalloc_unittest.cc	/^  vector<Object>        passed_;        \/\/ Pending objects passed from others$/;"	m	class:testing::TesterThread	file:
ptr	tests\tcmalloc_unittest.cc	/^    char*       ptr;                    \/\/ Allocated pointer$/;"	m	struct:testing::TesterThread::Object	file:
ptr	tests\tcmalloc_unittest.cc	/^  uintptr_t ptr;$/;"	m	struct:testing::__anon41::RangeCallbackState	file:
pvalloc	tests\tcmalloc_unittest.cc	104;"	d	file:
rnd_	tests\tcmalloc_unittest.cc	/^  AllocatorState        rnd_;           \/\/ For generating random numbers$/;"	m	class:testing::TesterThread	file:
seed_	tests\tcmalloc_unittest.cc	/^    int32 seed_;$/;"	m	class:testing::TesterThread::ACMRandom	file:
size	tests\tcmalloc_unittest.cc	/^    int         size;                   \/\/ Allocated size$/;"	m	struct:testing::TesterThread::Object	file:
tcmalloc_sample_parameter	tests\tcmalloc_unittest.cc	/^DECLARE_int64(tcmalloc_sample_parameter);$/;"	v
testing	tests\tcmalloc_unittest.cc	/^namespace testing {$/;"	n	file:
threads	tests\tcmalloc_unittest.cc	/^static TesterThread** threads;$/;"	m	namespace:testing	file:
total_weight_	tests\tcmalloc_unittest.cc	/^  int                   total_weight_;  \/\/ Total weight of all types$/;"	m	class:testing::TestHarness	file:
type	tests\tcmalloc_unittest.cc	/^    int         type;$/;"	m	struct:testing::TestHarness::Type	file:
types_	tests\tcmalloc_unittest.cc	/^  vector<Type>*         types_;         \/\/ Registered types$/;"	m	class:testing::TestHarness	file:
valloc	tests\tcmalloc_unittest.cc	103;"	d	file:
weight	tests\tcmalloc_unittest.cc	/^    int         weight;$/;"	m	struct:testing::TestHarness::Type	file:
~AggressiveDecommitChanger	tests\tcmalloc_unittest.cc	/^  ~AggressiveDecommitChanger() {$/;"	f	class:testing::AggressiveDecommitChanger
~AllocatorState	tests\tcmalloc_unittest.cc	/^  virtual ~AllocatorState() {}$/;"	f	class:testing::AllocatorState
~TestHarness	tests\tcmalloc_unittest.cc	/^  ~TestHarness() {$/;"	f	class:testing::TestHarness
~TesterThread	tests\tcmalloc_unittest.cc	/^  virtual ~TesterThread() {$/;"	f	class:testing::TesterThread
run_check_transfer_num_obj	tests\tcmalloc_unittest.sh	/^run_check_transfer_num_obj() {$/;"	f
run_unittest	tests\tcmalloc_unittest.sh	/^run_unittest() {$/;"	f
FunctionAndId	tests\testutil.cc	/^struct FunctionAndId {$/;"	s	file:
RunFunctionInThread	tests\testutil.cc	/^  DWORD WINAPI RunFunctionInThread(LPVOID ptr_to_ptr_to_fn) {$/;"	f
RunFunctionInThread	tests\testutil.cc	/^  static void* RunFunctionInThread(void *ptr_to_ptr_to_fn) {$/;"	f	file:
RunFunctionInThreadWithId	tests\testutil.cc	/^  DWORD WINAPI RunFunctionInThreadWithId(LPVOID ptr_to_fnid) {$/;"	f
RunFunctionInThreadWithId	tests\testutil.cc	/^  static void* RunFunctionInThreadWithId(void *ptr_to_fnid) {$/;"	f	file:
RunManyThreads	tests\testutil.cc	/^  void RunManyThreads(void (*fn)(), int count) {$/;"	f
RunManyThreads	tests\testutil.cc	/^extern "C" void RunManyThreads(void (*fn)(), int count) {$/;"	f
RunManyThreadsWithId	tests\testutil.cc	/^  void RunManyThreadsWithId(void (*fn)(int), int count, int stacksize) {$/;"	f
RunManyThreadsWithId	tests\testutil.cc	/^extern "C" void RunManyThreadsWithId(void (*fn)(int), int count, int) {$/;"	f
RunThread	tests\testutil.cc	/^  void RunThread(void (*fn)()) {$/;"	f
RunThread	tests\testutil.cc	/^extern "C" void RunThread(void (*fn)()) {$/;"	f
SAFE_PTHREAD	tests\testutil.cc	163;"	d	file:
SetTestResourceLimit	tests\testutil.cc	/^void SetTestResourceLimit() {$/;"	f
USE_RESOURCE	tests\testutil.cc	59;"	d	file:
WIN32_LEAN_AND_MEAN	tests\testutil.cc	104;"	d	file:
id	tests\testutil.cc	/^  int id;$/;"	m	struct:FunctionAndId	file:
ptr_to_function	tests\testutil.cc	/^  void (*ptr_to_function)(int);$/;"	m	struct:FunctionAndId	file:
TCMALLOC_TOOLS_TESTUTIL_H_	tests\testutil.h	35;"	d
AllocStuff	tests\thread_dealloc_unittest.cc	/^static void AllocStuff() {$/;"	f	file:
kNumObjects	tests\thread_dealloc_unittest.cc	/^static const int kNumObjects = 1024;$/;"	v	file:
kNumThreads	tests\thread_dealloc_unittest.cc	/^static const int kNumThreads = 1000;$/;"	v	file:
kObjectSize	tests\thread_dealloc_unittest.cc	/^static const int kObjectSize = 1024;$/;"	v	file:
main	tests\thread_dealloc_unittest.cc	/^int main(int argc, char** argv) {$/;"	f
CALL_FN_W_10W	third_party\valgrind.h	1322;"	d
CALL_FN_W_10W	third_party\valgrind.h	1765;"	d
CALL_FN_W_10W	third_party\valgrind.h	2271;"	d
CALL_FN_W_10W	third_party\valgrind.h	2826;"	d
CALL_FN_W_10W	third_party\valgrind.h	3387;"	d
CALL_FN_W_10W	third_party\valgrind.h	888;"	d
CALL_FN_W_11W	third_party\valgrind.h	1362;"	d
CALL_FN_W_11W	third_party\valgrind.h	1811;"	d
CALL_FN_W_11W	third_party\valgrind.h	2323;"	d
CALL_FN_W_11W	third_party\valgrind.h	2880;"	d
CALL_FN_W_11W	third_party\valgrind.h	3441;"	d
CALL_FN_W_11W	third_party\valgrind.h	926;"	d
CALL_FN_W_12W	third_party\valgrind.h	1404;"	d
CALL_FN_W_12W	third_party\valgrind.h	1861;"	d
CALL_FN_W_12W	third_party\valgrind.h	2379;"	d
CALL_FN_W_12W	third_party\valgrind.h	2938;"	d
CALL_FN_W_12W	third_party\valgrind.h	3499;"	d
CALL_FN_W_12W	third_party\valgrind.h	967;"	d
CALL_FN_W_5W	third_party\valgrind.h	1156;"	d
CALL_FN_W_5W	third_party\valgrind.h	1597;"	d
CALL_FN_W_5W	third_party\valgrind.h	2073;"	d
CALL_FN_W_5W	third_party\valgrind.h	2618;"	d
CALL_FN_W_5W	third_party\valgrind.h	3179;"	d
CALL_FN_W_5W	third_party\valgrind.h	730;"	d
CALL_FN_W_6W	third_party\valgrind.h	1184;"	d
CALL_FN_W_6W	third_party\valgrind.h	1625;"	d
CALL_FN_W_6W	third_party\valgrind.h	2107;"	d
CALL_FN_W_6W	third_party\valgrind.h	2654;"	d
CALL_FN_W_6W	third_party\valgrind.h	3215;"	d
CALL_FN_W_6W	third_party\valgrind.h	757;"	d
CALL_FN_W_7W	third_party\valgrind.h	1214;"	d
CALL_FN_W_7W	third_party\valgrind.h	1655;"	d
CALL_FN_W_7W	third_party\valgrind.h	2143;"	d
CALL_FN_W_7W	third_party\valgrind.h	2692;"	d
CALL_FN_W_7W	third_party\valgrind.h	3253;"	d
CALL_FN_W_7W	third_party\valgrind.h	786;"	d
CALL_FN_W_8W	third_party\valgrind.h	1248;"	d
CALL_FN_W_8W	third_party\valgrind.h	1688;"	d
CALL_FN_W_8W	third_party\valgrind.h	2182;"	d
CALL_FN_W_8W	third_party\valgrind.h	2733;"	d
CALL_FN_W_8W	third_party\valgrind.h	3294;"	d
CALL_FN_W_8W	third_party\valgrind.h	818;"	d
CALL_FN_W_9W	third_party\valgrind.h	1284;"	d
CALL_FN_W_9W	third_party\valgrind.h	1723;"	d
CALL_FN_W_9W	third_party\valgrind.h	2223;"	d
CALL_FN_W_9W	third_party\valgrind.h	2776;"	d
CALL_FN_W_9W	third_party\valgrind.h	3337;"	d
CALL_FN_W_9W	third_party\valgrind.h	852;"	d
CALL_FN_W_W	third_party\valgrind.h	1064;"	d
CALL_FN_W_W	third_party\valgrind.h	1505;"	d
CALL_FN_W_W	third_party\valgrind.h	1957;"	d
CALL_FN_W_W	third_party\valgrind.h	2494;"	d
CALL_FN_W_W	third_party\valgrind.h	3055;"	d
CALL_FN_W_W	third_party\valgrind.h	642;"	d
CALL_FN_W_WW	third_party\valgrind.h	1084;"	d
CALL_FN_W_WW	third_party\valgrind.h	1525;"	d
CALL_FN_W_WW	third_party\valgrind.h	1983;"	d
CALL_FN_W_WW	third_party\valgrind.h	2522;"	d
CALL_FN_W_WW	third_party\valgrind.h	3083;"	d
CALL_FN_W_WW	third_party\valgrind.h	661;"	d
CALL_FN_W_WWW	third_party\valgrind.h	1106;"	d
CALL_FN_W_WWW	third_party\valgrind.h	1547;"	d
CALL_FN_W_WWW	third_party\valgrind.h	2011;"	d
CALL_FN_W_WWW	third_party\valgrind.h	2552;"	d
CALL_FN_W_WWW	third_party\valgrind.h	3113;"	d
CALL_FN_W_WWW	third_party\valgrind.h	682;"	d
CALL_FN_W_WWWW	third_party\valgrind.h	1130;"	d
CALL_FN_W_WWWW	third_party\valgrind.h	1571;"	d
CALL_FN_W_WWWW	third_party\valgrind.h	2041;"	d
CALL_FN_W_WWWW	third_party\valgrind.h	2584;"	d
CALL_FN_W_WWWW	third_party\valgrind.h	3145;"	d
CALL_FN_W_WWWW	third_party\valgrind.h	705;"	d
CALL_FN_W_v	third_party\valgrind.h	1046;"	d
CALL_FN_W_v	third_party\valgrind.h	1487;"	d
CALL_FN_W_v	third_party\valgrind.h	1933;"	d
CALL_FN_W_v	third_party\valgrind.h	2468;"	d
CALL_FN_W_v	third_party\valgrind.h	3029;"	d
CALL_FN_W_v	third_party\valgrind.h	626;"	d
CALL_FN_v_W	third_party\valgrind.h	603;"	d
CALL_FN_v_WW	third_party\valgrind.h	607;"	d
CALL_FN_v_WWW	third_party\valgrind.h	611;"	d
CALL_FN_v_v	third_party\valgrind.h	599;"	d
I_WRAP_SONAME_FNNAME_ZU	third_party\valgrind.h	584;"	d
I_WRAP_SONAME_FNNAME_ZZ	third_party\valgrind.h	587;"	d
NVALGRIND	third_party\valgrind.h	116;"	d
OrigFn	third_party\valgrind.h	/^   OrigFn;$/;"	t	typeref:struct:__anon42
OrigFn	third_party\valgrind.h	/^   OrigFn;$/;"	t	typeref:struct:__anon43
OrigFn	third_party\valgrind.h	/^   OrigFn;$/;"	t	typeref:struct:__anon44
OrigFn	third_party\valgrind.h	/^   OrigFn;$/;"	t	typeref:struct:__anon45
OrigFn	third_party\valgrind.h	/^   OrigFn;$/;"	t	typeref:struct:__anon46
OrigFn	third_party\valgrind.h	/^   OrigFn;$/;"	t	typeref:struct:__anon47
PLAT_amd64_linux	third_party\valgrind.h	3918;"	d
PLAT_amd64_linux	third_party\valgrind.h	89;"	d
PLAT_amd64_linux	third_party\valgrind.h	98;"	d
PLAT_ppc32_aix5	third_party\valgrind.h	106;"	d
PLAT_ppc32_aix5	third_party\valgrind.h	3921;"	d
PLAT_ppc32_aix5	third_party\valgrind.h	92;"	d
PLAT_ppc32_linux	third_party\valgrind.h	100;"	d
PLAT_ppc32_linux	third_party\valgrind.h	3919;"	d
PLAT_ppc32_linux	third_party\valgrind.h	90;"	d
PLAT_ppc64_aix5	third_party\valgrind.h	104;"	d
PLAT_ppc64_aix5	third_party\valgrind.h	3922;"	d
PLAT_ppc64_aix5	third_party\valgrind.h	93;"	d
PLAT_ppc64_linux	third_party\valgrind.h	102;"	d
PLAT_ppc64_linux	third_party\valgrind.h	3920;"	d
PLAT_ppc64_linux	third_party\valgrind.h	91;"	d
PLAT_x86_linux	third_party\valgrind.h	3917;"	d
PLAT_x86_linux	third_party\valgrind.h	88;"	d
PLAT_x86_linux	third_party\valgrind.h	96;"	d
RUNNING_ON_VALGRIND	third_party\valgrind.h	3639;"	d
VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R11	third_party\valgrind.h	337;"	d
VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R11	third_party\valgrind.h	402;"	d
VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R11	third_party\valgrind.h	474;"	d
VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R11	third_party\valgrind.h	546;"	d
VALGRIND_CALL_NOREDIR_EAX	third_party\valgrind.h	223;"	d
VALGRIND_CALL_NOREDIR_RAX	third_party\valgrind.h	277;"	d
VALGRIND_COUNT_ERRORS	third_party\valgrind.h	3773;"	d
VALGRIND_CREATE_MEMPOOL	third_party\valgrind.h	3826;"	d
VALGRIND_DESTROY_MEMPOOL	third_party\valgrind.h	3834;"	d
VALGRIND_DISCARD_TRANSLATIONS	third_party\valgrind.h	3652;"	d
VALGRIND_DO_CLIENT_REQUEST	third_party\valgrind.h	131;"	d
VALGRIND_DO_CLIENT_REQUEST	third_party\valgrind.h	189;"	d
VALGRIND_DO_CLIENT_REQUEST	third_party\valgrind.h	243;"	d
VALGRIND_DO_CLIENT_REQUEST	third_party\valgrind.h	297;"	d
VALGRIND_DO_CLIENT_REQUEST	third_party\valgrind.h	358;"	d
VALGRIND_DO_CLIENT_REQUEST	third_party\valgrind.h	424;"	d
VALGRIND_DO_CLIENT_REQUEST	third_party\valgrind.h	496;"	d
VALGRIND_FREELIKE_BLOCK	third_party\valgrind.h	3818;"	d
VALGRIND_GET_NR_CONTEXT	third_party\valgrind.h	210;"	d
VALGRIND_GET_NR_CONTEXT	third_party\valgrind.h	264;"	d
VALGRIND_GET_NR_CONTEXT	third_party\valgrind.h	323;"	d
VALGRIND_GET_NR_CONTEXT	third_party\valgrind.h	381;"	d
VALGRIND_GET_NR_CONTEXT	third_party\valgrind.h	451;"	d
VALGRIND_GET_NR_CONTEXT	third_party\valgrind.h	523;"	d
VALGRIND_GET_ORIG_FN	third_party\valgrind.h	594;"	d
VALGRIND_MALLOCLIKE_BLOCK	third_party\valgrind.h	3807;"	d
VALGRIND_MEMPOOL_ALLOC	third_party\valgrind.h	3842;"	d
VALGRIND_MEMPOOL_CHANGE	third_party\valgrind.h	3874;"	d
VALGRIND_MEMPOOL_EXISTS	third_party\valgrind.h	3882;"	d
VALGRIND_MEMPOOL_FREE	third_party\valgrind.h	3850;"	d
VALGRIND_MEMPOOL_TRIM	third_party\valgrind.h	3858;"	d
VALGRIND_MOVE_MEMPOOL	third_party\valgrind.h	3866;"	d
VALGRIND_NON_SIMD_CALL0	third_party\valgrind.h	3728;"	d
VALGRIND_NON_SIMD_CALL1	third_party\valgrind.h	3738;"	d
VALGRIND_NON_SIMD_CALL2	third_party\valgrind.h	3748;"	d
VALGRIND_NON_SIMD_CALL3	third_party\valgrind.h	3758;"	d
VALGRIND_PRINTF	third_party\valgrind.h	/^VALGRIND_PRINTF(const char *format, ...)$/;"	f
VALGRIND_PRINTF	third_party\valgrind.h	3665;"	d
VALGRIND_PRINTF_BACKTRACE	third_party\valgrind.h	/^VALGRIND_PRINTF_BACKTRACE(const char *format, ...)$/;"	f
VALGRIND_PRINTF_BACKTRACE	third_party\valgrind.h	3666;"	d
VALGRIND_STACK_CHANGE	third_party\valgrind.h	3909;"	d
VALGRIND_STACK_DEREGISTER	third_party\valgrind.h	3901;"	d
VALGRIND_STACK_REGISTER	third_party\valgrind.h	3891;"	d
VG_CONTRACT_FRAME_BY	third_party\valgrind.h	2462;"	d
VG_CONTRACT_FRAME_BY	third_party\valgrind.h	3023;"	d
VG_EXPAND_FRAME_BY_trashes_r3	third_party\valgrind.h	2457;"	d
VG_EXPAND_FRAME_BY_trashes_r3	third_party\valgrind.h	3018;"	d
VG_IS_TOOL_USERREQ	third_party\valgrind.h	3581;"	d
VG_USERREQ_TOOL_BASE	third_party\valgrind.h	3579;"	d
VG_USERREQ__CLIENT_CALL0	third_party\valgrind.h	/^          VG_USERREQ__CLIENT_CALL0 = 0x1101,$/;"	e	enum:__anon48
VG_USERREQ__CLIENT_CALL1	third_party\valgrind.h	/^          VG_USERREQ__CLIENT_CALL1 = 0x1102,$/;"	e	enum:__anon48
VG_USERREQ__CLIENT_CALL2	third_party\valgrind.h	/^          VG_USERREQ__CLIENT_CALL2 = 0x1103,$/;"	e	enum:__anon48
VG_USERREQ__CLIENT_CALL3	third_party\valgrind.h	/^          VG_USERREQ__CLIENT_CALL3 = 0x1104,$/;"	e	enum:__anon48
VG_USERREQ__COUNT_ERRORS	third_party\valgrind.h	/^          VG_USERREQ__COUNT_ERRORS = 0x1201,$/;"	e	enum:__anon48
VG_USERREQ__CREATE_MEMPOOL	third_party\valgrind.h	/^          VG_USERREQ__CREATE_MEMPOOL   = 0x1303,$/;"	e	enum:__anon48
VG_USERREQ__DESTROY_MEMPOOL	third_party\valgrind.h	/^          VG_USERREQ__DESTROY_MEMPOOL  = 0x1304,$/;"	e	enum:__anon48
VG_USERREQ__DISCARD_TRANSLATIONS	third_party\valgrind.h	/^          VG_USERREQ__DISCARD_TRANSLATIONS = 0x1002,$/;"	e	enum:__anon48
VG_USERREQ__FREELIKE_BLOCK	third_party\valgrind.h	/^          VG_USERREQ__FREELIKE_BLOCK   = 0x1302,$/;"	e	enum:__anon48
VG_USERREQ__MALLOCLIKE_BLOCK	third_party\valgrind.h	/^          VG_USERREQ__MALLOCLIKE_BLOCK = 0x1301,$/;"	e	enum:__anon48
VG_USERREQ__MEMPOOL_ALLOC	third_party\valgrind.h	/^          VG_USERREQ__MEMPOOL_ALLOC    = 0x1305,$/;"	e	enum:__anon48
VG_USERREQ__MEMPOOL_CHANGE	third_party\valgrind.h	/^          VG_USERREQ__MEMPOOL_CHANGE   = 0x1309,$/;"	e	enum:__anon48
VG_USERREQ__MEMPOOL_EXISTS	third_party\valgrind.h	/^          VG_USERREQ__MEMPOOL_EXISTS   = 0x130a,$/;"	e	enum:__anon48
VG_USERREQ__MEMPOOL_FREE	third_party\valgrind.h	/^          VG_USERREQ__MEMPOOL_FREE     = 0x1306,$/;"	e	enum:__anon48
VG_USERREQ__MEMPOOL_TRIM	third_party\valgrind.h	/^          VG_USERREQ__MEMPOOL_TRIM     = 0x1307,$/;"	e	enum:__anon48
VG_USERREQ__MOVE_MEMPOOL	third_party\valgrind.h	/^          VG_USERREQ__MOVE_MEMPOOL     = 0x1308,$/;"	e	enum:__anon48
VG_USERREQ__PRINTF	third_party\valgrind.h	/^          VG_USERREQ__PRINTF           = 0x1401,$/;"	e	enum:__anon48
VG_USERREQ__PRINTF_BACKTRACE	third_party\valgrind.h	/^          VG_USERREQ__PRINTF_BACKTRACE = 0x1402,$/;"	e	enum:__anon48
VG_USERREQ__RUNNING_ON_VALGRIND	third_party\valgrind.h	/^   enum { VG_USERREQ__RUNNING_ON_VALGRIND  = 0x1001,$/;"	e	enum:__anon48
VG_USERREQ__STACK_CHANGE	third_party\valgrind.h	/^          VG_USERREQ__STACK_CHANGE     = 0x1503$/;"	e	enum:__anon48
VG_USERREQ__STACK_DEREGISTER	third_party\valgrind.h	/^          VG_USERREQ__STACK_DEREGISTER = 0x1502,$/;"	e	enum:__anon48
VG_USERREQ__STACK_REGISTER	third_party\valgrind.h	/^          VG_USERREQ__STACK_REGISTER   = 0x1501,$/;"	e	enum:__anon48
Vg_ClientRequest	third_party\valgrind.h	/^   } Vg_ClientRequest;$/;"	t	typeref:enum:__anon48
__CALLER_SAVED_REGS	third_party\valgrind.h	1019;"	d
__CALLER_SAVED_REGS	third_party\valgrind.h	1478;"	d
__CALLER_SAVED_REGS	third_party\valgrind.h	1924;"	d
__CALLER_SAVED_REGS	third_party\valgrind.h	2448;"	d
__CALLER_SAVED_REGS	third_party\valgrind.h	3009;"	d
__CALLER_SAVED_REGS	third_party\valgrind.h	621;"	d
__SPECIAL_INSTRUCTION_PREAMBLE	third_party\valgrind.h	185;"	d
__SPECIAL_INSTRUCTION_PREAMBLE	third_party\valgrind.h	239;"	d
__SPECIAL_INSTRUCTION_PREAMBLE	third_party\valgrind.h	293;"	d
__SPECIAL_INSTRUCTION_PREAMBLE	third_party\valgrind.h	354;"	d
__SPECIAL_INSTRUCTION_PREAMBLE	third_party\valgrind.h	420;"	d
__SPECIAL_INSTRUCTION_PREAMBLE	third_party\valgrind.h	492;"	d
__VALGRIND_H	third_party\valgrind.h	74;"	d
__extension__	third_party\valgrind.h	3632;"	d
nraddr	third_party\valgrind.h	/^      unsigned int nraddr; \/* where's the code? *\/$/;"	m	struct:__anon42
nraddr	third_party\valgrind.h	/^      unsigned int nraddr; \/* where's the code? *\/$/;"	m	struct:__anon44
nraddr	third_party\valgrind.h	/^      unsigned int nraddr; \/* where's the code? *\/$/;"	m	struct:__anon46
nraddr	third_party\valgrind.h	/^      unsigned long long int nraddr; \/* where's the code? *\/$/;"	m	struct:__anon43
nraddr	third_party\valgrind.h	/^      unsigned long long int nraddr; \/* where's the code? *\/$/;"	m	struct:__anon45
nraddr	third_party\valgrind.h	/^      unsigned long long int nraddr; \/* where's the code? *\/$/;"	m	struct:__anon47
r2	third_party\valgrind.h	/^      unsigned int r2;  \/* what tocptr do we need? *\/$/;"	m	struct:__anon46
r2	third_party\valgrind.h	/^      unsigned long long int r2;  \/* what tocptr do we need? *\/$/;"	m	struct:__anon45
r2	third_party\valgrind.h	/^      unsigned long long int r2;  \/* what tocptr do we need? *\/$/;"	m	struct:__anon47
ATTR_INITIAL_EXEC	thread_cache.cc	/^    ATTR_INITIAL_EXEC$/;"	m	namespace:tcmalloc	file:
BecomeIdle	thread_cache.cc	/^void ThreadCache::BecomeIdle() {$/;"	f	class:tcmalloc::ThreadCache
BecomeTemporarilyIdle	thread_cache.cc	/^void ThreadCache::BecomeTemporarilyIdle() {$/;"	f	class:tcmalloc::ThreadCache
Cleanup	thread_cache.cc	/^void ThreadCache::Cleanup() {$/;"	f	class:tcmalloc::ThreadCache
CreateCacheIfNecessary	thread_cache.cc	/^ThreadCache* ThreadCache::CreateCacheIfNecessary() {$/;"	f	class:tcmalloc::ThreadCache
DeleteCache	thread_cache.cc	/^void ThreadCache::DeleteCache(ThreadCache* heap) {$/;"	f	class:tcmalloc::ThreadCache
DestroyThreadCache	thread_cache.cc	/^void ThreadCache::DestroyThreadCache(void* ptr) {$/;"	f	class:tcmalloc::ThreadCache
FetchFromCentralCache	thread_cache.cc	/^void* ThreadCache::FetchFromCentralCache(size_t cl, size_t byte_size) {$/;"	f	class:tcmalloc::ThreadCache
GetSamplePeriod	thread_cache.cc	/^int ThreadCache::GetSamplePeriod() {$/;"	f	class:tcmalloc::ThreadCache
GetThreadStats	thread_cache.cc	/^void ThreadCache::GetThreadStats(uint64_t* total_bytes, uint64_t* class_count) {$/;"	f	class:tcmalloc::ThreadCache
IncreaseCacheLimit	thread_cache.cc	/^void ThreadCache::IncreaseCacheLimit() {$/;"	f	class:tcmalloc::ThreadCache
IncreaseCacheLimitLocked	thread_cache.cc	/^void ThreadCache::IncreaseCacheLimitLocked() {$/;"	f	class:tcmalloc::ThreadCache
Init	thread_cache.cc	/^void ThreadCache::Init(pthread_t tid) {$/;"	f	class:tcmalloc::ThreadCache
InitModule	thread_cache.cc	/^void ThreadCache::InitModule() {$/;"	f	class:tcmalloc::ThreadCache
InitTSD	thread_cache.cc	/^void ThreadCache::InitTSD() {$/;"	f	class:tcmalloc::ThreadCache
ListTooLong	thread_cache.cc	/^void ThreadCache::ListTooLong(FreeList* list, size_t cl) {$/;"	f	class:tcmalloc::ThreadCache
NewHeap	thread_cache.cc	/^ThreadCache* ThreadCache::NewHeap(pthread_t tid) {$/;"	f	class:tcmalloc::ThreadCache
RecomputePerThreadCacheSize	thread_cache.cc	/^void ThreadCache::RecomputePerThreadCacheSize() {$/;"	f	class:tcmalloc::ThreadCache
ReleaseToCentralCache	thread_cache.cc	/^void ThreadCache::ReleaseToCentralCache(FreeList* src, size_t cl, int N) {$/;"	f	class:tcmalloc::ThreadCache
Scavenge	thread_cache.cc	/^void ThreadCache::Scavenge() {$/;"	f	class:tcmalloc::ThreadCache
heap_key_	thread_cache.cc	/^pthread_key_t ThreadCache::heap_key_;$/;"	m	class:tcmalloc::ThreadCache	file:
next_memory_steal_	thread_cache.cc	/^ThreadCache* ThreadCache::next_memory_steal_ = NULL;$/;"	m	class:tcmalloc::ThreadCache	file:
overall_thread_cache_size_	thread_cache.cc	/^size_t ThreadCache::overall_thread_cache_size_ = kDefaultOverallThreadCacheSize;$/;"	m	class:tcmalloc::ThreadCache	file:
per_thread_cache_size_	thread_cache.cc	/^volatile size_t ThreadCache::per_thread_cache_size_ = kMaxThreadCacheSize;$/;"	m	class:tcmalloc::ThreadCache	file:
phinited	thread_cache.cc	/^static bool phinited = false;$/;"	m	namespace:tcmalloc	file:
set_overall_thread_cache_size	thread_cache.cc	/^void ThreadCache::set_overall_thread_cache_size(size_t new_size) {$/;"	f	class:tcmalloc::ThreadCache
tcmalloc	thread_cache.cc	/^namespace tcmalloc {$/;"	n	file:
thread_heap_count_	thread_cache.cc	/^int ThreadCache::thread_heap_count_ = 0;$/;"	m	class:tcmalloc::ThreadCache	file:
thread_heaps_	thread_cache.cc	/^ThreadCache* ThreadCache::thread_heaps_ = NULL;$/;"	m	class:tcmalloc::ThreadCache	file:
threadcache_allocator	thread_cache.cc	/^PageHeapAllocator<ThreadCache> threadcache_allocator;$/;"	m	namespace:tcmalloc	file:
tsd_inited_	thread_cache.cc	/^bool ThreadCache::tsd_inited_ = false;$/;"	m	class:tcmalloc::ThreadCache	file:
unclaimed_cache_space_	thread_cache.cc	/^ssize_t ThreadCache::unclaimed_cache_space_ = kDefaultOverallThreadCacheSize;$/;"	m	class:tcmalloc::ThreadCache	file:
ATTR_INITIAL_EXEC	thread_cache.h	/^  static __thread ThreadLocalData threadlocal_data_ ATTR_INITIAL_EXEC;$/;"	m	class:tcmalloc::ThreadCache
ATTR_INITIAL_EXEC	thread_cache.h	263;"	d
ATTR_INITIAL_EXEC	thread_cache.h	265;"	d
Allocate	thread_cache.h	/^inline void* ThreadCache::Allocate(size_t size, size_t cl) {$/;"	f	class:tcmalloc::ThreadCache
CACHELINE_ALIGNED	thread_cache.h	/^} CACHELINE_ALIGNED;$/;"	m	namespace:tcmalloc	typeref:class:tcmalloc::ThreadCache
Deallocate	thread_cache.h	/^inline void ThreadCache::Deallocate(void* ptr, size_t cl) {$/;"	f	class:tcmalloc::ThreadCache
FreeList	thread_cache.h	/^  class FreeList {$/;"	c	class:tcmalloc::ThreadCache
GetCache	thread_cache.h	/^inline ThreadCache* ThreadCache::GetCache() {$/;"	f	class:tcmalloc::ThreadCache
GetCacheIfPresent	thread_cache.h	/^inline ThreadCache* ThreadCache::GetCacheIfPresent() {$/;"	f	class:tcmalloc::ThreadCache
GetCacheWhichMustBePresent	thread_cache.h	/^inline ThreadCache* ThreadCache::GetCacheWhichMustBePresent() {$/;"	f	class:tcmalloc::ThreadCache
GetThreadHeap	thread_cache.h	/^inline ThreadCache* ThreadCache::GetThreadHeap() {$/;"	f	class:tcmalloc::ThreadCache
HeapsInUse	thread_cache.h	/^inline int ThreadCache::HeapsInUse() {$/;"	f	class:tcmalloc::ThreadCache
Init	thread_cache.h	/^    void Init() {$/;"	f	class:tcmalloc::ThreadCache::FreeList
IsFastPathAllowed	thread_cache.h	/^  static bool IsFastPathAllowed() { return MinSizeForSlowPath() != 0; }$/;"	f	class:tcmalloc::ThreadCache
IsUseEmergencyMalloc	thread_cache.h	/^inline bool ThreadCache::IsUseEmergencyMalloc() {$/;"	f	class:tcmalloc::ThreadCache
MinSizeForSlowPath	thread_cache.h	/^inline size_t ThreadCache::MinSizeForSlowPath() {$/;"	f	class:tcmalloc::ThreadCache
Next	thread_cache.h	/^    void* Next() {$/;"	f	class:tcmalloc::ThreadCache::FreeList
Pop	thread_cache.h	/^    void* Pop() {$/;"	f	class:tcmalloc::ThreadCache::FreeList
PopRange	thread_cache.h	/^    void PopRange(int N, void **start, void **end) {$/;"	f	class:tcmalloc::ThreadCache::FreeList
Push	thread_cache.h	/^    void Push(void* ptr) {$/;"	f	class:tcmalloc::ThreadCache::FreeList
PushRange	thread_cache.h	/^    void PushRange(int N, void *start, void *end) {$/;"	f	class:tcmalloc::ThreadCache::FreeList
ResetUseEmergencyMalloc	thread_cache.h	/^inline void ThreadCache::ResetUseEmergencyMalloc() {$/;"	f	class:tcmalloc::ThreadCache
SampleAllocation	thread_cache.h	/^inline bool ThreadCache::SampleAllocation(size_t k) {$/;"	f	class:tcmalloc::ThreadCache
SetMinSizeForSlowPath	thread_cache.h	/^inline void ThreadCache::SetMinSizeForSlowPath(size_t size) {$/;"	f	class:tcmalloc::ThreadCache
SetUseEmergencyMalloc	thread_cache.h	/^inline void ThreadCache::SetUseEmergencyMalloc() {$/;"	f	class:tcmalloc::ThreadCache
Size	thread_cache.h	/^  size_t Size() const { return size_; }$/;"	f	class:tcmalloc::ThreadCache
TCMALLOC_THREAD_CACHE_H_	thread_cache.h	35;"	d
ThreadCache	thread_cache.h	/^class ThreadCache {$/;"	c	namespace:tcmalloc
ThreadLocalData	thread_cache.h	/^  struct ThreadLocalData {$/;"	s	class:tcmalloc::ThreadCache
clear_lowwatermark	thread_cache.h	/^    void clear_lowwatermark() { lowater_ = length_; }$/;"	f	class:tcmalloc::ThreadCache::FreeList
empty	thread_cache.h	/^    bool empty() const {$/;"	f	class:tcmalloc::ThreadCache::FreeList
freelist_length	thread_cache.h	/^  int freelist_length(size_t cl) const { return list_[cl].length(); }$/;"	f	class:tcmalloc::ThreadCache
have_tls	thread_cache.h	/^  enum { have_tls = true };$/;"	e	enum:tcmalloc::ThreadCache::__anon49
heap	thread_cache.h	/^    ThreadCache* heap;$/;"	m	struct:tcmalloc::ThreadCache::ThreadLocalData
heap_key_	thread_cache.h	/^  static pthread_key_t heap_key_;$/;"	m	class:tcmalloc::ThreadCache
in_setspecific_	thread_cache.h	/^  bool          in_setspecific_;        \/\/ In call to pthread_setspecific?$/;"	m	class:tcmalloc::ThreadCache
length	thread_cache.h	/^    size_t length() const {$/;"	f	class:tcmalloc::ThreadCache::FreeList
length_	thread_cache.h	/^    uint16_t length_;$/;"	m	class:tcmalloc::ThreadCache::FreeList
length_	thread_cache.h	/^    uint32_t length_;      \/\/ Current length.$/;"	m	class:tcmalloc::ThreadCache::FreeList
length_overages	thread_cache.h	/^    size_t length_overages() const {$/;"	f	class:tcmalloc::ThreadCache::FreeList
length_overages_	thread_cache.h	/^    uint16_t length_overages_;$/;"	m	class:tcmalloc::ThreadCache::FreeList
length_overages_	thread_cache.h	/^    uint32_t length_overages_;$/;"	m	class:tcmalloc::ThreadCache::FreeList
list_	thread_cache.h	/^    void*    list_;       \/\/ Linked list of nodes$/;"	m	class:tcmalloc::ThreadCache::FreeList
list_	thread_cache.h	/^  FreeList      list_[kNumClasses];     \/\/ Array indexed by size-class$/;"	m	class:tcmalloc::ThreadCache
lowater_	thread_cache.h	/^    uint16_t lowater_;$/;"	m	class:tcmalloc::ThreadCache::FreeList
lowater_	thread_cache.h	/^    uint32_t lowater_;     \/\/ Low water mark for list length.$/;"	m	class:tcmalloc::ThreadCache::FreeList
lowwatermark	thread_cache.h	/^    int lowwatermark() const { return lowater_; }$/;"	f	class:tcmalloc::ThreadCache::FreeList
max_length	thread_cache.h	/^    size_t max_length() const {$/;"	f	class:tcmalloc::ThreadCache::FreeList
max_length_	thread_cache.h	/^    uint16_t max_length_;$/;"	m	class:tcmalloc::ThreadCache::FreeList
max_length_	thread_cache.h	/^    uint32_t max_length_;  \/\/ Dynamic max list length based on usage.$/;"	m	class:tcmalloc::ThreadCache::FreeList
max_size_	thread_cache.h	/^  size_t        max_size_;              \/\/ size_ > max_size_ --> Scavenge()$/;"	m	class:tcmalloc::ThreadCache
min_size_for_slow_path	thread_cache.h	/^    size_t min_size_for_slow_path;$/;"	m	struct:tcmalloc::ThreadCache::ThreadLocalData
next_	thread_cache.h	/^  ThreadCache* next_;$/;"	m	class:tcmalloc::ThreadCache
next_memory_steal_	thread_cache.h	/^  static ThreadCache* next_memory_steal_;$/;"	m	class:tcmalloc::ThreadCache
old_min_size_for_slow_path	thread_cache.h	/^    size_t old_min_size_for_slow_path;$/;"	m	struct:tcmalloc::ThreadCache::ThreadLocalData
overall_thread_cache_size	thread_cache.h	/^  static size_t overall_thread_cache_size() {$/;"	f	class:tcmalloc::ThreadCache
overall_thread_cache_size_	thread_cache.h	/^  static size_t overall_thread_cache_size_;$/;"	m	class:tcmalloc::ThreadCache
per_thread_cache_size_	thread_cache.h	/^  static volatile size_t per_thread_cache_size_;$/;"	m	class:tcmalloc::ThreadCache
prev_	thread_cache.h	/^  ThreadCache* prev_;$/;"	m	class:tcmalloc::ThreadCache
sampler_	thread_cache.h	/^  Sampler       sampler_;               \/\/ A sampler$/;"	m	class:tcmalloc::ThreadCache
set_length_overages	thread_cache.h	/^    void set_length_overages(size_t new_count) {$/;"	f	class:tcmalloc::ThreadCache::FreeList
set_max_length	thread_cache.h	/^    void set_max_length(size_t new_max) {$/;"	f	class:tcmalloc::ThreadCache::FreeList
size_	thread_cache.h	/^  size_t        size_;                  \/\/ Combined size of data$/;"	m	class:tcmalloc::ThreadCache
tcmalloc	thread_cache.h	/^namespace tcmalloc {$/;"	n
tcmalloc_sample_parameter	thread_cache.h	/^DECLARE_int64(tcmalloc_sample_parameter);$/;"	v
thread_heap_count_	thread_cache.h	/^  static int thread_heap_count_;$/;"	m	class:tcmalloc::ThreadCache
thread_heaps_	thread_cache.h	/^  static ThreadCache* thread_heaps_;$/;"	m	class:tcmalloc::ThreadCache
tid_	thread_cache.h	/^  pthread_t     tid_;                   \/\/ Which thread owns it$/;"	m	class:tcmalloc::ThreadCache
tsd_inited_	thread_cache.h	/^  static bool tsd_inited_;$/;"	m	class:tcmalloc::ThreadCache
unclaimed_cache_space_	thread_cache.h	/^  static ssize_t unclaimed_cache_space_;$/;"	m	class:tcmalloc::ThreadCache
use_emergency_malloc	thread_cache.h	/^    bool use_emergency_malloc;$/;"	m	struct:tcmalloc::ThreadCache::ThreadLocalData
SEARCH_CAP	windows\addr2line-pdb.c	48;"	d	file:
WEBSYM	windows\addr2line-pdb.c	49;"	d	file:
WIN32_LEAN_AND_MEAN	windows\addr2line-pdb.c	38;"	d	file:
_CRT_SECURE_NO_DEPRECATE	windows\addr2line-pdb.c	40;"	d	file:
_CRT_SECURE_NO_WARNINGS	windows\addr2line-pdb.c	39;"	d	file:
main	windows\addr2line-pdb.c	/^int main(int argc, char *argv[]) {$/;"	f
usage	windows\addr2line-pdb.c	/^void usage() {$/;"	f
AutoTestingHook	windows\auto_testing_hook.h	/^typedef const AutoTestingHookBase& AutoTestingHook;$/;"	t	namespace:sidestep
AutoTestingHookBase	windows\auto_testing_hook.h	/^class AutoTestingHookBase {$/;"	c	namespace:sidestep
AutoTestingHookHolder	windows\auto_testing_hook.h	/^  AutoTestingHookHolder() {}  \/\/ disallow$/;"	f	class:sidestep::AutoTestingHookHolder
AutoTestingHookHolder	windows\auto_testing_hook.h	/^  explicit AutoTestingHookHolder(AutoTestingHookBase* hook) : hook_(hook) {}$/;"	f	class:sidestep::AutoTestingHookHolder
AutoTestingHookHolder	windows\auto_testing_hook.h	/^class AutoTestingHookHolder {$/;"	c	namespace:sidestep
AutoTestingHookImpl	windows\auto_testing_hook.h	/^  AutoTestingHookImpl(T target_function, T replacement_function, bool do_it)$/;"	f	class:sidestep::AutoTestingHookImpl
AutoTestingHookImpl	windows\auto_testing_hook.h	/^class AutoTestingHookImpl : public AutoTestingHookBase {$/;"	c	namespace:sidestep
CEEE_TESTING_SIDESTEP_AUTO_TESTING_HOOK_H_	windows\auto_testing_hook.h	33;"	d
MakeTestingHook	windows\auto_testing_hook.h	/^  static AutoTestingHookImpl<T> MakeTestingHook(T target_function,$/;"	f	class:sidestep::AutoTestingHookImpl
MakeTestingHook	windows\auto_testing_hook.h	/^inline AutoTestingHookImpl<T> MakeTestingHook(T target, T replacement) {$/;"	f	namespace:sidestep
MakeTestingHook	windows\auto_testing_hook.h	/^inline AutoTestingHookImpl<T> MakeTestingHook(T target,$/;"	f	namespace:sidestep
MakeTestingHookHolder	windows\auto_testing_hook.h	/^  static AutoTestingHookImpl<T>* MakeTestingHookHolder(T target_function,$/;"	f	class:sidestep::AutoTestingHookImpl
MakeTestingHookHolder	windows\auto_testing_hook.h	/^inline AutoTestingHookImpl<T>* MakeTestingHookHolder(T target, T replacement) {$/;"	f	namespace:sidestep
SIDESTEP_CHK	windows\auto_testing_hook.h	39;"	d
SIDESTEP_EXPECT_TRUE	windows\auto_testing_hook.h	40;"	d
did_it_	windows\auto_testing_hook.h	/^  bool did_it_;  \/\/ Remember if we did it or not...$/;"	m	class:sidestep::AutoTestingHookImpl
hook_	windows\auto_testing_hook.h	/^  AutoTestingHookBase* hook_;$/;"	m	class:sidestep::AutoTestingHookHolder
original_function	windows\auto_testing_hook.h	/^  T original_function() {$/;"	f	class:sidestep::AutoTestingHookImpl
original_function_	windows\auto_testing_hook.h	/^  T original_function_;  \/\/ always valid$/;"	m	class:sidestep::AutoTestingHookImpl
replacement_function_	windows\auto_testing_hook.h	/^  T replacement_function_;  \/\/ always valid$/;"	m	class:sidestep::AutoTestingHookImpl
sidestep	windows\auto_testing_hook.h	/^namespace sidestep {$/;"	n
target_function_	windows\auto_testing_hook.h	/^  T target_function_;  \/\/ always valid$/;"	m	class:sidestep::AutoTestingHookImpl
~AutoTestingHookBase	windows\auto_testing_hook.h	/^  virtual ~AutoTestingHookBase() {}$/;"	f	class:sidestep::AutoTestingHookBase
~AutoTestingHookHolder	windows\auto_testing_hook.h	/^  ~AutoTestingHookHolder() { delete hook_; }$/;"	f	class:sidestep::AutoTestingHookHolder
~AutoTestingHookImpl	windows\auto_testing_hook.h	/^  ~AutoTestingHookImpl() {$/;"	f	class:sidestep::AutoTestingHookImpl
GOOGLE_PERFTOOLS_WINDOWS_CONFIG_H_	windows\config.h	13;"	d
GOOGLE_PERFTOOLS_WINDOWS_CONFIG_H_	windows\config.h	17;"	d
GPERFTOOLS_CONFIG_H_	windows\config.h	19;"	d
HAVE_BUILTIN_STACK_POINTER	windows\config.h	36;"	d
HAVE_CONFLICT_SIGNAL_H	windows\config.h	39;"	d
HAVE_CYGWIN_SIGNAL_H	windows\config.h	42;"	d
HAVE_DECL_CFREE	windows\config.h	46;"	d
HAVE_DECL_MEMALIGN	windows\config.h	50;"	d
HAVE_DECL_POSIX_MEMALIGN	windows\config.h	54;"	d
HAVE_DECL_PVALLOC	windows\config.h	58;"	d
HAVE_DECL_UNAME	windows\config.h	62;"	d
HAVE_DECL_VALLOC	windows\config.h	66;"	d
HAVE_DLFCN_H	windows\config.h	69;"	d
HAVE_ELF32_VERSYM	windows\config.h	72;"	d
HAVE_EXECINFO_H	windows\config.h	75;"	d
HAVE_FCNTL_H	windows\config.h	78;"	d
HAVE_FEATURES_H	windows\config.h	81;"	d
HAVE_GETEUID	windows\config.h	84;"	d
HAVE_GETPAGESIZE	windows\config.h	87;"	d
HAVE_GLOB_H	windows\config.h	90;"	d
HAVE_GRP_H	windows\config.h	93;"	d
HAVE_INTTYPES_H	windows\config.h	96;"	d
HAVE_LIBUNWIND_H	windows\config.h	99;"	d
HAVE_LINUX_PTRACE_H	windows\config.h	102;"	d
HAVE_MALLOC_H	windows\config.h	105;"	d
HAVE_MALLOC_MALLOC_H	windows\config.h	108;"	d
HAVE_MEMORY_H	windows\config.h	111;"	d
HAVE_MMAP	windows\config.h	114;"	d
HAVE_NAMESPACES	windows\config.h	117;"	d
HAVE_POLL_H	windows\config.h	120;"	d
HAVE_PROGRAM_INVOCATION_NAME	windows\config.h	123;"	d
HAVE_PTHREAD	windows\config.h	126;"	d
HAVE_PWD_H	windows\config.h	129;"	d
HAVE_SBRK	windows\config.h	132;"	d
HAVE_SCHED_H	windows\config.h	135;"	d
HAVE_SNPRINTF	windows\config.h	30;"	d
HAVE_SNPRINTF	windows\config.h	32;"	d
HAVE_STDINT_H	windows\config.h	139;"	d
HAVE_STDINT_H	windows\config.h	141;"	d
HAVE_STDLIB_H	windows\config.h	145;"	d
HAVE_STRINGS_H	windows\config.h	148;"	d
HAVE_STRING_H	windows\config.h	151;"	d
HAVE_STRUCT_MALLINFO	windows\config.h	154;"	d
HAVE_SYS_CDEFS_H	windows\config.h	157;"	d
HAVE_SYS_MALLOC_H	windows\config.h	160;"	d
HAVE_SYS_PARAM_H	windows\config.h	163;"	d
HAVE_SYS_PRCTL_H	windows\config.h	166;"	d
HAVE_SYS_RESOURCE_H	windows\config.h	169;"	d
HAVE_SYS_SOCKET_H	windows\config.h	172;"	d
HAVE_SYS_STAT_H	windows\config.h	175;"	d
HAVE_SYS_SYSCALL_H	windows\config.h	178;"	d
HAVE_SYS_TYPES_H	windows\config.h	181;"	d
HAVE_SYS_UCONTEXT_H	windows\config.h	184;"	d
HAVE_SYS_WAIT_H	windows\config.h	187;"	d
HAVE_TLS	windows\config.h	190;"	d
HAVE_UCONTEXT_H	windows\config.h	193;"	d
HAVE_UNISTD_H	windows\config.h	196;"	d
HAVE_UNWIND_H	windows\config.h	199;"	d
HAVE_VALGRIND_H	windows\config.h	202;"	d
HAVE___ATTRIBUTE__	windows\config.h	205;"	d
HAVE___ENVIRON	windows\config.h	208;"	d
HAVE___INT64	windows\config.h	211;"	d
INSTALL_PREFIX	windows\config.h	214;"	d
INT32_EQUALS_INTPTR	windows\config.h	217;"	d
LT_OBJDIR	windows\config.h	221;"	d
MALLOC_HOOK_MAYBE_VOLATILE	windows\config.h	224;"	d
NO_HEAP_CHECK	windows\config.h	315;"	d
NO_MINUS_C_MINUS_O	windows\config.h	227;"	d
PACKAGE	windows\config.h	230;"	d
PACKAGE_BUGREPORT	windows\config.h	233;"	d
PACKAGE_NAME	windows\config.h	236;"	d
PACKAGE_STRING	windows\config.h	239;"	d
PACKAGE_TARNAME	windows\config.h	242;"	d
PACKAGE_URL	windows\config.h	245;"	d
PACKAGE_VERSION	windows\config.h	248;"	d
PC_FROM_UCONTEXT	windows\config.h	251;"	d
PERFTOOLS_DLL_DECL	windows\config.h	260;"	d
PERFTOOLS_DLL_DECL_FOR_UNITTESTS	windows\config.h	261;"	d
PERFTOOLS_IS_A_DLL	windows\config.h	259;"	d
PRIdS	windows\config.h	265;"	d
PRIuS	windows\config.h	268;"	d
PRIxS	windows\config.h	271;"	d
PTHREADS_CRASHES_IF_RUN_TOO_EARLY	windows\config.h	276;"	d
PTHREAD_CREATE_JOINABLE	windows\config.h	281;"	d
STDC_HEADERS	windows\config.h	284;"	d
STL_NAMESPACE	windows\config.h	287;"	d
VERSION	windows\config.h	290;"	d
WIN32_OVERRIDE_ALLOCATORS	windows\config.h	26;"	d
_WIN32_WINNT	windows\config.h	311;"	d
__STDC_FORMAT_MACROS	windows\config.h	294;"	d
inline	windows\config.h	300;"	d
m	windows\get_mangled_names.cc	/^static char m;   \/\/ some dummy memory so new doesn't return NULL.$/;"	v	file:
operator delete	windows\get_mangled_names.cc	/^void operator delete(void* p) throw() { }$/;"	f
operator delete	windows\get_mangled_names.cc	/^void operator delete(void* p, const std::nothrow_t&) throw() { }$/;"	f
operator delete[]	windows\get_mangled_names.cc	/^void operator delete[](void* p) throw() { }$/;"	f
operator delete[]	windows\get_mangled_names.cc	/^void operator delete[](void* p, const std::nothrow_t&) throw() { }$/;"	f
operator new	windows\get_mangled_names.cc	/^void* operator new(size_t size) { return &m; }$/;"	f
operator new	windows\get_mangled_names.cc	/^void* operator new(size_t size, const std::nothrow_t&) throw() { return &m; }$/;"	f
operator new[]	windows\get_mangled_names.cc	/^void* operator new[](size_t size) { return &m; }$/;"	f
operator new[]	windows\get_mangled_names.cc	/^void* operator new[](size_t size, const std::nothrow_t&) throw() { return &m; }$/;"	f
PERFTOOLS_DLL_DECL	windows\gperftools\tcmalloc.h	133;"	d
PERFTOOLS_DLL_DECL	windows\gperftools\tcmalloc.h	60;"	d
PERFTOOLS_DLL_DECL	windows\gperftools\tcmalloc.h	62;"	d
PERFTOOLS_DLL_DECL_DEFINED	windows\gperftools\tcmalloc.h	134;"	d
PERFTOOLS_DLL_DECL_DEFINED	windows\gperftools\tcmalloc.h	58;"	d
PERFTOOLS_THROW	windows\gperftools\tcmalloc.h	130;"	d
PERFTOOLS_THROW	windows\gperftools\tcmalloc.h	48;"	d
PERFTOOLS_THROW	windows\gperftools\tcmalloc.h	51;"	d
PERFTOOLS_THROW	windows\gperftools\tcmalloc.h	53;"	d
TCMALLOC_TCMALLOC_H_	windows\gperftools\tcmalloc.h	37;"	d
TC_VERSION_MAJOR	windows\gperftools\tcmalloc.h	42;"	d
TC_VERSION_MINOR	windows\gperftools\tcmalloc.h	43;"	d
TC_VERSION_PATCH	windows\gperftools\tcmalloc.h	44;"	d
TC_VERSION_STRING	windows\gperftools\tcmalloc.h	45;"	d
std	windows\gperftools\tcmalloc.h	/^namespace std {$/;"	n
s_ia16_modrm_map_	windows\ia32_modrm_map.cc	/^const ModrmEntry MiniDisassembler::s_ia16_modrm_map_[] = {$/;"	m	class:sidestep::MiniDisassembler	file:
s_ia32_modrm_map_	windows\ia32_modrm_map.cc	/^const ModrmEntry MiniDisassembler::s_ia32_modrm_map_[] = {$/;"	m	class:sidestep::MiniDisassembler	file:
sidestep	windows\ia32_modrm_map.cc	/^namespace sidestep {$/;"	n	file:
s_first_opcode_byte	windows\ia32_opcode_map.cc	/^const Opcode s_first_opcode_byte[] = {$/;"	m	namespace:sidestep	file:
s_ia32_opcode_map_	windows\ia32_opcode_map.cc	/^const OpcodeTable MiniDisassembler::s_ia32_opcode_map_[]={$/;"	m	class:sidestep::MiniDisassembler	file:
s_opcode_byte_after_0f	windows\ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_0f[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_0f00	windows\ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_0f00[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_0f01	windows\ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_0f01[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_0f18	windows\ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_0f18[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_0f71	windows\ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_0f71[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_0f72	windows\ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_0f72[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_0f73	windows\ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_0f73[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_0fae	windows\ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_0fae[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_0fba	windows\ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_0fba[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_0fc7	windows\ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_0fc7[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_80	windows\ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_80[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_81	windows\ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_81[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_82	windows\ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_82[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_83	windows\ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_83[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_c0	windows\ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_c0[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_c1	windows\ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_c1[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_d0	windows\ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_d0[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_d1	windows\ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_d1[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_d2	windows\ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_d2[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_d3	windows\ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_d3[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_f6	windows\ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_f6[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_f7	windows\ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_f7[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_fe	windows\ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_fe[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_ff	windows\ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_ff[] = {$/;"	m	namespace:sidestep	file:
sidestep	windows\ia32_opcode_map.cc	/^namespace sidestep {$/;"	n	file:
GOOGLE_PERFTOOLS_WINDOWS_MINGW_H_	windows\mingw.h	40;"	d
HAVE_PID_T	windows\mingw.h	66;"	d
HAVE_PTHREAD	windows\mingw.h	63;"	d
HAVE_SNPRINTF	windows\mingw.h	57;"	d
PERFTOOLS_NO_ALIGNED_MALLOC	windows\mingw.h	46;"	d
_WIN32_WINNT	windows\mingw.h	54;"	d
Disassemble	windows\mini_disassembler.cc	/^InstructionType MiniDisassembler::Disassemble($/;"	f	class:sidestep::MiniDisassembler
Initialize	windows\mini_disassembler.cc	/^void MiniDisassembler::Initialize() {$/;"	f	class:sidestep::MiniDisassembler
MiniDisassembler	windows\mini_disassembler.cc	/^MiniDisassembler::MiniDisassembler()$/;"	f	class:sidestep::MiniDisassembler
MiniDisassembler	windows\mini_disassembler.cc	/^MiniDisassembler::MiniDisassembler(bool operand_default_is_32_bits,$/;"	f	class:sidestep::MiniDisassembler
ProcessModrm	windows\mini_disassembler.cc	/^bool MiniDisassembler::ProcessModrm(unsigned char* start_byte,$/;"	f	class:sidestep::MiniDisassembler
ProcessOpcode	windows\mini_disassembler.cc	/^InstructionType MiniDisassembler::ProcessOpcode(unsigned char* start_byte,$/;"	f	class:sidestep::MiniDisassembler
ProcessOperand	windows\mini_disassembler.cc	/^bool MiniDisassembler::ProcessOperand(int flag_operand) {$/;"	f	class:sidestep::MiniDisassembler
ProcessPrefixes	windows\mini_disassembler.cc	/^InstructionType MiniDisassembler::ProcessPrefixes(unsigned char* start_byte,$/;"	f	class:sidestep::MiniDisassembler
ProcessSib	windows\mini_disassembler.cc	/^bool MiniDisassembler::ProcessSib(unsigned char* start_byte,$/;"	f	class:sidestep::MiniDisassembler
sidestep	windows\mini_disassembler.cc	/^namespace sidestep {$/;"	n	file:
GOOGLE_PERFTOOLS_MINI_DISASSEMBLER_H_	windows\mini_disassembler.h	38;"	d
MiniDisassembler	windows\mini_disassembler.h	/^class PERFTOOLS_DLL_DECL MiniDisassembler {$/;"	c	namespace:sidestep
SIDESTEP_ASSERT	windows\mini_disassembler.h	46;"	d
SIDESTEP_LOG	windows\mini_disassembler.h	47;"	d
address_default_is_32_bits_	windows\mini_disassembler.h	/^  bool address_default_is_32_bits_;$/;"	m	class:sidestep::MiniDisassembler
address_is_32_bits_	windows\mini_disassembler.h	/^  bool address_is_32_bits_;$/;"	m	class:sidestep::MiniDisassembler
got_66_prefix_	windows\mini_disassembler.h	/^  bool got_f2_prefix_, got_f3_prefix_, got_66_prefix_;$/;"	m	class:sidestep::MiniDisassembler
got_f2_prefix_	windows\mini_disassembler.h	/^  bool got_f2_prefix_, got_f3_prefix_, got_66_prefix_;$/;"	m	class:sidestep::MiniDisassembler
got_f3_prefix_	windows\mini_disassembler.h	/^  bool got_f2_prefix_, got_f3_prefix_, got_66_prefix_;$/;"	m	class:sidestep::MiniDisassembler
have_modrm_	windows\mini_disassembler.h	/^  bool have_modrm_;$/;"	m	class:sidestep::MiniDisassembler
instruction_type_	windows\mini_disassembler.h	/^  InstructionType instruction_type_;$/;"	m	class:sidestep::MiniDisassembler
operand_bytes_	windows\mini_disassembler.h	/^  unsigned int operand_bytes_;$/;"	m	class:sidestep::MiniDisassembler
operand_default_is_32_bits_	windows\mini_disassembler.h	/^  bool operand_default_is_32_bits_;$/;"	m	class:sidestep::MiniDisassembler
operand_default_support_64_bits_	windows\mini_disassembler.h	/^  bool operand_default_support_64_bits_;$/;"	m	class:sidestep::MiniDisassembler
operand_is_32_bits_	windows\mini_disassembler.h	/^  bool operand_is_32_bits_;$/;"	m	class:sidestep::MiniDisassembler
operand_is_64_bits_	windows\mini_disassembler.h	/^  bool operand_is_64_bits_;$/;"	m	class:sidestep::MiniDisassembler
s_ia16_modrm_map_	windows\mini_disassembler.h	/^  static const ModrmEntry s_ia16_modrm_map_[];$/;"	m	class:sidestep::MiniDisassembler
s_ia32_modrm_map_	windows\mini_disassembler.h	/^  static const ModrmEntry s_ia32_modrm_map_[];$/;"	m	class:sidestep::MiniDisassembler
s_ia32_opcode_map_	windows\mini_disassembler.h	/^  static const OpcodeTable s_ia32_opcode_map_[];$/;"	m	class:sidestep::MiniDisassembler
should_decode_modrm_	windows\mini_disassembler.h	/^  bool should_decode_modrm_;$/;"	m	class:sidestep::MiniDisassembler
sidestep	windows\mini_disassembler.h	/^namespace sidestep {$/;"	n
AM_A	windows\mini_disassembler_types.h	/^  AM_A = 0x00010000,    \/\/ A addressing type$/;"	e	enum:sidestep::AddressingMethod
AM_C	windows\mini_disassembler_types.h	/^  AM_C = 0x00020000,    \/\/ C addressing type$/;"	e	enum:sidestep::AddressingMethod
AM_D	windows\mini_disassembler_types.h	/^  AM_D = 0x00030000,    \/\/ D addressing type$/;"	e	enum:sidestep::AddressingMethod
AM_E	windows\mini_disassembler_types.h	/^  AM_E = 0x00040000,    \/\/ E addressing type$/;"	e	enum:sidestep::AddressingMethod
AM_F	windows\mini_disassembler_types.h	/^  AM_F = 0x00050000,    \/\/ F addressing type$/;"	e	enum:sidestep::AddressingMethod
AM_G	windows\mini_disassembler_types.h	/^  AM_G = 0x00060000,    \/\/ G addressing type$/;"	e	enum:sidestep::AddressingMethod
AM_I	windows\mini_disassembler_types.h	/^  AM_I = 0x00070000,    \/\/ I addressing type$/;"	e	enum:sidestep::AddressingMethod
AM_IMPLICIT	windows\mini_disassembler_types.h	/^  AM_IMPLICIT = 0x00150000,  \/\/ An implicit, fixed value is used$/;"	e	enum:sidestep::AddressingMethod
AM_J	windows\mini_disassembler_types.h	/^  AM_J = 0x00080000,    \/\/ J addressing type$/;"	e	enum:sidestep::AddressingMethod
AM_M	windows\mini_disassembler_types.h	/^  AM_M = 0x00090000,    \/\/ M addressing type$/;"	e	enum:sidestep::AddressingMethod
AM_MASK	windows\mini_disassembler_types.h	/^  AM_MASK = 0x00FF0000,  \/\/ Mask for the rest of the values in this enumeration$/;"	e	enum:sidestep::AddressingMethod
AM_NOT_USED	windows\mini_disassembler_types.h	/^  AM_NOT_USED = 0,        \/\/ This operand is not used for this instruction$/;"	e	enum:sidestep::AddressingMethod
AM_O	windows\mini_disassembler_types.h	/^  AM_O = 0x000A0000,    \/\/ O addressing type$/;"	e	enum:sidestep::AddressingMethod
AM_P	windows\mini_disassembler_types.h	/^  AM_P = 0x000B0000,    \/\/ P addressing type$/;"	e	enum:sidestep::AddressingMethod
AM_Q	windows\mini_disassembler_types.h	/^  AM_Q = 0x000C0000,    \/\/ Q addressing type$/;"	e	enum:sidestep::AddressingMethod
AM_R	windows\mini_disassembler_types.h	/^  AM_R = 0x000D0000,    \/\/ R addressing type$/;"	e	enum:sidestep::AddressingMethod
AM_REGISTER	windows\mini_disassembler_types.h	/^  AM_REGISTER = 0x00140000,  \/\/ Specific register is always used as this op$/;"	e	enum:sidestep::AddressingMethod
AM_S	windows\mini_disassembler_types.h	/^  AM_S = 0x000E0000,    \/\/ S addressing type$/;"	e	enum:sidestep::AddressingMethod
AM_T	windows\mini_disassembler_types.h	/^  AM_T = 0x000F0000,    \/\/ T addressing type$/;"	e	enum:sidestep::AddressingMethod
AM_V	windows\mini_disassembler_types.h	/^  AM_V = 0x00100000,    \/\/ V addressing type$/;"	e	enum:sidestep::AddressingMethod
AM_W	windows\mini_disassembler_types.h	/^  AM_W = 0x00110000,    \/\/ W addressing type$/;"	e	enum:sidestep::AddressingMethod
AM_X	windows\mini_disassembler_types.h	/^  AM_X = 0x00120000,    \/\/ X addressing type$/;"	e	enum:sidestep::AddressingMethod
AM_Y	windows\mini_disassembler_types.h	/^  AM_Y = 0x00130000,    \/\/ Y addressing type$/;"	e	enum:sidestep::AddressingMethod
AddressingMethod	windows\mini_disassembler_types.h	/^enum AddressingMethod {$/;"	g	namespace:sidestep
GOOGLE_PERFTOOLS_MINI_DISASSEMBLER_TYPES_H_	windows\mini_disassembler_types.h	39;"	d
IOS_64	windows\mini_disassembler_types.h	/^  IOS_64 = 0x00001000$/;"	e	enum:sidestep::ImmediateOperandSize
IOS_DEFAULT	windows\mini_disassembler_types.h	/^  IOS_DEFAULT = 0x0,$/;"	e	enum:sidestep::ImmediateOperandSize
IOS_MASK	windows\mini_disassembler_types.h	/^  IOS_MASK = 0x0000F000,$/;"	e	enum:sidestep::ImmediateOperandSize
IT_GENERIC	windows\mini_disassembler_types.h	/^  IT_GENERIC,$/;"	e	enum:sidestep::InstructionType
IT_JUMP	windows\mini_disassembler_types.h	/^  IT_JUMP,$/;"	e	enum:sidestep::InstructionType
IT_PREFIX	windows\mini_disassembler_types.h	/^  IT_PREFIX,$/;"	e	enum:sidestep::InstructionType
IT_PREFIX_ADDRESS	windows\mini_disassembler_types.h	/^  IT_PREFIX_ADDRESS,$/;"	e	enum:sidestep::InstructionType
IT_PREFIX_OPERAND	windows\mini_disassembler_types.h	/^  IT_PREFIX_OPERAND,$/;"	e	enum:sidestep::InstructionType
IT_REFERENCE	windows\mini_disassembler_types.h	/^  IT_REFERENCE,$/;"	e	enum:sidestep::InstructionType
IT_RETURN	windows\mini_disassembler_types.h	/^  IT_RETURN,$/;"	e	enum:sidestep::InstructionType
IT_UNKNOWN	windows\mini_disassembler_types.h	/^  IT_UNKNOWN,$/;"	e	enum:sidestep::InstructionType
IT_UNUSED	windows\mini_disassembler_types.h	/^  IT_UNUSED,$/;"	e	enum:sidestep::InstructionType
ImmediateOperandSize	windows\mini_disassembler_types.h	/^enum ImmediateOperandSize {$/;"	g	namespace:sidestep
InstructionType	windows\mini_disassembler_types.h	/^enum InstructionType {$/;"	g	namespace:sidestep
ModrmEntry	windows\mini_disassembler_types.h	/^struct ModrmEntry {$/;"	s	namespace:sidestep
OS_128_BIT_PACKED_SINGLE_PRECISION_FLOATING	windows\mini_disassembler_types.h	/^  OS_128_BIT_PACKED_SINGLE_PRECISION_FLOATING = 128\/8,$/;"	e	enum:sidestep::OperandSize
OS_32_BIT_POINTER	windows\mini_disassembler_types.h	/^  OS_32_BIT_POINTER = 32\/8,$/;"	e	enum:sidestep::OperandSize
OS_48_BIT_POINTER	windows\mini_disassembler_types.h	/^  OS_48_BIT_POINTER = 48\/8,$/;"	e	enum:sidestep::OperandSize
OS_BYTE	windows\mini_disassembler_types.h	/^  OS_BYTE = 1,$/;"	e	enum:sidestep::OperandSize
OS_DOUBLE_EXTENDED_PRECISION_FLOATING	windows\mini_disassembler_types.h	/^  OS_DOUBLE_EXTENDED_PRECISION_FLOATING = 80\/8,$/;"	e	enum:sidestep::OperandSize
OS_DOUBLE_PRECISION_FLOATING	windows\mini_disassembler_types.h	/^  OS_DOUBLE_PRECISION_FLOATING = 64\/8,$/;"	e	enum:sidestep::OperandSize
OS_DOUBLE_QUAD_WORD	windows\mini_disassembler_types.h	/^  OS_DOUBLE_QUAD_WORD = 16,$/;"	e	enum:sidestep::OperandSize
OS_DOUBLE_WORD	windows\mini_disassembler_types.h	/^  OS_DOUBLE_WORD = 4,$/;"	e	enum:sidestep::OperandSize
OS_PSEUDO_DESCRIPTOR	windows\mini_disassembler_types.h	/^  OS_PSEUDO_DESCRIPTOR = 6$/;"	e	enum:sidestep::OperandSize
OS_QUAD_WORD	windows\mini_disassembler_types.h	/^  OS_QUAD_WORD = 8,$/;"	e	enum:sidestep::OperandSize
OS_SINGLE_PRECISION_FLOATING	windows\mini_disassembler_types.h	/^  OS_SINGLE_PRECISION_FLOATING = 32\/8,$/;"	e	enum:sidestep::OperandSize
OS_WORD	windows\mini_disassembler_types.h	/^  OS_WORD = 2,$/;"	e	enum:sidestep::OperandSize
OS_ZERO	windows\mini_disassembler_types.h	/^  OS_ZERO = 0,$/;"	e	enum:sidestep::OperandSize
OT_A	windows\mini_disassembler_types.h	/^  OT_A = 0x01000000,$/;"	e	enum:sidestep::OperandType
OT_ADDRESS_MODE_M	windows\mini_disassembler_types.h	/^  OT_ADDRESS_MODE_M = 0x80000000$/;"	e	enum:sidestep::OperandType
OT_B	windows\mini_disassembler_types.h	/^  OT_B = 0x02000000,$/;"	e	enum:sidestep::OperandType
OT_C	windows\mini_disassembler_types.h	/^  OT_C = 0x03000000,$/;"	e	enum:sidestep::OperandType
OT_D	windows\mini_disassembler_types.h	/^  OT_D = 0x04000000,$/;"	e	enum:sidestep::OperandType
OT_DQ	windows\mini_disassembler_types.h	/^  OT_DQ = 0x05000000,$/;"	e	enum:sidestep::OperandType
OT_MASK	windows\mini_disassembler_types.h	/^  OT_MASK = 0xFF000000,$/;"	e	enum:sidestep::OperandType
OT_P	windows\mini_disassembler_types.h	/^  OT_P = 0x06000000,$/;"	e	enum:sidestep::OperandType
OT_PD	windows\mini_disassembler_types.h	/^  OT_PD = 0x10000000,  \/\/ double-precision floating point$/;"	e	enum:sidestep::OperandType
OT_PI	windows\mini_disassembler_types.h	/^  OT_PI = 0x07000000,$/;"	e	enum:sidestep::OperandType
OT_PS	windows\mini_disassembler_types.h	/^  OT_PS = 0x08000000,  \/\/ actually unsupported for (we don't know its size)$/;"	e	enum:sidestep::OperandType
OT_Q	windows\mini_disassembler_types.h	/^  OT_Q = 0x09000000,$/;"	e	enum:sidestep::OperandType
OT_S	windows\mini_disassembler_types.h	/^  OT_S = 0x0A000000,$/;"	e	enum:sidestep::OperandType
OT_SD	windows\mini_disassembler_types.h	/^  OT_SD = 0x0F000000,  \/\/ scalar double-precision floating-point value$/;"	e	enum:sidestep::OperandType
OT_SI	windows\mini_disassembler_types.h	/^  OT_SI = 0x0C000000,$/;"	e	enum:sidestep::OperandType
OT_SS	windows\mini_disassembler_types.h	/^  OT_SS = 0x0B000000,$/;"	e	enum:sidestep::OperandType
OT_V	windows\mini_disassembler_types.h	/^  OT_V = 0x0D000000,$/;"	e	enum:sidestep::OperandType
OT_W	windows\mini_disassembler_types.h	/^  OT_W = 0x0E000000,$/;"	e	enum:sidestep::OperandType
Opcode	windows\mini_disassembler_types.h	/^struct Opcode {$/;"	s	namespace:sidestep
OpcodeTable	windows\mini_disassembler_types.h	/^struct OpcodeTable {$/;"	s	namespace:sidestep
OperandSize	windows\mini_disassembler_types.h	/^enum OperandSize {$/;"	g	namespace:sidestep
OperandType	windows\mini_disassembler_types.h	/^enum OperandType {$/;"	g	namespace:sidestep
SpecificOpcode	windows\mini_disassembler_types.h	/^struct SpecificOpcode {$/;"	s	namespace:sidestep
flag_aux_	windows\mini_disassembler_types.h	/^  int flag_aux_;$/;"	m	struct:sidestep::Opcode
flag_aux_	windows\mini_disassembler_types.h	/^  int flag_aux_;$/;"	m	struct:sidestep::SpecificOpcode
flag_dest_	windows\mini_disassembler_types.h	/^  int flag_dest_;$/;"	m	struct:sidestep::Opcode
flag_dest_	windows\mini_disassembler_types.h	/^  int flag_dest_;$/;"	m	struct:sidestep::SpecificOpcode
flag_source_	windows\mini_disassembler_types.h	/^  int flag_source_;$/;"	m	struct:sidestep::Opcode
flag_source_	windows\mini_disassembler_types.h	/^  int flag_source_;$/;"	m	struct:sidestep::SpecificOpcode
is_encoded_in_instruction_	windows\mini_disassembler_types.h	/^  bool is_encoded_in_instruction_;$/;"	m	struct:sidestep::ModrmEntry
is_prefix_dependent_	windows\mini_disassembler_types.h	/^  bool is_prefix_dependent_;$/;"	m	struct:sidestep::Opcode
mask_	windows\mini_disassembler_types.h	/^  unsigned char mask_;$/;"	m	struct:sidestep::OpcodeTable
max_lim_	windows\mini_disassembler_types.h	/^  unsigned char max_lim_;$/;"	m	struct:sidestep::OpcodeTable
min_lim_	windows\mini_disassembler_types.h	/^  unsigned char min_lim_;$/;"	m	struct:sidestep::OpcodeTable
mnemonic_	windows\mini_disassembler_types.h	/^  const char* mnemonic_;$/;"	m	struct:sidestep::Opcode
mnemonic_	windows\mini_disassembler_types.h	/^  const char* mnemonic_;$/;"	m	struct:sidestep::SpecificOpcode
opcode_if_66_prefix_	windows\mini_disassembler_types.h	/^  SpecificOpcode opcode_if_66_prefix_;$/;"	m	struct:sidestep::Opcode
opcode_if_f2_prefix_	windows\mini_disassembler_types.h	/^  SpecificOpcode opcode_if_f2_prefix_;$/;"	m	struct:sidestep::Opcode
opcode_if_f3_prefix_	windows\mini_disassembler_types.h	/^  SpecificOpcode opcode_if_f3_prefix_;$/;"	m	struct:sidestep::Opcode
operand_size_	windows\mini_disassembler_types.h	/^  OperandSize operand_size_;$/;"	m	struct:sidestep::ModrmEntry
shift_	windows\mini_disassembler_types.h	/^  unsigned char shift_;$/;"	m	struct:sidestep::OpcodeTable
sidestep	windows\mini_disassembler_types.h	/^namespace sidestep {$/;"	n
table_	windows\mini_disassembler_types.h	/^  const Opcode* table_;$/;"	m	struct:sidestep::OpcodeTable
table_index_	windows\mini_disassembler_types.h	/^  int table_index_;$/;"	m	struct:sidestep::Opcode
table_index_	windows\mini_disassembler_types.h	/^  int table_index_;$/;"	m	struct:sidestep::SpecificOpcode
type_	windows\mini_disassembler_types.h	/^  InstructionType type_;$/;"	m	struct:sidestep::Opcode
type_	windows\mini_disassembler_types.h	/^  InstructionType type_;$/;"	m	struct:sidestep::SpecificOpcode
use_sib_byte_	windows\mini_disassembler_types.h	/^  bool use_sib_byte_;$/;"	m	struct:sidestep::ModrmEntry
EnumSymProc	windows\nm-pdb.c	/^static BOOL CALLBACK EnumSymProc(PSYMBOL_INFO symbol_info,$/;"	f	file:
MaybePrint	windows\nm-pdb.c	/^static void MaybePrint(const char* var, const char* description) {$/;"	f	file:
PrintAvailability	windows\nm-pdb.c	/^static void PrintAvailability(BOOL var, const char *description) {$/;"	f	file:
SEARCH_CAP	windows\nm-pdb.c	59;"	d	file:
SYM	windows\nm-pdb.c	/^} SYM;$/;"	t	typeref:struct:__anon50	file:
SYM_CONTEXT	windows\nm-pdb.c	/^} SYM_CONTEXT;$/;"	t	typeref:struct:__anon51	file:
ShowSymbolInfo	windows\nm-pdb.c	/^static void ShowSymbolInfo(HANDLE process, ULONG64 module_base) {$/;"	f	file:
WEBSYM	windows\nm-pdb.c	60;"	d	file:
WIN32_LEAN_AND_MEAN	windows\nm-pdb.c	38;"	d	file:
_CRT_SECURE_NO_DEPRECATE	windows\nm-pdb.c	40;"	d	file:
_CRT_SECURE_NO_WARNINGS	windows\nm-pdb.c	39;"	d	file:
addr	windows\nm-pdb.c	/^  ULONG64 addr;$/;"	m	struct:__anon50	file:
flags	windows\nm-pdb.c	/^  ULONG flags;$/;"	m	struct:__anon50	file:
main	windows\nm-pdb.c	/^int main(int argc, char *argv[]) {$/;"	f
module_base	windows\nm-pdb.c	/^  ULONG64 module_base;$/;"	m	struct:__anon51	file:
name	windows\nm-pdb.c	/^  char *name;$/;"	m	struct:__anon50	file:
sym_cmp	windows\nm-pdb.c	/^static int sym_cmp(const void *_s1, const void *_s2) {$/;"	f	file:
syms	windows\nm-pdb.c	/^  SYM *syms;$/;"	m	struct:__anon51	file:
syms_cap	windows\nm-pdb.c	/^  DWORD syms_cap;$/;"	m	struct:__anon51	file:
syms_len	windows\nm-pdb.c	/^  DWORD syms_len;$/;"	m	struct:__anon51	file:
usage	windows\nm-pdb.c	/^void usage() {$/;"	f
_CrtDbgReport	windows\override_functions.cc	/^int _CrtDbgReport(int, const char*, int, const char*, const char*, ...) {$/;"	f
_CrtDbgReportW	windows\override_functions.cc	/^int _CrtDbgReportW(int, const wchar_t*, int, const wchar_t*, const wchar_t*, ...) {$/;"	f
_CrtSetReportMode	windows\override_functions.cc	/^int _CrtSetReportMode(int, int) {$/;"	f
_calloc_dbg	windows\override_functions.cc	/^extern "C" void* _calloc_dbg(size_t n, size_t size, int, const char*, int) {$/;"	f
_calloc_impl	windows\override_functions.cc	/^extern "C" void* _calloc_impl(size_t n, size_t size) {$/;"	f
_crtheap	windows\override_functions.cc	/^extern "C" void* _crtheap = reinterpret_cast<void*>(1);$/;"	v
_free_dbg	windows\override_functions.cc	/^extern "C" void _free_dbg(void* ptr, int) {$/;"	f
_get_heap_handle	windows\override_functions.cc	/^extern "C" intptr_t _get_heap_handle() {$/;"	f
_heap_init	windows\override_functions.cc	/^extern "C" int _heap_init() {$/;"	f
_heap_term	windows\override_functions.cc	/^extern "C" void _heap_term() {$/;"	f
_malloc_dbg	windows\override_functions.cc	/^extern "C" void* _malloc_dbg(size_t size, int , const char*, int) {$/;"	f
_msize	windows\override_functions.cc	/^extern "C" size_t _msize(void* p) {$/;"	f
_recalloc	windows\override_functions.cc	/^extern "C" void* _recalloc(void* p, size_t n, size_t size) {$/;"	f
_set_new_mode	windows\override_functions.cc	/^extern "C" int _set_new_mode(int flag) {$/;"	f
calloc	windows\override_functions.cc	93;"	d	file:
free	windows\override_functions.cc	92;"	d	file:
malloc	windows\override_functions.cc	91;"	d	file:
CopyFrom	windows\patch_functions.cc	/^  void CopyFrom(const LibcInfo& that) {$/;"	f	class:__anon52::LibcInfo
FunctionInfo	windows\patch_functions.cc	/^  struct FunctionInfo {$/;"	s	class:__anon52::WindowsInfo	file:
GenericFnPtr	windows\patch_functions.cc	/^typedef void (*GenericFnPtr)();$/;"	t	namespace:__anon52	file:
LibcInfo	windows\patch_functions.cc	/^  LibcInfo() {$/;"	f	class:__anon52::LibcInfo
LibcInfo	windows\patch_functions.cc	/^class LibcInfo {$/;"	c	namespace:__anon52	file:
LibcInfoWithPatchFunctions	windows\patch_functions.cc	/^template<int> class LibcInfoWithPatchFunctions : public LibcInfo {$/;"	c	namespace:__anon52	file:
ModuleEntryCopy	windows\patch_functions.cc	/^  ModuleEntryCopy() {$/;"	f	struct:__anon52::ModuleEntryCopy
ModuleEntryCopy	windows\patch_functions.cc	/^  ModuleEntryCopy(const MODULEINFO& mi) {$/;"	f	struct:__anon52::ModuleEntryCopy
ModuleEntryCopy	windows\patch_functions.cc	/^struct ModuleEntryCopy {$/;"	s	namespace:__anon52	file:
PSAPI_VERSION	windows\patch_functions.cc	82;"	d	file:
Patch	windows\patch_functions.cc	/^bool LibcInfoWithPatchFunctions<T>::Patch(const LibcInfo& me_info) {$/;"	f	class:__anon52::LibcInfoWithPatchFunctions
Patch	windows\patch_functions.cc	/^void WindowsInfo::Patch() {$/;"	f	class:__anon52::WindowsInfo
PatchAllModules	windows\patch_functions.cc	/^bool PatchAllModules() {$/;"	f	namespace:__anon52
PatchMainExecutableLocked	windows\patch_functions.cc	/^void PatchMainExecutableLocked() {$/;"	f	namespace:__anon52
PatchOneModuleLocked	windows\patch_functions.cc	/^void PatchOneModuleLocked(const LibcInfo& me_info) {$/;"	f	namespace:__anon52
PatchWindowsFunctions	windows\patch_functions.cc	/^void PatchWindowsFunctions() {$/;"	f
Perftools_FreeLibrary	windows\patch_functions.cc	/^BOOL WINAPI WindowsInfo::Perftools_FreeLibrary(HMODULE hLibModule) {$/;"	f	class:WindowsInfo
Perftools_HeapAlloc	windows\patch_functions.cc	/^LPVOID WINAPI WindowsInfo::Perftools_HeapAlloc(HANDLE hHeap, DWORD dwFlags,$/;"	f	class:WindowsInfo
Perftools_HeapFree	windows\patch_functions.cc	/^BOOL WINAPI WindowsInfo::Perftools_HeapFree(HANDLE hHeap, DWORD dwFlags,$/;"	f	class:WindowsInfo
Perftools_LoadLibraryExW	windows\patch_functions.cc	/^HMODULE WINAPI WindowsInfo::Perftools_LoadLibraryExW(LPCWSTR lpFileName,$/;"	f	class:WindowsInfo
Perftools_MapViewOfFileEx	windows\patch_functions.cc	/^LPVOID WINAPI WindowsInfo::Perftools_MapViewOfFileEx($/;"	f	class:WindowsInfo
Perftools_UnmapViewOfFile	windows\patch_functions.cc	/^BOOL WINAPI WindowsInfo::Perftools_UnmapViewOfFile(LPCVOID lpBaseAddress) {$/;"	f	class:WindowsInfo
Perftools_VirtualAllocEx	windows\patch_functions.cc	/^LPVOID WINAPI WindowsInfo::Perftools_VirtualAllocEx(HANDLE process,$/;"	f	class:WindowsInfo
Perftools_VirtualFreeEx	windows\patch_functions.cc	/^BOOL WINAPI WindowsInfo::Perftools_VirtualFreeEx(HANDLE process, LPVOID address,$/;"	f	class:WindowsInfo
Perftools_delete	windows\patch_functions.cc	/^void LibcInfoWithPatchFunctions<T>::Perftools_delete(void *p) {$/;"	f	class:LibcInfoWithPatchFunctions
Perftools_deletearray	windows\patch_functions.cc	/^void LibcInfoWithPatchFunctions<T>::Perftools_deletearray(void *p) {$/;"	f	class:LibcInfoWithPatchFunctions
Perftools_new	windows\patch_functions.cc	/^void* LibcInfoWithPatchFunctions<T>::Perftools_new(size_t size) {$/;"	f	class:LibcInfoWithPatchFunctions
Perftools_newarray	windows\patch_functions.cc	/^void* LibcInfoWithPatchFunctions<T>::Perftools_newarray(size_t size) {$/;"	f	class:LibcInfoWithPatchFunctions
PopulateWindowsFn	windows\patch_functions.cc	/^bool LibcInfo::PopulateWindowsFn(const ModuleEntryCopy& module_entry) {$/;"	f	class:__anon52::LibcInfo
Unpatch	windows\patch_functions.cc	/^void LibcInfoWithPatchFunctions<T>::Unpatch() {$/;"	f	class:__anon52::LibcInfoWithPatchFunctions
Unpatch	windows\patch_functions.cc	/^void WindowsInfo::Unpatch() {$/;"	f	class:__anon52::WindowsInfo
WindowsInfo	windows\patch_functions.cc	/^class WindowsInfo {$/;"	c	namespace:__anon52	file:
__THROW	windows\patch_functions.cc	/^                                            const std::nothrow_t&) __THROW;$/;"	m	class:__anon52::LibcInfoWithPatchFunctions	file:
__THROW	windows\patch_functions.cc	/^                                          const std::nothrow_t&) __THROW;$/;"	m	class:__anon52::LibcInfoWithPatchFunctions	file:
__THROW	windows\patch_functions.cc	/^                                       const std::nothrow_t&) __THROW;$/;"	m	class:__anon52::LibcInfoWithPatchFunctions	file:
__THROW	windows\patch_functions.cc	/^                                     const std::nothrow_t&) __THROW;$/;"	m	class:__anon52::LibcInfoWithPatchFunctions	file:
__THROW	windows\patch_functions.cc	/^  static size_t Perftools__msize(void *ptr) __THROW;$/;"	m	class:__anon52::LibcInfoWithPatchFunctions	file:
__THROW	windows\patch_functions.cc	/^  static void Perftools_free(void* ptr) __THROW;$/;"	m	class:__anon52::LibcInfoWithPatchFunctions	file:
__THROW	windows\patch_functions.cc	/^  static void* Perftools__expand(void *ptr, size_t size) __THROW;$/;"	m	class:__anon52::LibcInfoWithPatchFunctions	file:
__THROW	windows\patch_functions.cc	/^  static void* Perftools_calloc(size_t nmemb, size_t size) __THROW;$/;"	m	class:__anon52::LibcInfoWithPatchFunctions	file:
__THROW	windows\patch_functions.cc	/^  static void* Perftools_malloc(size_t size) __THROW;$/;"	m	class:__anon52::LibcInfoWithPatchFunctions	file:
__THROW	windows\patch_functions.cc	/^  static void* Perftools_realloc(void* ptr, size_t size) __THROW;$/;"	m	class:__anon52::LibcInfoWithPatchFunctions	file:
__tcmalloc	windows\patch_functions.cc	/^void __tcmalloc() { }$/;"	f
_tcmalloc	windows\patch_functions.cc	/^void _tcmalloc() { }$/;"	f
ctrgProcAddress	windows\patch_functions.cc	/^  static const int ctrgProcAddress = kNumFunctions;$/;"	m	class:__anon52::LibcInfo	file:
function_info_	windows\patch_functions.cc	/^  static FunctionInfo function_info_[kNumFunctions];$/;"	m	class:__anon52::WindowsInfo	file:
function_info_	windows\patch_functions.cc	/^\/*static*\/ WindowsInfo::FunctionInfo WindowsInfo::function_info_[] = {$/;"	m	class:__anon52::WindowsInfo	file:
function_name	windows\patch_functions.cc	/^  static const char* const function_name(int ifunction) {$/;"	f	class:__anon52::LibcInfo
function_name_	windows\patch_functions.cc	/^  static const char* const function_name_[kNumFunctions];$/;"	m	class:__anon52::LibcInfo	file:
function_name_	windows\patch_functions.cc	/^const char* const LibcInfo::function_name_[] = {$/;"	m	class:__anon52::LibcInfo	file:
g_last_loaded	windows\patch_functions.cc	/^static std::set<HMODULE> *g_last_loaded;$/;"	m	namespace:__anon52	file:
g_load_map	windows\patch_functions.cc	/^static std::map<HMODULE, int>* g_load_map = NULL;$/;"	v	file:
g_module_libcs	windows\patch_functions.cc	/^static LibcInfo* g_module_libcs[] = {$/;"	m	namespace:__anon52	file:
hmodule	windows\patch_functions.cc	/^  HMODULE hmodule() const {$/;"	f	class:__anon52::LibcInfo
is_valid	windows\patch_functions.cc	/^  bool is_valid() const { return is_valid_; }$/;"	f	class:__anon52::LibcInfo
is_valid_	windows\patch_functions.cc	/^  bool is_valid_;$/;"	m	class:__anon52::LibcInfo	file:
kCalloc	windows\patch_functions.cc	/^    kMalloc, kFree, kRealloc, kCalloc,$/;"	e	enum:__anon52::LibcInfo::__anon53	file:
kDelete	windows\patch_functions.cc	/^    kNew, kNewArray, kDelete, kDeleteArray,$/;"	e	enum:__anon52::LibcInfo::__anon53	file:
kDeleteArray	windows\patch_functions.cc	/^    kNew, kNewArray, kDelete, kDeleteArray,$/;"	e	enum:__anon52::LibcInfo::__anon53	file:
kDeleteArrayNothrow	windows\patch_functions.cc	/^    kNewNothrow, kNewArrayNothrow, kDeleteNothrow, kDeleteArrayNothrow,$/;"	e	enum:__anon52::LibcInfo::__anon53	file:
kDeleteNothrow	windows\patch_functions.cc	/^    kNewNothrow, kNewArrayNothrow, kDeleteNothrow, kDeleteArrayNothrow,$/;"	e	enum:__anon52::LibcInfo::__anon53	file:
kFree	windows\patch_functions.cc	/^    kMalloc, kFree, kRealloc, kCalloc,$/;"	e	enum:__anon52::LibcInfo::__anon53	file:
kFreeLibrary	windows\patch_functions.cc	/^    kMapViewOfFileEx, kUnmapViewOfFile, kLoadLibraryExW, kFreeLibrary,$/;"	e	enum:__anon52::WindowsInfo::__anon54	file:
kHeapAlloc	windows\patch_functions.cc	/^    kHeapAlloc, kHeapFree, kVirtualAllocEx, kVirtualFreeEx,$/;"	e	enum:__anon52::WindowsInfo::__anon54	file:
kHeapFree	windows\patch_functions.cc	/^    kHeapAlloc, kHeapFree, kVirtualAllocEx, kVirtualFreeEx,$/;"	e	enum:__anon52::WindowsInfo::__anon54	file:
kLoadLibraryExW	windows\patch_functions.cc	/^    kMapViewOfFileEx, kUnmapViewOfFile, kLoadLibraryExW, kFreeLibrary,$/;"	e	enum:__anon52::WindowsInfo::__anon54	file:
kMalloc	windows\patch_functions.cc	/^    kMalloc, kFree, kRealloc, kCalloc,$/;"	e	enum:__anon52::LibcInfo::__anon53	file:
kMangledDelete	windows\patch_functions.cc	/^const char kMangledDelete[] = "??3@YAXPAX@Z";$/;"	v
kMangledDelete	windows\patch_functions.cc	/^const char kMangledDelete[] = "??3@YAXPEAX@Z";$/;"	v
kMangledDeleteArray	windows\patch_functions.cc	/^const char kMangledDeleteArray[] = "??_V@YAXPAX@Z";$/;"	v
kMangledDeleteArray	windows\patch_functions.cc	/^const char kMangledDeleteArray[] = "??_V@YAXPEAX@Z";$/;"	v
kMangledDeleteArrayNothrow	windows\patch_functions.cc	/^const char kMangledDeleteArrayNothrow[] = "??_V@YAXPAXABUnothrow_t@std@@@Z";$/;"	v
kMangledDeleteArrayNothrow	windows\patch_functions.cc	/^const char kMangledDeleteArrayNothrow[] = "??_V@YAXPEAXAEBUnothrow_t@std@@@Z";$/;"	v
kMangledDeleteNothrow	windows\patch_functions.cc	/^const char kMangledDeleteNothrow[] = "??3@YAXPAXABUnothrow_t@std@@@Z";$/;"	v
kMangledDeleteNothrow	windows\patch_functions.cc	/^const char kMangledDeleteNothrow[] = "??3@YAXPEAXAEBUnothrow_t@std@@@Z";$/;"	v
kMangledNew	windows\patch_functions.cc	/^const char kMangledNew[] = "??2@YAPAXI@Z";$/;"	v
kMangledNew	windows\patch_functions.cc	/^const char kMangledNew[] = "??2@YAPEAX_K@Z";$/;"	v
kMangledNewArray	windows\patch_functions.cc	/^const char kMangledNewArray[] = "??_U@YAPAXI@Z";$/;"	v
kMangledNewArray	windows\patch_functions.cc	/^const char kMangledNewArray[] = "??_U@YAPEAX_K@Z";$/;"	v
kMangledNewArrayNothrow	windows\patch_functions.cc	/^const char kMangledNewArrayNothrow[] = "??_U@YAPAXIABUnothrow_t@std@@@Z";$/;"	v
kMangledNewArrayNothrow	windows\patch_functions.cc	/^const char kMangledNewArrayNothrow[] = "??_U@YAPEAX_KAEBUnothrow_t@std@@@Z";$/;"	v
kMangledNewNothrow	windows\patch_functions.cc	/^const char kMangledNewNothrow[] = "??2@YAPAXIABUnothrow_t@std@@@Z";$/;"	v
kMangledNewNothrow	windows\patch_functions.cc	/^const char kMangledNewNothrow[] = "??2@YAPEAX_KAEBUnothrow_t@std@@@Z";$/;"	v
kMapViewOfFileEx	windows\patch_functions.cc	/^    kMapViewOfFileEx, kUnmapViewOfFile, kLoadLibraryExW, kFreeLibrary,$/;"	e	enum:__anon52::WindowsInfo::__anon54	file:
kMaxModules	windows\patch_functions.cc	/^const int kMaxModules = 8182;$/;"	v
kNew	windows\patch_functions.cc	/^    kNew, kNewArray, kDelete, kDeleteArray,$/;"	e	enum:__anon52::LibcInfo::__anon53	file:
kNewArray	windows\patch_functions.cc	/^    kNew, kNewArray, kDelete, kDeleteArray,$/;"	e	enum:__anon52::LibcInfo::__anon53	file:
kNewArrayNothrow	windows\patch_functions.cc	/^    kNewNothrow, kNewArrayNothrow, kDeleteNothrow, kDeleteArrayNothrow,$/;"	e	enum:__anon52::LibcInfo::__anon53	file:
kNewNothrow	windows\patch_functions.cc	/^    kNewNothrow, kNewArrayNothrow, kDeleteNothrow, kDeleteArrayNothrow,$/;"	e	enum:__anon52::LibcInfo::__anon53	file:
kNumFunctions	windows\patch_functions.cc	/^    kNumFunctions$/;"	e	enum:__anon52::LibcInfo::__anon53	file:
kNumFunctions	windows\patch_functions.cc	/^    kNumFunctions$/;"	e	enum:__anon52::WindowsInfo::__anon54	file:
kRealloc	windows\patch_functions.cc	/^    kMalloc, kFree, kRealloc, kCalloc,$/;"	e	enum:__anon52::LibcInfo::__anon53	file:
kUnmapViewOfFile	windows\patch_functions.cc	/^    kMapViewOfFileEx, kUnmapViewOfFile, kLoadLibraryExW, kFreeLibrary,$/;"	e	enum:__anon52::WindowsInfo::__anon54	file:
kVirtualAllocEx	windows\patch_functions.cc	/^    kHeapAlloc, kHeapFree, kVirtualAllocEx, kVirtualFreeEx,$/;"	e	enum:__anon52::WindowsInfo::__anon54	file:
kVirtualFreeEx	windows\patch_functions.cc	/^    kHeapAlloc, kHeapFree, kVirtualAllocEx, kVirtualFreeEx,$/;"	e	enum:__anon52::WindowsInfo::__anon54	file:
k_CallocCrt	windows\patch_functions.cc	/^    k_CallocCrt,$/;"	e	enum:__anon52::LibcInfo::__anon53	file:
k_Expand	windows\patch_functions.cc	/^    k_Msize, k_Expand,$/;"	e	enum:__anon52::LibcInfo::__anon53	file:
k_Msize	windows\patch_functions.cc	/^    k_Msize, k_Expand,$/;"	e	enum:__anon52::LibcInfo::__anon53	file:
libc1	windows\patch_functions.cc	/^static LibcInfoWithPatchFunctions<1> libc1;$/;"	m	namespace:__anon52	file:
libc2	windows\patch_functions.cc	/^static LibcInfoWithPatchFunctions<2> libc2;$/;"	m	namespace:__anon52	file:
libc3	windows\patch_functions.cc	/^static LibcInfoWithPatchFunctions<3> libc3;$/;"	m	namespace:__anon52	file:
libc4	windows\patch_functions.cc	/^static LibcInfoWithPatchFunctions<4> libc4;$/;"	m	namespace:__anon52	file:
libc5	windows\patch_functions.cc	/^static LibcInfoWithPatchFunctions<5> libc5;$/;"	m	namespace:__anon52	file:
libc6	windows\patch_functions.cc	/^static LibcInfoWithPatchFunctions<6> libc6;$/;"	m	namespace:__anon52	file:
libc7	windows\patch_functions.cc	/^static LibcInfoWithPatchFunctions<7> libc7;$/;"	m	namespace:__anon52	file:
libc8	windows\patch_functions.cc	/^static LibcInfoWithPatchFunctions<8> libc8;$/;"	m	namespace:__anon52	file:
main_executable	windows\patch_functions.cc	/^static LibcInfoWithPatchFunctions<0> main_executable;$/;"	m	namespace:__anon52	file:
main_executable_windows	windows\patch_functions.cc	/^static WindowsInfo main_executable_windows;$/;"	m	namespace:__anon52	file:
modBaseAddr	windows\patch_functions.cc	/^  LPVOID  modBaseAddr;     \/\/ the same as hmodule$/;"	m	struct:__anon52::ModuleEntryCopy	file:
modBaseSize	windows\patch_functions.cc	/^  DWORD   modBaseSize;$/;"	m	struct:__anon52::ModuleEntryCopy	file:
module_base_address_	windows\patch_functions.cc	/^  const void *module_base_address_;$/;"	m	class:__anon52::LibcInfo	file:
module_base_size_	windows\patch_functions.cc	/^  size_t module_base_size_;$/;"	m	class:__anon52::LibcInfo	file:
name	windows\patch_functions.cc	/^    const char* const name;          \/\/ name of fn in a module (eg "malloc")$/;"	m	struct:__anon52::WindowsInfo::FunctionInfo	file:
origstub_fn	windows\patch_functions.cc	/^    GenericFnPtr origstub_fn;        \/\/ original fn contents after we patch$/;"	m	struct:__anon52::WindowsInfo::FunctionInfo	file:
origstub_fn_	windows\patch_functions.cc	/^  static GenericFnPtr origstub_fn_[kNumFunctions];$/;"	m	class:__anon52::LibcInfoWithPatchFunctions	file:
origstub_fn_	windows\patch_functions.cc	/^template<int T> GenericFnPtr LibcInfoWithPatchFunctions<T>::origstub_fn_[] = {$/;"	m	class:__anon52::LibcInfoWithPatchFunctions	file:
patched	windows\patch_functions.cc	/^  bool patched() const { return is_valid(); }$/;"	f	class:__anon52::LibcInfo
perftools_fn	windows\patch_functions.cc	/^    const GenericFnPtr perftools_fn; \/\/ fn we want to patch in$/;"	m	struct:__anon52::WindowsInfo::FunctionInfo	file:
perftools_fn_	windows\patch_functions.cc	/^  static const GenericFnPtr perftools_fn_[kNumFunctions];$/;"	m	class:__anon52::LibcInfoWithPatchFunctions	file:
perftools_fn_	windows\patch_functions.cc	/^const GenericFnPtr LibcInfoWithPatchFunctions<T>::perftools_fn_[] = {$/;"	m	class:__anon52::LibcInfoWithPatchFunctions	file:
rgProcAddresses	windows\patch_functions.cc	/^  GenericFnPtr rgProcAddresses[LibcInfo::ctrgProcAddress];$/;"	m	struct:__anon52::ModuleEntryCopy	file:
set_is_valid	windows\patch_functions.cc	/^  void set_is_valid(bool b) { is_valid_ = b; }$/;"	f	class:__anon52::LibcInfo
static_fn	windows\patch_functions.cc	/^  static GenericFnPtr static_fn(int ifunction) {$/;"	f	class:__anon52::LibcInfo
static_fn_	windows\patch_functions.cc	/^  static const GenericFnPtr static_fn_[kNumFunctions];$/;"	m	class:__anon52::LibcInfo	file:
static_fn_	windows\patch_functions.cc	/^const GenericFnPtr LibcInfo::static_fn_[] = {$/;"	m	class:__anon52::LibcInfo	file:
windows_fn	windows\patch_functions.cc	/^    GenericFnPtr windows_fn;         \/\/ the fn whose name we call (&malloc)$/;"	m	struct:__anon52::WindowsInfo::FunctionInfo	file:
windows_fn	windows\patch_functions.cc	/^  GenericFnPtr windows_fn(int ifunction) const {$/;"	f	class:__anon52::LibcInfo
windows_fn_	windows\patch_functions.cc	/^  GenericFnPtr windows_fn_[kNumFunctions];$/;"	m	class:__anon52::LibcInfo	file:
DeleteMatchingFiles	windows\port.cc	/^void DeleteMatchingFiles(const char* prefix, const char* full_glob) {$/;"	f
DestrFnClosure	windows\port.cc	/^struct DestrFnClosure {$/;"	s	file:
DllMain	windows\port.cc	/^BOOL WINAPI DllMain(HINSTANCE h, DWORD dwReason, PVOID pv) {$/;"	f
NOMINMAX	windows\port.cc	39;"	d	file:
PthreadKeyCreate	windows\port.cc	/^extern "C" pthread_key_t PthreadKeyCreate(void (*destr_fn)(void*)) {$/;"	f
WriteToStderr	windows\port.cc	/^extern "C" PERFTOOLS_DLL_DECL void WriteToStderr(const char* buf, int len) {$/;"	f
__sbrk	windows\port.cc	/^extern "C" PERFTOOLS_DLL_DECL void* __sbrk(ptrdiff_t increment) {$/;"	f
destr_fn	windows\port.cc	/^  void (*destr_fn)(void*);$/;"	m	struct:DestrFnClosure	file:
destr_fn_info	windows\port.cc	/^static DestrFnClosure destr_fn_info;   \/\/ initted to all NULL\/0.$/;"	v	file:
getpagesize	windows\port.cc	/^int getpagesize() {$/;"	f
key_for_destr_fn_arg	windows\port.cc	/^  pthread_key_t key_for_destr_fn_arg;$/;"	m	struct:DestrFnClosure	file:
on_process_term	windows\port.cc	/^static int on_process_term(void) {$/;"	f	file:
on_tls_callback	windows\port.cc	/^static void NTAPI on_tls_callback(HINSTANCE h, DWORD dwReason, PVOID pv) {$/;"	f	file:
p_process_term_tcmalloc	windows\port.cc	/^int (*p_process_term_tcmalloc)(void) = on_process_term;$/;"	v
p_thread_callback_tcmalloc	windows\port.cc	/^void (NTAPI *p_thread_callback_tcmalloc)($/;"	v
perftools_pthread_once	windows\port.cc	/^extern "C" int perftools_pthread_once(pthread_once_t *once_control,$/;"	f
EXTERN_C	windows\port.h	495;"	d
EXTERN_C	windows\port.h	97;"	d
EXTERN_C	windows\port.h	99;"	d
GOOGLE_BASE_WINDOWS_H_	windows\port.h	42;"	d
GOOGLE_MAYBE_THREADS_H_	windows\port.h	146;"	d
HAVE_DECL_NANOSLEEP	windows\port.h	452;"	d
HAVE_DECL_SLEEP	windows\port.h	432;"	d
MAP_ANONYMOUS	windows\port.h	278;"	d
MAP_FAILED	windows\port.h	273;"	d
MAP_PRIVATE	windows\port.h	279;"	d
MAP_SHARED	windows\port.h	280;"	d
MREMAP_FIXED	windows\port.h	274;"	d
O_RDONLY	windows\port.h	365;"	d
PATH_MAX	windows\port.h	359;"	d
PRId64	windows\port.h	345;"	d
PRIu64	windows\port.h	347;"	d
PRIuPTR	windows\port.h	349;"	d
PRIuPTR	windows\port.h	352;"	d
PRIx64	windows\port.h	343;"	d
PRIxPTR	windows\port.h	350;"	d
PRIxPTR	windows\port.h	353;"	d
PROT_READ	windows\port.h	276;"	d
PROT_WRITE	windows\port.h	277;"	d
PTHREAD_ONCE_INIT	windows\port.h	/^enum { PTHREAD_ONCE_INIT = 0 };   \/* important that this be 0! for SpinLock *\/$/;"	e	enum:__anon55
SCNd64	windows\port.h	346;"	d
SCNx64	windows\port.h	344;"	d
STDERR_FILENO	windows\port.h	/^enum { STDIN_FILENO = 0, STDOUT_FILENO = 1, STDERR_FILENO = 2 };$/;"	e	enum:__anon56
STDIN_FILENO	windows\port.h	/^enum { STDIN_FILENO = 0, STDOUT_FILENO = 1, STDERR_FILENO = 2 };$/;"	e	enum:__anon56
STDOUT_FILENO	windows\port.h	/^enum { STDIN_FILENO = 0, STDOUT_FILENO = 1, STDERR_FILENO = 2 };$/;"	e	enum:__anon56
WIN32_LEAN_AND_MEAN	windows\port.h	54;"	d
_TIMESPEC_DEFINED	windows\port.h	68;"	d
__THROW	windows\port.h	485;"	d
__thread	windows\port.h	192;"	d
access	windows\port.h	/^inline int access(const char *pathname, int mode) {$/;"	f
atoll	windows\port.h	/^inline long long atoll(const char *nptr) {$/;"	f
close	windows\port.h	/^inline int close(int fd) {$/;"	f
getcwd	windows\port.h	/^inline char *getcwd(char *buf, size_t size) {$/;"	f
getpid	windows\port.h	/^inline pid_t getpid(void) { return _getpid(); }$/;"	f
getppid	windows\port.h	/^inline pid_t getppid(void) { return 0; }$/;"	f
inline	windows\port.h	494;"	d
inline	windows\port.h	89;"	d
inline	windows\port.h	91;"	d
int16_t	windows\port.h	/^typedef __int16 int16_t;$/;"	t
int32_t	windows\port.h	/^typedef __int32 int32_t;$/;"	t
int64_t	windows\port.h	/^typedef __int64 int64_t;$/;"	t
int8_t	windows\port.h	/^typedef __int8 int8_t;$/;"	t
lseek	windows\port.h	/^inline off_t lseek(int fd, off_t offset, int whence) {$/;"	f
mkdir	windows\port.h	/^inline int mkdir(const char *pathname, int) {$/;"	f
mmap	windows\port.h	/^inline void *mmap(void *addr, size_t length, int prot, int flags,$/;"	f
munmap	windows\port.h	/^inline int munmap(void *addr, size_t length) {$/;"	f
nanosleep	windows\port.h	/^inline int nanosleep(const struct timespec *req, struct timespec *rem) {$/;"	f
off_t	windows\port.h	/^typedef _off_t off_t;$/;"	t
open	windows\port.h	/^inline int open(const char *pathname, int flags, int mode = 0) {$/;"	f
pclose	windows\port.h	/^inline int pclose(FILE *stream) {$/;"	f
perftools_pthread_getspecific	windows\port.h	/^inline void* perftools_pthread_getspecific(DWORD key) {$/;"	f
perftools_pthread_key_create	windows\port.h	/^inline int perftools_pthread_key_create(pthread_key_t *pkey,$/;"	f
perftools_pthread_setspecific	windows\port.h	/^inline int perftools_pthread_setspecific(pthread_key_t key, const void *value) {$/;"	f
perftools_vsnprintf	windows\port.h	/^inline int perftools_vsnprintf(char *str, size_t size, const char *format,$/;"	f
pid_t	windows\port.h	/^typedef int pid_t;$/;"	t
poll	windows\port.h	/^inline int poll(struct pollfd* fds, int nfds, int timeout) {$/;"	f
popen	windows\port.h	/^inline FILE *popen(const char *command, const char *type) {$/;"	f
pthread_equal	windows\port.h	/^inline bool pthread_equal(pthread_t left, pthread_t right) {$/;"	f
pthread_key_t	windows\port.h	/^typedef DWORD pthread_key_t;$/;"	t
pthread_once_t	windows\port.h	/^typedef LONG pthread_once_t;$/;"	t
pthread_self	windows\port.h	/^inline pthread_t pthread_self(void) {$/;"	f
pthread_t	windows\port.h	/^typedef DWORD pthread_t;$/;"	t
random	windows\port.h	/^inline long random(void) { return rand(); }$/;"	f
read	windows\port.h	/^inline ssize_t read(int fd, void *buf, size_t count) {$/;"	f
sbrk	windows\port.h	/^inline void *sbrk(intptr_t increment) {$/;"	f
sched_yield	windows\port.h	/^inline void sched_yield(void) {$/;"	f
sleep	windows\port.h	/^inline unsigned int sleep(unsigned int seconds) {$/;"	f
snprintf	windows\port.h	/^inline int snprintf(char *str, size_t size, const char *format, ...) {$/;"	f
srandom	windows\port.h	/^inline void srandom(unsigned int seed) { srand(seed); }$/;"	f
ssize_t	windows\port.h	/^typedef intptr_t ssize_t;$/;"	t
strtoll	windows\port.h	/^inline long long int strtoll(const char *nptr, char **endptr, int base) {$/;"	f
strtoq	windows\port.h	/^inline long long int strtoq(const char *nptr, char **endptr, int base) {$/;"	f
strtoull	windows\port.h	/^inline unsigned long long int strtoull(const char *nptr, char **endptr,$/;"	f
strtouq	windows\port.h	/^inline unsigned long long int strtouq(const char *nptr, char **endptr,$/;"	f
timespec	windows\port.h	/^struct timespec {$/;"	s
tv_nsec	windows\port.h	/^  int tv_nsec;$/;"	m	struct:timespec
tv_sec	windows\port.h	/^  int tv_sec;$/;"	m	struct:timespec
uint16_t	windows\port.h	/^typedef unsigned __int16 uint16_t;$/;"	t
uint32_t	windows\port.h	/^typedef unsigned __int32 uint32_t;$/;"	t
uint64_t	windows\port.h	/^typedef unsigned __int64 uint64_t;$/;"	t
uint8_t	windows\port.h	/^typedef unsigned __int8 uint8_t;$/;"	t
write	windows\port.h	/^inline ssize_t write(int fd, const void *buf, size_t count) {$/;"	f
ASM_INT3	windows\preamble_patcher.cc	47;"	d	file:
ASM_JCC32REL_0	windows\preamble_patcher.cc	51;"	d	file:
ASM_JCC32REL_1_MASK	windows\preamble_patcher.cc	52;"	d	file:
ASM_JMP	windows\preamble_patcher.cc	57;"	d	file:
ASM_JMP32ABS_0	windows\preamble_patcher.cc	48;"	d	file:
ASM_JMP32ABS_1	windows\preamble_patcher.cc	49;"	d	file:
ASM_JMP32REL	windows\preamble_patcher.cc	46;"	d	file:
ASM_JMP8REL	windows\preamble_patcher.cc	50;"	d	file:
ASM_JMP_RAX	windows\preamble_patcher.cc	58;"	d	file:
ASM_MOVRAX_IMM	windows\preamble_patcher.cc	56;"	d	file:
ASM_NOP	windows\preamble_patcher.cc	53;"	d	file:
ASM_REXW	windows\preamble_patcher.cc	55;"	d	file:
AllocPageNear	windows\preamble_patcher.cc	/^void* PreamblePatcher::AllocPageNear(void* target) {$/;"	f	class:sidestep::PreamblePatcher
AllocPreambleBlockNear	windows\preamble_patcher.cc	/^unsigned char* PreamblePatcher::AllocPreambleBlockNear(void* target) {$/;"	f	class:sidestep::PreamblePatcher
DeleteUnsignedCharArray	windows\preamble_patcher.cc	/^  DeleteUnsignedCharArray(unsigned char* array) : array_(array) {$/;"	f	class:sidestep::DeleteUnsignedCharArray
DeleteUnsignedCharArray	windows\preamble_patcher.cc	/^class DeleteUnsignedCharArray {$/;"	c	namespace:sidestep	file:
FreePreambleBlock	windows\preamble_patcher.cc	/^void PreamblePatcher::FreePreambleBlock(unsigned char* block) {$/;"	f	class:sidestep::PreamblePatcher
Initialize	windows\preamble_patcher.cc	/^void PreamblePatcher::Initialize() {$/;"	f	class:sidestep::PreamblePatcher
IsMovWithDisplacement	windows\preamble_patcher.cc	/^bool PreamblePatcher::IsMovWithDisplacement($/;"	f	class:sidestep::PreamblePatcher
IsNearAbsoluteCall	windows\preamble_patcher.cc	/^bool PreamblePatcher::IsNearAbsoluteCall($/;"	f	class:sidestep::PreamblePatcher
IsNearConditionalJump	windows\preamble_patcher.cc	/^bool PreamblePatcher::IsNearConditionalJump($/;"	f	class:sidestep::PreamblePatcher
IsNearRelativeCall	windows\preamble_patcher.cc	/^bool PreamblePatcher::IsNearRelativeCall($/;"	f	class:sidestep::PreamblePatcher
IsNearRelativeJump	windows\preamble_patcher.cc	/^bool PreamblePatcher::IsNearRelativeJump($/;"	f	class:sidestep::PreamblePatcher
IsShortConditionalJump	windows\preamble_patcher.cc	/^bool PreamblePatcher::IsShortConditionalJump($/;"	f	class:sidestep::PreamblePatcher
IsShortJump	windows\preamble_patcher.cc	/^bool PreamblePatcher::IsShortJump($/;"	f	class:sidestep::PreamblePatcher
PatchMovWithDisplacement	windows\preamble_patcher.cc	/^SideStepError PreamblePatcher::PatchMovWithDisplacement($/;"	f	class:sidestep::PreamblePatcher
PatchNearJumpOrCall	windows\preamble_patcher.cc	/^SideStepError PreamblePatcher::PatchNearJumpOrCall($/;"	f	class:sidestep::PreamblePatcher
PatchShortConditionalJump	windows\preamble_patcher.cc	/^SideStepError PreamblePatcher::PatchShortConditionalJump($/;"	f	class:sidestep::PreamblePatcher
PatchShortJump	windows\preamble_patcher.cc	/^SideStepError PreamblePatcher::PatchShortJump($/;"	f	class:sidestep::PreamblePatcher
RawPatch	windows\preamble_patcher.cc	/^SideStepError PreamblePatcher::RawPatch(void* target_function,$/;"	f	class:sidestep::PreamblePatcher
RawPatchWithStubAndProtections	windows\preamble_patcher.cc	/^SideStepError PreamblePatcher::RawPatchWithStubAndProtections($/;"	f	class:sidestep::PreamblePatcher
Release	windows\preamble_patcher.cc	/^  unsigned char* Release() {$/;"	f	class:sidestep::DeleteUnsignedCharArray
ResolveTargetImpl	windows\preamble_patcher.cc	/^void* PreamblePatcher::ResolveTargetImpl(unsigned char* target,$/;"	f	class:sidestep::PreamblePatcher
Unpatch	windows\preamble_patcher.cc	/^SideStepError PreamblePatcher::Unpatch(void* target_function,$/;"	f	class:sidestep::PreamblePatcher
array_	windows\preamble_patcher.cc	/^  unsigned char* array_;$/;"	m	class:sidestep::DeleteUnsignedCharArray	file:
granularity_	windows\preamble_patcher.cc	/^long PreamblePatcher::granularity_ = 0;$/;"	m	class:sidestep::PreamblePatcher	file:
initialized_	windows\preamble_patcher.cc	/^bool PreamblePatcher::initialized_ = false;$/;"	m	class:sidestep::PreamblePatcher	file:
kPreamblePageMagic	windows\preamble_patcher.cc	/^static const unsigned int kPreamblePageMagic = 0x4347414D; \/\/ "MAGC"$/;"	m	namespace:sidestep	file:
pagesize_	windows\preamble_patcher.cc	/^long PreamblePatcher::pagesize_ = 0;$/;"	m	class:sidestep::PreamblePatcher	file:
preamble_pages_	windows\preamble_patcher.cc	/^PreamblePatcher::PreamblePage* PreamblePatcher::preamble_pages_ = NULL;$/;"	m	class:sidestep::PreamblePatcher	file:
sidestep	windows\preamble_patcher.cc	/^namespace sidestep {$/;"	n	file:
~DeleteUnsignedCharArray	windows\preamble_patcher.cc	/^  ~DeleteUnsignedCharArray() {$/;"	f	class:sidestep::DeleteUnsignedCharArray
GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_	windows\preamble_patcher.h	39;"	d
MAX_PREAMBLE_STUB_SIZE	windows\preamble_patcher.h	61;"	d
MAX_PREAMBLE_STUB_SIZE	windows\preamble_patcher.h	63;"	d
Patch	windows\preamble_patcher.h	/^  static SideStepError Patch(LPCTSTR module_name,$/;"	f	class:sidestep::PreamblePatcher
Patch	windows\preamble_patcher.h	/^  static SideStepError Patch(T target_function,$/;"	f	class:sidestep::PreamblePatcher
PreamblePage	windows\preamble_patcher.h	/^  struct PreamblePage {$/;"	s	class:sidestep::PreamblePatcher
PreamblePatcher	windows\preamble_patcher.h	/^class PERFTOOLS_DLL_DECL PreamblePatcher {$/;"	c	namespace:sidestep
ResolveTarget	windows\preamble_patcher.h	/^  static T ResolveTarget(T target_function) {$/;"	f	class:sidestep::PreamblePatcher
SIDESTEP_ACCESS_DENIED	windows\preamble_patcher.h	/^  SIDESTEP_ACCESS_DENIED,$/;"	e	enum:sidestep::SideStepError
SIDESTEP_ASSERT	windows\preamble_patcher.h	46;"	d
SIDESTEP_FUNCTION_TOO_SMALL	windows\preamble_patcher.h	/^  SIDESTEP_FUNCTION_TOO_SMALL,$/;"	e	enum:sidestep::SideStepError
SIDESTEP_INSUFFICIENT_BUFFER	windows\preamble_patcher.h	/^  SIDESTEP_INSUFFICIENT_BUFFER,$/;"	e	enum:sidestep::SideStepError
SIDESTEP_INVALID_PARAMETER	windows\preamble_patcher.h	/^  SIDESTEP_INVALID_PARAMETER,$/;"	e	enum:sidestep::SideStepError
SIDESTEP_JUMP_INSTRUCTION	windows\preamble_patcher.h	/^  SIDESTEP_JUMP_INSTRUCTION,$/;"	e	enum:sidestep::SideStepError
SIDESTEP_LOG	windows\preamble_patcher.h	47;"	d
SIDESTEP_NO_SUCH_FUNCTION	windows\preamble_patcher.h	/^  SIDESTEP_NO_SUCH_FUNCTION,$/;"	e	enum:sidestep::SideStepError
SIDESTEP_NO_SUCH_MODULE	windows\preamble_patcher.h	/^  SIDESTEP_NO_SUCH_MODULE,$/;"	e	enum:sidestep::SideStepError
SIDESTEP_SUCCESS	windows\preamble_patcher.h	/^  SIDESTEP_SUCCESS = 0,$/;"	e	enum:sidestep::SideStepError
SIDESTEP_TO_HRESULT	windows\preamble_patcher.h	89;"	d
SIDESTEP_UNEXPECTED	windows\preamble_patcher.h	/^  SIDESTEP_UNEXPECTED,$/;"	e	enum:sidestep::SideStepError
SIDESTEP_UNSUPPORTED_INSTRUCTION	windows\preamble_patcher.h	/^  SIDESTEP_UNSUPPORTED_INSTRUCTION,$/;"	e	enum:sidestep::SideStepError
SideStepError	windows\preamble_patcher.h	/^enum SideStepError {$/;"	g	namespace:sidestep
free_	windows\preamble_patcher.h	/^    void* free_;$/;"	m	struct:sidestep::PreamblePatcher::PreamblePage
granularity_	windows\preamble_patcher.h	/^  static long granularity_;$/;"	m	class:sidestep::PreamblePatcher
initialized_	windows\preamble_patcher.h	/^  static bool initialized_;$/;"	m	class:sidestep::PreamblePatcher
kIs64BitBinary	windows\preamble_patcher.h	/^static const bool kIs64BitBinary = false;$/;"	v
kIs64BitBinary	windows\preamble_patcher.h	/^static const bool kIs64BitBinary = true;$/;"	v
magic_	windows\preamble_patcher.h	/^    unsigned int magic_;$/;"	m	struct:sidestep::PreamblePatcher::PreamblePage
next_	windows\preamble_patcher.h	/^    PreamblePage* next_;$/;"	m	struct:sidestep::PreamblePatcher::PreamblePage
pagesize_	windows\preamble_patcher.h	/^  static long pagesize_;$/;"	m	class:sidestep::PreamblePatcher
preamble_pages_	windows\preamble_patcher.h	/^  static PreamblePage* preamble_pages_;$/;"	m	class:sidestep::PreamblePatcher
sidestep	windows\preamble_patcher.h	/^namespace sidestep {$/;"	n
AutoHookIncrementNumber	windows\preamble_patcher_test.cc	/^int __declspec(noinline) AutoHookIncrementNumber(int i) {$/;"	f	namespace:__anon57
AutoTestingHookInContainerTest	windows\preamble_patcher_test.cc	/^bool AutoTestingHookInContainerTest() {$/;"	f	namespace:sidestep
AutoTestingHookTest	windows\preamble_patcher_test.cc	/^bool AutoTestingHookTest() {$/;"	f	namespace:sidestep
HookIncrementNumber	windows\preamble_patcher_test.cc	/^int HookIncrementNumber(int i) {$/;"	f	namespace:__anon57
IncrementNumber	windows\preamble_patcher_test.cc	/^int __declspec(noinline) IncrementNumber(int i) {$/;"	f	namespace:__anon57
IncrementingFunc	windows\preamble_patcher_test.cc	/^typedef int (*IncrementingFunc)(int);$/;"	t	namespace:__anon57	file:
PatchThenUnpatch	windows\preamble_patcher_test.cc	/^bool PatchThenUnpatch() {$/;"	f	namespace:sidestep
TestDisassembler	windows\preamble_patcher_test.cc	/^bool TestDisassembler() {$/;"	f	namespace:sidestep
TestPatchUsingDynamicStub	windows\preamble_patcher_test.cc	/^bool TestPatchUsingDynamicStub() {$/;"	f	namespace:sidestep
TestPatchWithLongJump	windows\preamble_patcher_test.cc	/^bool TestPatchWithLongJump() {$/;"	f	namespace:sidestep
TestPatchWithPreambleAbsoluteJump	windows\preamble_patcher_test.cc	/^bool TestPatchWithPreambleAbsoluteJump() {$/;"	f	namespace:sidestep
TestPatchWithPreambleNearRelativeCall	windows\preamble_patcher_test.cc	/^bool TestPatchWithPreambleNearRelativeCall() {$/;"	f	namespace:sidestep
TestPatchWithPreambleNearRelativeCondJump	windows\preamble_patcher_test.cc	/^bool TestPatchWithPreambleNearRelativeCondJump() {$/;"	f	namespace:sidestep
TestPatchWithPreambleShortCondJump	windows\preamble_patcher_test.cc	/^bool TestPatchWithPreambleShortCondJump() {$/;"	f	namespace:sidestep
TestPreambleAllocation	windows\preamble_patcher_test.cc	/^bool TestPreambleAllocation() {$/;"	f	namespace:sidestep
UNPATCH	windows\preamble_patcher_test.cc	63;"	d	file:
UnitTests	windows\preamble_patcher_test.cc	/^bool UnitTests() {$/;"	f	namespace:sidestep
WIN32_LEAN_AND_MEAN	windows\preamble_patcher_test.cc	46;"	d	file:
_tmain	windows\preamble_patcher_test.cc	/^int _tmain(int argc, _TCHAR* argv[])$/;"	f
original_function	windows\preamble_patcher_test.cc	/^IncrementingFunc original_function = NULL;$/;"	m	namespace:__anon57	file:
safe_vsnprintf	windows\preamble_patcher_test.cc	/^int safe_vsnprintf(char *str, size_t size, const char *format, va_list ap) {$/;"	f
sidestep	windows\preamble_patcher_test.cc	/^namespace sidestep {$/;"	n	file:
ASM_INT3	windows\preamble_patcher_with_stub.cc	44;"	d	file:
ASM_JMP	windows\preamble_patcher_with_stub.cc	49;"	d	file:
ASM_JMP32REL	windows\preamble_patcher_with_stub.cc	43;"	d	file:
ASM_JMP_RAX	windows\preamble_patcher_with_stub.cc	50;"	d	file:
ASM_MOVRAX_IMM	windows\preamble_patcher_with_stub.cc	47;"	d	file:
ASM_NOP	windows\preamble_patcher_with_stub.cc	45;"	d	file:
ASM_PUSH	windows\preamble_patcher_with_stub.cc	51;"	d	file:
ASM_RET	windows\preamble_patcher_with_stub.cc	52;"	d	file:
ASM_REXW	windows\preamble_patcher_with_stub.cc	48;"	d	file:
RawPatchWithStub	windows\preamble_patcher_with_stub.cc	/^SideStepError PreamblePatcher::RawPatchWithStub($/;"	f	class:sidestep::PreamblePatcher
sidestep	windows\preamble_patcher_with_stub.cc	/^namespace sidestep {$/;"	n	file:
CallNearRelativeFunction	windows\shortproc.asm	/^CallNearRelativeFunction PROC$/;"	l
JumpAbsoluteFunction	windows\shortproc.asm	/^JumpAbsoluteFunction PROC$/;"	l
JumpNearCondFunction	windows\shortproc.asm	/^JumpNearCondFunction PROC$/;"	l
JumpShortCondFunction	windows\shortproc.asm	/^JumpShortCondFunction PROC$/;"	l
TooShortFunction	windows\shortproc.asm	/^TooShortFunction PROC$/;"	l
jumpspot	windows\shortproc.asm	/^jumpspot:$/;"	l
Alloc	windows\system-alloc.cc	/^void* VirtualSysAllocator::Alloc(size_t size, size_t *actual_size,$/;"	f	class:VirtualSysAllocator
DumpSystemAllocatorStats	windows\system-alloc.cc	/^void DumpSystemAllocatorStats(TCMalloc_Printer* printer) {$/;"	f
InitSystemAllocators	windows\system-alloc.cc	/^void InitSystemAllocators(void) {$/;"	f
RegisterSystemAllocator	windows\system-alloc.cc	/^bool RegisterSystemAllocator(SysAllocator *allocator, int priority) {$/;"	f
TCMalloc_SystemAlloc	windows\system-alloc.cc	/^void* TCMalloc_SystemAlloc(size_t size, size_t *actual_size,$/;"	f
TCMalloc_SystemCommit	windows\system-alloc.cc	/^void TCMalloc_SystemCommit(void* start, size_t length) {$/;"	f
TCMalloc_SystemRelease	windows\system-alloc.cc	/^bool TCMalloc_SystemRelease(void* start, size_t length) {$/;"	f
TCMalloc_SystemTaken	windows\system-alloc.cc	/^size_t TCMalloc_SystemTaken = 0;$/;"	v
VirtualSysAllocator	windows\system-alloc.cc	/^  VirtualSysAllocator() : SysAllocator() {$/;"	f	class:VirtualSysAllocator
VirtualSysAllocator	windows\system-alloc.cc	/^class VirtualSysAllocator : public SysAllocator {$/;"	c	file:
sys_alloc	windows\system-alloc.cc	/^SysAllocator* sys_alloc = NULL;$/;"	v
system_alloc_inited	windows\system-alloc.cc	/^static bool system_alloc_inited = false;$/;"	v	file:
tc_get_sysalloc_default	windows\system-alloc.cc	/^extern "C" SysAllocator* tc_get_sysalloc_default(SysAllocator *def)$/;"	f
tc_get_sysalloc_override	windows\system-alloc.cc	/^SysAllocator* tc_get_sysalloc_override(SysAllocator *def)$/;"	f
virtual_space	windows\system-alloc.cc	/^static char virtual_space[sizeof(VirtualSysAllocator)];$/;"	v	file:
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_PROGRAM_VERSION	5.8	//
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
